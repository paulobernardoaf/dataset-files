<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\merge-recursive.c">




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"merge-recursive.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"advice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"alloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diffcore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ll-merge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lockfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string-list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree-walk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unpack-trees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xdiff-interface.h"</cpp:file></cpp:include>

<struct>struct <name>merge_options_internal</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>call_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>needed_rename_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>current_file_dir_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>df_conflict_file_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>unpack_trees_options</name></name></type> <name>unpack_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name></type> <name>orig_index</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>path_hashmap_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>path_hashmap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cmp_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>keydata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>path_hashmap_entry</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>keydata</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>path_hashmap_entry</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>path_hashmap_entry</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>key</name></expr> ?</condition><then> <expr><name>key</name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>key</name></expr> ?</condition><then> <expr><name>key</name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>path_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then> <expr><call><name>strihash</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strhash</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>











<struct>struct <name>dir_rename_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>non_unique_new_dir</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>new_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>possible_new_dirs</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>dir_rename_find_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>hashmap</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name></type> <name>key</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>ent</name></name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>.</operator><name>dir</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>
<return>return <expr><call><name>hashmap_get_entry</name><argument_list>(<argument><expr><name>hashmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dir_rename_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_cmp_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_keydata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>e1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>dir_rename_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e2</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>dir_rename_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>e2</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dir_rename_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>dir_rename_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dir_rename_entry_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>directory</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>collision_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_entry</name></name></type> <name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>target_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>source_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>reported_already</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>collision_entry</name></name> <modifier>*</modifier></type><name>collision_find_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>hashmap</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>target_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>collision_entry</name></name></type> <name>key</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>ent</name></name></expr></argument>, <argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>target_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>.</operator><name>target_file</name></name> <operator>=</operator> <name>target_file</name></expr>;</expr_stmt>
<return>return <expr><call><name>hashmap_get_entry</name><argument_list>(<argument><expr><name>hashmap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>collision_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_cmp_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>entry_or_key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_keydata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>collision_entry</name></name> <modifier>*</modifier></type><name>e1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>collision_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e2</name> <operator>=</operator> <call><name>container_of</name><argument_list>(<argument><expr><name>entry_or_key</name></expr></argument>, <argument><expr><specifier>const</specifier> struct <name>collision_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>target_file</name></name></expr></argument>, <argument><expr><name><name>e2</name><operator>-&gt;</operator><name>target_file</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>collision_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>collision_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_output</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>obuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>obuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>err</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>params</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flush_output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_complete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="string">"error: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_vaddf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>obuf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>shift_tree_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>one</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>two</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subtree_shift</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>shifted</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>subtree_shift</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shift_tree</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>one</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>two</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shifted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>shift_tree_by</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>one</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>two</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shifted</name></expr></argument>,
<argument><expr><name>subtree_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>two</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shifted</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>two</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>lookup_tree</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shifted</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_commit_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>maybe_tree</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>make_virtual_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><call><name>alloc_commit_node</name><argument_list>(<argument><expr><name>repo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_merge_remote_desc</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>object</name> <operator>*</operator><operator>)</operator><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_commit_tree</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>parsed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>commit</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>rename_type</name> <block>{
<decl><name>RENAME_NORMAL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>RENAME_VIA_DIR</name></decl>,
<decl><name>RENAME_ADD</name></decl>,
<decl><name>RENAME_DELETE</name></decl>,
<decl><name>RENAME_ONE_FILE_TO_ONE</name></decl>,
<decl><name>RENAME_ONE_FILE_TO_TWO</name></decl>,
<decl><name>RENAME_TWO_FILES_TO_ONE</name></decl>
}</block>;</enum>





<struct>struct <name>stage_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name></type> <name><name>stages</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>rename_conflict_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>processed</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>rename</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>processed</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>pair</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch</name></decl>;</decl_stmt> 





<decl_stmt><decl><type><name>char</name></type> <name>dir_rename_original_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dir_rename_original_dest</name></decl>;</decl_stmt>



















<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>src_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>dst_entry</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>rename_conflict_info</name> <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>rename_type</name></name></type> <name>rename_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren2</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>setup_rename_conflict_info</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>rename_type</name></name></type> <name>rename_type</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name>ren2</name> <operator>&amp;&amp;</operator> <name><name>ren1</name><operator>-&gt;</operator><name>branch</name></name> <operator>!=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>rename_type</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren2</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rename_conflict_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>rename_type</name></name> <operator>=</operator> <name>rename_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name></name> <operator>=</operator> <name>ren1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name></name> <operator>=</operator> <name>ren2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>rename_conflict_info</name></name> <operator>=</operator> <name>ci</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ren2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>rename_conflict_info</name></name> <operator>=</operator> <name>ci</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>show</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;=</operator> <name>v</name><operator>)</operator> <operator>||</operator>
<name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>;</return>
</block_content>}</block></function>

<macro><name>__attribute__</name><argument_list>(<argument>(format (printf, <literal type="number">3</literal>, <literal type="number">4</literal>))</argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addchars</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_vaddf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flush_output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>output_commit_title</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_remote_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addchars</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>merge_remote_util</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="string">"virtual %s\n"</literal></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(bad commit)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>get_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>find_commit_subject</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="string">"%.*s\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>unuse_commit_buffer</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>flush_output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_cacheinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>blob</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refresh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>make_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>blob</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>blob</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>stage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ce</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"add_cacheinfo failed for path '%s'; merge aborting."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>add_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>refresh</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>nce</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nce</name> <operator>=</operator> <call><name>refresh_cache_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ce</name></expr></argument>,
<argument><expr><name>CE_MATCH_REFRESH</name> <operator>|</operator> <name>CE_MATCH_IGNORE_MISSING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nce</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"add_cacheinfo failed to refresh for path '%s'; merge aborting."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nce</name> <operator>!=</operator> <name>ce</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>add_index_entry</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>nce</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>merge_detect_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_tree_desc_from_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>parse_tree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_tree_desc</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>unpack_trees_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>common</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_desc</name></name></type> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name></type> <name>tmp_index</name> <init>= <expr><block>{ <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>index_only</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>update</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>merge</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>head_idx</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>threeway_merge</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>src_index</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>dst_index</name></name> <operator>=</operator> <operator>&amp;</operator><name>tmp_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>aggressive</name></name> <operator>=</operator> <operator>!</operator><call><name>merge_detect_rename</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_unpack_trees_porcelain</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>, <argument><expr><literal type="string">"merge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_tree_desc_from_tree</name><argument_list>(<argument><expr><name>t</name><operator>+</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_tree_desc_from_tree</name><argument_list>(<argument><expr><name>t</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_tree_desc_from_tree</name><argument_list>(<argument><expr><name>t</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unpack_trees</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cache_tree_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name> <operator>=</operator> <operator>*</operator><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>tmp_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>src_index</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name></expr>;</expr_stmt>

<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unpack_trees_finish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_unpack_trees_porcelain</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>save_files_dirs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_hashmap_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>baselen</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FLEX_ALLOC_MEM</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><call><name>path_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>current_file_dir_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>READ_TREE_RECURSIVE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_files_dirs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pathspec</name></name></type> <name>match_all</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>match_all</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>match_all</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_tree_recursive</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>match_all</name></expr></argument>, <argument><expr><name>save_files_dirs</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_tree_entry_if_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>dfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_tree_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dfs</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dfs</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>dfs</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dfs</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dfs</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>insert_stage_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>stage_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_tree_entry_if_blob</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_tree_entry_if_blob</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_tree_entry_if_blob</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_insert</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>get_unmerged</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>unmerged</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>string_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>unmerged</name><operator>-&gt;</operator><name>strdup_strings</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>unmerged</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_insert</name><argument_list>(<argument><expr><name>unmerged</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>stage_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>unmerged</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>string_list_df_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>one</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>two</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>onelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>twolen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>two</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>












<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>df_name_compare</name><argument_list>(<argument><expr><name>one</name></expr></argument>, <argument><expr><name>onelen</name></expr></argument>, <argument><expr><name>S_IFDIR</name></expr></argument>,
<argument><expr><name>two</name></expr></argument>, <argument><expr><name>twolen</name></expr></argument>, <argument><expr><name>S_IFDIR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>onelen</name> <operator>-</operator> <name>twolen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>record_df_conflict_files</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>













<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>df_sorted_entries</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entries</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><operator>&amp;</operator><name><name>entries</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>df_sorted_entries</name></expr></argument>, <argument><expr><name><name>next</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator>
<name><name>next</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>df_sorted_entries</name><operator>.</operator><name>cmp</name></name> <operator>=</operator> <name>string_list_df_name_compare</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>df_sorted_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>df_sorted_entries</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>df_sorted_entries</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>df_sorted_entries</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name>last_file</name> <operator>&amp;&amp;</operator>
<name>len</name> <operator>&gt;</operator> <name>last_len</name> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>last_file</name></expr></argument>, <argument><expr><name>last_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>path</name><index>[<expr><name>last_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name></name></expr></argument>, <argument><expr><name>last_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_file</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>last_file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>df_sorted_entries</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_stages</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>









<decl_stmt><decl><type><name>int</name></type> <name>clear</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>ADD_CACHE_OK_TO_ADD</name> <operator>|</operator> <name>ADD_CACHE_SKIP_DFCHECK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>clear</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remove_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clean</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_wd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>update_cache</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>||</operator> <name>clean</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>update_working_directory</name> <init>= <expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>no_wd</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>update_cache</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>update_working_directory</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>index_file_exists</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <call><name>ce_stage</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>remove_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>add_flattened_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unique_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_hashmap_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>newpath</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>suffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>base_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpath</name></expr></argument>, <argument><expr><literal type="string">"%s~"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_flattened_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpath</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base_len</name> <operator>=</operator> <name><name>newpath</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hashmap_get_from_hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>current_file_dir_set</name></name></expr></argument>,
<argument><expr><call><name>path_hash</name><argument_list>(<argument><expr><name><name>newpath</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>newpath</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <call><name>file_exists</name><argument_list>(<argument><expr><name><name>newpath</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpath</name></expr></argument>, <argument><expr><name>base_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpath</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>suffix</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>FLEX_ALLOC_MEM</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>newpath</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>newpath</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><call><name>path_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>current_file_dir_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>dir_in_way</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_working_copy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>dirpath</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirpath</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>dirpath</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>dirpath</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>dirpath</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><name><name>dirpath</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>check_working_copy</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>empty_ok</name> <operator>&amp;&amp;</operator> <call><name>is_empty_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>has_symlink_leading_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>was_tracked_and_matches</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>blob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name><operator>.</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>blob</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name> <operator>==</operator> <name><name>blob</name><operator>-&gt;</operator><name>mode</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>was_tracked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>would_lose_untracked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>


















<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>






<switch>switch <condition>(<expr><call><name>ce_stage</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><call><name>file_exists</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>was_dirty</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dirty</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>||</operator> <operator>!</operator><call><name>was_tracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><name>dirty</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>index_file_exists</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name><operator>.</operator><name>src_index</name></name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirty</name> <operator>=</operator> <call><name>verify_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>unpack_opts</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>dirty</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>make_room_for_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create path '%s'%s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>df_path</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>pathlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>df_pathlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>df_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>df_pathlen</name> <operator>&lt;</operator> <name>pathlen</name> <operator>&amp;&amp;</operator>
<name><name>path</name><index>[<expr><name>df_pathlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>df_path</name></expr></argument>, <argument><expr><name>df_pathlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Removing %s to make room for subdirectory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>df_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>df_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unsorted_string_list_delete_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name></name></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>safe_create_leading_directories_const</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>SCLD_EXISTS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">": perhaps a D/F conflict?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"refusing to lose untracked file at '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">": perhaps a D/F conflict?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_file_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>contents</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>update_cache</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>update_wd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>update_wd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>update_wd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>update_wd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>update_index</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contents</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot read object %s '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contents</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>free_buf</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"blob expected for %s '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contents</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>free_buf</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>strbuf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>convert_to_working_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>strbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>make_room_for_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>update_wd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>free_buf</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>has_symlinks</name> <operator>&amp;&amp;</operator> <call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <literal type="number">0100</literal></expr> ?</condition><then> <expr><literal type="number">0777</literal></expr> </then><else>: <expr><literal type="number">0666</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to open '%s': %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>free_buf</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>write_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lnk</name> <init>= <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>safe_create_leading_directories_const</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>lnk</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to symlink '%s': %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lnk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"do not know what to do with %06o %s '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>contents</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contents</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<label><name>free_buf</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>update_index</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name>update_cache</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>refresh</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator>
<name><name>contents</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>S_IFGITLINK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>refresh</name></expr></argument>,
<argument><expr><name>ADD_CACHE_OK_TO_ADD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>clean</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>contents</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>update_file_flags</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>||</operator> <name>clean</name></expr></argument>, <argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<struct>struct <name>merge_file_info</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name></type> <name>blob</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>clean</name><range>:<expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>merge</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_3way</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name>mmbuffer_t</name> <modifier>*</modifier></type><name>result_buf</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>extra_marker_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mmfile_t</name></type> <name>orig</name></decl>, <decl><type ref="prev"/><name>src1</name></decl>, <decl><type ref="prev"/><name>src2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ll_merge_options</name></name></type> <name>ll_opts</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>merge_status</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>renormalize</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>renormalize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>extra_marker_size</name></name> <operator>=</operator> <name>extra_marker_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>xdl_opts</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>virtual_ancestor</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>variant</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MERGE_VARIANT_OURS</name></expr>:</case>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>variant</name></name> <operator>=</operator> <name>XDL_MERGE_FAVOR_OURS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MERGE_VARIANT_THEIRS</name></expr>:</case>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>variant</name></name> <operator>=</operator> <name>XDL_MERGE_FAVOR_THEIRS</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name><name>ll_opts</name><operator>.</operator><name>variant</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>path</name></name> <operator>&amp;&amp;</operator> <name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name>branch1</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name2</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name>branch2</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>branch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name2</name> <operator>=</operator> <call><name>mkpathdup</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>branch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>read_mmblob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_mmblob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_mmblob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>merge_status</name> <operator>=</operator> <call><name>ll_merge</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>, <argument><expr><name>base</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>src1</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src2</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ll_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>orig</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>src1</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>src2</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>merge_status</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_first_merges</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_array</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_array</name></name></type> <name>merges</name> <init>= <expr><name>OBJECT_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>contains_another</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>merged_revision</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>rev_args</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"rev-list"</literal></expr>, <expr><literal type="string">"--merges"</literal></expr>, <expr><literal type="string">"--ancestry-path"</literal></expr>,
<expr><literal type="string">"--all"</literal></expr>, <expr><name>merged_revision</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>setup_revision_opt</name></name></type> <name>rev_opts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_array</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_opts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev_opts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>merged_revision</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>merged_revision</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev_opts</name><operator>.</operator><name>submodule</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>single_worktree</name></name> <operator>=</operator> <name>path</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_revisions</name><argument_list>(<argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>rev_args</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rev_args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name>commit</name> <operator>=</operator> <call><name>get_revision</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_object_array</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>reset_revision_walk</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>merges</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>m1</name> <init>= <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>contains_another</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>merges</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>m2</name> <init>= <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>item</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>j</name> <operator>&amp;&amp;</operator> <call><name>in_merge_bases</name><argument_list>(<argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>contains_another</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>contains_another</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_object_array</name><argument_list>(<argument><expr><name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>object_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>result</name><operator>-&gt;</operator><name>nr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pretty_print_context</name></name></type> <name>ctx</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>date_mode</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>DATE_NORMAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>format_commit_message</name><argument_list>(<argument><expr><name>commit</name></expr></argument>, <argument><expr><literal type="string">" %h: %m %s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_valid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>dfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>dfs</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dfs</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_submodule</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit_base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>commit_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>commit_b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parent_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_array</name></name></type> <name>merges</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>search</name> <init>= <expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>add_submodule_odb</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (not checked out)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>commit_base</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name>commit_a</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name>commit_b</name> <operator>=</operator> <call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (commits not present)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>commit_base</name></expr></argument>, <argument><expr><name>commit_a</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>commit_base</name></expr></argument>, <argument><expr><name>commit_b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (commits don't follow merge-base)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>commit_a</name></expr></argument>, <argument><expr><name>commit_b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fast-forwarding submodule %s to the following commit:"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_commit_title</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>commit_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fast-forwarding submodule %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> 

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>commit_b</name></expr></argument>, <argument><expr><name>commit_a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fast-forwarding submodule %s to the following commit:"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_commit_title</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>commit_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Fast-forwarding submodule %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> 

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><operator>!</operator><name>search</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>parent_count</name> <operator>=</operator> <call><name>find_first_merges</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merges</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>commit_a</name></expr></argument>, <argument><expr><name>commit_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>parent_count</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (merge following commits not found)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (not fast-forward)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Found a possible merge resolution for the submodule:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_commit</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(
<argument><expr><literal type="string">"If this is correct simply add it to the index "</literal>
<literal type="string">"for example\n"</literal>
<literal type="string">"by using:\n\n"</literal>
<literal type="string">" git update-index --cacheinfo 160000 %s \"%s\"\n\n"</literal>
<literal type="string">"which will accept this suggestion.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>item</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to merge submodule %s (multiple merges found)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>merges</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_commit</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator> <name><name>merges</name><operator>.</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>object_array_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_mode_and_contents</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>extra_marker_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>merge_file_info</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>!=</operator> <name>branch1</name></expr>)</condition> <block>{<block_content>





<return>return <expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>,
<argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>branch2</name></expr></argument>, <argument><expr><name>branch1</name></expr></argument>,
<argument><expr><name>extra_marker_size</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>merge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>S_IFMT</name> <operator>&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>mode</name></name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>S_IFMT</name> <operator>&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>mode</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>merge</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>mode</name></name> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>merge</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>mmbuffer_t</name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>merge_status</name></decl>;</decl_stmt>

<expr_stmt><expr><name>merge_status</name> <operator>=</operator> <call><name>merge_3way</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
<argument><expr><name>branch1</name></expr></argument>, <argument><expr><name>branch2</name></expr></argument>,
<argument><expr><name>extra_marker_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>merge_status</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>result_buf</name><operator>.</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Failed to execute internal merge"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator>
<call><name>write_object_file</name><argument_list>(<argument><expr><name><name>result_buf</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>result_buf</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name>blob_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unable to add %s to database"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>result_buf</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <operator>(</operator><name>merge_status</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <call><name>merge_submodule</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MERGE_VARIANT_NORMAL</name></expr>:</case>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>MERGE_VARIANT_OURS</name></expr>:</case>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MERGE_VARIANT_THEIRS</name></expr>:</case>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unsupported object type in the tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>merge</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Auto-merging %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_via_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>






<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file_path</name> <init>= <expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mark_conflicted</name> <init>= <expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>==</operator>
<name>MERGE_DIRECTORY_RENAMES_CONFLICT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mark_conflicted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>file_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error: Refusing to lose untracked file at %s; "</literal>
<literal type="string">"writing to %s instead."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mark_conflicted</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>file_path</name> <operator>!=</operator> <name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>file_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><name>dest</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>dest</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_change_delete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>changed</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>change_branch</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delete_branch</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>change</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>change_past</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alt_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>update_path</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dir_in_way</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>update_path</name> <operator>=</operator> <name>alt_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>change_branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>update_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>















<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt_path</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s/delete): %s deleted in %s "</literal>
<literal type="string">"and %s in %s. Version %s of %s left in tree."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>change</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>, <argument><expr><name>change_past</name></expr></argument>,
<argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s/delete): %s deleted in %s "</literal>
<literal type="string">"and %s to %s in %s. Version %s of %s left in tree."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>change</name></expr></argument>, <argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>, <argument><expr><name>change_past</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s/delete): %s deleted in %s "</literal>
<literal type="string">"and %s in %s. Version %s of %s left in tree at %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>change</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>, <argument><expr><name>change_past</name></expr></argument>,
<argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>alt_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s/delete): %s deleted in %s "</literal>
<literal type="string">"and %s to %s in %s. Version %s of %s left in tree at %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>change</name></expr></argument>, <argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>, <argument><expr><name>change_past</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>change_branch</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>alt_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>






<if_stmt><if>if <condition>(<expr><name>change_branch</name> <operator>!=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>||</operator> <name>alt_path</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>changed</name></expr></argument>, <argument><expr><name>update_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_delete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>orig</name> <init>= <expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rename_branch</name> <init>= <expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delete_branch</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>==</operator> <name><name>ren</name><operator>-&gt;</operator><name>branch</name></name></expr> ?</condition><then>
<expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr> </then><else>: <expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>handle_change_delete</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr> ?</condition><then> <expr><name><name>orig</name><operator>-&gt;</operator><name>path</name></name></expr> </then><else>: <expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>orig</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>,
<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
<argument><expr><name>rename_branch</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"rename"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"renamed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>rename_branch</name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><name>dest</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>rename_branch</name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>dest</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_file_collision</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collide_path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_path1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_path2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch2</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name></type> <name>null</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alt_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>update_path</name> <init>= <expr><name>collide_path</name></expr></init></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name>branch1</name> <operator>!=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>,
<argument><expr><name>prev_path2</name></expr></argument>, <argument><expr><name>prev_path1</name></expr></argument>,
<argument><expr><name>branch2</name></expr></argument>, <argument><expr><name>branch1</name></expr></argument>,
<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>prev_path1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>prev_path1</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>||</operator> <call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>prev_path1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prev_path2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>prev_path2</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>||</operator> <call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>prev_path2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name>was_dirty</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to lose dirty file at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>collide_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>update_path</name> <operator>=</operator> <name>alt_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>, <argument><expr><literal type="string">"merged"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to lose untracked file at "</literal>
<literal type="string">"%s, even though it's in the way."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>collide_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>update_path</name> <operator>=</operator> <name>alt_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>, <argument><expr><literal type="string">"merged"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>










<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name><name>null</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>collide_path</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>null</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>null</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>,
<argument><expr><name>branch1</name></expr></argument>, <argument><expr><name>branch2</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mfi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>mfi</name><operator>.</operator><name>clean</name></name> <operator>&amp;=</operator> <operator>!</operator><name>alt_path</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>mfi</name><operator>.</operator><name>clean</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>, <argument><expr><name>update_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mfi</name><operator>.</operator><name>clean</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator>
<call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>collide_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<return>return <expr><name><name>mfi</name><operator>.</operator><name>clean</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prev_path_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rename_branch</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>add_branch</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>==</operator> <name>rename_branch</name></expr> ?</condition><then>
<expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr> </then><else>: <expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>other_stage</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (rename/add): "</literal>
<literal type="string">"Rename %s-&gt;%s in %s. Added %s in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>rename_branch</name></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>add_branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_path_desc</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"version of %s from %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name></expr></argument>,
<argument><expr><name>prev_path_desc</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>,
<argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mfi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev_path_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>mfi</name><operator>.</operator><name>blob</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>rename_branch</name></expr></argument>, <argument><expr><name>add_branch</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_path_for_conflict</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dir_in_way</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>branch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s is a directory in %s adding "</literal>
<literal type="string">"as %s instead"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>branch2</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>would_lose_untracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>branch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to lose untracked file"</literal>
<literal type="string">" at %s; adding as %s instead"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>new_path</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>flip_stage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <name>stage</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_rename_1to2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>add</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path_desc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (rename/rename): "</literal>
<literal type="string">"Rename \"%s\"-&gt;\"%s\" in branch \"%s\" "</literal>
<literal type="string">"rename \"%s\"-&gt;\"%s\" in \"%s\"%s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (left unresolved)"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path_desc</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"%s and %s, both renamed from %s"</literal></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>path_desc</name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mfi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<expr_stmt><expr><name>add</name> <operator>=</operator> <operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><call><name>flip_stage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_valid</name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>add</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>mfi</name><operator>.</operator><name>blob</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>, <argument><expr><name>add</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><call><name>find_path_for_conflict</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>new_path</name></expr> ?</condition><then> <expr><name>new_path</name></expr> </then><else>: <expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator>
<call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>add</name> <operator>=</operator> <operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><call><name>flip_stage</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_valid</name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>add</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>mfi</name><operator>.</operator><name>blob</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name>add</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><call><name>find_path_for_conflict</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>new_path</name></expr> ?</condition><then> <expr><name>new_path</name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator>
<call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_rename_2to1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>c1</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>c2</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>c1</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path_side_1_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path_side_2_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi_c1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi_c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ostage1</name></decl>, <decl><type ref="prev"/><name>ostage2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (rename/rename): "</literal>
<literal type="string">"Rename %s-&gt;%s in %s. "</literal>
<literal type="string">"Rename %s-&gt;%s in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>c1</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>c2</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path_side_1_desc</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"version of %s from %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path_side_2_desc</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"version of %s from %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ostage1</name> <operator>=</operator> <ternary><condition><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ostage2</name> <operator>=</operator> <call><name>flip_stage</name><argument_list>(<argument><expr><name>ostage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>ostage1</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>ostage2</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>c1</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>ostage1</name></expr>]</index></name></expr></argument>,
<argument><expr><name>path_side_1_desc</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>,
<argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mfi_c1</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>ostage2</name></expr>]</index></name></expr></argument>,
<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>path_side_2_desc</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>,
<argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mfi_c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path_side_1_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path_side_2_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mfi_c1</name><operator>.</operator><name>blob</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mfi_c2</name><operator>.</operator><name>blob</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<return>return <expr><call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>mfi_c1</name><operator>.</operator><name>blob</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi_c2</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>get_diffpairs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>o_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_options</name></name></type> <name>opts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_diff_setup</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>recursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>flags</name><operator>.</operator><name>rename_empty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>detect_rename</name></name> <operator>=</operator> <call><name>merge_detect_rename</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>detect_rename</name></name> <operator>&gt;</operator> <name>DIFF_DETECT_RENAME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>detect_rename</name></name> <operator>=</operator> <name>DIFF_DETECT_RENAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>rename_limit</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name></expr> </then><else>: <expr><literal type="number">1000</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>rename_score</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>rename_score</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>show_rename_progress</name></name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>show_rename_progress</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_NO_OUTPUT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_setup_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_tree_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o_tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diffcore_std</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>needed_rename_limit</name></name> <operator>&gt;</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>needed_rename_limit</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>needed_rename_limit</name></name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>needed_rename_limit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <name>diff_queued_diff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>output_format</name></name> <operator>=</operator> <name>DIFF_FORMAT_NO_OUTPUT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_queued_diff</name><operator>.</operator><name>nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff_queued_diff</name><operator>.</operator><name>queue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tree_has_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>hashy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>mode_o</name></decl>;</decl_stmt>

<return>return <expr><operator>!</operator><call><name>get_tree_entry</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>hashy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode_o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>apply_dir_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>new_path</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldlen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>








<expr_stmt><expr><name>oldlen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>len</name></name> <operator>+</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>oldlen</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_path</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_path</name><index>[<expr><name>oldlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_renamed_dir_portion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>old_dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end_of_old</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_of_new</name></decl>;</decl_stmt>


<expr_stmt><expr><operator>*</operator><name>old_dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>














<expr_stmt><expr><name>end_of_old</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end_of_new</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><name>end_of_old</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 





<if_stmt><if>if <condition>(<expr><name>end_of_new</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>old_dir</name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>end_of_old</name> <operator>-</operator> <name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_dir</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>*</operator><operator>--</operator><name>end_of_new</name> <operator>==</operator> <operator>*</operator><operator>--</operator><name>end_of_old</name> <operator>&amp;&amp;</operator>
<name>end_of_old</name> <operator>!=</operator> <name>old_path</name> <operator>&amp;&amp;</operator>
<name>end_of_new</name> <operator>!=</operator> <name>new_path</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while> 





<if_stmt><if>if <condition>(<expr><name>end_of_old</name> <operator>==</operator> <name>old_path</name> <operator>&amp;&amp;</operator> <name>end_of_new</name> <operator>==</operator> <name>new_path</name> <operator>&amp;&amp;</operator>
<operator>*</operator><name>end_of_old</name> <operator>==</operator> <operator>*</operator><name>end_of_new</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 












<if_stmt><if>if <condition>(<expr><name>end_of_new</name> <operator>==</operator> <name>new_path</name> <operator>&amp;&amp;</operator>
<name>end_of_old</name> <operator>!=</operator> <name>old_path</name> <operator>&amp;&amp;</operator> <name><name>end_of_old</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>old_dir</name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><operator>--</operator><name>end_of_old</name> <operator>-</operator> <name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_dir</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



















<expr_stmt><expr><name>end_of_old</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>++</operator><name>end_of_old</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end_of_new</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>++</operator><name>end_of_new</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>old_dir</name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>end_of_old</name> <operator>-</operator> <name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_dir</name> <operator>=</operator> <call><name>xstrndup</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>end_of_new</name> <operator>-</operator> <name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_hashmap_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>items_to_remove</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>items_to_remove</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>items_to_remove</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_remove</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><name>items_to_remove</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>handle_path_level_conflicts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>collisions</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>collision_entry</name></name> <modifier>*</modifier></type><name>collision_ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>collision_paths</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>apply_dir_rename</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_path</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"entry-&gt;non_unqiue_dir not set and !new_path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (directory rename split): "</literal>
<literal type="string">"Unclear where to place %s because directory "</literal>
<literal type="string">"%s was renamed to multiple other directories, "</literal>
<literal type="string">"with no destination getting a majority of the "</literal>
<literal type="string">"files."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>collision_ent</name> <operator>=</operator> <call><name>collision_find_entry</name><argument_list>(<argument><expr><name>collisions</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>collision_ent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"collision_ent is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>collision_ent</name><operator>-&gt;</operator><name>reported_already</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tree_has_path</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>collision_ent</name><operator>-&gt;</operator><name>reported_already</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add_separated_string_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collision_paths</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>collision_ent</name><operator>-&gt;</operator><name>source_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (implicit dir rename): Existing "</literal>
<literal type="string">"file/dir at %s in the way of implicit "</literal>
<literal type="string">"directory rename(s) putting the following "</literal>
<literal type="string">"path(s) there: %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>collision_paths</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>collision_ent</name><operator>-&gt;</operator><name>source_files</name><operator>.</operator><name>nr</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>collision_ent</name><operator>-&gt;</operator><name>reported_already</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add_separated_string_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collision_paths</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>collision_ent</name><operator>-&gt;</operator><name>source_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (implicit dir rename): Cannot map "</literal>
<literal type="string">"more than one path to %s; implicit directory "</literal>
<literal type="string">"renames tried to put these paths there: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>collision_paths</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collision_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>clean</name> <operator>&amp;&amp;</operator> <name>new_path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>new_path</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_directory_level_conflicts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_re_head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_re_merge</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>head_ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>merge_ent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>remove_from_head</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>remove_from_merge</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>dir_re_head</argument>, <argument>&amp;iter</argument>, <argument>head_ent</argument>,
<argument>ent</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>merge_ent</name> <operator>=</operator> <call><name>dir_rename_find_entry</name><argument_list>(<argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>merge_ent</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>head_ent</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>merge_ent</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strbuf_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>merge_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_head</name></expr></argument>,
<argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>head_ent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_merge</name></expr></argument>,
<argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>merge_ent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merge_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tree_has_path</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_head</name></expr></argument>,
<argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>head_ent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>remove_hashmap_entries</name><argument_list>(<argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remove_from_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_hashmap_entries</name><argument_list>(<argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remove_from_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>dir_re_merge</argument>, <argument>&amp;iter</argument>, <argument>merge_ent</argument>,
<argument>ent</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>head_ent</name> <operator>=</operator> <call><name>dir_rename_find_entry</name><argument_list>(<argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tree_has_path</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_merge</name></expr></argument>,
<argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>merge_ent</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>head_ent</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>head_ent</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>merge_ent</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (rename/rename): "</literal>
<literal type="string">"Rename directory %s-&gt;%s in %s. "</literal>
<literal type="string">"Rename directory %s-&gt;%s in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>,
<argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_head</name></expr></argument>,
<argument><expr><name><name>head_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>head_ent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remove_from_merge</name></expr></argument>,
<argument><expr><name><name>merge_ent</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>merge_ent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merge_ent</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>remove_hashmap_entries</name><argument_list>(<argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remove_from_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_hashmap_entries</name><argument_list>(<argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remove_from_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>get_directory_renames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>pairs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

















<expr_stmt><expr><name>dir_renames</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dir_renames</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dir_rename_init</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pairs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><name><name>pairs</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_dir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_dir</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>get_renamed_dir_portion</name><argument_list>(<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>old_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_dir</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dir_rename_find_entry</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>, <argument><expr><name>old_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dir_rename_entry_init</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>old_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_put</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>old_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name></name></expr></argument>, <argument><expr><name>new_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name></name></expr></argument>,
<argument><expr><name>new_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>










<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>dir_renames</argument>, <argument>&amp;iter</argument>, <argument>entry</argument>,
<argument>ent</argument> )</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bad_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>best</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>count</name> <operator>==</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bad_max</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>count</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>bad_max</name> <operator>==</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>non_unique_new_dir</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>, <argument><expr><name>best</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>








<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name><operator>.</operator><name>strdup_strings</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>possible_new_dirs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><name>dir_renames</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>check_dir_renamed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>end</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dir_rename_find_entry</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compute_collisions</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>collisions</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>pairs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

















<expr_stmt><expr><call><name>collision_init</name><argument_list>(<argument><expr><name>collisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pairs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>dir_rename_ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>collision_entry</name></name> <modifier>*</modifier></type><name>collision_ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><name><name>pairs</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dir_rename_ent</name> <operator>=</operator> <call><name>check_dir_renamed</name><argument_list>(<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name>dir_renames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir_rename_ent</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>apply_dir_rename</name><argument_list>(<argument><expr><name>dir_rename_ent</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_path</name></expr>)</condition><block type="pseudo"><block_content>






<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>collision_ent</name> <operator>=</operator> <call><name>collision_find_entry</name><argument_list>(<argument><expr><name>collisions</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collision_ent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>collision_ent</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>collision_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>collision_ent</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>,
<argument><expr><call><name>strhash</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_put</name><argument_list>(<argument><expr><name>collisions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>collision_ent</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>collision_ent</name><operator>-&gt;</operator><name>target_file</name></name> <operator>=</operator> <name>new_path</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>collision_ent</name><operator>-&gt;</operator><name>source_files</name></name></expr></argument>,
<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>check_for_directory_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_rename_exclusions</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>collisions</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>clean_merge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>check_dir_renamed</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir_renames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>oentry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>new_path</name></expr>;</return></block_content></block></if></if_stmt>

























<expr_stmt><expr><name>oentry</name> <operator>=</operator> <call><name>dir_rename_find_entry</name><argument_list>(<argument><expr><name>dir_rename_exclusions</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oentry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WARNING: Avoiding applying %s -&gt; %s rename "</literal>
<literal type="string">"to %s, because %s itself was renamed."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>new_dir</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>handle_path_level_conflicts</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
<argument><expr><name>collisions</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>clean_merge</name> <operator>&amp;=</operator> <operator>(</operator><name>new_path</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>new_path</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>apply_directory_rename_modifications</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>pair</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>o_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>a_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>b_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stage</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>tree</name> <operator>==</operator> <name>a_tree</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>update_wd</name></decl>;</decl_stmt>










<expr_stmt><expr><name>update_wd</name> <operator>=</operator> <operator>!</operator><call><name>was_dirty</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update_wd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to lose dirty file at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>!</operator><name>update_wd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>









<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name></name> <operator>=</operator> <call><name>insert_stage_data</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>,
<argument><expr><name>o_tree</name></expr></argument>, <argument><expr><name>a_tree</name></expr></argument>, <argument><expr><name>b_tree</name></expr></argument>,
<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_insert</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>dst_entry</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

















<expr_stmt><expr><call><name>get_tree_entry</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>stage</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>stage</name></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>





<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="char">'R'</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>new_path</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>get_renames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branch</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>pairs</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_rename_exclusions</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>o_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>a_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>b_tree</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>clean_merge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name></type> <name>collisions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>collision_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>renames</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>compute_collisions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collisions</name></expr></argument>, <argument><expr><name>dir_renames</name></expr></argument>, <argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>renames</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>string_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pairs</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filepair</name></name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><name><name>pairs</name><operator>-&gt;</operator><name>queue</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'R'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>diff_free_filepair</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>check_for_directory_rename</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>,
<argument><expr><name>dir_renames</name></expr></argument>,
<argument><expr><name>dir_rename_exclusions</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>collisions</name></expr></argument>,
<argument><expr><name>clean_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>new_path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>diff_free_filepair</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>re</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name></name> <operator>=</operator> <name>pair</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>branch</name></name> <operator>=</operator> <name>branch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>src_entry</name></name> <operator>=</operator> <call><name>insert_stage_data</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name>o_tree</name></expr></argument>, <argument><expr><name>a_tree</name></expr></argument>, <argument><expr><name>b_tree</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>src_entry</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name></name> <operator>=</operator> <call><name>insert_stage_data</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
<argument><expr><name>o_tree</name></expr></argument>, <argument><expr><name>a_tree</name></expr></argument>, <argument><expr><name>b_tree</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dst_entry</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>string_list_insert</name><argument_list>(<argument><expr><name>renames</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>util</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_path</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>apply_directory_rename_modifications</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>,
<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>o_tree</name></expr></argument>,
<argument><expr><name>a_tree</name></expr></argument>, <argument><expr><name>b_tree</name></expr></argument>,
<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>&amp;collisions</argument>, <argument>&amp;iter</argument>, <argument>e</argument>,
<argument>ent</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>target_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>source_files</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collisions</name></expr></argument>, <argument><expr>struct <name>collision_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>renames</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>process_renames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>a_renames</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>b_renames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>clean_merge</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>a_by_dst</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>b_by_dst</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>sre</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sre</name> <operator>=</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a_by_dst</name></expr></argument>, <argument><expr><name><name>sre</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name>
<operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sre</name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sre</name> <operator>=</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b_by_dst</name></expr></argument>, <argument><expr><name><name>sre</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name>
<operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sre</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>nr</name></name> <operator>||</operator> <name>j</name> <operator>&lt;</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>renames1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>renames2Dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ren2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ren1_src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ren1_dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>lookup</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ren2</name> <operator>=</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ren1</name> <operator>=</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>compare</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>,
<argument><expr><name><name>b_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ren1</name> <operator>=</operator> <name><name>a_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ren2</name> <operator>=</operator> <name><name>b_renames</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ren1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>renames1</name> <operator>=</operator> <name>a_renames</name></expr>;</expr_stmt>
<expr_stmt><expr><name>renames2Dst</name> <operator>=</operator> <operator>&amp;</operator><name>b_by_dst</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>renames1</name> <operator>=</operator> <name>b_renames</name></expr>;</expr_stmt>
<expr_stmt><expr><name>renames2Dst</name> <operator>=</operator> <operator>&amp;</operator><name>a_by_dst</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>ren2</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ren1</name><operator>-&gt;</operator><name>processed</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ren1</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>



<expr_stmt><expr><name><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ren1_src</name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ren1_dst</name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ren2</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ren2_src</name> <init>= <expr><name><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ren2_dst</name> <init>= <expr><name><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>rename_type</name></name></type> <name>rename_type</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ren1_src</name></expr></argument>, <argument><expr><name>ren2_src</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"ren1_src != ren2_src"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ren2</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ren2</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ren1_dst</name></expr></argument>, <argument><expr><name>ren2_dst</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rename_type</name> <operator>=</operator> <name>RENAME_ONE_FILE_TO_TWO</name></expr>;</expr_stmt>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>rename_type</name> <operator>=</operator> <name>RENAME_ONE_FILE_TO_ONE</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ren1_src</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_entry</name><argument_list>(<argument><expr><name><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name></name></expr></argument>,
<argument><expr><name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr></argument>,
<argument><expr><name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></argument>,
<argument><expr><name><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>rename_type</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>ren2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>lookup</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>renames2Dst</name></expr></argument>, <argument><expr><name>ren1_dst</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ren2_dst</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ren2</name> <operator>=</operator> <name><name>lookup</name><operator>-&gt;</operator><name>util</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ren2_dst</name> <operator>=</operator> <name><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ren1_dst</name></expr></argument>, <argument><expr><name>ren2_dst</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"ren1_dst != ren2_dst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ren2</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>





<expr_stmt><expr><name><name>ren2</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>RENAME_TWO_FILES_TO_ONE</name></expr></argument>,
<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>ren2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name></type> <name>src_other</name></decl>, <decl><type ref="prev"/><name>dst_other</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>try_merge</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>int</name></type> <name>renamed_stage</name> <init>= <expr><ternary><condition><expr><name>a_renames</name> <operator>==</operator> <name>renames1</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>other_stage</name> <init>= <expr><ternary><condition><expr><name>a_renames</name> <operator>==</operator> <name>renames1</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ren1_src</name></expr></argument>,
<argument><expr><name>renamed_stage</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>was_tracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_other</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src_other</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>src_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_other</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst_other</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><name>other_stage</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>try_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_other</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ren1</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>RENAME_VIA_DIR</name></expr></argument>,
<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src_other</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>RENAME_DELETE</name></expr></argument>,
<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>dst_other</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>mode</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_other</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>








<if_stmt><if>if <condition>(<expr><call><name>update_file_flags</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr></argument>,
<argument><expr><name>ren1_dst</name></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, 
<argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_other</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>RENAME_ADD</name></expr></argument>,
<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>try_merge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>clean_merge</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup_and_return</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>try_merge</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>src_other</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ren1_src</name></expr>;</expr_stmt>

<expr_stmt><expr><name>o</name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>a_renames</name> <operator>==</operator> <name>renames1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>&amp;</operator><name>src_other</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>&amp;</operator><name>src_other</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>update_entry</name><argument_list>(<argument><expr><name><name>ren1</name><operator>-&gt;</operator><name>dst_entry</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_rename_conflict_info</name><argument_list>(<argument><expr><name>RENAME_NORMAL</name></expr></argument>,
<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<label><name>cleanup_and_return</name>:</label>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a_by_dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b_by_dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clean_merge</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>rename_info</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>head_renames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>merge_renames</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initial_cleanup_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>pairs</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_renames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_rename_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<macro><name>hashmap_for_each_entry</name><argument_list>(<argument>dir_renames</argument>, <argument>&amp;iter</argument>, <argument>e</argument>,
<argument>ent</argument> )</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>
<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>, <argument><expr>struct <name>dir_rename_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dir_renames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pairs</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>detect_and_process_renames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>common</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_info</name></name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_queue_struct</name></name> <modifier>*</modifier></type><name>head_pairs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>merge_pairs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>dir_re_head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dir_re_merge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>head_renames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>merge_renames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>merge_detect_rename</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>head_pairs</name> <operator>=</operator> <call><name>get_diffpairs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>common</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_pairs</name> <operator>=</operator> <call><name>get_diffpairs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>common</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>==</operator> <name>MERGE_DIRECTORY_RENAMES_TRUE</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>==</operator> <name>MERGE_DIRECTORY_RENAMES_CONFLICT</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dir_re_head</name> <operator>=</operator> <call><name>get_directory_renames</name><argument_list>(<argument><expr><name>head_pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dir_re_merge</name> <operator>=</operator> <call><name>get_directory_renames</name><argument_list>(<argument><expr><name>merge_pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>handle_directory_level_conflicts</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><name>head</name></expr></argument>,
<argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dir_re_head</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dir_re_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dir_re_merge</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dir_re_merge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dir_rename_init</name><argument_list>(<argument><expr><name>dir_re_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dir_rename_init</name><argument_list>(<argument><expr><name>dir_re_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>head_renames</name></name> <operator>=</operator> <call><name>get_renames</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>, <argument><expr><name>head_pairs</name></expr></argument>,
<argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><name>head</name></expr></argument>,
<argument><expr><name>common</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>clean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>merge_renames</name></name> <operator>=</operator> <call><name>get_renames</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>, <argument><expr><name>merge_pairs</name></expr></argument>,
<argument><expr><name>dir_re_head</name></expr></argument>, <argument><expr><name>dir_re_merge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>,
<argument><expr><name>common</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>clean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clean</name> <operator>&amp;=</operator> <call><name>process_renames</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>head_renames</name></name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>merge_renames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>





<expr_stmt><expr><call><name>initial_cleanup_rename</name><argument_list>(<argument><expr><name>head_pairs</name></expr></argument>, <argument><expr><name>dir_re_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initial_cleanup_rename</name><argument_list>(<argument><expr><name>merge_pairs</name></expr></argument>, <argument><expr><name>dir_re_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>final_cleanup_rename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>rename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rename</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>re</name> <operator>=</operator> <name><name>rename</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_free_filepair</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>pair</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><name>rename</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>final_cleanup_renames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rename_info</name></name> <modifier>*</modifier></type><name>re_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>final_cleanup_rename</name><argument_list>(<argument><expr><name><name>re_info</name><operator>-&gt;</operator><name>head_renames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>final_cleanup_rename</name><argument_list>(<argument><expr><name><name>re_info</name><operator>-&gt;</operator><name>merge_renames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_oid_strbuf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot read object %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %s is not a blob"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_attach</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>blob_unchanged</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>renormalize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>obuf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>abuf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name><name>o</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>renormalize</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_oid_strbuf</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obuf</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>read_oid_strbuf</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>renormalize_buffer</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>obuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>obuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obuf</name></expr></argument>)</argument_list></call> <operator>|</operator>
<call><name>renormalize_buffer</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>abuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>abuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name><name>obuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>abuf</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>obuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>abuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>obuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>error_return</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_modify_delete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modify_branch</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>delete_branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>changed</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_valid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>modify_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>delete_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>modify_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>delete_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>handle_change_delete</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>o</name></expr></argument>, <argument><expr><name>changed</name></expr></argument>,
<argument><expr><name>modify_branch</name></expr></argument>, <argument><expr><name>delete_branch</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"modify"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"modified"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_content_merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_file_info</name></name> <modifier>*</modifier></type><name>mfi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_dirty</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"content"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>df_conflict_remains</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_valid</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"add/add"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>path</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>&amp;&amp;</operator> <call><name>dir_in_way</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr></argument>,
<argument><expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>df_conflict_remains</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>merge_mode_and_contents</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>mfi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name> <operator>&amp;&amp;</operator> <call><name>was_tracked_and_matches</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>df_conflict_remains</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Skipped %s (merged same as existing)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_cacheinfo</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_dirty</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>






<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>orig_index</name><operator>.</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_flags</name></name> <operator>|=</operator> <name>CE_SKIP_WORKTREE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>mfi</name><operator>-&gt;</operator><name>blob</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"submodule"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s): Merge conflict in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>reason</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>df_conflict_remains</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>df_conflict_remains</name> <operator>||</operator> <name>is_dirty</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>file_from_stage2</name> <init>= <expr><call><name>was_tracked</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>file_from_stage2</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>file_from_stage2</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>new_path</name> <operator>=</operator> <call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_dirty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Refusing to lose dirty file at %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Adding as %s instead"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mfi</name><operator>-&gt;</operator><name>blob</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>!</operator><name>is_dirty</name> <operator>&amp;&amp;</operator> <name><name>mfi</name><operator>-&gt;</operator><name>clean</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_rename_normal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>side</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>handle_content_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mfi</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>was_dirty</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&amp;&amp;</operator>
<name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>==</operator> <name>MERGE_DIRECTORY_RENAMES_CONFLICT</name> <operator>&amp;&amp;</operator>
<name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>update_stages</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>side</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>side</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>mfi</name><operator>.</operator><name>blob</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dir_rename_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_add</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>clean</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>other_branch</name></decl>;</decl_stmt>
<expr_stmt><expr><name>other_branch</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr> ?</condition><then>
<expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr> </then><else>: <expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_add</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><ternary><condition><expr><name>clean</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
<argument><expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name>other_branch</name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><ternary><condition><expr><name>clean</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
<argument><expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>,
<argument><expr><name>other_branch</name></expr></argument>, <argument><expr><name><name>ren</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>warn_about_dir_renamed_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rename</name></name> <modifier>*</modifier></type><name>ren</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_add</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ren</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>clean</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_dest</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>clean</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>&gt;</operator> <name>MERGE_DIRECTORY_RENAMES_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>||</operator>
<name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>clean</name> <operator>=</operator> <operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>==</operator> <name>MERGE_DIRECTORY_RENAMES_TRUE</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>is_add</name> <operator>=</operator> <operator>(</operator><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'A'</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>clean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Path updated: %s added in %s inside a "</literal>
<literal type="string">"directory that was renamed in %s; moving it to %s."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>clean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (file location): %s added in %s "</literal>
<literal type="string">"inside a directory that was renamed in %s, "</literal>
<literal type="string">"suggesting it should perhaps be moved to %s."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <name>clean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Path updated: %s renamed to %s in %s, inside a "</literal>
<literal type="string">"directory that was renamed in %s; moving it to %s."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ren</name><operator>-&gt;</operator><name>dir_rename_original_type</name></name> <operator>==</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>clean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (file location): %s renamed to %s in %s, "</literal>
<literal type="string">"inside a directory that was renamed in %s, "</literal>
<literal type="string">"suggesting it should perhaps be moved to %s."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"Impossible dir_rename_original_type/clean combination"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>dir_rename_warning</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>is_add</name></expr></argument>, <argument><expr><name>clean</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>process_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>clean_merge</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>normalize</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>renormalize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>stages</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>o_valid</name> <init>= <expr><call><name>is_valid</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a_valid</name> <init>= <expr><call><name>is_valid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_valid</name> <init>= <expr><call><name>is_valid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>rename_conflict_info</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rename_conflict_info</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>rename_conflict_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>path_clean</name></decl>;</decl_stmt>

<expr_stmt><expr><name>path_clean</name> <operator>=</operator> <call><name>warn_about_dir_renamed_entries</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path_clean</name> <operator>&amp;=</operator> <call><name>warn_about_dir_renamed_entries</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name>temp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>==</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>b</name></expr> </then><else>: <expr><name>a</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>temp</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>ren2</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>==</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>branch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>rename_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RENAME_NORMAL</name></expr>:</case>
<case>case <expr><name>RENAME_ONE_FILE_TO_ONE</name></expr>:</case>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_rename_normal</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RENAME_VIA_DIR</name></expr>:</case>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_rename_via_dir</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RENAME_ADD</name></expr>:</case>






<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_rename_add</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RENAME_DELETE</name></expr>:</case>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_rename_delete</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>RENAME_ONE_FILE_TO_TWO</name></expr>:</case>




<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>one</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_rename_rename_1to2</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>RENAME_TWO_FILES_TO_ONE</name></expr>:</case>




<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren1</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>ren2</name><operator>-&gt;</operator><name>pair</name><operator>-&gt;</operator><name>two</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>







<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_rename_rename_2to1</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>path_clean</name> <operator>&lt;</operator> <name>clean_merge</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <name>path_clean</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>o_valid</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>a_valid</name> <operator>||</operator> <operator>!</operator><name>b_valid</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>a_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>b_valid</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>b_valid</name> <operator>&amp;&amp;</operator> <call><name>blob_unchanged</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>normalize</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>a_valid</name> <operator>&amp;&amp;</operator> <call><name>blob_unchanged</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>normalize</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>a_valid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Removing %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>!</operator><name>a_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>handle_modify_delete</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>o_valid</name> <operator>&amp;&amp;</operator> <name>a_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>b_valid</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>o_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>a_valid</name> <operator>&amp;&amp;</operator> <name>b_valid</name><operator>)</operator></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>add_branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>other_branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>diff_filespec</name></name> <modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a_valid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>other_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>contents</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>conf</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"file/directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>add_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>other_branch</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>contents</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>conf</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory/file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dir_in_way</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_path</name> <init>= <expr><call><name>unique_path</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>add_branch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (%s): There is a directory with name %s in %s. "</literal>
<literal type="string">"Adding %s as %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>other_branch</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>update_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>remove_file_from_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Adding %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>update_file_flags</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name>a_valid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>a_valid</name> <operator>&amp;&amp;</operator> <name>b_valid</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o_valid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONFLICT (add/add): Merge conflict in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_file_collision</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>,
<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>merge_file_info</name></name></type> <name>mfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_dirty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><name>clean_merge</name> <operator>=</operator> <call><name>handle_content_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mfi</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>is_dirty</name></expr></argument>,
<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>o_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>a_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>b_valid</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>remove_file</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"fatal merge failure, shouldn't happen."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>clean_merge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_trees_internal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge_base</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>, <decl><type ref="prev"/><name>clean</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>subtree_shift</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>merge</name> <operator>=</operator> <call><name>shift_tree_object</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>subtree_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_base</name> <operator>=</operator> <call><name>shift_tree_object</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge_base</name></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>subtree_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merge_base</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>merge</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Already up to date!"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>unpack_trees_start</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>merge_base</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"merging of trees %s and %s failed"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>head</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merge</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>unpack_trees_finish</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unmerged_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rename_info</name></name></type> <name>re_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>







<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>current_file_dir_set</name></name></expr></argument>, <argument><expr><name>path_hashmap_cmp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_files_dirs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_files_dirs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>get_unmerged</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>detect_and_process_renames</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>merge_base</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>,
<argument><expr><name>entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>re_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>record_df_conflict_files</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>entries</name><operator>-&gt;</operator><name>nr</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>entries</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>entries</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>processed</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>process_entry</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entries</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stage_data</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>entries</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>util</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>processed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"unprocessed path??? %s"</literal></expr></argument>,
<argument><expr><name><name>entries</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>final_cleanup_renames</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>current_file_dir_set</name></name></expr></argument>,
<argument><expr>struct <name>path_hashmap_entry</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unpack_trees_finish</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>unpack_trees_finish</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><operator>*</operator><name>result</name> <operator>=</operator> <call><name>write_in_core_index_as_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>reverse_commit_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>backup</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>current</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>current</name></expr>;</condition> <incr><expr><name>current</name> <operator>=</operator> <name>backup</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>backup</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>next</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_recursive_internal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>h1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>h2</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>merge_bases</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>merged_merge_bases</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>result_tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ancestor_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>merge_base_abbrev</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Merging:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_commit_title</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>h1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_commit_title</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>h2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merge_bases</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>merge_bases</name> <operator>=</operator> <call><name>get_merge_bases</name><argument_list>(<argument><expr><name>h1</name></expr></argument>, <argument><expr><name>h2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_bases</name> <operator>=</operator> <call><name>reverse_commit_list</name><argument_list>(<argument><expr><name>merge_bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>cnt</name> <init>= <expr><call><name>commit_list_count</name><argument_list>(<argument><expr><name>merge_bases</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"found %u common ancestor:"</literal></expr></argument>,
<argument><expr><literal type="string">"found %u common ancestors:"</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>iter</name> <operator>=</operator> <name>merge_bases</name></expr>;</init> <condition><expr><name>iter</name></expr>;</condition> <incr><expr><name>iter</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_commit_title</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>merged_merge_bases</name> <operator>=</operator> <call><name>pop_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_bases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>merged_merge_bases</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>lookup_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>hash_algo</name><operator>-&gt;</operator><name>empty_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merged_merge_bases</name> <operator>=</operator> <call><name>make_virtual_commit</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>,
<argument><expr><literal type="string">"ancestor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ancestor_name</name> <operator>=</operator> <literal type="string">"empty tree"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ancestor_name</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>merge_bases</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ancestor_name</name> <operator>=</operator> <literal type="string">"merged common ancestors"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_add_unique_abbrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_base_abbrev</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>merged_merge_bases</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><name>DEFAULT_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ancestor_name</name> <operator>=</operator> <name><name>merge_base_abbrev</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>iter</name> <operator>=</operator> <name>merge_bases</name></expr>;</init> <condition><expr><name>iter</name></expr>;</condition> <incr><expr><name>iter</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>saved_b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>saved_b2</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name><operator>++</operator></expr>;</expr_stmt>








<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>saved_b1</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>saved_b2</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>=</operator> <literal type="string">"Temporary merge branch 1"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name> <operator>=</operator> <literal type="string">"Temporary merge branch 2"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>merge_recursive_internal</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>merged_merge_bases</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>item</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_merge_bases</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>=</operator> <name>saved_b1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name> <operator>=</operator> <name>saved_b2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>merged_merge_bases</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"merge returned no commit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>discard_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>repo_read_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>=</operator> <name>ancestor_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>merge_trees_internal</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
<argument><expr><call><name>repo_get_commit_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>h1</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>repo_get_commit_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>h2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>repo_get_commit_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>,
<argument><expr><name>merged_merge_bases</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>result_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_base_abbrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>flush_output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>make_virtual_commit</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>result_tree</name></expr></argument>,
<argument><expr><literal type="string">"merged tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>h1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>h2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name><name>parents</name><operator>-&gt;</operator><name>next</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>merge_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>&lt;=</operator> <name>DIFF_DETECT_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>&gt;=</operator> <name>MERGE_DIRECTORY_RENAMES_NONE</name> <operator>&amp;&amp;</operator>
<name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>&lt;=</operator> <name>MERGE_DIRECTORY_RENAMES_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>rename_score</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>rename_score</name></name> <operator>&lt;=</operator> <name>MAX_SCORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>show_rename_progress</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>show_rename_progress</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name> <operator>&gt;=</operator> <name>MERGE_VARIANT_NORMAL</name> <operator>&amp;&amp;</operator>
<name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name> <operator>&lt;=</operator> <name>MERGE_VARIANT_THEIRS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&lt;=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>obuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>repo_index_has_changes</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Your local changes to the following files would be overwritten by merge:\n %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>df_conflict_file_set</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>merge_finalize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>flush_output</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>call_depth</name></name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>show</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>diff_warn_rename_limit</name><argument_list>(<argument><expr><literal type="string">"merge.renamelimit"</literal></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name><operator>-&gt;</operator><name>needed_rename_limit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>priv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>merge_trees</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>merge_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree</name></name> <modifier>*</modifier></type><name>ignored</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>merge_start</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>merge_trees_internal</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name>merge_base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>merge_finalize</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>merge_recursive</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>h1</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>h2</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>merge_bases</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name></expr></argument>, <argument><expr><literal type="string">"constructed merge base"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>merge_start</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>repo_get_commit_tree</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>h1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>merge_recursive_internal</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>h1</name></expr></argument>, <argument><expr><name>h2</name></expr></argument>, <argument><expr><name>merge_bases</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>merge_finalize</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>get_ref</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>object</name></decl>;</decl_stmt>

<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>deref_tag</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>object</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>make_virtual_commit</name><argument_list>(<argument><expr><name>repo</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>tree</name><operator>*</operator><operator>)</operator><name>object</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_commit</name><argument_list>(<argument><expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator>struct <name>commit</name> <operator>*</operator><operator>)</operator><name>object</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>merge_recursive_generic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>head</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>merge</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>num_merge_bases</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>merge_bases</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lock_file</name></name></type> <name>lock</name> <init>= <expr><name>LOCK_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>head_commit</name> <init>= <expr><call><name>get_ref</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>next_commit</name> <init>= <expr><call><name>get_ref</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>branch2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>merge_bases</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_merge_bases</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>base</name> <operator>=</operator> <call><name>get_ref</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><name><name>merge_bases</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name><name>merge_bases</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Could not parse object '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name><name>merge_bases</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>commit_list_insert</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>num_merge_bases</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>ancestor</name></name> <operator>=</operator> <literal type="string">"constructed merge base"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>repo_hold_locked_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>, <argument><expr><name>LOCK_DIE_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clean</name> <operator>=</operator> <call><name>merge_recursive</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>head_commit</name></expr></argument>, <argument><expr><name>next_commit</name></expr></argument>, <argument><expr><name>ca</name></expr></argument>,
<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>clean</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>clean</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write_locked_index</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>,
<argument><expr><name>COMMIT_LOCK</name> <operator>|</operator> <name>SKIP_IF_UNCHANGED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>err</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unable to write index."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>clean</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>merge_recursive_config</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"merge.verbosity"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"diff.renamelimit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"merge.renamelimit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_string</name><argument_list>(<argument><expr><literal type="string">"diff.renames"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <call><name>git_config_rename</name><argument_list>(<argument><expr><literal type="string">"diff.renames"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_string</name><argument_list>(<argument><expr><literal type="string">"merge.renames"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <call><name>git_config_rename</name><argument_list>(<argument><expr><literal type="string">"merge.renames"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_string</name><argument_list>(<argument><expr><literal type="string">"merge.directoryrenames"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>boolval</name> <init>= <expr><call><name>git_parse_maybe_bool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>boolval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>=</operator> <ternary><condition><expr><name>boolval</name></expr> ?</condition><then>
<expr><name>MERGE_DIRECTORY_RENAMES_TRUE</name></expr> </then><else>:
<expr><name>MERGE_DIRECTORY_RENAMES_NONE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"conflict"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>=</operator>
<name>MERGE_DIRECTORY_RENAMES_CONFLICT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt> 
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_xmerge_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>init_merge_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>merge_verbosity</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>merge_options</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>repo</name></name> <operator>=</operator> <name>repo</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_directory_renames</name></name> <operator>=</operator> <name>MERGE_DIRECTORY_RENAMES_CONFLICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>rename_limit</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>renormalize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>merge_recursive_config</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_verbosity</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GIT_MERGE_VERBOSITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>merge_verbosity</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>merge_verbosity</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>buffer_output</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_merge_opt</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>merge_options</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"ours"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name> <operator>=</operator> <name>MERGE_VARIANT_OURS</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"theirs"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>recursive_variant</name></name> <operator>=</operator> <name>MERGE_VARIANT_THEIRS</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"subtree"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>subtree_shift</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"subtree="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>subtree_shift</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"patience"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name> <operator>=</operator> <call><name>DIFF_WITH_ALG</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>PATIENCE_DIFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"histogram"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name> <operator>=</operator> <call><name>DIFF_WITH_ALG</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>HISTOGRAM_DIFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"diff-algorithm="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>parse_algorithm_value</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DIFF_XDL_CLR</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>NEED_MINIMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name> <operator>&amp;=</operator> <operator>~</operator><name>XDF_DIFF_ALGORITHM_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>xdl_opts</name></name> <operator>|=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"ignore-space-change"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DIFF_XDL_SET</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>IGNORE_WHITESPACE_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"ignore-all-space"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DIFF_XDL_SET</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>IGNORE_WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"ignore-space-at-eol"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DIFF_XDL_SET</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>IGNORE_WHITESPACE_AT_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"ignore-cr-at-eol"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DIFF_XDL_SET</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>IGNORE_CR_AT_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"renormalize"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>renormalize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"no-renormalize"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>renormalize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"no-renames"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"find-renames"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>rename_score</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"find-renames="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>skip_prefix</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"rename-threshold="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>rename_score</name></name> <operator>=</operator> <call><name>parse_rename_score</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>detect_renames</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>




<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
