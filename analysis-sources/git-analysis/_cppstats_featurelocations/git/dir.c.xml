<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\dir.c">






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wildmatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathspec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"varint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ewah/ewok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fsmonitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"submodule-config.h"</cpp:file></cpp:include>







<enum>enum <name>path_treatment</name> <block>{
<decl><name>path_none</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>path_recurse</name></decl>,
<decl><name>path_excluded</name></decl>,
<decl><name>path_untracked</name></decl>
}</block>;</enum>




<struct>struct <name>cached_dir</name> <block>{
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>fdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr_dirs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>d_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ucd</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>read_directory_recursive</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop_at_first_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>resolve_dtype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type> <name>count_slashes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fspathcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then> <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fspathncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then> <expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>git_fnmatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec_item</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>WM_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pattern</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>string</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATHSPEC_ONESTAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pattern_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>++</operator><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>string_len</name> <operator>&lt;</operator> <name>pattern_len</name> <operator>||</operator>
<call><name>ps_strcmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
<argument><expr><name>string</name> <operator>+</operator> <name>string_len</name> <operator>-</operator> <name>pattern_len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_GLOB</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>wildmatch</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
<argument><expr><name>WM_PATHNAME</name> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_ICASE</name></expr> ?</condition><then> <expr><name>WM_CASEFOLD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>wildmatch</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_ICASE</name></expr> ?</condition><then> <expr><name>WM_CASEFOLD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fnmatch_icase_mem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>patternlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stringlen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>match_status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>pat_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>str_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>use_pat</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>use_str</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pattern</name><index>[<expr><name>patternlen</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat_buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>patternlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>use_pat</name> <operator>=</operator> <name><name>pat_buf</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>string</name><index>[<expr><name>stringlen</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str_buf</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>stringlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>use_str</name> <operator>=</operator> <name><name>str_buf</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WM_CASEFOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>match_status</name> <operator>=</operator> <call><name>wildmatch</name><argument_list>(<argument><expr><name>use_pat</name></expr></argument>, <argument><expr><name>use_str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>match_status</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>common_prefix_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>








<expr_stmt><expr><call><name>GUARD_PATHSPEC</name><argument_list>(<argument><expr><name>pathspec</name></expr></argument>,
<argument><expr><name>PATHSPEC_FROMTOP</name> <operator>|</operator>
<name>PATHSPEC_MAXDEPTH</name> <operator>|</operator>
<name>PATHSPEC_LITERAL</name> <operator>|</operator>
<name>PATHSPEC_GLOB</name> <operator>|</operator>
<name>PATHSPEC_ICASE</name> <operator>|</operator>
<name>PATHSPEC_EXCLUDE</name> <operator>|</operator>
<name>PATHSPEC_ATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>item_len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>magic</name> <operator>&amp;</operator> <name>PATHSPEC_EXCLUDE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>magic</name> <operator>&amp;</operator> <name>PATHSPEC_ICASE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>item_len</name> <operator>=</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>prefix</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>item_len</name> <operator>=</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nowildcard_len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>item_len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <name>max</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>match</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>match</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>max</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>char</name> <modifier>*</modifier></type><name>common_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name> <init>= <expr><call><name>common_prefix_len</name><argument_list>(<argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>len</name></expr> ?</condition><then> <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>match</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fill_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prefix_len</name></decl>;</decl_stmt>





<expr_stmt><expr><name>prefix_len</name> <operator>=</operator> <call><name>common_prefix_len</name><argument_list>(<argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <ternary><condition><expr><name>prefix_len</name></expr> ?</condition><then> <expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>match</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><call><name>read_directory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>prefix_len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>within_depth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>name</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cpe</name> <init>= <expr><name>name</name> <operator>+</operator> <name>namelen</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>cpe</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <name>max_depth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>do_read_blob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>oid_stat</name></name> <modifier>*</modifier></type><name>oid_stat</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size_out</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>size_out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>data_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name> <operator>||</operator> <name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oid_stat</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><name>sz</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>st_add</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><index>[<expr><name>sz</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>size_out</name> <operator>=</operator> <call><name>xsize_t</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>data_out</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_MATCH_EXCLUDE</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_MATCH_DIRECTORY</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_MATCH_LEADING_PATHSPEC</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
























<function><type><specifier>static</specifier> <name>int</name></type> <name>match_pathspec_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec_item</name></name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>match</name></name> <operator>+</operator> <name>prefix</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>matchlen</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>prefix</name></expr></init></decl>;</decl_stmt>






























<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>prefix</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_ICASE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>name</name> <operator>-</operator> <name>prefix</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>attr_match_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>match_pathspec_attrs</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_RECURSIVELY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>matchlen</name> <operator>&lt;=</operator> <name>namelen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>matchlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>matchlen</name> <operator>==</operator> <name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_EXACTLY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>matchlen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><name>matchlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_RECURSIVELY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DO_MATCH_DIRECTORY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>match</name><index>[<expr><name>matchlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<name>namelen</name> <operator>==</operator> <name>matchlen</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_EXACTLY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>git_fnmatch</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name> <operator>-</operator> <name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_FNMATCH</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>DO_MATCH_LEADING_PATHSPEC</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><ternary><condition><expr><name><name>name</name><index>[<expr><name>namelen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namelen</name> <operator>&lt;</operator> <name>matchlen</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>match</name><index>[<expr><name>namelen</name><operator>-</operator><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_RECURSIVELY_LEADING_PATHSPEC</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
<call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name> <operator>-</operator> <name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name> <operator>==</operator> <name><name>item</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>










<return>return <expr><name>MATCHED_RECURSIVELY_LEADING_PATHSPEC</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>int</name></type> <name>do_match_pathspec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seen</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>exclude</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DO_MATCH_EXCLUDE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GUARD_PATHSPEC</name><argument_list>(<argument><expr><name>ps</name></expr></argument>,
<argument><expr><name>PATHSPEC_FROMTOP</name> <operator>|</operator>
<name>PATHSPEC_MAXDEPTH</name> <operator>|</operator>
<name>PATHSPEC_LITERAL</name> <operator>|</operator>
<name>PATHSPEC_GLOB</name> <operator>|</operator>
<name>PATHSPEC_ICASE</name> <operator>|</operator>
<name>PATHSPEC_EXCLUDE</name> <operator>|</operator>
<name>PATHSPEC_ATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ps</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ps</name><operator>-&gt;</operator><name>recursive</name></name> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>ps</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_MAXDEPTH</name><operator>)</operator> <operator>||</operator>
<name><name>ps</name><operator>-&gt;</operator><name>max_depth</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_RECURSIVELY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>within_depth</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>max_depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED_EXACTLY</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> <operator>-=</operator> <name>prefix</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>ps</name><operator>-&gt;</operator><name>nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>how</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>exclude</name> <operator>&amp;&amp;</operator> <name><name>ps</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>magic</name> <operator>&amp;</operator> <name>PATHSPEC_EXCLUDE</name><operator>)</operator> <operator>||</operator>
<operator>(</operator> <name>exclude</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>ps</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>magic</name> <operator>&amp;</operator> <name>PATHSPEC_EXCLUDE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>seen</name> <operator>&amp;&amp;</operator> <name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>MATCHED_EXACTLY</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>seen</name> <operator>&amp;&amp;</operator> <name><name>ps</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>magic</name> <operator>&amp;</operator> <name>PATHSPEC_EXCLUDE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>MATCHED_FNMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>how</name> <operator>=</operator> <call><name>match_pathspec_item</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>items</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>recursive</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ps</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_MAXDEPTH</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>ps</name><operator>-&gt;</operator><name>max_depth</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name>how</name> <operator>&amp;&amp;</operator> <name>how</name> <operator>!=</operator> <name>MATCHED_FNMATCH</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>ps</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>within_depth</name><argument_list>(<argument><expr><name>name</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>namelen</name><operator>-</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>max_depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>how</name> <operator>=</operator> <name>MATCHED_EXACTLY</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>how</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>how</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>&lt;</operator> <name>how</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>how</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>seen</name> <operator>&amp;&amp;</operator> <name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>how</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>how</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_pathspec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namelen</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>positive</name></decl>, <decl><type ref="prev"/><name>negative</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><ternary><condition><expr><name>is_dir</name></expr> ?</condition><then> <expr><name>DO_MATCH_DIRECTORY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>positive</name> <operator>=</operator> <call><name>do_match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ps</name><operator>-&gt;</operator><name>magic</name></name> <operator>&amp;</operator> <name>PATHSPEC_EXCLUDE</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>positive</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>positive</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>negative</name> <operator>=</operator> <call><name>do_match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>,
<argument><expr><name>flags</name> <operator>|</operator> <name>DO_MATCH_EXCLUDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>negative</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>positive</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>submodule_path_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>submodule_name</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>matched</name> <init>= <expr><call><name>do_match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr><name>submodule_name</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>submodule_name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>seen</name></expr></argument>,
<argument><expr><name>DO_MATCH_DIRECTORY</name> <operator>|</operator>
<name>DO_MATCH_LEADING_PATHSPEC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>matched</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>report_path_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ps_matched</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>num</name> <operator>&lt;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>num</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>other</name></decl>, <decl><type ref="prev"/><name>found_dup</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ps_matched</name><index>[<expr><name>num</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>






<for>for <control>(<init><expr><name>found_dup</name> <operator>=</operator> <name>other</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><operator>!</operator><name>found_dup</name> <operator>&amp;&amp;</operator> <name>other</name> <operator>&lt;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition>
<incr><expr><name>other</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>other</name> <operator>==</operator> <name>num</name> <operator>||</operator> <operator>!</operator><name><name>ps_matched</name><index>[<expr><name>other</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>other</name></expr>]</index></name><operator>.</operator><name>original</name></expr></argument>,
<argument><expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>num</name></expr>]</index></name><operator>.</operator><name>original</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name>found_dup</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>found_dup</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pathspec '%s' did not match any file(s) known to git"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>num</name></expr>]</index></name><operator>.</operator><name>original</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>errors</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>simple_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>match</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_glob_special</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>no_wildcard</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>string</name><index>[<expr><call><name>simple_length</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>parse_path_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pattern</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>patternlen</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nowildcardlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pattern</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>PATTERN_FLAG_NEGATIVE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>PATTERN_FLAG_MUSTBEDIR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>PATTERN_FLAG_NODIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nowildcardlen</name> <operator>=</operator> <call><name>simple_length</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nowildcardlen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nowildcardlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <call><name>no_wildcard</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>PATTERN_FLAG_ENDSWITH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pattern</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>patternlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>pl_hashmap_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unused_cmp_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hashmap_entry</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pattern_entry</name></name> <modifier>*</modifier></type><name>ee1</name> <init>=
<expr><call><name>container_of</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>struct <name>pattern_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pattern_entry</name></name> <modifier>*</modifier></type><name>ee2</name> <init>=
<expr><call><name>container_of</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>struct <name>pattern_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>min_len</name> <init>= <expr><ternary><condition><expr><name><name>ee1</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>&lt;=</operator> <name><name>ee2</name><operator>-&gt;</operator><name>patternlen</name></name></expr>
?</condition><then> <expr><name><name>ee1</name><operator>-&gt;</operator><name>patternlen</name></name></expr>
</then><else>: <expr><name><name>ee2</name><operator>-&gt;</operator><name>patternlen</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name><name>ee1</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>ee2</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>min_len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ee1</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>ee2</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>min_len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dup_and_filter_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>set</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>set</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><name>read</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>read</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>read</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>read</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>set</name> <operator>=</operator> <operator>*</operator><name>read</name></expr>;</expr_stmt>

<expr_stmt><expr><name>set</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>read</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>set</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><operator>(</operator><name>set</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><operator>(</operator><name>set</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>set</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_pattern_to_hashsets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>given</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_entry</name></name> <modifier>*</modifier></type><name>translated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>truncated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pl</name><operator>-&gt;</operator><name>use_cone_patterns</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>given</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name> <operator>&amp;&amp;</operator>
<name><name>given</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_MUSTBEDIR</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><literal type="string">"/*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>full_cone</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>given</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><literal type="string">"/*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>full_cone</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>given</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator>
<operator>*</operator><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator>
<call><name>strstr</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><literal type="string">"**"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized pattern: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>clear_hashmaps</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>given</name><operator>-&gt;</operator><name>pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>given</name><operator>-&gt;</operator><name>pattern</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>cur</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_glob_special</name><argument_list>(<argument><expr><operator>*</operator><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>increment</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prev</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>increment</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator>
<call><name>is_glob_special</name><argument_list>(<argument><expr><operator>*</operator><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>increment</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prev</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><name>cur</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><name>next</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>increment</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized pattern: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>clear_hashmaps</name>;</goto>

<label><name>increment</name>:</label>
<expr_stmt><expr><name>prev</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cur</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>given</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name> <operator>+</operator> <name><name>given</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"/*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>given</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized pattern: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>clear_hashmaps</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>truncated</name> <operator>=</operator> <call><name>dup_and_filter_pattern</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>translated</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pattern_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>truncated</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>translated</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name><name>given</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then>
<expr><call><name>strihash</name><argument_list>(<argument><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>strhash</name><argument_list>(<argument><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hashmap_get_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>,
<argument><expr><name>translated</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized negative pattern: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>translated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>clear_hashmaps</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>given</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized negative pattern: '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>clear_hashmaps</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>translated</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pattern_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>dup_and_filter_pattern</name><argument_list>(<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>translated</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name><name>given</name><operator>-&gt;</operator><name>patternlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then>
<expr><call><name>strihash</name><argument_list>(<argument><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>strhash</name><argument_list>(<argument><expr><name><name>translated</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hashmap_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hashmap_get_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr><name>translated</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"your sparse-checkout file may have issues: pattern '%s' is repeated"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>given</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>translated</name><operator>-&gt;</operator><name>ent</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>translated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return;</return>

<label><name>clear_hashmaps</name>:</label>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"disabling cone pattern matching"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr>struct <name>pattern_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_free_entries</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>, <argument><expr>struct <name>pattern_entry</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>use_cone_patterns</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>hashmap_contains_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_entry</name></name></type> <name>p</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>p</name><operator>.</operator><name>pattern</name></name> <operator>=</operator> <name><name>pattern</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>.</operator><name>patternlen</name></name> <operator>=</operator> <name><name>pattern</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_entry_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>ent</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>ignore_case</name></expr> ?</condition><then>
<expr><call><name>strihash</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>strhash</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><operator>!</operator><call><name>hashmap_get_entry</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>hashmap_contains_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashmap</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slash_pos</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slash_pos</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>slash_pos</name> <operator>&gt;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>slash_pos</name> <operator>-</operator> <name><name>buffer</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hashmap_contains_path</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>slash_pos</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>add_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>patternlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nowildcardlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>parse_path_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patternlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nowildcardlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PATTERN_FLAG_MUSTBEDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FLEXPTR_ALLOC_MEM</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>patternlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pattern</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>patternlen</name></name> <operator>=</operator> <name>patternlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>nowildcardlen</name></name> <operator>=</operator> <name>nowildcardlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>baselen</name></name> <operator>=</operator> <name>baselen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>srcpos</name></name> <operator>=</operator> <name>srcpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>patterns</name></name></expr></argument>, <argument><expr><name><name>pl</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pl</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>patterns</name><index>[<expr><name><name>pl</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pattern</name><operator>-&gt;</operator><name>pl</name></name> <operator>=</operator> <name>pl</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_pattern_to_hashsets</name><argument_list>(<argument><expr><name>pl</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_skip_worktree_file_from_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size_out</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data_out</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>oid_stat</name></name> <modifier>*</modifier></type><name>oid_stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_skip_worktree</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>do_read_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>oid</name></expr></argument>, <argument><expr><name>oid_stat</name></expr></argument>, <argument><expr><name>size_out</name></expr></argument>, <argument><expr><name>data_out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>clear_pattern_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pl</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>patterns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>patterns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>filebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trim_trailing_spaces</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_space</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_space</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_space</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><name>last_space</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></switch></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>last_space</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>last_space</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>lookup_untracked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>last</name> <operator>&gt;</operator> <name>first</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>, <decl><type ref="prev"/><name>next</name> <init>= <expr><name>first</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>last</name> <operator>-</operator> <name>first</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>next</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmp</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>d</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>next</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>dir_created</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FLEX_ALLOC_MEM</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MOVE_ARRAY</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name></name> <operator>+</operator> <name>first</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name></name> <operator>+</operator> <name>first</name></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name> <operator>-</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>first</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_invalidate_gitignore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_invalidate_gitignore</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_gitignore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>gitignore_invalidated</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_invalidate_gitignore</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>dir_invalidated</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dir</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>recurse</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>add_patterns_from_buffer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>)</parameter_list>;</function_decl>










<function><type><specifier>static</specifier> <name>int</name></type> <name>add_patterns</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>oid_stat</name></name> <modifier>*</modifier></type><name>oid_stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warn_on_fopen_errors</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>istate</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read_skip_worktree_file_from_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
<argument><expr><name>oid_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>xsize_t</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>oid_stat</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>empty_blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oid_stat</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmallocz</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_in_full</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oid_stat</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oid_stat</name><operator>-&gt;</operator><name>valid</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>match_stat_data_racy</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><name>istate</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ce_stage</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ce_uptodate</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>would_convert_to_git</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name></expr>]</index></name><operator>-&gt;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hash_object_file</name><argument_list>(<argument><expr><name>the_hash_algo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><literal type="string">"blob"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oid_stat</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>add_patterns_from_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_patterns_from_buffer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>lineno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>, <argument><expr><name>pl_hashmap_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashmap_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr><name>pl_hashmap_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>filebuf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_utf8_bom</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>buf</name> <operator>-</operator> <name><name>pl</name><operator>-&gt;</operator><name>filebuf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>buf</name> <operator>+</operator> <name>i</name> <operator>&amp;&amp;</operator> <name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trim_trailing_spaces</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pattern</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>add_patterns_from_file_to_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>add_patterns</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>add_patterns_from_blob_to_list</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>do_read_blob</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>add_patterns_from_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>add_pattern_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>group_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_list_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

<expr_stmt><expr><name>group</name> <operator>=</operator> <operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>exclude_list_group</name><index>[<expr><name>group_type</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pl</name></name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>pl</name><index>[<expr><name><name>group</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
<return>return <expr><name>pl</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>add_patterns_from_file_1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>oid_stat</name></name> <modifier>*</modifier></type><name>oid_stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>unmanaged_exclude_files</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <call><name>add_pattern_list</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>EXC_FILE</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>add_patterns</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>oid_stat</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use %s as an exclude file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>add_patterns_from_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>unmanaged_exclude_files</name></name><operator>++</operator></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>add_patterns_from_file_1</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_basename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>basenamelen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>patternlen</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>==</operator> <name>patternlen</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>patternlen</name> <operator>==</operator> <name>basenamelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>fspathncmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>basenamelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PATTERN_FLAG_ENDSWITH</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>patternlen</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>basenamelen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>fspathncmp</name><argument_list>(<argument><expr><name>pattern</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>basename</name> <operator>+</operator> <name>basenamelen</name> <operator>-</operator> <operator>(</operator><name>patternlen</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
<argument><expr><name>patternlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fnmatch_icase_mem</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>patternlen</name></expr></argument>,
<argument><expr><name>basename</name></expr></argument>, <argument><expr><name>basenamelen</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>match_pathname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>patternlen</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namelen</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>patternlen</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>pathlen</name> <operator>&lt;</operator> <name>baselen</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>
<operator>(</operator><name>baselen</name> <operator>&amp;&amp;</operator> <name><name>pathname</name><index>[<expr><name>baselen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator> <operator>||</operator>
<call><name>fspathncmp</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>namelen</name> <operator>=</operator> <ternary><condition><expr><name>baselen</name></expr> ?</condition><then> <expr><name>pathlen</name> <operator>-</operator> <name>baselen</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>pathlen</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>pathname</name> <operator>+</operator> <name>pathlen</name> <operator>-</operator> <name>namelen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>&gt;</operator> <name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fspathncmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pattern</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>patternlen</name> <operator>-=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> <operator>-=</operator> <name>prefix</name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>patternlen</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>namelen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>fnmatch_icase_mem</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>patternlen</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>,
<argument><expr><name>WM_PATHNAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>last_matching_pattern_from_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pl</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>pl</name><operator>-&gt;</operator><name>nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><name><name>pl</name><operator>-&gt;</operator><name>patterns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exclude</name> <init>= <expr><name><name>pattern</name><operator>-&gt;</operator><name>pattern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefix</name> <init>= <expr><name><name>pattern</name><operator>-&gt;</operator><name>nowildcardlen</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_MUSTBEDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dtype</name> <operator>=</operator> <call><name>resolve_dtype</name><argument_list>(<argument><expr><operator>*</operator><name>dtype</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dtype</name> <operator>!=</operator> <name>DT_DIR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NODIR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>match_basename</name><argument_list>(<argument><expr><name>basename</name></expr></argument>,
<argument><expr><name>pathlen</name> <operator>-</operator> <operator>(</operator><name>basename</name> <operator>-</operator> <name>pathname</name><operator>)</operator></expr></argument>,
<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>,
<argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>baselen</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>pattern</name><operator>-&gt;</operator><name>base</name><index>[<expr><name><name>pattern</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>match_pathname</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>,
<argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>pattern</name><operator>-&gt;</operator><name>baselen</name></name></expr> ?</condition><then> <expr><name><name>pattern</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>patternlen</name></name></expr></argument>,
<argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><name><name>enum</name> <name>pattern_match_result</name></name></type> <name>path_matches_pattern_list</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>parent_pathname</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>NOT_MATCHED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash_pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pl</name><operator>-&gt;</operator><name>use_cone_patterns</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>last_matching_pattern_from_list</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>,
<argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NOT_MATCHED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>MATCHED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>UNDECIDED</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pl</name><operator>-&gt;</operator><name>full_cone</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MATCHED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hashmap_contains_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MATCHED_RECURSIVE</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>slash_pos</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>parent_pathname</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slash_pos</name> <operator>==</operator> <name><name>parent_pathname</name><operator>.</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MATCHED</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>, <argument><expr><name>slash_pos</name> <operator>-</operator> <name><name>parent_pathname</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hashmap_contains_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>parent_hashmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MATCHED</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hashmap_contains_parent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pl</name><operator>-&gt;</operator><name>recursive_hashmap</name></name></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MATCHED_RECURSIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>last_matching_pattern_from_lists</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_list_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>EXC_CMDL</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>EXC_FILE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>group</name> <operator>=</operator> <operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>exclude_list_group</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>nr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>last_matching_pattern_from_list</name><argument_list>(
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>dtype_p</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>pl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>pattern</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>prep_exclude</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_list_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_stack</name></name> <modifier>*</modifier></type><name>stk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>current</name></decl>;</decl_stmt>

<expr_stmt><expr><name>group</name> <operator>=</operator> <operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>exclude_list_group</name><index>[<expr><name>EXC_DIRS</name></expr>]</index></name></expr>;</expr_stmt>






<while>while <condition>(<expr><operator>(</operator><name>stk</name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>&lt;=</operator> <name>baselen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>pl</name><index>[<expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name><operator>-&gt;</operator><name>exclude_ix</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name> <operator>=</operator> <name><name>stk</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pl</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>clear_pattern_list</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>stk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nr</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>current</name> <operator>=</operator> <ternary><condition><expr><name>stk</name></expr> ?</condition><then> <expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>current</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>current</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>untracked</name> <operator>=</operator> <ternary><condition><expr><name>stk</name></expr> ?</condition><then> <expr><name><name>stk</name><operator>-&gt;</operator><name>ucd</name></name></expr> </then><else>: <expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>untracked</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><name>current</name> <operator>&lt;</operator> <name>baselen</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>oid_stat</name></name></type> <name>oid_stat</name></decl>;</decl_stmt>

<expr_stmt><expr><name>stk</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>stk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>current</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>current</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"oops in prep_exclude"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>untracked</name> <operator>=</operator>
<call><name>lookup_untracked</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>,
<argument><expr><name>base</name> <operator>+</operator> <name>current</name></expr></argument>,
<argument><expr><name>cp</name> <operator>-</operator> <name>base</name> <operator>-</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>stk</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>=</operator> <name>cp</name> <operator>-</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stk</name><operator>-&gt;</operator><name>exclude_ix</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>nr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stk</name><operator>-&gt;</operator><name>ucd</name></name> <operator>=</operator> <name>untracked</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <call><name>add_pattern_list</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>EXC_DIRS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <name>current</name></expr></argument>, <argument><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>==</operator> <name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>dt</name> <init>= <expr><name>DT_DIR</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name><index>[<expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>last_matching_pattern_from_lists</name><argument_list>(<argument><expr><name>dir</name></expr></argument>,
<argument><expr><name>istate</name></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name><operator>.</operator><name>buf</name><index>[<expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name> <operator>&amp;&amp;</operator>
<name><name>dir</name><operator>-&gt;</operator><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name> <operator>=</operator> <name>stk</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oid_stat</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>&amp;&amp;</operator>





<operator>(</operator><operator>!</operator><name>untracked</name> <operator>||</operator> <operator>!</operator><name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name> <operator>||</operator>






<operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>exclude_oid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>








<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_per_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pl</name><operator>-&gt;</operator><name>src</name></name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_patterns</name><argument_list>(<argument><expr><name><name>pl</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>pl</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name></expr></argument>, <argument><expr><name>pl</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>untracked</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>oid_stat</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>














<if_stmt><if>if <condition>(<expr><name>untracked</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>exclude_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalidate_gitignore</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>exclude_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name> <operator>=</operator> <name>stk</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>stk</name><operator>-&gt;</operator><name>baselen</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>last_matching_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pathlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>basename</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>basename</name><operator>)</operator></expr> ?</condition><then> <expr><name>basename</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>pathname</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prep_exclude</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>basename</name><operator>-</operator><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>pattern</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>last_matching_pattern_from_lists</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>,
<argument><expr><name>basename</name></expr></argument>, <argument><expr><name>dtype_p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>is_excluded</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dtype_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>path_pattern</name></name> <modifier>*</modifier></type><name>pattern</name> <init>=
<expr><call><name>last_matching_pattern</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>dtype_p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name><name>pattern</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PATTERN_FLAG_NEGATIVE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>dir_entry_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FLEX_ALLOC_MEM</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<return>return <expr><name>ent</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>dir_add_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>index_file_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>dir_entry_new</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>dir_add_ignored</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_name_is_other</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>ignored</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>ignored_nr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>ignored_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>ignored</name><index>[<expr><name><name>dir</name><operator>-&gt;</operator><name>ignored_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>dir_entry_new</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>exist_status</name> <block>{
<decl><name>index_nonexistent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>index_directory</name></decl>,
<decl><name>index_gitdir</name></decl>
}</block>;</enum>






<function><type><specifier>static</specifier> <name><name>enum</name> <name>exist_status</name></name></type> <name>directory_exists_in_index_icase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>index_dir_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>index_directory</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>index_file_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>index_gitdir</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>index_nonexistent</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>enum</name> <name>exist_status</name></name></type> <name>directory_exists_in_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>directory_exists_in_index_icase</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>endchar</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>endchar</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>endchar</name> <operator>&gt;</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>endchar</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>index_directory</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endchar</name> <operator>&amp;&amp;</operator> <call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>index_gitdir</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>index_nonexistent</name></expr>;</return>
</block_content>}</block></function>


































<function><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>treat_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nested_repo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<switch>switch <condition>(<expr><call><name>directory_exists_in_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>index_directory</name></expr>:</case>
<return>return <expr><name>path_recurse</name></expr>;</return>

<case>case <expr><name>index_gitdir</name></expr>:</case>
<return>return <expr><name>path_none</name></expr>;</return>

<case>case <expr><name>index_nonexistent</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SKIP_NESTED_GIT</name><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_NO_GITLINKS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nested_repo</name> <operator>=</operator> <call><name>is_nonbare_repository_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nested_repo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SKIP_NESTED_GIT</name><operator>)</operator></expr> ?</condition><then> <expr><name>path_none</name></expr> </then><else>:
<expr><operator>(</operator><ternary><condition><expr><name>exclude</name></expr> ?</condition><then> <expr><name>path_excluded</name></expr> </then><else>: <expr><name>path_untracked</name></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_OTHER_DIRECTORIES</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO_MODE_MATCHING</name><operator>)</operator></expr>)</condition> <block>{<block_content>












<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_HIDE_EMPTY_DIRECTORIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_excluded</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_directory_recursive</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
<argument><expr><name>untracked</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>path_excluded</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_excluded</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>path_none</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>path_recurse</name></expr>;</return>
</block_content>}</block></switch>



<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_HIDE_EMPTY_DIRECTORIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>exclude</name></expr> ?</condition><then> <expr><name>path_excluded</name></expr> </then><else>: <expr><name>path_untracked</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>untracked</name> <operator>=</operator> <call><name>lookup_untracked</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>,
<argument><expr><name>dirname</name> <operator>+</operator> <name>baselen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<return>return <expr><call><name>read_directory_recursive</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
<argument><expr><name>untracked</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>simplify_away</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pathspec</name> <operator>||</operator> <operator>!</operator><name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GUARD_PATHSPEC</name><argument_list>(<argument><expr><name>pathspec</name></expr></argument>,
<argument><expr><name>PATHSPEC_FROMTOP</name> <operator>|</operator>
<name>PATHSPEC_MAXDEPTH</name> <operator>|</operator>
<name>PATHSPEC_LITERAL</name> <operator>|</operator>
<name>PATHSPEC_GLOB</name> <operator>|</operator>
<name>PATHSPEC_ICASE</name> <operator>|</operator>
<name>PATHSPEC_EXCLUDE</name> <operator>|</operator>
<name>PATHSPEC_ATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>pathlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>pathlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>int</name></type> <name>exclude_matches_pathspec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pathlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pathspec</name> <operator>||</operator> <operator>!</operator><name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GUARD_PATHSPEC</name><argument_list>(<argument><expr><name>pathspec</name></expr></argument>,
<argument><expr><name>PATHSPEC_FROMTOP</name> <operator>|</operator>
<name>PATHSPEC_MAXDEPTH</name> <operator>|</operator>
<name>PATHSPEC_LITERAL</name> <operator>|</operator>
<name>PATHSPEC_GLOB</name> <operator>|</operator>
<name>PATHSPEC_ICASE</name> <operator>|</operator>
<name>PATHSPEC_EXCLUDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec_item</name></name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>pathspec</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>nowildcard_len</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>pathlen</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>pathlen</name> <operator>&amp;&amp;</operator>
<name><name>item</name><operator>-&gt;</operator><name>match</name><index>[<expr><name>pathlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ps_strncmp</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_index_dtype</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>index_file_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ce</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_DIR</name></expr>;</return></block_content></block></if></if_stmt>




<return>return <expr><name>DT_REG</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>index_name_pos</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <name><name>istate</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ce_uptodate</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
<return>return <expr><name>DT_DIR</name></expr>;</return>
</block_content>}</block></while>
<return>return <expr><name>DT_UNKNOWN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>resolve_dtype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dtype</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dtype</name> <operator>!=</operator> <name>DT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>dtype</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dtype</name> <operator>=</operator> <call><name>get_index_dtype</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dtype</name> <operator>!=</operator> <name>DT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>dtype</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>dtype</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_REG</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_DIR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DT_LNK</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>dtype</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>treat_one_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>exclude</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_path_in_index</name> <init>= <expr><operator>!</operator><operator>!</operator><call><name>index_file_exists</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>ignore_case</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>path_treatment</name></name></type> <name>path_treatment</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dtype</name> <operator>=</operator> <call><name>resolve_dtype</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>dtype</name> <operator>!=</operator> <name>DT_DIR</name> <operator>&amp;&amp;</operator> <name>has_path_in_index</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_none</name></expr>;</return></block_content></block></if></if_stmt>



















<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_COLLECT_KILLED_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>dtype</name> <operator>==</operator> <name>DT_DIR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><name>has_path_in_index</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>directory_exists_in_index</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>index_nonexistent</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_none</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>exclude</name> <operator>=</operator> <call><name>is_excluded</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>DIR_SHOW_IGNORED</name><operator>|</operator><name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_excluded</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<return>return <expr><name>path_none</name></expr>;</return>
<case>case <expr><name>DT_DIR</name></expr>:</case>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path_treatment</name> <operator>=</operator> <call><name>treat_directory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>,
<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclude</name> <operator>&amp;&amp;</operator>
<name>path_treatment</name> <operator>==</operator> <name>path_excluded</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO_MODE_MATCHING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_recurse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>path_treatment</name></expr>;</return>
<case>case <expr><name>DT_REG</name></expr>:</case>
<case>case <expr><name>DT_LNK</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>exclude</name></expr> ?</condition><then> <expr><name>path_excluded</name></expr> </then><else>: <expr><name>path_untracked</name></expr></else></ternary></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>treat_path_fast</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path_untracked</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_complete</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name><operator>-&gt;</operator><name>check_only</name></name></expr>)</condition><block type="pseudo"><block_content>





<return>return <expr><call><name>read_directory_recursive</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>






<return>return <expr><name>path_recurse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>treat_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>treat_path_fast</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><name>cdir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_dot_or_dotdot</name><argument_list>(<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>fspathcmp</name><argument_list>(<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".git"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_none</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>simplify_away</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path_none</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>treat_one_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>,
<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_type</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_untracked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ALLOC_GROW</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked_nr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name><name>dir</name><operator>-&gt;</operator><name>untracked_nr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>valid_cached_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>untracked</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>refresh_fsmonitor</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>use_fsmonitor</name></name> <operator>&amp;&amp;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name> <operator>||</operator>
<call><name>match_stat_data_racy</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fill_stat_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>untracked</name><operator>-&gt;</operator><name>check_only</name></name> <operator>!=</operator> <operator>!</operator><operator>!</operator><name>check_only</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prep_exclude</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>prep_exclude</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<return>return <expr><name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>open_cached_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>check_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c_path</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cdir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cdir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>untracked</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>valid_cached_dir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>check_only</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c_path</name> <operator>=</operator> <ternary><condition><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>c_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not open directory '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalidate_directory</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_opened</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_cached_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>de</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name>DT_UNKNOWN</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_name</name></name> <operator>=</operator> <name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <call><name>DTYPE</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_dirs</name></name> <operator>&lt;</operator> <name><name>cdir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_dirs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>recurse</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_dirs</name></name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_dirs</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></while>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>ucd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_files</name></name> <operator>&lt;</operator> <name><name>cdir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>untracked_nr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name><name>cdir</name><operator>-&gt;</operator><name>nr_files</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>close_cached_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>recurse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_path_to_appropriate_result_list</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>cached_dir</name></name> <modifier>*</modifier></type><name>cdir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>path_treatment</name></name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>path_excluded</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dir_add_name</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_COLLECT_IGNORED</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>exclude_matches_pathspec</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name>pathspec</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dir_add_ignored</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>path_untracked</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dir_add_name</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>-&gt;</operator><name>fdir</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_untracked</name><argument_list>(<argument><expr><name>untracked</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>




















<function><type><specifier>static</specifier> <name><name>enum</name> <name>path_treatment</name></name></type> <name>read_directory_recursive</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>baselen</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_only</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>stop_at_first_file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>









<decl_stmt><decl><type><name><name>struct</name> <name>cached_dir</name></name></type> <name>cdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>path_treatment</name></name></type> <name>state</name></decl>, <decl><type ref="prev"/><name>subdir_state</name></decl>, <decl><type ref="prev"/><name>dir_state</name> <init>= <expr><name>path_none</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>path</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>open_cached_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><name>check_only</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>untracked</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>untracked</name><operator>-&gt;</operator><name>check_only</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>check_only</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>read_cached_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>treat_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>,
<argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>&gt;</operator> <name>dir_state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dir_state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>==</operator> <name>path_recurse</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>state</name> <operator>==</operator> <name>path_untracked</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>resolve_dtype</name><argument_list>(<argument><expr><name><name>cdir</name><operator>.</operator><name>d_type</name></name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DT_DIR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>pathspec</name> <operator>&amp;&amp;</operator>
<call><name>do_match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DO_MATCH_LEADING_PATHSPEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MATCHED_RECURSIVELY_LEADING_PATHSPEC</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ud</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ud</name> <operator>=</operator> <call><name>lookup_untracked</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>,
<argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>baselen</name></expr></argument>,
<argument><expr><name><name>path</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>subdir_state</name> <operator>=</operator>
<call><name>read_directory_recursive</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><name><name>path</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>ud</name></expr></argument>,
<argument><expr><name>check_only</name></expr></argument>, <argument><expr><name>stop_at_first_file</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subdir_state</name> <operator>&gt;</operator> <name>dir_state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dir_state</name> <operator>=</operator> <name>subdir_state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pathspec</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>path_none</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>check_only</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>stop_at_first_file</name></expr>)</condition> <block>{<block_content>















<if_stmt><if>if <condition>(<expr><name>dir_state</name> <operator>&gt;=</operator> <name>path_excluded</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dir_state</name> <operator>=</operator> <name>path_excluded</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>dir_state</name> <operator>==</operator> <name>path_untracked</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cdir</name><operator>.</operator><name>fdir</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_untracked</name><argument_list>(<argument><expr><name>untracked</name></expr></argument>, <argument><expr><name><name>path</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>add_path_to_appropriate_result_list</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>,
<argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>,
<argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>close_cached_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dir_state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmp_dir_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>e1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>dir_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>e2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> struct <name>dir_entry</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>name_compare</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>e2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>e2</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>check_dir_entry_contains</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dir_entry</name></name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>name</name><index>[<expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>treat_leading_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>









<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>subdir</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prevlen</name></decl>, <decl><type ref="prev"/><name>baselen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cached_dir</name></name></type> <name>cdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>path_treatment</name></name></type> <name>state</name> <init>= <expr><name>path_none</name></expr></init></decl>;</decl_stmt>


















<while>while <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cdir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>.</operator><name>d_type</name></name> <operator>=</operator> <name>DT_DIR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>baselen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prevlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prevlen</name> <operator>=</operator> <name>baselen</name> <operator>+</operator> <operator>!</operator><operator>!</operator><name>baselen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>path</name> <operator>+</operator> <name>prevlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>path</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>baselen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>baselen</name> <operator>=</operator> <name>cp</name> <operator>-</operator> <name>path</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_directory</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subdir</name></expr></argument>, <argument><expr><name>path</name><operator>+</operator><name>prevlen</name></expr></argument>, <argument><expr><name>baselen</name><operator>-</operator><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cdir</name><operator>.</operator><name>d_name</name></name> <operator>=</operator> <name><name>subdir</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>treat_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>,
<argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>path_untracked</name> <operator>&amp;&amp;</operator>
<call><name>resolve_dtype</name><argument_list>(<argument><expr><name><name>cdir</name><operator>.</operator><name>d_type</name></name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DT_DIR</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name> <operator>||</operator>
<call><name>do_match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DO_MATCH_LEADING_PATHSPEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MATCHED_RECURSIVELY_LEADING_PATHSPEC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_pathspec</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>path_none</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_path_to_appropriate_result_list</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>,
<argument><expr><name>istate</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>,
<argument><expr><name>pathspec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>path_recurse</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>path_recurse</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>baselen</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
</block_content>}</block></while>
<expr_stmt><expr><call><name>add_path_to_appropriate_result_list</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>,
<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>state</name> <operator>==</operator> <name>path_recurse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_ident_string</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>uts</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>uname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uts</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to get kernel name and information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"Location %s, system %s"</literal></expr></argument>, <argument><expr><call><name>get_git_work_tree</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>uts</name><operator>.</operator><name>sysname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>sb</name><operator>.</operator><name>buf</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ident_in_untracked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>)</parameter_list>
<block>{<block_content>






<return>return <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>uc</name><operator>-&gt;</operator><name>ident</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>get_ident_string</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_untracked_ident</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>, <argument><expr><call><name>get_ident_string</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>new_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>uc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>=</operator> <literal type="string">".gitignore"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>dir_flags</name></name> <operator>=</operator> <name>DIR_SHOW_OTHER_DIRECTORIES</name> <operator>|</operator> <name>DIR_HIDE_EMPTY_DIRECTORIES</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_untracked_ident</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>uc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>UNTRACKED_CHANGED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>add_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>new_untracked_cache</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ident_in_untracked</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_untracked_cache</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_untracked_cache</name><argument_list>(<argument><expr><name>istate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>remove_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_untracked_cache</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>UNTRACKED_CHANGED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>validate_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>base_len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>untracked_cache_disabled</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>untracked_cache_disabled</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>untracked_cache_disabled</name> <operator>=</operator> <call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_DISABLE_UNTRACKED_CACHE"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>untracked_cache_disabled</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>unmanaged_exclude_files</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>base_len</name> <operator>||</operator> <operator>(</operator><name>pathspec</name> <operator>&amp;&amp;</operator> <name><name>pathspec</name><operator>-&gt;</operator><name>nr</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>!=</operator> <name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_flags</name></name> <operator>||</operator>





<operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_OTHER_DIRECTORIES</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>DIR_SHOW_IGNORED</name> <operator>|</operator> <name>DIR_SHOW_IGNORED_TOO</name> <operator>|</operator>
<name>DIR_COLLECT_IGNORED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>!=</operator> <name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_per_dir</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>exclude_per_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_list_group</name><index>[<expr><name>EXC_CMDL</name></expr>]</index></name><operator>.</operator><name>nr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ident_in_untracked</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"untracked cache is disabled on this system or location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>ss_info_exclude</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>ss_info_exclude</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalidate_gitignore</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>ss_info_exclude</name></name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>ss_info_exclude</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>ss_excludes_file</name><operator>.</operator><name>oid</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>ss_excludes_file</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalidate_gitignore</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>ss_excludes_file</name></name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>ss_excludes_file</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>recurse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>read_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pathspec</name></name> <modifier>*</modifier></type><name>pathspec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>trace_performance_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>has_symlink_leading_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trace_performance_leave</name><argument_list>(<argument><expr><literal type="string">"read directory %.*s"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>untracked</name> <operator>=</operator> <call><name>validate_untracked_cache</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>untracked</name></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>||</operator> <call><name>treat_leading_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_directory_recursive</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>untracked</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pathspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name></expr></argument>, <argument><expr><name>cmp_dir_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>ignored</name></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>ignored_nr</name></name></expr></argument>, <argument><expr><name>cmp_dir_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_IGNORED_TOO</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DIR_KEEP_UNTRACKED_CONTENTS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dir</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;&amp;</operator>
<call><name>check_dir_entry_contains</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trace_performance_leave</name><argument_list>(<argument><expr><literal type="string">"read directory %.*s"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>force_untracked_cache</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>trace_key</name></name></type> <name>trace_untracked_stats</name> <init>= <expr><call><name>TRACE_KEY_INIT</name><argument_list>(<argument><expr><name>UNTRACKED_STATS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>force_untracked_cache</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>force_untracked_cache</name> <operator>=</operator>
<call><name>git_env_bool</name><argument_list>(<argument><expr><literal type="string">"GIT_FORCE_UNTRACKED_CACHE"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>trace_printf_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trace_untracked_stats</name></expr></argument>,
<argument><expr><literal type="string">"node creation: %u\n"</literal>
<literal type="string">"gitignore invalidation: %u\n"</literal>
<literal type="string">"directory invalidation: %u\n"</literal>
<literal type="string">"opendir: %u\n"</literal></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_created</name></name></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>gitignore_invalidated</name></name></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_invalidated</name></name></expr></argument>,
<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_opened</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>force_untracked_cache</name> <operator>&amp;&amp;</operator>
<name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name> <operator>==</operator> <name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_opened</name></name> <operator>||</operator>
<name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>gitignore_invalidated</name></name> <operator>||</operator>
<name><name>dir</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>dir_invalidated</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>cache_changed</name></name> <operator>|=</operator> <name>UNTRACKED_CHANGED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name> <operator>!=</operator> <name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>nr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>file_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
<return>return <expr><call><name>lstat</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>repo_file_exists</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>repo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>repo</name> <operator>!=</operator> <name>the_repository</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BUG</name><argument_list>(<argument><expr><literal type="string">"do not know how to check file existence in arbitrary repo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>file_exists</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_icase</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ignore_case</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>toupper</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>toupper</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>a</name> <operator>-</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>dir_inside_of</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dir</name> <operator>&amp;&amp;</operator> <name>subdir</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>dir</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>dir</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>subdir</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>cmp_icase</name><argument_list>(<argument><expr><operator>*</operator><name>dir</name></expr></argument>, <argument><expr><operator>*</operator><name>subdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dir</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>subdir</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dir</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>subdir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>subdir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>!</operator><operator>*</operator><name>dir</name></expr> ?</condition><then> <expr><name>offset</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt> 


<if_stmt><if>if <condition>(<expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>dir</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>subdir</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>offset</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><ternary><condition><expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><operator>*</operator><name>subdir</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_inside_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cwd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cwd</name> <operator>=</operator> <call><name>xgetcwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><call><name>dir_inside_of</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_empty_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_dot_or_dotdot</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></while>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>remove_dir_recurse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>kept_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>original_len</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>kept_down</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>only_empty</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REMOVE_DIR_EMPTY_ONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>keep_toplevel</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REMOVE_DIR_KEEP_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>submodule_head</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>REMOVE_DIR_KEEP_NESTED_GIT</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>resolve_gitlink_ref</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"HEAD"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>submodule_head</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>kept_up</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>kept_up</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flag</name> <operator>&amp;=</operator> <operator>~</operator><name>REMOVE_DIR_KEEP_TOPLEVEL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>keep_toplevel</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>keep_toplevel</name></expr>)</condition><block type="pseudo"><block_content>




<return>return <expr><call><name>rmdir</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_complete</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_dot_or_dotdot</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>




<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>remove_dir_recurse</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kept_down</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>only_empty</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>unlink</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<continue>continue;</continue> 
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></while>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_setlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>original_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>keep_toplevel</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>kept_down</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><call><name>rmdir</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>kept_up</name></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><operator>*</operator><name>kept_up</name> <operator>=</operator> <operator>!</operator><name>ret</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>remove_dir_recursively</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>remove_dir_recurse</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_info_exclude</argument>, <argument><literal type="string">"info/exclude"</literal></argument>)</argument_list></macro>

<name>void</name> <macro><name>setup_standard_excludes</name><argument_list>(<argument>struct dir_struct *dir</argument>)</argument_list></macro>
<block>{
<expr><name><name>dir</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>=</operator> <literal type="string">".gitignore"</literal></expr>;


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>excludes_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>excludes_file</name> <operator>=</operator> <call><name>xdg_config_home</name><argument_list>(<argument><expr><literal type="string">"ignore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><name>excludes_file</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>access_or_warn</name><argument_list>(<argument><expr><name>excludes_file</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_patterns_from_file_1</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>excludes_file</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>ss_excludes_file</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>startup_info</name><operator>-&gt;</operator><name>have_repository</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>git_path_info_exclude</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>access_or_warn</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_patterns_from_file_1</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>dir</name><operator>-&gt;</operator><name>untracked</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>ss_info_exclude</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
}

int <macro><name>remove_path</name><argument_list>(<argument>const char *name</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slash</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_missing_file_error</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dirs</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>slash</name> <operator>=</operator> <name>dirs</name> <operator>+</operator> <operator>(</operator><name>slash</name> <operator>-</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>slash</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>dirs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>dirs</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>





<function><type><name>void</name></type> <name>clear_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_struct</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_list_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pattern_list</name></name> <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_stack</name></name> <modifier>*</modifier></type><name>stk</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>EXC_CMDL</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>EXC_FILE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>group</name> <operator>=</operator> <operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>exclude_list_group</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>group</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>pl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>EXC_DIRS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pl</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>clear_pattern_list</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>stk</name> <operator>=</operator> <name><name>dir</name><operator>-&gt;</operator><name>exclude_stack</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>stk</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>exclude_stack</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>stk</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>stk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stk</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>basebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>ondisk_untracked_cache</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>stat_data</name></name></type> <name>info_exclude_stat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat_data</name></name></type> <name>excludes_file_stat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>dir_flags</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ouc_offset</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(struct ondisk_untracked_cache, x)</cpp:value></cpp:define>

<struct>struct <name>write_data</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>check_only</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>valid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>sha1_valid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb_stat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sb_sha1</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stat_data_to_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_dev</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_dev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ino</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_ino</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_uid</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_gid</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_size</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>sd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_one_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>write_data</name></name> <modifier>*</modifier></type><name>wd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat_data</name></name></type> <name>stat_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>&amp;</operator><name><name>wd</name><operator>-&gt;</operator><name>out</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>intlen</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>wd</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>untracked</name><operator>-&gt;</operator><name>untracked_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>untracked</name><operator>-&gt;</operator><name>check_only</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>untracked</name><operator>-&gt;</operator><name>check_only</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ewah_set</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>check_only</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>untracked</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ewah_set</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stat_data_to_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>-&gt;</operator><name>sb_stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stat_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>exclude_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ewah_set</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>sha1_valid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>-&gt;</operator><name>sb_sha1</name></name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>exclude_oid</name><operator>.</operator><name>hash</name></name></expr></argument>,
<argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>intlen</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>untracked_nr</name></name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>, <argument><expr><name>intlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>untracked</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>intlen</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>, <argument><expr><name>intlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>untracked_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>untracked</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_one_dir</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>wd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>write_untracked_extension</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>untracked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ondisk_untracked_cache</name></name> <modifier>*</modifier></type><name>ouc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>write_data</name></name></type> <name>wd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>varbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varint_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ouc</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ouc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stat_data_to_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ouc</name><operator>-&gt;</operator><name>info_exclude_stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>ss_info_exclude</name><operator>.</operator><name>stat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stat_data_to_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ouc</name><operator>-&gt;</operator><name>excludes_file_stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>ss_excludes_file</name><operator>.</operator><name>stat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ouc</name><operator>-&gt;</operator><name>dir_flags</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>dir_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varint_len</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>ident</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>, <argument><expr><name>varint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>untracked</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>ouc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ouc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>ss_info_exclude</name><operator>.</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>hashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>ss_excludes_file</name><operator>.</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>hashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>exclude_per_dir</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>exclude_per_dir</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>ouc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>varint_len</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>, <argument><expr><name>varint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>wd</name><operator>.</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wd</name><operator>.</operator><name>check_only</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wd</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wd</name><operator>.</operator><name>sha1_valid</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_stat</name></name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_sha1</name></name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_one_dir</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varint_len</name> <operator>=</operator> <call><name>encode_varint</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>, <argument><expr><name>varint_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_serialize_strbuf</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>valid</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_serialize_strbuf</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>check_only</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_serialize_strbuf</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>sha1_valid</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_stat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_sha1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>check_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>wd</name><operator>.</operator><name>sha1_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_stat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wd</name><operator>.</operator><name>sb_sha1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_untracked</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ucd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ucd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ucd</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free_untracked</name><argument_list>(<argument><expr><name><name>ucd</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ucd</name><operator>-&gt;</operator><name>untracked_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ucd</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ucd</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ucd</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ucd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_untracked_cache</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>uc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free_untracked</name><argument_list>(<argument><expr><name><name>uc</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>read_data</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ucd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>check_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ewah_bitmap</name></name> <modifier>*</modifier></type><name>sha1_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stat_data_from_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>stat_data</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ctime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_mtime</name><operator>.</operator><name>nsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_dev</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_dev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ino</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_ino</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_uid</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_gid</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>sd_size</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>sd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_one_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>untracked_</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>read_data</name></name> <modifier>*</modifier></type><name>rd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name></type> <name>ud</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>untracked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ud</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>decode_varint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ud</name><operator>.</operator><name>recurse</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ud</name><operator>.</operator><name>untracked_alloc</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ud</name><operator>.</operator><name>untracked_nr</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ud</name><operator>.</operator><name>untracked_nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name><name>ud</name><operator>.</operator><name>untracked</name></name></expr></argument>, <argument><expr><name><name>ud</name><operator>.</operator><name>untracked_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ud</name><operator>.</operator><name>dirs_alloc</name></name> <operator>=</operator> <name><name>ud</name><operator>.</operator><name>dirs_nr</name></name> <operator>=</operator> <call><name>decode_varint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name><name>ud</name><operator>.</operator><name>dirs</name></name></expr></argument>, <argument><expr><name><name>ud</name><operator>.</operator><name>dirs_nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>eos</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eos</name> <operator>||</operator> <name>eos</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>untracked_</name> <operator>=</operator> <name>untracked</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>st_add3</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>untracked</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>eos</name> <operator>-</operator> <name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>untracked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ud</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>eos</name> <operator>-</operator> <name>data</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>eos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>untracked_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>eos</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eos</name> <operator>||</operator> <name>eos</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>untracked</name><operator>-&gt;</operator><name>untracked</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>eos</name> <operator>-</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>eos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>ucd</name><index>[<expr><name><name>rd</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>untracked</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>untracked</name><operator>-&gt;</operator><name>dirs_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>read_one_dir</name><argument_list>(<argument><expr><name><name>untracked</name><operator>-&gt;</operator><name>dirs</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_check_only</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>read_data</name></name> <modifier>*</modifier></type><name>rd</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>ucd</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ud</name><operator>-&gt;</operator><name>check_only</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_stat</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>read_data</name></name> <modifier>*</modifier></type><name>rd</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>ucd</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>stat_data</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>rd</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>rd</name><operator>-&gt;</operator><name>end</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>stat_data_from_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ud</name><operator>-&gt;</operator><name>stat_data</name></name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>stat_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ud</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_oid</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>read_data</name></name> <modifier>*</modifier></type><name>rd</name> <init>= <expr><name>cb</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><name><name>rd</name><operator>-&gt;</operator><name>ucd</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name> <operator>&gt;</operator> <name><name>rd</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>rd</name><operator>-&gt;</operator><name>end</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>ud</name><operator>-&gt;</operator><name>exclude_oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>-&gt;</operator><name>data</name></name> <operator>+=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>load_oid_stat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>oid_stat</name></name> <modifier>*</modifier></type><name>oid_stat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sha1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>stat_data_from_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oid_stat</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>oid_stat</name><operator>-&gt;</operator><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>sha1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oid_stat</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>read_untracked_extension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>read_data</name></name></type> <name>rd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>data</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>data</name> <operator>+</operator> <name>sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ident_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exclude_per_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hashsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>offset</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ondisk_untracked_cache</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>exclude_per_dir_offset</name> <init>= <expr><name>offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>hashsz</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>end</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ident_len</name> <operator>=</operator> <call><name>decode_varint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>+</operator> <name>ident_len</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ident</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>+=</operator> <name>ident_len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>next</name> <operator>+</operator> <name>exclude_per_dir_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>uc</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>uc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>, <argument><expr><name>ident_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ident</name></name></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><name>ident_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>load_oid_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ss_info_exclude</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>+</operator> <call><name>ouc_offset</name><argument_list>(<argument><expr><name>info_exclude_stat</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>next</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>load_oid_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>ss_excludes_file</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>+</operator> <call><name>ouc_offset</name><argument_list>(<argument><expr><name>excludes_file_stat</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>next</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <name>hashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>dir_flags</name></name> <operator>=</operator> <call><name>get_be32</name><argument_list>(<argument><expr><name>next</name> <operator>+</operator> <call><name>ouc_offset</name><argument_list>(<argument><expr><name>dir_flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exclude_per_dir</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>next</name> <operator>+</operator> <name>exclude_per_dir_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>exclude_per_dir</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>exclude_per_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>+=</operator> <name>exclude_per_dir_offset</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>exclude_per_dir</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done2</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>decode_varint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done2</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>check_only</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>sha1_valid</name></name> <operator>=</operator> <call><name>ewah_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>ucd</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_one_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uc</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>rd</name><operator>.</operator><name>index</name></name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>rd</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ewah_read_mmap</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>valid</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ewah_read_mmap</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>check_only</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ewah_read_mmap</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>sha1_valid</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ewah_each_bit</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>check_only</name></name></expr></argument>, <argument><expr><name>set_check_only</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rd</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>next</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_each_bit</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>valid</name></name></expr></argument>, <argument><expr><name>read_stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_each_bit</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>sha1_valid</name></name></expr></argument>, <argument><expr><name>read_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>rd</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>ucd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>check_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ewah_free</name><argument_list>(<argument><expr><name><name>rd</name><operator>.</operator><name>sha1_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done2</name>:</label>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_untracked_cache</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>uc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_one_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>ucd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>uc</name><operator>-&gt;</operator><name>dir_invalidated</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ucd</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ucd</name><operator>-&gt;</operator><name>untracked_nr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>int</name></type> <name>invalidate_one_component</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>untracked_cache</name></name> <modifier>*</modifier></type><name>uc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rest</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rest</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>component_len</name> <init>= <expr><name>rest</name> <operator>-</operator> <name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>untracked_cache_dir</name></name> <modifier>*</modifier></type><name>d</name> <init>=
<expr><call><name>lookup_untracked</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>component_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>=
<expr><call><name>invalidate_one_component</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rest</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>len</name> <operator>-</operator> <operator>(</operator><name>component_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>invalidate_one_directory</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>invalidate_one_directory</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>uc</name><operator>-&gt;</operator><name>dir_flags</name></name> <operator>&amp;</operator> <name>DIR_SHOW_OTHER_DIRECTORIES</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>untracked_cache_invalidate_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>safe_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name> <operator>||</operator> <operator>!</operator><name><name>istate</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe_path</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>verify_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>invalidate_one_component</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name></name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>untracked</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>untracked_cache_remove_from_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>untracked_cache_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>untracked_cache_add_to_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>index_state</name></name> <modifier>*</modifier></type><name>istate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>untracked_cache_invalidate_path</name><argument_list>(<argument><expr><name>istate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>connect_wt_gitdir_in_nested</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sub_worktree</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sub_gitdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>repository</name></name></type> <name>subrepo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sub_wt</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>sub_gd</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>submodule</name></name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>repo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>, <argument><expr><name>sub_gitdir</name></expr></argument>, <argument><expr><name>sub_worktree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>repo_read_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index file corrupt in repo %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>subrepo</name><operator>.</operator><name>gitdir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>subrepo</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cache_entry</name></name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><name><name>subrepo</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>ce_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>subrepo</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>cache_nr</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>subrepo</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>cache</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>submodule_from_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_oid</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name> <operator>||</operator> <operator>!</operator><call><name>is_submodule_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_wt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_gd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_wt</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>sub_worktree</name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_gd</name></expr></argument>, <argument><expr><literal type="string">"%s/modules/%s"</literal></expr></argument>, <argument><expr><name>sub_gitdir</name></expr></argument>, <argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>connect_work_tree_and_git_dir</name><argument_list>(<argument><expr><name><name>sub_wt</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>sub_gd</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_wt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_gd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subrepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>connect_work_tree_and_git_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>work_tree_</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>git_dir_</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>recurse_into_nested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>gitfile_sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>cfg_sb</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>rel_path</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>git_dir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>work_tree</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gitfile_sb</name></expr></argument>, <argument><expr><literal type="string">"%s/.git"</literal></expr></argument>, <argument><expr><name>work_tree_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>safe_create_leading_directories_const</name><argument_list>(<argument><expr><name><name>gitfile_sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not create directories for %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gitfile_sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cfg_sb</name></expr></argument>, <argument><expr><literal type="string">"%s/config"</literal></expr></argument>, <argument><expr><name>git_dir_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>safe_create_leading_directories_const</name><argument_list>(<argument><expr><name><name>cfg_sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not create directories for %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cfg_sb</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>git_dir</name> <operator>=</operator> <call><name>real_pathdup</name><argument_list>(<argument><expr><name>git_dir_</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>work_tree</name> <operator>=</operator> <call><name>real_pathdup</name><argument_list>(<argument><expr><name>work_tree_</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>write_file</name><argument_list>(<argument><expr><name><name>gitfile_sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"gitdir: %s"</literal></expr></argument>,
<argument><expr><call><name>relative_path</name><argument_list>(<argument><expr><name>git_dir</name></expr></argument>, <argument><expr><name>work_tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_config_set_in_file</name><argument_list>(<argument><expr><name><name>cfg_sb</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"core.worktree"</literal></expr></argument>,
<argument><expr><call><name>relative_path</name><argument_list>(<argument><expr><name>work_tree</name></expr></argument>, <argument><expr><name>git_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gitfile_sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cfg_sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse_into_nested</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>connect_wt_gitdir_in_nested</name><argument_list>(<argument><expr><name>work_tree</name></expr></argument>, <argument><expr><name>git_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>work_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>git_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>relocate_gitdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_git_dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_git_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>old_git_dir</name></expr></argument>, <argument><expr><name>new_git_dir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not migrate git directory from '%s' to '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>old_git_dir</name></expr></argument>, <argument><expr><name>new_git_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>connect_work_tree_and_git_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_git_dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
