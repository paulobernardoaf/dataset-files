<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\fast-import.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repository.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lockfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"blob.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"csum-file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"packfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mem-pool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"khash.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_ID_BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PACK_ID</name></cpp:macro> <cpp:value>((1&lt;&lt;PACK_ID_BITS)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPTH_BITS</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEPTH</name></cpp:macro> <cpp:value>((1&lt;&lt;DEPTH_BITS)-1)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DELTA</name></cpp:macro> <cpp:value>S_ISUID</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_SIZE_THRESHOLD</name></cpp:macro> <cpp:value>(the_hash_algo-&gt;rawsz * 3)</cpp:value></cpp:define>

<struct>struct <name>object_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>pack_idx_entry</name></name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name> <range>: <expr><name>TYPE_BITS</name></expr></range></decl>,
<decl><type ref="prev"/><name>pack_id</name> <range>: <expr><name>PACK_ID_BITS</name></expr></range></decl>,
<decl><type ref="prev"/><name>depth</name> <range>: <expr><name>DEPTH_BITS</name></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>object_entry_pool</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry_pool</name></name> <modifier>*</modifier></type><name>next_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>next_free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name></type> <name><name>entries</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>

<struct>struct <name>mark_set</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name><name>oids</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name><name>marked</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name><name>sets</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>data</name></decl>;</union>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>shift</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>last_object</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>no_swap</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>atom_str</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>atom_str</name></name> <modifier>*</modifier></type><name>next_atom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>str_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>str_dat</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>

<struct_decl>struct <name>tree_content</name>;</struct_decl>
<struct>struct <name>tree_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>atom_str</name></name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<struct>struct <name>tree_entry_ms</name> <block>{
<decl_stmt><decl><type><name>uint16_t</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
}</block> <decl><name><name>versions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</struct>
}</block>;</struct>

<struct>struct <name>tree_content</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>entry_capacity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>entry_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>delta_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name><name>entries</name><index>[<expr><name>FLEX_ARRAY</name></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>

<struct>struct <name>avail_tree_content</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>entry_capacity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>avail_tree_content</name></name> <modifier>*</modifier></type><name>next_avail</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>branch</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>table_next_branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>active_next_branch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name></type> <name>branch_tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>last_commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>num_notes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>active</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>delete</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>pack_id</name> <range>: <expr><name>PACK_ID_BITS</name></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>tag</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>next_tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pack_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>hash_list</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>hash_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><enum>enum <block>{
<decl><name>WHENSPEC_RAW</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>WHENSPEC_RFC2822</name></decl>,
<decl><name>WHENSPEC_NOW</name></decl>
}</block></enum></type> <name>whenspec_type</name>;</typedef>

<struct>struct <name>recent_command</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>mark_set_inserter_t</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>each_mark_fn_t</name>)<parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbp</name></decl></parameter>)</parameter_list>;</function_decl></typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>max_depth</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>off_t</name></type> <name>max_packsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>unpack_limit</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>force_update</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>alloc_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>marks_set_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name><name>object_count_by_type</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TYPE_BITS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name><name>duplicate_count_by_type</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TYPE_BITS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name><name>delta_count_by_type</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TYPE_BITS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name><name>delta_count_attempts_by_type</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TYPE_BITS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>object_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>branch_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>branch_load_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>failure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>pack_edges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>show_stats</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>global_argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>global_argv</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mem_pool</name></name></type> <name>fi_mem_pool</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">2</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal> <operator>-</operator>
<sizeof>sizeof<argument_list>(<argument><expr>struct <name>mp_block</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>atom_table_sz</name> <init>= <expr><literal type="number">4451</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>atom_cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>atom_str</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>atom_table</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pack_idx_option</name></name></type> <name>pack_idx_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>pack_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>hashfile</name></name> <modifier>*</modifier></type><name>pack_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>pack_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>all_packs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>off_t</name></type> <name>pack_size</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>object_entry_alloc</name> <init>= <expr><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry_pool</name></name> <modifier>*</modifier></type><name>blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name><name>object_table</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>marks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>export_marks_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>import_marks_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>import_marks_file_from_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>import_marks_file_ignore_missing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>import_marks_file_done</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>relative_marks_paths</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>last_object</name></name></type> <name>last_blob</name> <init>= <expr><block>{ <expr><name>STRBUF_INIT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>tree_entry_alloc</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>avail_tree_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>avail_tree_table_sz</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>avail_tree_content</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>avail_tree_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>tree_entry_allocd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>old_tree</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>new_tree</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>max_active_branches</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>cur_active_branches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>branch_table_sz</name> <init>= <expr><literal type="number">1039</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>branch_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>active_branches</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>first_tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>last_tag</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>whenspec_type</name></type> <name>whenspec</name> <init>= <expr><name>WHENSPEC_RAW</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>command_buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>unread_command_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>recent_command</name></name></type> <name>cmd_hist</name> <init>= <expr><block>{<expr><operator>&amp;</operator><name>cmd_hist</name></expr>, <expr><operator>&amp;</operator><name>cmd_hist</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>cmd_tail</name> <init>= <expr><operator>&amp;</operator><name>cmd_hist</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>rc_free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>cmd_save</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>next_mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>new_data</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>seen_data_command</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>require_explicit_termination</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>allow_unsafe_features</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>checkpoint_requested</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>sub_marks_from</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>string_list</name></name></type> <name>sub_marks_to</name> <init>= <expr><name>STRING_LIST_INIT_DUP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>kh_oid_map_t</name> <modifier>*</modifier></type><name>sub_oid_map</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cat_blob_fd</name> <init>= <expr><name>STDOUT_FILENO</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_argv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_get_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_cat_blob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_ls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>for_each_mark</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>each_mark_fn_t</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>k</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>shift</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>for_each_mark</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <operator>(</operator><name>k</name> <operator>&lt;&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>shift</name></name><operator>)</operator></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>marked</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>marked</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_marks_fn</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>object</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>cbp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">":%"</literal> <name>PRIuMAX</name> <literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_branch_report</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>rpt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">"%s:\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" status :"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" active"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" loaded"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" dirty"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" tip commit : %s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" old tree : %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" cur tree : %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" commit clock: %"</literal> <name>PRIuMAX</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>last_commit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" last pack : "</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>&lt;</operator> <name>MAX_PACK_ID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>write_crash_report</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><call><name>git_pathdup</name><argument_list>(<argument><expr><literal type="string">"fast_import_crash_%"</literal><name>PRIuMAX</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>rpt</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rpt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"can't write crash report %s"</literal></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fast-import: dumping crash report to %s\n"</literal></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">"fast-import crash report:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" fast-import process: %"</literal><name>PRIuMAX</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" parent process : %"</literal><name>PRIuMAX</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" at %s\n"</literal></expr></argument>, <argument><expr><call><name>show_date</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>DATE_MODE</name><argument_list>(<argument><expr><name>ISO8601</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"fatal: "</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Most Recent Commands Before Crash\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"---------------------------------\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>rc</name> <operator>=</operator> <name><name>cmd_hist</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>rc</name> <operator>!=</operator> <operator>&amp;</operator><name>cmd_hist</name></expr>;</condition> <incr><expr><name>rc</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <operator>&amp;</operator><name>cmd_hist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"* "</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Active Branch LRU\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-----------------\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" active_branches = %lu cur, %lu max\n"</literal></expr></argument>,
<argument><expr><name>cur_active_branches</name></expr></argument>,
<argument><expr><name>max_active_branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" pos clock name\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name>active_branches</name></expr><operator>,</operator> <expr><name>lu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>active_next_branch</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" %2lu) %6"</literal> <name>PRIuMAX</name><literal type="string">" %s\n"</literal></expr></argument>,
<argument><expr><operator>++</operator><name>lu</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>last_commit</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Inactive Branches\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-----------------\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>lu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lu</name> <operator>&lt;</operator> <name>branch_table_sz</name></expr>;</condition> <incr><expr><name>lu</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>lu</name></expr>]</index></name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>write_branch_report</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>first_tag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>tg</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Annotated Tags\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"--------------\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>tg</name> <operator>=</operator> <name>first_tag</name></expr>;</init> <condition><expr><name>tg</name></expr>;</condition> <incr><expr><name>tg</name> <operator>=</operator> <name><name>tg</name><operator>-&gt;</operator><name>next_tag</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tg</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>tg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Marks\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-----\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>export_marks_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>, <argument><expr><literal type="string">" exported to %s\n"</literal></expr></argument>, <argument><expr><name>export_marks_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>for_each_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dump_marks_fn</name></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"-------------------\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"END OF CRASH REPORT\n"</literal></expr></argument>, <argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>rpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>end_packfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unkeep_all_packs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_marks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>NORETURN</name> <name>void</name></type> <name>die_nicely</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>zombie</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"fatal: "</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zombie</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zombie</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_crash_report</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>end_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unkeep_all_packs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_checkpoint_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>checkpoint_requested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_checkpoint_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sa</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>checkpoint_signal</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_RESTART</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alloc_objects</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry_pool</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_entry_pool</name></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <name>cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>next_pool</name></name> <operator>=</operator> <name>blocks</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>next_free</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>entries</name></name> <operator>+</operator> <name>cnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>blocks</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>alloc_count</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>new_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>blocks</name><operator>-&gt;</operator><name>next_free</name></name> <operator>==</operator> <name><name>blocks</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>alloc_objects</name><argument_list>(<argument><expr><name>object_entry_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>blocks</name><operator>-&gt;</operator><name>next_free</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>find_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name><name>object_table</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>e</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>insert_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name><name>oid</name><operator>-&gt;</operator><name>hash</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>object_table</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>e</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>new_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>object_table</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>object_table</name><index>[<expr><name>h</name></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>invalidate_pack_id</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>h</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>object_table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>h</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name><name>object_table</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>lu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lu</name> <operator>&lt;</operator> <name>branch_table_sz</name></expr>;</condition> <incr><expr><name>lu</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>lu</name></expr>]</index></name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name>first_tag</name></expr>;</init> <condition><expr><name>t</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>hc_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>r</name> <operator>*</operator> <literal type="number">31</literal> <operator>+</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pool_strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>mem_pool_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>insert_mark</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>idnum</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>idnum</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>mem_pool_calloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>mark_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>shift</name></name> <operator>=</operator> <name><name>marks</name><operator>-&gt;</operator><name>shift</name></name> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>marks</name></expr>;</expr_stmt>
<expr_stmt><expr><name>marks</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>i</name> <init>= <expr><name>idnum</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>idnum</name> <operator>-=</operator> <name>i</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>mem_pool_calloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>mark_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>shift</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>marked</name><index>[<expr><name>idnum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>marks_set_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>marked</name><index>[<expr><name>idnum</name></expr>]</index></name> <operator>=</operator> <name>oe</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>find_mark</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>idnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>orig_idnum</name> <init>= <expr><name>idnum</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idnum</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name><operator>)</operator> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>i</name> <init>= <expr><name>idnum</name> <operator>&gt;&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>idnum</name> <operator>-=</operator> <name>i</name> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>marked</name><index>[<expr><name>idnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"mark :%"</literal> <name>PRIuMAX</name> <literal type="string">" not declared"</literal></expr></argument>, <argument><expr><name>orig_idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>oe</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>atom_str</name></name> <modifier>*</modifier></type><name>to_atom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hc</name> <init>= <expr><call><name>hc_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>atom_table_sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>atom_str</name></name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name><name>atom_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</init> <condition><expr><name>c</name></expr>;</condition> <incr><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next_atom</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>str_len</name></name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mem_pool_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>atom_str</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>str_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>str_dat</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>next_atom</name></name> <operator>=</operator> <name><name>atom_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>atom_table</name><index>[<expr><name>hc</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>atom_cnt</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>lookup_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hc</name> <init>= <expr><call><name>hc_str</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>%</operator> <name>branch_table_sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>new_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hc</name> <init>= <expr><call><name>hc_str</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>%</operator> <name>branch_table_sz</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>lookup_branch</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid attempt to create duplicate branch: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_refname_format</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>REFNAME_ALLOW_ONELEVEL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Branch name doesn't conform to GIT standards: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>mem_pool_calloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>branch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pool_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>S_IFDIR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>S_IFDIR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>branch_table</name><index>[<expr><name>hc</name></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>branch_count</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>hc_entries</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <ternary><condition><expr><name>cnt</name> <operator>&amp;</operator> <literal type="number">7</literal></expr> ?</condition><then> <expr><operator>(</operator><name>cnt</name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>cnt</name> <operator>/</operator> <literal type="number">8</literal></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>cnt</name> <operator>&lt;</operator> <name>avail_tree_table_sz</name></expr> ?</condition><then> <expr><name>cnt</name></expr> </then><else>: <expr><name>avail_tree_table_sz</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>new_tree_content</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>avail_tree_content</name></name> <modifier>*</modifier></type><name>f</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hc</name> <init>= <expr><call><name>hc_entries</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name><name>avail_tree_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>f</name></expr><operator>,</operator> <expr><name>f</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next_avail</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>entry_capacity</name></name> <operator>&gt;=</operator> <name>cnt</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>next_avail</name></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next_avail</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>avail_tree_table</name><index>[<expr><name>hc</name></expr>]</index></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next_avail</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <ternary><condition><expr><name>cnt</name> <operator>&amp;</operator> <literal type="number">7</literal></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>cnt</name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">8</literal></expr> </then><else>: <expr><name>cnt</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>mem_pool_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>entry_capacity</name></name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator>struct <name>tree_content</name><operator>*</operator><operator>)</operator><name>f</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>delta_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>release_tree_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type> <name>release_tree_content</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>avail_tree_content</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>avail_tree_content</name><operator>*</operator><operator>)</operator><name>t</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hc</name> <init>= <expr><call><name>hc_entries</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>entry_capacity</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>next_avail</name></name> <operator>=</operator> <name><name>avail_tree_table</name><index>[<expr><name>hc</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avail_tree_table</name><index>[<expr><name>hc</name></expr>]</index></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>release_tree_content_recursive</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_entry</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>release_tree_content</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>grow_tree_content</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>new_tree_content</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>+</operator> <name>amt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>delta_depth</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>delta_depth</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>COPY_ARRAY</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>release_tree_content</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>new_tree_entry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>avail_tree_entry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name> <init>= <expr><name>tree_entry_alloc</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tree_entry_allocd</name> <operator>+=</operator> <name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>tree_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_tree_entry</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>e</name><operator>)</operator> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>e</name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>avail_tree_entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_tree_entry</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>e</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>release_tree_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>e</name><operator>)</operator> <operator>=</operator> <name>avail_tree_entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_tree_entry</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>dup_tree_content</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>new_tree_content</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_tree_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>tree</name></name> <operator>&amp;&amp;</operator> <call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <call><name>dup_tree_content</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>delta_depth</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>delta_depth</name></name></expr>;</expr_stmt>

<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>start_packfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>tmp_file</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_header</name></name></type> <name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pack_fd</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pack_fd</name> <operator>=</operator> <call><name>odb_mkstemp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_file</name></expr></argument>, <argument><expr><literal type="string">"pack/tmp_pack_XXXXXX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FLEX_ALLOC_STR</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pack_name</name></expr></argument>, <argument><expr><name><name>tmp_file</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pack_fd</name></name> <operator>=</operator> <name>pack_fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>do_not_close</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_file</name> <operator>=</operator> <call><name>hashfd</name><argument_list>(<argument><expr><name>pack_fd</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_signature</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>PACK_SIGNATURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_version</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>hdr_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pack_data</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>object_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REALLOC_ARRAY</name><argument_list>(<argument><expr><name>all_packs</name></expr></argument>, <argument><expr><name>pack_id</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>all_packs</name><index>[<expr><name>pack_id</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>create_index</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pack_idx_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>idx</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry_pool</name></name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>object_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>o</name> <operator>=</operator> <name>blocks</name></expr>;</init> <condition><expr><name>o</name></expr>;</condition> <incr><expr><name>o</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next_pool</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>next_free</name></name></expr>;</init> <condition><expr><name>e</name><operator>--</operator> <operator>!=</operator> <name><name>o</name><operator>-&gt;</operator><name>entries</name></name></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>pack_id</name> <operator>==</operator> <name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>c</name><operator>++</operator> <operator>=</operator> <operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>idx</name> <operator>+</operator> <name>object_count</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>last</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"internal consistency error creating the index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmpfile</name> <operator>=</operator> <call><name>write_idx_file</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>object_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pack_idx_opts</name></expr></argument>,
<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tmpfile</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>keep_pack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curr_index_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keep_msg</name> <init>= <expr><literal type="string">"fast-import"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>keep_fd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>odb_pack_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"keep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keep_fd</name> <operator>=</operator> <call><name>odb_pack_keep</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keep_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot create keep file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>write_or_die</name><argument_list>(<argument><expr><name>keep_fd</name></expr></argument>, <argument><expr><name>keep_msg</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>keep_msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>keep_fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"failed to write keep file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>odb_pack_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"pack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>finalize_object_file</name><argument_list>(<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot store pack file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>odb_pack_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>finalize_object_file</name><argument_list>(<argument><expr><name>curr_index_name</name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"cannot store index file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>curr_index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unkeep_all_packs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>pack_id</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>all_packs</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>odb_pack_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="string">"keep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>loosen_small_pack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>child_process</name></name></type> <name>unpack</name> <init>= <expr><name>CHILD_PROCESS_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pack_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Failed seeking to start of '%s'"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>unpack</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_fd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unpack</name><operator>.</operator><name>git_cmd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unpack</name><operator>.</operator><name>stdout_to_stderr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unpack</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="string">"unpack-objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_stats</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unpack</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>run_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpack</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>end_packfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>running</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>running</name> <operator>||</operator> <operator>!</operator><name>pack_data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>running</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_delta_base_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>object_count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>new_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>cur_pack_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>idx_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>close_pack_windows</name><argument_list>(<argument><expr><name>pack_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>finalize_hashfile</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name><name>cur_pack_oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fixup_pack_header_footer</name><argument_list>(<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_fd</name></name></expr></argument>, <argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>, <argument><expr><name>object_count</name></expr></argument>,
<argument><expr><name><name>cur_pack_oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>pack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>object_count</name> <operator>&lt;=</operator> <name>unpack_limit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>loosen_small_pack</name><argument_list>(<argument><expr><name>pack_data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalidate_pack_id</name><argument_list>(<argument><expr><name>pack_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>discard_pack</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx_name</name> <operator>=</operator> <call><name>keep_pack</name><argument_list>(<argument><expr><call><name>create_index</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>new_p</name> <operator>=</operator> <call><name>add_packed_git</name><argument_list>(<argument><expr><name>idx_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>idx_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"core git rejected index %s"</literal></expr></argument>, <argument><expr><name>idx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>all_packs</name><index>[<expr><name>pack_id</name></expr>]</index></name> <operator>=</operator> <name>new_p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>install_packed_git</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>new_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>idx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>pack_edges</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name><name>new_p</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>branch_table_sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>pack_id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name>first_tag</name></expr>;</init> <condition><expr><name>t</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>pack_id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>pack_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pack_id</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<label><name>discard_pack</name>:</label>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><name><name>pack_data</name><operator>-&gt;</operator><name>pack_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>pack_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>running</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last_blob</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last_blob</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last_blob</name><operator>.</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cycle_packfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>end_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>start_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>store_object</name><parameter_list>(
<parameter><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>dat</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>last_object</name></name> <modifier>*</modifier></type><name>last</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oidout</name></decl></parameter>,
<parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>out</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hdr</name><index>[<expr><literal type="number">96</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hdrlen</name></decl>, <decl><type ref="prev"/><name>deltalen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_hash_ctx</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_zstream</name></type> <name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>xsnprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s %lu"</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name><name>dat</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oidout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>insert_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>insert_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>find_sha1_pack</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>,
<argument><expr><call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last</name> <operator>&amp;&amp;</operator> <name><name>last</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>last</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buf</name></name> <operator>&amp;&amp;</operator> <name><name>last</name><operator>-&gt;</operator><name>depth</name></name> <operator>&lt;</operator> <name>max_depth</name>
<operator>&amp;&amp;</operator> <name><name>dat</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>delta_count_attempts_by_type</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>delta</name> <operator>=</operator> <call><name>diff_delta</name><argument_list>(<argument><expr><name><name>last</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>last</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>dat</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>deltalen</name></expr></argument>, <argument><expr><name><name>dat</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>git_deflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>deltalen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>dat</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <call><name>git_deflate_bound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>out</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>git_deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while> 
<expr_stmt><expr><call><name>git_deflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>max_packsize</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>pack_size</name> <operator>+</operator> <name>PACK_SIZE_THRESHOLD</name> <operator>+</operator> <name><name>s</name><operator>.</operator><name>total_out</name></name><operator>)</operator> <operator>&gt;</operator> <name>max_packsize</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>pack_size</name> <operator>+</operator> <name>PACK_SIZE_THRESHOLD</name> <operator>+</operator> <name><name>s</name><operator>.</operator><name>total_out</name></name><operator>)</operator> <operator>&lt;</operator> <name>pack_size</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>pack_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cycle_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_AND_NULL</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_deflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>dat</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <call><name>git_deflate_bound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>out</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>git_deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while> 
<expr_stmt><expr><call><name>git_deflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>pack_id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>pack_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>object_count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>object_count_by_type</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>crc32_begin</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>off_t</name></type> <name>ofs</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>-</operator> <name><name>last</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>pos</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>delta_count_by_type</name><index>[<expr><name>type</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>OBJ_OFS_DELTA</name></expr></argument>, <argument><expr><name>deltalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hdr</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ofs</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>hdr</name><index>[<expr><operator>--</operator><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">128</literal> <operator>|</operator> <operator>(</operator><operator>--</operator><name>ofs</name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>hdr</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>dat</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>+=</operator> <name><name>s</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <call><name>crc32_end</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>last</name><operator>-&gt;</operator><name>no_swap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>*</operator><name>dat</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_swap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>depth</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>truncate_pack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hashfile_checkpoint</name></name> <modifier>*</modifier></type><name>checkpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hashfile_truncate</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>checkpoint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot truncate pack to skip duplicate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>=</operator> <name><name>checkpoint</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_blob</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oidout</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>in_sz</name> <init>= <expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>, <decl><type ref="prev"/><name>out_sz</name> <init>= <expr><literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>in_sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>out_sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hdrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_hash_ctx</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>git_zstream</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hashfile_checkpoint</name></name></type> <name>checkpoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>max_packsize</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>pack_size</name> <operator>+</operator> <name>PACK_SIZE_THRESHOLD</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&gt;</operator> <name>max_packsize</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>pack_size</name> <operator>+</operator> <name>PACK_SIZE_THRESHOLD</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;</operator> <name>pack_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>cycle_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hashfile_checkpoint</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>checkpoint</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>xsnprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>out_buf</name></expr></argument>, <argument><expr><name>out_sz</name></expr></argument>, <argument><expr><literal type="string">"blob %"</literal> <name>PRIuMAX</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>init_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>out_buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>crc32_begin</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>git_deflate_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>pack_compression_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>encode_in_pack_object_header</name><argument_list>(<argument><expr><name>out_buf</name></expr></argument>, <argument><expr><name>out_sz</name></expr></argument>, <argument><expr><name>OBJ_BLOB</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>out_buf</name> <operator>+</operator> <name>hdrlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>out_sz</name> <operator>-</operator> <name>hdrlen</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>status</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>.</operator><name>avail_in</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><ternary><condition><expr><name>in_sz</name> <operator>&lt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>in_sz</name></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>fread</name><argument_list>(<argument><expr><name>in_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name> <operator>&amp;&amp;</operator> <call><name>feof</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"EOF in data (%"</literal> <name>PRIuMAX</name> <literal type="string">" bytes remaining)"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>update_fn</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>in_buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>in_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>git_deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name>len</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>Z_FINISH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>||</operator> <name>status</name> <operator>==</operator> <name>Z_STREAM_END</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name><name>s</name><operator>.</operator><name>next_out</name></name> <operator>-</operator> <name>out_buf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashwrite</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>, <argument><expr><name>out_buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pack_size</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>out_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>out_sz</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Z_OK</name></expr>:</case>
<case>case <expr><name>Z_BUF_ERROR</name></expr>:</case>
<case>case <expr><name>Z_STREAM_END</name></expr>:</case>
<continue>continue;</continue>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unexpected deflate failure: %d"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><call><name>git_deflate_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>the_hash_algo</name><operator>-&gt;</operator><name>final_fn</name></name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oidout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>insert_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>insert_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>truncate_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>find_sha1_pack</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>,
<argument><expr><call><name>get_all_packs</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OBJ_BLOB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>truncate_pack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OBJ_BLOB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>pack_id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <call><name>crc32_end</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>object_count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>object_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>in_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>out_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>gfi_unpack_entry</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packed_git</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>all_packs</name><index>[<expr><name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>pack_data</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pack_size</name></name> <operator>&lt;</operator> <operator>(</operator><name>pack_size</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><call><name>close_pack_windows</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashflush</name><argument_list>(<argument><expr><name>pack_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pack_size</name></name> <operator>=</operator> <name>pack_size</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>unpack_entry</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><name>sizep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>modep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="char">'7'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>mode</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>modep</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>load_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name> <init>= <expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>myoe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>t</name> <operator>=</operator> <call><name>new_tree_content</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>myoe</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>myoe</name> <operator>&amp;&amp;</operator> <name><name>myoe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>!=</operator> <name>MAX_PACK_ID</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>myoe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a tree: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>delta_depth</name></name> <operator>=</operator> <name><name>myoe</name><operator>-&gt;</operator><name>depth</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>gfi_unpack_entry</name><argument_list>(<argument><expr><name>myoe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't load tree %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name>type</name> <operator>!=</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't load tree %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>!=</operator> <operator>(</operator><name>buf</name> <operator>+</operator> <name>size</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>new_tree_entry</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_capacity</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>t</name> <operator>=</operator> <call><name>grow_tree_content</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>get_mode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Corrupt mode in %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>to_atom</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashcpy</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tecmp0</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>tree_entry</name><operator>*</operator><operator>*</operator><operator>)</operator><name>_a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>tree_entry</name><operator>*</operator><operator>*</operator><operator>)</operator><name>_b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>base_name_compare</name><argument_list>(
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>,
<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tecmp1</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>tree_entry</name><operator>*</operator><operator>*</operator><operator>)</operator><name>_a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>tree_entry</name><operator>*</operator><operator>*</operator><operator>)</operator><name>_b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>base_name_compare</name><argument_list>(
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>,
<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mktree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>maxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>, <argument><expr><name>tecmp0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>, <argument><expr><name>tecmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>versions</name><index>[<expr><name>v</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxlen</name> <operator>+=</operator> <name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>+</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_grow</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><name>v</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="string">"%o %s%c"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><name>v</name></expr>]</index></name><operator>.</operator><name>mode</name> <operator>&amp;</operator> <operator>~</operator><name>NO_DELTA</name><operator>)</operator></expr></argument>,
<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><name>v</name></expr>]</index></name><operator>.</operator><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>store_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>del</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>last_object</name></name></type> <name>lo</name> <init>= <expr><block>{ <expr><name>STRBUF_INIT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>le</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tree</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>store_tree</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>&amp;</operator> <name>NO_DELTA</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>le</name> <operator>&amp;&amp;</operator> <name><name>le</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>pack_id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mktree</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lo</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>old_tree</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lo</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>le</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lo</name><operator>.</operator><name>depth</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>delta_depth</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mktree</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>store_object</name><argument_list>(<argument><expr><name>OBJ_TREE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>delta_depth</name></name> <operator>=</operator> <name><name>lo</name><operator>.</operator><name>depth</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>del</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>release_tree_entry</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tree_content_replace</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint16_t</name></type> <name>mode</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>newtree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Root cannot be a non-directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>newtree</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tree_content_set</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint16_t</name></type> <name>mode</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>subtree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slash1</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>slash1</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Empty path component found in input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>slash1</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>subtree</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Non-directories cannot have subtrees"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>==</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fspathncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>slash1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>==</operator> <name>mode</name>
<operator>&amp;&amp;</operator> <call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>subtree</name></expr>;</expr_stmt>














<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>|=</operator> <name>NO_DELTA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <call><name>new_tree_content</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>S_IFDIR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tree_content_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>slash1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>subtree</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_capacity</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>t</name> <operator>=</operator> <call><name>grow_tree_content</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>new_tree_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>to_atom</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slash1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <call><name>new_tree_content</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>S_IFDIR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tree_content_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>slash1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>subtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>subtree</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tree_content_remove</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>backup_leaf</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>allow_root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slash1</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>slash1</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <name>allow_root</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
<goto>goto <name>del_entry</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>==</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fspathncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slash1</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>






<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>slash1</name> <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>del_entry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tree_content_remove</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>slash1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>backup_leaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>e</name><operator>-&gt;</operator><name>tree</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>tree</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>backup_leaf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>del_entry</name>;</goto>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>del_entry</name>:</label>
<if_stmt><if>if <condition>(<expr><name>backup_leaf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>backup_leaf</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>backup_leaf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tree_content_get</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>allow_root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slash1</name> <operator>=</operator> <call><name>strchrnul</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>slash1</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allow_root</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Empty path component found in input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
<goto>goto <name>found_entry</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>==</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fspathncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>slash1</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>found_entry</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>tree_content_get</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>slash1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>leaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>found_entry</name>:</label>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>leaf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name> <operator>&amp;&amp;</operator> <call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <call><name>dup_tree_content</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"fast-import"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_transaction</name></name> <modifier>*</modifier></type><name>transaction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>old_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>delete</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>delete_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_ref</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_update</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>old_cmit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_cmit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>old_cmit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_cmit</name> <operator>=</operator> <call><name>lookup_commit_reference_gently</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_cmit</name> <operator>||</operator> <operator>!</operator><name>new_cmit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Branch %s is missing commits."</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_merge_bases</name><argument_list>(<argument><expr><name>old_cmit</name></expr></argument>, <argument><expr><name>new_cmit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"Not updating %s"</literal>
<literal type="string">" (new tip %s does not contain %s)"</literal></expr></argument>,
<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>transaction</name> <operator>=</operator> <call><name>ref_transaction_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transaction</name> <operator>||</operator>
<call><name>ref_transaction_update</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_oid</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>ref_transaction_commit</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ref_transaction_free</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ref_transaction_free</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_branches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>branch_table_sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>branch_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>table_next_branch</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>update_branch</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_tags</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"fast-import"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>ref_name</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>err</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ref_transaction</name></name> <modifier>*</modifier></type><name>transaction</name></decl>;</decl_stmt>

<expr_stmt><expr><name>transaction</name> <operator>=</operator> <call><name>ref_transaction_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transaction</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name>first_tag</name></expr>;</init> <condition><expr><name>t</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_name</name></expr></argument>, <argument><expr><literal type="string">"refs/tags/%s"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ref_transaction_update</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><name><name>ref_name</name><operator>.</operator><name>buf</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>ref_transaction_commit</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>err</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>ref_transaction_free</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_marks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lock_file</name></name></type> <name>mark_lock</name> <init>= <expr><name>LOCK_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>export_marks_file</name> <operator>||</operator> <operator>(</operator><name>import_marks_file</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>import_marks_file_done</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>safe_create_leading_directories_const</name><argument_list>(<argument><expr><name>export_marks_file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"unable to create leading directories of %s"</literal></expr></argument>,
<argument><expr><name>export_marks_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hold_lock_file_for_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mark_lock</name></expr></argument>, <argument><expr><name>export_marks_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"Unable to write marks file %s"</literal></expr></argument>,
<argument><expr><name>export_marks_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fdopen_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mark_lock</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rollback_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mark_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error</name><argument_list>(<argument><expr><literal type="string">"Unable to write marks file %s: %s"</literal></expr></argument>,
<argument><expr><name>export_marks_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>for_each_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dump_marks_fn</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>commit_lock_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mark_lock</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>failure</name> <operator>|=</operator> <call><name>error_errno</name><argument_list>(<argument><expr><literal type="string">"Unable to write file %s"</literal></expr></argument>,
<argument><expr><name>export_marks_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>insert_object_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"object not found: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>insert_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>insert_mark</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>insert_oid_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>insert_mark</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_mark_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>mark_set_inserter_t</name></type> <name>inserter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>!</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"corrupt mark line: %s"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>strtoumax</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mark</name> <operator>||</operator> <name>end</name> <operator>==</operator> <name>line</name> <operator>+</operator> <literal type="number">1</literal>
<operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">' '</literal>
<operator>||</operator> <call><name>get_oid_hex_any</name><argument_list>(<argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIT_HASH_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"corrupt mark line: %s"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>inserter</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_marks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>import_marks_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>import_marks_file_ignore_missing</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot read '%s'"</literal></expr></argument>, <argument><expr><name>import_marks_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>read_mark_file</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>insert_object_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><name>import_marks_file_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_next_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stdin_eof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stdin_eof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unread_command_buf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unread_command_buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unread_command_buf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>recent_command</name></name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>stdin_eof</name> <operator>=</operator> <call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>command_buf</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>stdin_eof</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>seen_data_command</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"feature "</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>starts_with</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"option "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parse_argv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc_free</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rc_free</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>cmd_hist</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cmd_hist</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cmd_hist</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>&amp;</operator><name>cmd_hist</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>cmd_tail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>cmd_hist</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd_tail</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>command_buf</name><operator>.</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>skip_optional_lf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>term_char</name> <init>= <expr><call><name>fgetc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>term_char</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>term_char</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>term_char</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_mark</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"mark :"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next_mark</name> <operator>=</operator> <call><name>strtoumax</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>next_mark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_original_identifier</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"original-oid "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>uintmax_t</name> <modifier>*</modifier></type><name>len_res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"data "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Expected 'data n' command, found: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>term</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>term_len</name> <init>= <expr><name><name>command_buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name>data</name> <operator>-</operator> <name><name>command_buf</name><operator>.</operator><name>buf</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>command_buf</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"EOF in data (terminator '%s' not found)"</literal></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>term_len</name> <operator>==</operator> <name><name>command_buf</name><operator>.</operator><name>len</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>command_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>len</name> <init>= <expr><call><name>strtoumax</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>length</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>limit</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len_res</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"data is too large to use in this context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>s</name> <init>= <expr><call><name>strbuf_fread</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>&amp;&amp;</operator> <call><name>feof</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"EOF in data (%lu bytes remaining)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>length</name> <operator>-</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>skip_optional_lf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>validate_raw_date</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_src</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator> <name>endp</name> <operator>==</operator> <name>src</name> <operator>||</operator> <operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>src</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>src</name> <operator>!=</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>src</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator> <name>endp</name> <operator>==</operator> <name>src</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>endp</name> <operator>||</operator> <literal type="number">1400</literal> <operator>&lt;</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>orig_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ltgt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>name_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>ident</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ltgt</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ltgt</name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing &lt; in ident string: %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ltgt</name> <operator>!=</operator> <name>buf</name> <operator>&amp;&amp;</operator> <name><name>ltgt</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space before &lt; in ident string: %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ltgt</name> <operator>=</operator> <name>ltgt</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>ltgt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ltgt</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing &gt; in ident string: %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ltgt</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ltgt</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after &gt; in ident string: %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ltgt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <name>ltgt</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>whenspec</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>WHENSPEC_RAW</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>validate_raw_date</name><argument_list>(<argument><expr><name>ltgt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid raw date \"%s\" in ident: %s"</literal></expr></argument>, <argument><expr><name>ltgt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>WHENSPEC_RFC2822</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>parse_date</name><argument_list>(<argument><expr><name>ltgt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid rfc2822 date \"%s\" in ident: %s"</literal></expr></argument>, <argument><expr><name>ltgt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>WHENSPEC_NOW</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"now"</literal></expr></argument>, <argument><expr><name>ltgt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Date in ident must be 'now': %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>datestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ident</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_and_store_blob</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>last_object</name></name> <modifier>*</modifier></type><name>last</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oidout</name></decl></parameter>,
<parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>big_file_threshold</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>store_object</name><argument_list>(<argument><expr><name>OBJ_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>oidout</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>stream_blob</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>oidout</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_optional_lf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_new_blob</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_original_identifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_and_store_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_blob</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>next_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unload_one_branch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>cur_active_branches</name>
<operator>&amp;&amp;</operator> <name>cur_active_branches</name> <operator>&gt;=</operator> <name>max_active_branches</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>min_commit</name> <init>= <expr><name>ULONG_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <name>active_branches</name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>active_next_branch</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>last_commit</name></name> <operator>&lt;</operator> <name>min_commit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min_commit</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>last_commit</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>active_next_branch</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>active_next_branch</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>active_next_branch</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>active_branches</name></expr>;</expr_stmt>
<expr_stmt><expr><name>active_branches</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>active_next_branch</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>active_next_branch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cur_active_branches</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>load_branch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>active_next_branch</name></name> <operator>=</operator> <name>active_branches</name></expr>;</expr_stmt>
<expr_stmt><expr><name>active_branches</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cur_active_branches</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>branch_load_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>convert_num_notes_to_fanout</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>num_notes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>fanout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>num_notes</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fanout</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>fanout</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>construct_path_with_fanout</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hex_sha1</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>fanout</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fanout</name> <operator>&gt;=</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>rawsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Too large fanout (%u)"</literal></expr></argument>, <argument><expr><name>fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>fanout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>hex_sha1</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>hex_sha1</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fanout</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>hex_sha1</name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name> <operator>+</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>-</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>do_change_note_fanout</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>orig_root</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hex_oid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hex_oid_len</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>fullpath_len</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>fanout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_content</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"/><name>leaf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>tmp_hex_oid_len</name></decl>, <decl><type ref="prev"/><name>tmp_fullpath_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>num_notes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>realpath</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>GIT_MAX_HEXSZ</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hexsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>entry_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_hex_oid_len</name> <operator>=</operator> <name>hex_oid_len</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_fullpath_len</name> <operator>=</operator> <name>fullpath_len</name></expr>;</expr_stmt>









<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>||</operator>
<name>tmp_hex_oid_len</name> <operator>&gt;</operator> <name>hexsz</name> <operator>||</operator>
<name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>hex_oid</name> <operator>+</operator> <name>hex_oid_len</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>,
<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_fullpath_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>fullpath</name><index>[<expr><name>tmp_fullpath_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fullpath</name> <operator>+</operator> <name>tmp_fullpath_len</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_dat</name></name></expr></argument>,
<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_fullpath_len</name> <operator>+=</operator> <name><name>e</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>str_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fullpath</name><index>[<expr><name>tmp_fullpath_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_hex_oid_len</name> <operator>==</operator> <name>hexsz</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_oid_hex</name><argument_list>(<argument><expr><name>hex_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fanout</name> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num_notes</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>construct_path_with_fanout</name><argument_list>(<argument><expr><name>hex_oid</name></expr></argument>, <argument><expr><name>fanout</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num_notes</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tree_content_remove</name><argument_list>(<argument><expr><name>orig_root</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Failed to remove path %s"</literal></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tree_content_set</name><argument_list>(<argument><expr><name>orig_root</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num_notes</name> <operator>+=</operator> <call><name>do_change_note_fanout</name><argument_list>(<argument><expr><name>orig_root</name></expr></argument>, <argument><expr><name>e</name></expr></argument>,
<argument><expr><name>hex_oid</name></expr></argument>, <argument><expr><name>tmp_hex_oid_len</name></expr></argument>,
<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>tmp_fullpath_len</name></expr></argument>, <argument><expr><name>fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>num_notes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>change_note_fanout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>fanout</name></decl></parameter>)</parameter_list>
<block>{<block_content>






<decl_stmt><decl><type><name>char</name></type> <name><name>hex_oid</name><index>[<expr><name>GIT_MAX_HEXSZ</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>path</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <operator>(</operator><name>GIT_MAX_HEXSZ</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<return>return <expr><call><name>do_change_note_fanout</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>hex_oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fanout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_mapped_oid_hex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hex</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>algo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>khiter_t</name></type> <name>it</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>oid</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>algo</name> <operator>=</operator> <call><name>parse_oid_hex_any</name><argument_list>(<argument><expr><name>hex</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>algo</name> <operator>==</operator> <name>GIT_HASH_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>kh_get_oid_map</name><argument_list>(<argument><expr><name>sub_oid_map</name></expr></argument>, <argument><expr><operator>*</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <call><name>kh_end</name><argument_list>(<argument><expr><name>sub_oid_map</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>hash_algos</name><index>[<expr><name>algo</name></expr>]</index></name><operator>.</operator><name>format_id</name> <operator>==</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>format_id</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><call><name>kh_value</name><argument_list>(<argument><expr><name>sub_oid_map</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>parse_mark_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>mark</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>strtoumax</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"No value after ':' in mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>mark</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>parse_mark_ref_eol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>mark</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>parse_mark_ref</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>mark</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>uintmax_t</name></type> <name>parse_mark_ref_space</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>parse_mark_ref</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name><operator>++</operator> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>mark</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>file_change_m</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>mode</name></decl>, <decl><type ref="prev"/><name>inline_data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>get_mode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Corrupt mode: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0644</literal></expr>:</case>
<case>case <expr><literal type="number">0755</literal></expr>:</case>
<expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFREG</name></expr>;</expr_stmt>
<case>case <expr><name>S_IFREG</name> <operator>|</operator> <literal type="number">0644</literal></expr>:</case>
<case>case <expr><name>S_IFREG</name> <operator>|</operator> <literal type="number">0755</literal></expr>:</case>
<case>case <expr><name>S_IFLNK</name></expr>:</case>
<case>case <expr><name>S_IFDIR</name></expr>:</case>
<case>case <expr><name>S_IFGITLINK</name></expr>:</case>

<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Corrupt mode: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><call><name>parse_mark_ref_space</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"inline "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inline_data</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_mapped_oid_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid dataref: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after SHA1: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after path in: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_empty_tree_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tree_content_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>inline_data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Git links cannot be specified 'inline': %s"</literal></expr></argument>,
<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>oe</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a commit (actually a %s): %s"</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>




</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inline_data</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Directories cannot be specified 'inline': %s"</literal></expr></argument>,
<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><call><name>read_next_command</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"cat-blob "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_cat_blob</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>parse_and_store_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>expected</name> <init>= <expr><ternary><condition><expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
<expr><name>OBJ_TREE</name></expr></then><else>: <expr><name>OBJ_BLOB</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><ternary><condition><expr><name>oe</name></expr> ?</condition><then> <expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>:
<expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s not found: %s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Tree"</literal></expr> </then><else>: <expr><literal type="string">"Blob"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a %s (actually a %s): %s"</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tree_content_replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tree_content_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>file_change_d</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after path in: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tree_content_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>file_change_cr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>s_uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>d_uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name></type> <name>leaf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_uq</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after source: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after source: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_uq</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s_uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>endp</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing dest: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d_uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d_uq</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after dest in: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>d_uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leaf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rename</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tree_content_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tree_content_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Path %s not in branch"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>d</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>tree_content_replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tree_content_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>,
<argument><expr><name><name>leaf</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>note_change_n</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old_fanout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>, <decl><type ref="prev"/><name>commit_oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>GIT_MAX_RAWSZ</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>inline_data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>new_fanout</name></decl>;</decl_stmt>











<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>old_fanout</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name> <operator>=</operator> <call><name>change_note_fanout</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>old_fanout</name> <operator>=</operator> <call><name>convert_num_notes_to_fanout</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><call><name>parse_mark_ref_space</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"inline "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inline_data</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_mapped_oid_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid dataref: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after SHA1: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't add a note on empty branch."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>commit_mark</name> <init>= <expr><call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>commit_oe</name> <init>= <expr><call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>commit_mark</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>commit_oe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Mark :%"</literal> <name>PRIuMAX</name> <literal type="string">" not a commit"</literal></expr></argument>, <argument><expr><name>commit_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>commit_oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>get_oid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>read_object_with_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>,
<argument><expr><name>commit_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name>size</name> <operator>&lt;</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a valid commit: %s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid ref name or SHA1 expression: %s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inline_data</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_and_store_blob</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_blob</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oe</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a blob (actually a %s): %s"</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Blob not found: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a blob (actually a %s): %s"</literal></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>construct_path_with_fanout</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>old_fanout</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tree_content_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>new_fanout</name> <operator>=</operator> <call><name>convert_num_notes_to_fanout</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>construct_path_with_fanout</name><argument_list>(<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_fanout</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tree_content_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>S_IFREG</name> <operator>|</operator> <literal type="number">0644</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>file_change_deleteall</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_from_commit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name>size</name> <operator>&lt;</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a valid commit: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"tree "</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>get_oid_hex</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"The commit %s is corrupt"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_from_existing</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_with_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>commit_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_from_commit</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_objectish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objectish</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>objectish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't create a branch from itself: %s"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>objectish</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>idnum</name> <init>= <expr><call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>objectish</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>idnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Mark :%"</literal> <name>PRIuMAX</name> <literal type="string">" not a commit"</literal></expr></argument>, <argument><expr><name>idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>!=</operator> <name>MAX_PACK_ID</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>gfi_unpack_entry</name><argument_list>(<argument><expr><name>oe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>parse_from_commit</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_from_existing</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>get_oid</name><argument_list>(<argument><expr><name>objectish</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parse_from_existing</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>delete</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid ref name or SHA1 expression: %s"</literal></expr></argument>, <argument><expr><name>objectish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_from</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"from "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>parse_objectish</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_objectish_with_prefix</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>parse_objectish</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>hash_list</name></name> <modifier>*</modifier></type><name>parse_merge</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_list</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>list</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"merge "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>from</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>idnum</name> <init>= <expr><call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>idnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_COMMIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Mark :%"</literal> <name>PRIuMAX</name> <literal type="string">" not a commit"</literal></expr></argument>, <argument><expr><name>idnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>get_oid</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>read_object_with_reference</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
<argument><expr><name>commit_type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name>size</name> <operator>&lt;</operator> <name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a valid commit: %s"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid ref name or SHA1 expression: %s"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_new_commit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>msg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>author</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>committer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_list</name></name> <modifier>*</modifier></type><name>merge_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>merge_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>prev_fanout</name></decl>, <decl><type ref="prev"/><name>new_fanout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_branch</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_original_identifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"author "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>author</name> <operator>=</operator> <call><name>parse_ident</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"committer "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>committer</name> <operator>=</operator> <call><name>parse_ident</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>committer</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Expected committer but didn't get one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"encoding "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>parse_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_from</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_list</name> <operator>=</operator> <call><name>parse_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name> <operator>||</operator> <operator>!</operator><name>max_active_branches</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unload_one_branch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>load_branch</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev_fanout</name> <operator>=</operator> <call><name>convert_num_notes_to_fanout</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>command_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"M "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>file_change_m</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"D "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>file_change_d</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"R "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>file_change_cr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"C "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>file_change_cr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"N "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>note_change_n</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"deleteall"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>file_change_deleteall</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"ls "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_ls</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"cat-blob "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_cat_blob</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>unread_command_buf</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_next_command</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>new_fanout</name> <operator>=</operator> <call><name>convert_num_notes_to_fanout</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_fanout</name> <operator>!=</operator> <name>prev_fanout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_notes</name></name> <operator>=</operator> <call><name>change_note_fanout</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>, <argument><expr><name>new_fanout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>store_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><literal type="string">"tree %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><literal type="string">"parent %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>merge_list</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_list</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>merge_list</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><literal type="string">"parent %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>merge_list</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>merge_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>,
<argument><expr><literal type="string">"author %s\n"</literal>
<literal type="string">"committer %s\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>author</name></expr> ?</condition><then> <expr><name>author</name></expr> </then><else>: <expr><name>committer</name></expr></else></ternary></expr></argument>, <argument><expr><name>committer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>,
<argument><expr><literal type="string">"encoding %s\n"</literal></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>author</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>committer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>store_object</name><argument_list>(<argument><expr><name>OBJ_COMMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>next_mark</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>pack_id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>last_commit</name></name> <operator>=</operator> <name><name>object_count_by_type</name><index>[<expr><name>OBJ_COMMIT</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_new_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>msg</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tagger</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>from_mark</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>mem_pool_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pool_strdup</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>last_tag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>last_tag</name><operator>-&gt;</operator><name>next_tag</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>first_tag</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>last_tag</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"from "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Expected from command, got %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't tag an empty branch."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>OBJ_COMMIT</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl>;</decl_stmt>
<expr_stmt><expr><name>from_mark</name> <operator>=</operator> <call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>from_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>get_oid</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a valid object: %s"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid ref name or SHA1 expression: %s"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>parse_original_identifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"tagger "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tagger</name> <operator>=</operator> <call><name>parse_ident</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tagger</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>parse_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>,
<argument><expr><literal type="string">"object %s\n"</literal>
<literal type="string">"type %s\n"</literal>
<literal type="string">"tag %s\n"</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tagger</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>,
<argument><expr><literal type="string">"tagger %s\n"</literal></expr></argument>, <argument><expr><name>tagger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tagger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>store_object</name><argument_list>(<argument><expr><name>OBJ_TAG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>next_mark</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>pack_id</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_reset_branch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>lookup_branch</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidclr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_branch</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_from</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>delete</name></name> <operator>&amp;&amp;</operator> <call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"refs/tags/"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>









<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>t</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name>first_tag</name></expr>;</init> <condition><expr><name>t</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>tag_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next_tag</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>first_tag</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>next_tag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_tag</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>command_buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unread_command_buf</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cat_blob_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>write_in_full</name><argument_list>(<argument><expr><name>cat_blob_fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"Write to frontend failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cat_blob</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>line</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name> <operator>||</operator> <name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>MAX_PACK_ID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>gfi_unpack_entry</name><argument_list>(<argument><expr><name>oe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s missing\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't read object %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OBJ_BLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Object %s is a %s but a blob was expected."</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s %s %"</literal><name>PRIuMAX</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oe</name> <operator>&amp;&amp;</operator> <name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>==</operator> <name>pack_id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>last_blob</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_attach</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>last_blob</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>last_blob</name><operator>.</operator><name>depth</name></name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>depth</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_get_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>output</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a mark: %s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unknown mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>xsnprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_cat_blob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><call><name>parse_mark_ref_eol</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unknown mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>parse_mapped_oid_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid dataref: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after SHA1: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>cat_blob</name><argument_list>(<argument><expr><name>oe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>dereference</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>oe</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>hexsz</name> <init>= <expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oe</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name> <init>= <expr><call><name>oid_object_info</name><argument_list>(<argument><expr><name>the_repository</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"object not found: %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oe</name> <operator>=</operator> <call><name>insert_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>=</operator> <name>MAX_PACK_ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oe</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_TREE</name></expr>:</case> 
<return>return <expr><name>oe</name></expr>;</return>
<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>
<case>case <expr><name>OBJ_TAG</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not a tree-ish: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>pack_id</name></name> <operator>!=</operator> <name>MAX_PACK_ID</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>gfi_unpack_entry</name><argument_list>(<argument><expr><name>oe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>unused</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_object_file</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unused</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Can't load object %s"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<switch>switch <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_TAG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>hexsz</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"object "</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>get_oid_hex</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"object "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid SHA1 in tag: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>OBJ_COMMIT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>hexsz</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"tree "</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>get_oid_hex</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"tree "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid SHA1 in commit: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>find_object</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>insert_mapped_mark</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>mark</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cbp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>fromoid</name> <init>= <expr><name>object</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>tooid</name> <init>= <expr><call><name>find_mark</name><argument_list>(<argument><expr><name>cbp</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>khiter_t</name></type> <name>it</name></decl>;</decl_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>kh_put_oid_map</name><argument_list>(<argument><expr><name>sub_oid_map</name></expr></argument>, <argument><expr><operator>*</operator><name>fromoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>kh_value</name><argument_list>(<argument><expr><name>sub_oid_map</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tooid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>build_mark_map_one</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>for_each_mark</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>insert_mapped_mark</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>build_mark_map</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list_item</name></name> <modifier>*</modifier></type><name>fromp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>top</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sub_oid_map</name> <operator>=</operator> <call><name>kh_init_oid_map</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<macro><name>for_each_string_list_item</name><argument_list>(<argument>fromp</argument>, <argument>from</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>string_list_lookup</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>fromp</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fromp</name><operator>-&gt;</operator><name>util</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Missing from marks for submodule '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fromp</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>top</name> <operator>||</operator> <operator>!</operator><name><name>top</name><operator>-&gt;</operator><name>util</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Missing to marks for submodule '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fromp</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>build_mark_map_one</name><argument_list>(<argument><expr><name><name>fromp</name><operator>-&gt;</operator><name>util</name></name></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>util</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>parse_treeish_dataref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name></type> <name>oid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>find_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><call><name>parse_mark_ref_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unknown mark: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>parse_mapped_oid_hex</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid dataref: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>++</operator> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Missing space after tree-ish: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_TREE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>dereference</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_ls</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>line</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>=
<expr><ternary><condition><expr><call><name>S_ISGITLINK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>commit_type</name></expr> </then><else>:
<expr><ternary><condition><expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>tree_type</name></expr> </then><else>:
<expr><name>blob_type</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="string">"missing "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quote_c_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="string">"%06o %s %s\t"</literal></expr></argument>,
<argument><expr><name>mode</name> <operator>&amp;</operator> <operator>~</operator><name>NO_DELTA</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>hash_to_hex</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quote_c_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>cat_blob_write</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_ls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>branch</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tree_entry</name></name></type> <name>leaf</name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Not in a commit: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>root</name> <operator>=</operator> <operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>parse_treeish_dataref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>new_tree_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>idx</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_null_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>S_IFDIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>load_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>strbuf</name></name></type> <name>uq</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unquote_c_style</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uq</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Invalid path: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Garbage after path in: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>uq</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tree_content_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>store_tree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>print_ls</name><argument_list>(<argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mode</name></expr></argument>, <argument><expr><name><name>leaf</name><operator>.</operator><name>versions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>oid</name><operator>.</operator><name>hash</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>leaf</name><operator>.</operator><name>tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_content_recursive</name><argument_list>(<argument><expr><name><name>leaf</name><operator>.</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name> <operator>||</operator> <name>root</name> <operator>!=</operator> <operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>branch_tree</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>release_tree_entry</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>checkpoint_requested</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>object_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cycle_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dump_branches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_tags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_checkpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>checkpoint_requested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_optional_lf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_progress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>skip_optional_lf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_alias</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>branch</name></name></type> <name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>skip_optional_lf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>read_next_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>parse_mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next_mark</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected 'mark' command, got %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_objectish_with_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="string">"to "</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected 'to' command, got %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>find_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>insert_mark</name><argument_list>(<argument><expr><name>marks</name></expr></argument>, <argument><expr><name>next_mark</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>make_fast_import_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relative_marks_paths</name> <operator>||</operator> <call><name>is_absolute_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>git_pathdup</name><argument_list>(<argument><expr><literal type="string">"info/fast-import/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_import_marks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>marks</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>from_stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ignore_missing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>import_marks_file</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from_stream</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Only one import-marks command allowed per stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><name>import_marks_file_from_stream</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>import_marks_file</name> <operator>=</operator> <call><name>make_fast_import_path</name><argument_list>(<argument><expr><name>marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>import_marks_file_from_stream</name> <operator>=</operator> <name>from_stream</name></expr>;</expr_stmt>
<expr_stmt><expr><name>import_marks_file_ignore_missing</name> <operator>=</operator> <name>ignore_missing</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_date_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"raw"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>whenspec</name> <operator>=</operator> <name>WHENSPEC_RAW</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"rfc2822"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>whenspec</name> <operator>=</operator> <name>WHENSPEC_RFC2822</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="string">"now"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>whenspec</name> <operator>=</operator> <name>WHENSPEC_NOW</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unknown --date-format argument %s"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>ulong_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rv</name> <init>= <expr><call><name>strtoul</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>endptr</name> <operator>==</operator> <name>arg</name> <operator>||</operator> <operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s: argument must be a non-negative integer"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_depth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>max_depth</name> <operator>=</operator> <call><name>ulong_arg</name><argument_list>(<argument><expr><literal type="string">"--depth"</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&gt;</operator> <name>MAX_DEPTH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--depth cannot exceed %u"</literal></expr></argument>, <argument><expr><name>MAX_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_active_branches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>branches</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>max_active_branches</name> <operator>=</operator> <call><name>ulong_arg</name><argument_list>(<argument><expr><literal type="string">"--active-branches"</literal></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_export_marks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>marks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>export_marks_file</name> <operator>=</operator> <call><name>make_fast_import_path</name><argument_list>(<argument><expr><name>marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_cat_blob_fd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name> <init>= <expr><call><name>ulong_arg</name><argument_list>(<argument><expr><literal type="string">"--cat-blob-fd"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"--cat-blob-fd cannot exceed %d"</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cat_blob_fd</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_export_pack_edges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>edges</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pack_edges</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pack_edges</name> <operator>=</operator> <call><name>xfopen</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>option_rewrite_submodules</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>mark_set</name></name> <modifier>*</modifier></type><name>ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected format name:filename for submodule rewrite option"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ms</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_insert</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>util</name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><literal type="string">"cannot read '%s'"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>read_mark_file</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>insert_oid_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_one_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"max-pack-size="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_parse_ulong</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">8192</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"max-pack-size is now in bytes, assuming --max-pack-size=%lum"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>*=</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"minimum max-pack-size is 1 MiB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>max_packsize</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"big-file-threshold="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_parse_ulong</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>big_file_threshold</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"depth="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_depth</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"active-branches="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_active_branches</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"export-pack-edges="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_export_pack_edges</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"quiet"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>show_stats</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"stats"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>show_stats</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">"allow-unsafe-features"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_unsafe_feature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>feature</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from_stream</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allow_unsafe_features</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"feature '%s' forbidden in input without --allow-unsafe-features"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>feature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_one_feature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>feature</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"date-format="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_date_format</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"import-marks="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>check_unsafe_feature</name><argument_list>(<argument><expr><literal type="string">"import-marks"</literal></expr></argument>, <argument><expr><name>from_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>option_import_marks</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>from_stream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"import-marks-if-exists="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>check_unsafe_feature</name><argument_list>(<argument><expr><literal type="string">"import-marks-if-exists"</literal></expr></argument>, <argument><expr><name>from_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>option_import_marks</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>from_stream</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"export-marks="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>check_unsafe_feature</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><name>from_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>option_export_marks</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"alias"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"rewrite-submodules-to="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_rewrite_submodules</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_marks_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"rewrite-submodules-from="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_rewrite_submodules</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_marks_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"rewrite-submodules-from="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"get-mark"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"cat-blob"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"relative-marks"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>relative_marks_paths</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"no-relative-marks"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>relative_marks_paths</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"done"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>require_explicit_termination</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"force"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>force_update</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"notes"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="string">"ls"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_feature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>feature</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>seen_data_command</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Got feature command '%s' after data command"</literal></expr></argument>, <argument><expr><name>feature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_one_feature</name><argument_list>(<argument><expr><name>feature</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"This version of fast-import does not support feature %s."</literal></expr></argument>, <argument><expr><name>feature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>seen_data_command</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Got option command '%s' after data command"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_one_option</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"This version of fast-import does not support option: %s"</literal></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>git_pack_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>indexversion_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>packsizelimit_value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_ulong</name><argument_list>(<argument><expr><literal type="string">"pack.depth"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&gt;</operator> <name>MAX_DEPTH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_depth</name> <operator>=</operator> <name>MAX_DEPTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"pack.indexversion"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexversion_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>indexversion_value</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>git_die_config</name><argument_list>(<argument><expr><literal type="string">"pack.indexversion"</literal></expr></argument>,
<argument><expr><literal type="string">"bad pack.indexversion=%"</literal><name>PRIu32</name></expr></argument>, <argument><expr><name><name>pack_idx_opts</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_ulong</name><argument_list>(<argument><expr><literal type="string">"pack.packsizelimit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>packsizelimit_value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_packsize</name> <operator>=</operator> <name>packsizelimit_value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"fastimport.unpacklimit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unpack_limit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>git_config_get_int</name><argument_list>(<argument><expr><literal type="string">"transfer.unpacklimit"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unpack_limit</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_default_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>fast_import_usage</name><index>[]</index></name> <init>=
<expr><literal type="string">"git fast-import [--date-format=&lt;f&gt;] [--max-pack-size=&lt;n&gt;] [--big-file-threshold=&lt;n&gt;] [--depth=&lt;n&gt;] [--active-branches=&lt;n&gt;] [--export-marks=&lt;marks.file&gt;]"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_argv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>global_argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>global_argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>a</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>skip_prefix</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unknown option %s"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_one_option</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_one_feature</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"cat-blob-fd="</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>option_cat_blob_fd</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"unknown option --%s"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>global_argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>fast_import_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>seen_data_command</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>import_marks_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>build_mark_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub_marks_from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_marks_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmd_main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-h"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>fast_import_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>setup_git_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reset_pack_idx_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pack_idx_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>git_pack_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alloc_objects</name><argument_list>(<argument><expr><name>object_entry_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>command_buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>atom_table</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>atom_table_sz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>atom_str</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>branch_table</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>branch_table_sz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>branch</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_tree_table</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>avail_tree_table_sz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>avail_tree_content</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>marks</name> <operator>=</operator> <call><name>mem_pool_calloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>mark_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"--allow-unsafe-features"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>allow_unsafe_features</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>global_argc</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>global_argv</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rc_free</name> <operator>=</operator> <call><name>mem_pool_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fi_mem_pool</name></expr></argument>, <argument><expr><name>cmd_save</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>rc_free</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>cmd_save</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>rc_free</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>rc_free</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>rc_free</name><index>[<expr><name>cmd_save</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>start_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_die_routine</name><argument_list>(<argument><expr><name>die_nicely</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_checkpoint_signal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>read_next_command</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"blob"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_new_blob</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"commit "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_new_commit</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"tag "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_new_tag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"reset "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_reset_branch</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"ls "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_ls</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"cat-blob "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_cat_blob</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"get-mark "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_get_mark</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"checkpoint"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_checkpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"done"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"alias"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_alias</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"progress "</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_progress</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"feature "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_feature</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>skip_prefix</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"option git "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_option</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"option "</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Unsupported command: %s"</literal></expr></argument>, <argument><expr><name><name>command_buf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>checkpoint_requested</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>checkpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>seen_data_command</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_argv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>require_explicit_termination</name> <operator>&amp;&amp;</operator> <call><name>feof</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"stream ends early"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>end_packfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_branches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_tags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unkeep_all_packs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pack_edges</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pack_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_stats</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>total_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>duplicate_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>object_count_by_type</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>total_count</name> <operator>+=</operator> <name><name>object_count_by_type</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>duplicate_count_by_type</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>duplicate_count</name> <operator>+=</operator> <name><name>duplicate_count_by_type</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s statistics:\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Alloc'd objects: %10"</literal> <name>PRIuMAX</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>alloc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Total objects: %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" duplicates )\n"</literal></expr></argument>, <argument><expr><name>total_count</name></expr></argument>, <argument><expr><name>duplicate_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" blobs : %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" duplicates %10"</literal> <name>PRIuMAX</name> <literal type="string">" deltas of %10"</literal> <name>PRIuMAX</name><literal type="string">" attempts)\n"</literal></expr></argument>, <argument><expr><name><name>object_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_attempts_by_type</name><index>[<expr><name>OBJ_BLOB</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" trees : %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" duplicates %10"</literal> <name>PRIuMAX</name> <literal type="string">" deltas of %10"</literal> <name>PRIuMAX</name><literal type="string">" attempts)\n"</literal></expr></argument>, <argument><expr><name><name>object_count_by_type</name><index>[<expr><name>OBJ_TREE</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_TREE</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_by_type</name><index>[<expr><name>OBJ_TREE</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_attempts_by_type</name><index>[<expr><name>OBJ_TREE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" commits: %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" duplicates %10"</literal> <name>PRIuMAX</name> <literal type="string">" deltas of %10"</literal> <name>PRIuMAX</name><literal type="string">" attempts)\n"</literal></expr></argument>, <argument><expr><name><name>object_count_by_type</name><index>[<expr><name>OBJ_COMMIT</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_COMMIT</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_by_type</name><index>[<expr><name>OBJ_COMMIT</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_attempts_by_type</name><index>[<expr><name>OBJ_COMMIT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" tags : %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" duplicates %10"</literal> <name>PRIuMAX</name> <literal type="string">" deltas of %10"</literal> <name>PRIuMAX</name><literal type="string">" attempts)\n"</literal></expr></argument>, <argument><expr><name><name>object_count_by_type</name><index>[<expr><name>OBJ_TAG</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>duplicate_count_by_type</name><index>[<expr><name>OBJ_TAG</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_by_type</name><index>[<expr><name>OBJ_TAG</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta_count_attempts_by_type</name><index>[<expr><name>OBJ_TAG</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Total branches: %10lu (%10lu loads )\n"</literal></expr></argument>, <argument><expr><name>branch_count</name></expr></argument>, <argument><expr><name>branch_load_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" marks: %10"</literal> <name>PRIuMAX</name> <literal type="string">" (%10"</literal> <name>PRIuMAX</name> <literal type="string">" unique )\n"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uintmax_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>marks</name><operator>-&gt;</operator><name>shift</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1024</literal></expr></argument>, <argument><expr><name>marks_set_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" atoms: %10u\n"</literal></expr></argument>, <argument><expr><name>atom_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Memory total: %10"</literal> <name>PRIuMAX</name> <literal type="string">" KiB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>tree_entry_allocd</name> <operator>+</operator> <name><name>fi_mem_pool</name><operator>.</operator><name>pool_alloc</name></name> <operator>+</operator> <name>alloc_count</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_entry</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>/</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" pools: %10lu KiB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>(</operator><name>tree_entry_allocd</name> <operator>+</operator> <name><name>fi_mem_pool</name><operator>.</operator><name>pool_alloc</name></name><operator>)</operator> <operator>/</operator><literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" objects: %10"</literal> <name>PRIuMAX</name> <literal type="string">" KiB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>alloc_count</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>object_entry</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>/</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_report</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>failure</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
