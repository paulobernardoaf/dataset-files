<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\bisect.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revision.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"refs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list-objects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-lookup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"run-command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log-tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bisect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sha1-array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"argv-array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-slab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commit-reach.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object-store.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>oid_array</name></name></type> <name>good_revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>oid_array</name></name></type> <name>skipped_revs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>current_bad_oid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv_checkout</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"checkout"</literal></expr>, <expr><literal type="string">"-q"</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"--"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv_show_branch</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"show-branch"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>term_bad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>term_good</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COUNTED</name></cpp:macro> <cpp:value>(1u&lt;&lt;16)</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <name>int</name></type> <name>count_distance</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>UNINTERESTING</name> <operator>|</operator> <name>COUNTED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>COUNTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nr</name> <operator>+=</operator> <call><name>count_distance</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<return>return <expr><name>nr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_distance</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>COUNTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<expr_stmt><expr><call><name>define_commit_slab</name><argument_list>(<argument><expr><name>commit_weight</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>commit_weight</name></name></type> <name>commit_weight</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_BISECT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>weight</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>*</operator><operator>*</operator><call><name>commit_weight_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>weight_set</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>elem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>*</operator><call><name>commit_weight_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>count_interesting_parents</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>halfway</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>TREESAME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>DEBUG_BISECT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<switch>switch <condition>(<expr><literal type="number">2</literal> <operator>*</operator> <call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debug</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>counted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DEBUG_BISECT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s (%d/%d)\n"</literal></expr></argument>, <argument><expr><name>debug</name></expr></argument>, <argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>object_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>read_object_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subject_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>subject_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c%c%c "</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'T'</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UNINTERESTING</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'U'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>COUNTED</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'C'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>commit_weight_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%3d"</literal></expr></argument>, <argument><expr><call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"---"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <name><name>commit</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>pp</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <name><name>pp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pp</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>subject_len</name> <operator>=</operator> <call><name>find_commit_subject</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subject_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subject_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %.*s"</literal></expr></argument>, <argument><expr><name>subject_len</name></expr></argument>, <argument><expr><name>subject_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>best_bisection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>best</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>best_distance</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>best</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nr</name> <operator>-</operator> <name>distance</name> <operator>&lt;</operator> <name>distance</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>distance</name> <operator>=</operator> <name>nr</name> <operator>-</operator> <name>distance</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&gt;</operator> <name>best_distance</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_distance</name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>best</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>commit_dist</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_commit_dist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_dist</name></name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator>struct <name>commit_dist</name> <operator>*</operator><operator>)</operator><name>a_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator>struct <name>commit_dist</name> <operator>*</operator><operator>)</operator><name>b_</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>distance</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>b</name><operator>-&gt;</operator><name>distance</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>distance</name></name></expr>;</return></block_content></block></if></if_stmt> 
<return>return <expr><call><name>oidcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>best_bisection_sorted</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_dist</name></name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><name>nr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>array</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>buf</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr><operator>,</operator> <expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>distance</name> <operator>=</operator> <call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nr</name> <operator>-</operator> <name>distance</name> <operator>&lt;</operator> <name>distance</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>distance</name> <operator>=</operator> <name>nr</name> <operator>-</operator> <name>distance</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>.</operator><name>commit</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>.</operator><name>distance</name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>QSORT</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>compare_commit_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>object</name></name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>commit</name><operator>-&gt;</operator><name>object</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strbuf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dist=%d"</literal></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_name_decoration</name><argument_list>(<argument><expr><name>DECORATION_NONE</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commit</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>do_find_bisection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>weights</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>find_all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>counted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>counted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>commit</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><call><name>commit_weight_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>&amp;</operator><name><name>weights</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>count_interesting_parents</name><argument_list>(<argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>counted</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 count one"</literal></expr></argument>,
<argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 initialize"</literal></expr></argument>, <argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>















<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>count_distance</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_distance</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_all</name> <operator>&amp;&amp;</operator> <call><name>halfway</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>counted</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 count_distance"</literal></expr></argument>, <argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>counted</name> <operator>&lt;</operator> <name>nr</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>weight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>parents</name></name></expr>;</init> <condition><expr><name>q</name></expr>;</condition> <incr><expr><name>q</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>weight</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>weight</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>counted</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 count one"</literal></expr></argument>,
<argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>weight_set</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>weight</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_all</name> <operator>&amp;&amp;</operator> <call><name>halfway</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></while>

<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 counted all"</literal></expr></argument>, <argument><expr><name>counted</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_all</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>best_bisection</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>best_bisection_sorted</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>find_bisection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>commit_list</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>reaches</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>all</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>find_all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>, <decl><type ref="prev"/><name>on_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>best</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>weights</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 entry"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>commit_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_commit_weight</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>nr</name> <operator>=</operator> <name>on_list</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>last</name> <operator>=</operator> <name>NULL</name></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <operator>*</operator><name>commit_list</name></expr>;</init>
<condition><expr><name>p</name></expr>;</condition>
<incr><expr><name>p</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>UNINTERESTING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TREESAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>on_list</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_list</name><argument_list>(<argument><expr><literal type="string">"bisection 2 sorted"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>all</name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>weights</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>on_list</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>weights</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>best</name> <operator>=</operator> <call><name>do_find_bisection</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>weights</name></expr></argument>, <argument><expr><name>find_all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>best</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_all</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <name><name>best</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>best</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>reaches</name> <operator>=</operator> <call><name>weight</name><argument_list>(<argument><expr><name>best</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>weights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>commit_list</name> <operator>=</operator> <name>best</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_commit_weight</name><argument_list>(<argument><expr><operator>&amp;</operator><name>commit_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>register_ref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>good_prefix</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_prefix</name></expr></argument>, <argument><expr><name>term_good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_prefix</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>current_bad_oid</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>current_bad_oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>oidcpy</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>good_prefix</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_revs</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>starts_with</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="string">"skip-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>oid_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skipped_revs</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_bisect_refs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>for_each_ref_in</name><argument_list>(<argument><expr><literal type="string">"refs/bisect/"</literal></expr></argument>, <argument><expr><name>register_ref</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_names</argument>, <argument><literal type="string">"BISECT_NAMES"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_expected_rev</argument>, <argument><literal type="string">"BISECT_EXPECTED_REV"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_ancestors_ok</argument>, <argument><literal type="string">"BISECT_ANCESTORS_OK"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_run</argument>, <argument><literal type="string">"BISECT_RUN"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_start</argument>, <argument><literal type="string">"BISECT_START"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_log</argument>, <argument><literal type="string">"BISECT_LOG"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_bisect_terms</argument>, <argument><literal type="string">"BISECT_TERMS"</literal></argument>)</argument_list></macro>
<specifier>static</specifier> <macro><name>GIT_PATH_FUNC</name><argument_list>(<argument>git_path_head_name</argument>, <argument><literal type="string">"head-name"</literal></argument>)</argument_list></macro>

<specifier>static</specifier> <name>void</name> <macro><name>read_bisect_paths</name><argument_list>(<argument>struct argv_array *array</argument>)</argument_list></macro>
<block>{
struct <expr><name>strbuf</name> <name>str</name> <operator>=</operator> <name>STRBUF_INIT</name></expr>;
<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>filename</name> <operator>=</operator> <call><name>git_path_bisect_names</name><argument_list>()</argument_list></call></expr>;
<expr><name>FILE</name> <operator>*</operator><name>fp</name> <operator>=</operator> <call><name>xfopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;

<while>while <condition>(<expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_trim</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sq_dequote_to_argv_array</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Badly quoted content in file '%s': %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></while>}</block>

<call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

static <function><type><name>char</name> <modifier>*</modifier></type><name>join_sha1_array_hex</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>oid_array</name></name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>joined_hexs</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_addstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>joined_hexs</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>oid</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strbuf_addch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>joined_hexs</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>joined_hexs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>filter_skipped</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tried</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>show_all</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>skipped_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>filtered</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>f</name> <init>= <expr><operator>&amp;</operator><name>filtered</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>tried</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skipped_first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>skipped_first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>skipped_revs</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>oid_array_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skipped_revs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>skipped_first</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>skipped_first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>skipped_first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>tried</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tried</name> <operator>=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_all</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipped_first</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>skipped_first</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>skipped_first</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>skipped_first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>skipped_first</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>skipped_first</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>skipped_first</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>skipped_first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>filtered</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRN_MODULO</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>







<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>get_prn</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name>count</name> <operator>*</operator> <literal type="number">1103515245</literal> <operator>+</operator> <literal type="number">12345</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>count</name><operator>/</operator><literal type="number">65536</literal><operator>)</operator> <operator>%</operator> <name>PRN_MODULO</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>sqrti</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>d</name></decl>, <decl><type ref="prev"/><name>x</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><name>x</name> <operator>+</operator> <operator>(</operator><name>float</name><operator>)</operator><name>val</name> <operator>/</operator> <name>x</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>y</name> <operator>&gt;</operator> <name>x</name><operator>)</operator></expr> ?</condition><then> <expr><name>y</name> <operator>-</operator> <name>x</name></expr> </then><else>: <expr><name>x</name> <operator>-</operator> <name>y</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>d</name> <operator>&gt;=</operator> <literal type="number">0.5</literal></expr>)</condition>;</do>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>skip_away</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>cur</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prn</name></decl>, <decl><type ref="prev"/><name>index</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prn</name> <operator>=</operator> <call><name>get_prn</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>count</name> <operator>*</operator> <name>prn</name> <operator>/</operator> <name>PRN_MODULO</name><operator>)</operator> <operator>*</operator> <call><name>sqrti</name><argument_list>(<argument><expr><name>prn</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>sqrti</name><argument_list>(<argument><expr><name>PRN_MODULO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>previous</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cur</name></expr>;</condition> <incr><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>index</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>oideq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cur</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>previous</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>previous</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>previous</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>managed_skipped</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tried</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>skipped_first</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>tried</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>skipped_revs</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>filter_skipped</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>skipped_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipped_first</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>skip_away</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>bisect_rev_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bad_format</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>good_format</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>read_paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>argv_array</name></name></type> <name>rev_argv</name> <init>= <expr><name>ARGV_ARRAY_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>revs</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>-&gt;</operator><name>abbrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>-&gt;</operator><name>commit_format</name></name> <operator>=</operator> <name>CMIT_FMT_UNSPECIFIED</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_argv</name></expr></argument>, <argument><expr><literal type="string">"bisect_rev_setup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_argv</name></expr></argument>, <argument><expr><name>bad_format</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>good_revs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>argv_array_pushf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_argv</name></expr></argument>, <argument><expr><name>good_format</name></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name><name>good_revs</name><operator>.</operator><name>oid</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>argv_array_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_argv</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>read_paths</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>read_bisect_paths</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rev_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>setup_revisions</name><argument_list>(<argument><expr><name><name>rev_argv</name><operator>.</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>rev_argv</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>bisect_common</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rev_info</name></name> <modifier>*</modifier></type><name>revs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>prepare_revision_walk</name><argument_list>(<argument><expr><name>revs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"revision walk setup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>revs</name><operator>-&gt;</operator><name>tree_objects</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mark_edges_uninteresting</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>bisect_error</name></name></type> <name>error_if_skipped_commits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>tried</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>bad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tried</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>BISECT_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"There are only 'skip'ped commits left to test.\n"</literal>
<literal type="string">"The first %s commit could be any of:\n"</literal></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>tried</name></expr>;</condition> <incr><expr><name>tried</name> <operator>=</operator> <name><name>tried</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tried</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>bad</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>bad</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"We cannot bisect more!\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>BISECT_ONLY_SKIPPED_LEFT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_expected_rev</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>git_path_bisect_expected_rev</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>str</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen_or_warn</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>bisect_error</name></name></type> <name>bisect_checkout</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>bisect_rev</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_checkout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>bisect_rev_hex</name><index>[<expr><name>GIT_MAX_HEXSZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>bisect_error</name></name></type> <name>res</name> <init>= <expr><name>BISECT_OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bisect_rev_hex</name></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>bisect_rev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>the_hash_algo</name><operator>-&gt;</operator><name>hexsz</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BISECT_EXPECTED_REV"</literal></expr></argument>, <argument><expr><name>bisect_rev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>UPDATE_REFS_DIE_ON_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv_checkout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>bisect_rev_hex</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>no_checkout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>update_ref</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BISECT_HEAD"</literal></expr></argument>, <argument><expr><name>bisect_rev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>UPDATE_REFS_DIE_ON_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>run_command_v_opt</name><argument_list>(<argument><expr><name>argv_checkout</name></expr></argument>, <argument><expr><name>RUN_GIT_CMD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>





<return>return <expr><operator>-</operator><call><name>abs</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>argv_show_branch</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>bisect_rev_hex</name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>run_command_v_opt</name><argument_list>(<argument><expr><name>argv_show_branch</name></expr></argument>, <argument><expr><name>RUN_GIT_CMD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<return>return <expr><operator>-</operator><call><name>abs</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>get_commit_reference</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lookup_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Not a valid commit name %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>get_bad_and_good_commits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rev_nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ALLOC_ARRAY</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>good_revs</name><operator>.</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>get_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>good_revs</name><operator>.</operator><name>nr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>rev</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>get_commit_reference</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>good_revs</name><operator>.</operator><name>oid</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>*</operator><name>rev_nr</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<return>return <expr><name>rev</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>bisect_error</name></name></type> <name>handle_bad_merge_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_expected_rev</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bad_hex</name> <init>= <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>good_hex</name> <init>= <expr><call><name>join_sha1_array_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_revs</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term_bad</name></expr></argument>, <argument><expr><literal type="string">"bad"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term_good</name></expr></argument>, <argument><expr><literal type="string">"good"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The merge base %s is bad.\n"</literal>
<literal type="string">"This means the bug has been fixed "</literal>
<literal type="string">"between %s and [%s].\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>good_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term_bad</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term_good</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The merge base %s is new.\n"</literal>
<literal type="string">"The property has changed "</literal>
<literal type="string">"between %s and [%s].\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>good_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The merge base %s is %s.\n"</literal>
<literal type="string">"This means the first '%s' commit is "</literal>
<literal type="string">"between %s and [%s].\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>, <argument><expr><name>term_good</name></expr></argument>, <argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>good_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>BISECT_MERGE_BASE_CHECK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Some %s revs are not ancestors of the %s rev.\n"</literal>
<literal type="string">"git bisect cannot work properly in this case.\n"</literal>
<literal type="string">"Maybe you mistook %s and %s revs?\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>term_good</name></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>, <argument><expr><name>term_good</name></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>BISECT_FAILED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_skipped_merge_base</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>mb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mb_hex</name> <init>= <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bad_hex</name> <init>= <expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>good_hex</name> <init>= <expr><call><name>join_sha1_array_hex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_revs</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"the merge base between %s and [%s] "</literal>
<literal type="string">"must be skipped.\n"</literal>
<literal type="string">"So we cannot be sure the first %s commit is "</literal>
<literal type="string">"between %s and %s.\n"</literal>
<literal type="string">"We continue anyway."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>bad_hex</name></expr></argument>, <argument><expr><name>good_hex</name></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>, <argument><expr><name>mb_hex</name></expr></argument>, <argument><expr><name>bad_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>good_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name><name>enum</name> <name>bisect_error</name></name></type> <name>check_merge_bases</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rev_nr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rev</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_checkout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>bisect_error</name></name></type> <name>res</name> <init>= <expr><name>BISECT_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_merge_bases_many</name><argument_list>(<argument><expr><name><name>rev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rev_nr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>rev</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>result</name></expr>;</condition> <incr><expr><name>result</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>mb</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><name>mb</name></expr></argument>, <argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_bad_merge_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>oid_array_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>good_revs</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>oid_array_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skipped_revs</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>handle_skipped_merge_base</name><argument_list>(<argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Bisecting: a merge base must be tested\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bisect_checkout</name><argument_list>(<argument><expr><name>mb</name></expr></argument>, <argument><expr><name>no_checkout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>BISECT_INTERNAL_SUCCESS_MERGE_BASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free_commit_list</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_ancestors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev_nr</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rev</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bisect_rev_setup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bisect_common</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name><name>revs</name><operator>.</operator><name>commits</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>clear_commit_marks_many</name><argument_list>(<argument><expr><name>rev_nr</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>ALL_REV_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>enum</name> <name>bisect_error</name></name></type> <name>check_good_are_ancestors_of_bad</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>no_checkout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>rev_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>bisect_error</name></name></type> <name>res</name> <init>= <expr><name>BISECT_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_bad_oid</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"a %s revision is needed"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>git_pathdup</name><argument_list>(<argument><expr><literal type="string">"BISECT_ANCESTORS_OK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>good_revs</name><operator>.</operator><name>nr</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>



<expr_stmt><expr><name>rev</name> <operator>=</operator> <call><name>get_bad_and_good_commits</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rev_nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_ancestors</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rev_nr</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>check_merge_bases</name><argument_list>(<argument><expr><name>rev_nr</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>no_checkout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>







<expr_stmt><expr><call><name>warning_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not create file '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>show_diff_tree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>commit</name></name> <modifier>*</modifier></type><name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"diff-tree"</literal></expr>, <expr><literal type="string">"--pretty"</literal></expr>, <expr><literal type="string">"--stat"</literal></expr>, <expr><literal type="string">"--summary"</literal></expr>, <expr><literal type="string">"--cc"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>opt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>git_config</name><argument_list>(<argument><expr><name>git_diff_ui_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repo_init_revisions</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setup_revisions</name><argument_list>(<argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>log_tree_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>read_bisect_terms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>read_bad</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>read_good</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>strbuf</name></name></type> <name>str</name> <init>= <expr><name>STRBUF_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>git_path_bisect_terms</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>read_bad</name> <operator>=</operator> <literal type="string">"bad"</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>read_good</name> <operator>=</operator> <literal type="string">"good"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>die_errno</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not read file '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>read_bad</name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strbuf_getline_lf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>read_good</name> <operator>=</operator> <call><name>strbuf_detach</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>strbuf_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name><name>enum</name> <name>bisect_error</name></name></type> <name>bisect_next_all</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>repository</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_checkout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rev_info</name></name></type> <name>revs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>commit_list</name></name> <modifier>*</modifier></type><name>tried</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reaches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>all</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nr</name></decl>, <decl><type ref="prev"/><name>steps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>bisect_error</name></name></type> <name>res</name> <init>= <expr><name>BISECT_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>bisect_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>steps_msg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>read_bisect_terms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>term_bad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>term_good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_bisect_refs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"reading bisect refs failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>check_good_are_ancestors_of_bad</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>no_checkout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bisect_rev_setup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>limited</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bisect_common</name><argument_list>(<argument><expr><operator>&amp;</operator><name>revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_bisection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>revs</name><operator>.</operator><name>commits</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reaches</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all</name></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name><name>skipped_revs</name><operator>.</operator><name>nr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revs</name><operator>.</operator><name>commits</name></name> <operator>=</operator> <call><name>managed_skipped</name><argument_list>(<argument><expr><name><name>revs</name><operator>.</operator><name>commits</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tried</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>revs</name><operator>.</operator><name>commits</name></name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>error_if_skipped_commits</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s was both %s and %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>term_good</name></expr></argument>,
<argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>BISECT_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No testable commit found.\n"</literal>
<literal type="string">"Maybe you started with bad path parameters?\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>BISECT_NO_TESTABLE_COMMIT</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bisect_rev</name> <operator>=</operator> <operator>&amp;</operator><name><name>revs</name><operator>.</operator><name>commits</name><operator>-&gt;</operator><name>item</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>oideq</name><argument_list>(<argument><expr><name>bisect_rev</name></expr></argument>, <argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>error_if_skipped_commits</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>current_bad_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s is the first %s commit\n"</literal></expr></argument>, <argument><expr><call><name>oid_to_hex</name><argument_list>(<argument><expr><name>bisect_rev</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>term_bad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>show_diff_tree</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>revs</name><operator>.</operator><name>commits</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<return>return <expr><name>BISECT_INTERNAL_SUCCESS_1ST_BAD_FOUND</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>all</name> <operator>-</operator> <name>reaches</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>steps</name> <operator>=</operator> <call><name>estimate_bisect_steps</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>steps_msg</name> <operator>=</operator> <call><name>xstrfmt</name><argument_list>(<argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"(roughly %d step)"</literal></expr></argument>, <argument><expr><literal type="string">"(roughly %d steps)"</literal></expr></argument>,
<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>Q_</name><argument_list>(<argument><expr><literal type="string">"Bisecting: %d revision left to test after this %s\n"</literal></expr></argument>,
<argument><expr><literal type="string">"Bisecting: %d revisions left to test after this %s\n"</literal></expr></argument>,
<argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>steps_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>steps_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bisect_checkout</name><argument_list>(<argument><expr><name>bisect_rev</name></expr></argument>, <argument><expr><name>no_checkout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>log2i</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>log2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>log2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>log2</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>exp2i</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>estimate_bisect_steps</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>all</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>log2i</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>exp2i</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>all</name> <operator>-</operator> <name>e</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>e</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>*</operator> <name>x</name><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mark_for_removal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>object_id</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><name>cb_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>xstrfmt</name><argument_list>(<argument><expr><literal type="string">"refs/bisect%s"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>bisect_clean_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>string_list</name></name></type> <name>refs_for_removal</name> <init>= <expr><name>STRING_LIST_INIT_NODUP</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>for_each_ref_in</name><argument_list>(<argument><expr><literal type="string">"refs/bisect"</literal></expr></argument>, <argument><expr><name>mark_for_removal</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>refs_for_removal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refs_for_removal</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><literal type="string">"BISECT_HEAD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>delete_refs</name><argument_list>(<argument><expr><literal type="string">"bisect: remove"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>refs_for_removal</name></expr></argument>, <argument><expr><name>REF_NO_DEREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>refs_for_removal</name><operator>.</operator><name>strdup_strings</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>string_list_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refs_for_removal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_expected_rev</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_ancestors_ok</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_log</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_names</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_run</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_terms</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_head_name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>unlink_or_warn</name><argument_list>(<argument><expr><call><name>git_path_bisect_start</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
