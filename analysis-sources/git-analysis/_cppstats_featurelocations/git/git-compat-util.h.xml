<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\git-analysis\_cppstats_featurelocations\git\git-compat-util.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GIT_COMPAT_UTIL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_COMPAT_UTIL_H</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_MSVC_CRTDBG</name></expr></argument>)</argument_list></call></expr></cpp:if>




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crtdbg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_FILE_OFFSET_BITS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>










<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC_MINOR__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_GNUC_PREREQ</name><parameter_list>(<parameter><type><name>maj</name></type></parameter>, <parameter><type><name>min</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((__GNUC__ &lt;&lt; 16) + __GNUC_MINOR__ &gt;= ((maj) &lt;&lt; 16) + (min))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_GNUC_PREREQ</name><parameter_list>(<parameter><type><name>maj</name></type></parameter>, <parameter><type><name>min</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FLEX_ARRAY</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__SUNPRO_C</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>__SUNPRO_C</name> <operator>&gt;</operator> <literal type="number">0x580</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ARRAY</name></cpp:macro></cpp:define> 
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">3</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ARRAY</name></cpp:macro></cpp:define> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ARRAY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FLEX_ARRAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ARRAY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILD_ASSERT_OR_ZERO</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(char [1 - 2*!(cond)]) - 1)</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>GIT_GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARF_UNLESS_AN_ARRAY</name><parameter_list>(<parameter><type><name>arr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), __typeof__(&amp;(arr)[0])))</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARF_UNLESS_AN_ARRAY</name><parameter_list>(<parameter><type><name>arr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_SIZE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bitsizeof</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(CHAR_BIT * sizeof(x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>maximum_signed_value_of_type</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(INTMAX_MAX &gt;&gt; (bitsizeof(intmax_t) - bitsizeof(a)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>maximum_unsigned_value_of_type</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(UINTMAX_MAX &gt;&gt; (bitsizeof(uintmax_t) - bitsizeof(a)))</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>signed_add_overflows</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b) &gt; maximum_signed_value_of_type(a) - (a))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unsigned_add_overflows</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b) &gt; maximum_unsigned_value_of_type(a) - (a))</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unsigned_mult_overflows</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &amp;&amp; (b) &gt; maximum_unsigned_value_of_type(a) / (a))</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPEOF</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__typeof__(x))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPEOF</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>bits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; TYPEOF(x)(~0ULL &lt;&lt; (bitsizeof(x) - (bits))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_MULTI_BITS</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((i) &amp; ((i) - 1))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIV_ROUND_UP</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n) + (d) - 1) / (d))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>decimal_length</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)(sizeof(x) * 2.56 + 0.5) + 1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun__</name></expr></argument>)</argument_list></call></expr></cpp:if>







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>-</operator> <literal type="number">0</literal> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>500</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__USLC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_UNIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__DragonFly__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__TANDEM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__QNX__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MirBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE_EXTENDED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ALL_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BSD_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_NETBSD_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SGI_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WINNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_WINNT</name></cpp:macro> <cpp:value>0x0600</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_WINDOWS_NATIVE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRINGS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEEDS_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;regex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BSD_SYSCTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/win32/path-utils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/win32/path-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/mingw.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/win32/path-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/msvc.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_SYS_SELECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/un.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_INTTYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_INTPTR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>







<typedef>typedef <type><name>long</name></type> <name>intptr_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>uintptr_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_ALL_SOURCE</name></cpp:undef> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ALL_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PRECOMPOSE_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/precompose_utf8.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>precompose_str</name><parameter_list>(<parameter><type><name>in</name></type></parameter>,<parameter><type><name>i_nfd2nfc</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>precompose_argv</name><parameter_list>(<parameter><type><name>c</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>probe_utf8_pathname_composition</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MKDIR_WO_TRAILING_SLASH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mkdir</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>compat_mkdir_wo_trailing_slash((a),(b))</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>compat_mkdir_wo_trailing_slash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>mode_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_STRUCT_ITIMERVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>itimerval</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>it_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>it_value</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SETITIMER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setitimer</name><parameter_list>(<parameter><type><name>which</name></type></parameter>,<parameter><type><name>value</name></type></parameter>,<parameter><type><name>ovalue</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_LIBGEN_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>basename</name></cpp:macro> <cpp:value>gitbasename</cpp:value></cpp:define>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>gitbasename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirname</name></cpp:macro> <cpp:value>gitdirname</cpp:value></cpp:define>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>gitdirname</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_ICONV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iconv.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__AVAILABILITY_MACROS_USES_AVAILABILITY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;AvailabilityMacros.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEPRECATED_ATTRIBUTE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPRECATED_ATTRIBUTE</name></cpp:macro></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>__AVAILABILITY_MACROS_USES_AVAILABILITY</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXHOST</name></cpp:macro> <cpp:value>1025</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXSERV</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>uintmax_t</name></type> <name>timestamp_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRItime</name></cpp:macro> <cpp:value>PRIuMAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>parse_timestamp</name></cpp:macro> <cpp:value>strtoumax</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_MAX</name></cpp:macro> <cpp:value>UINTMAX_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_MIN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PATH_SEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_SEP</name></cpp:macro> <cpp:value>':'</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;paths.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_PATH_DEFPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PATH_DEFPATH</name></cpp:macro> <cpp:value>"/usr/local/bin:/usr/bin:/bin"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>platform_core_config</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>noop_core_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>platform_core_config</name></cpp:macro> <cpp:value>noop_core_config</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>has_dos_drive_prefix</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>git_has_dos_drive_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_dos_drive_prefix</name></cpp:macro> <cpp:value>git_has_dos_drive_prefix</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>skip_dos_drive_prefix</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>git_skip_dos_drive_prefix</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skip_dos_drive_prefix</name></cpp:macro> <cpp:value>git_skip_dos_drive_prefix</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>is_dir_sep</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>git_is_dir_sep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_dir_sep</name></cpp:macro> <cpp:value>git_is_dir_sep</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>offset_1st_component</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>git_offset_1st_component</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>is_dir_sep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>offset_1st_component</name></cpp:macro> <cpp:value>git_offset_1st_component</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>is_valid_path</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_valid_path</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>find_last_dir_sep</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>git_find_last_dir_sep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>find_last_dir_sep</name></cpp:macro> <cpp:value>git_find_last_dir_sep</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>query_user_email</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>query_user_email</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>NULL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__TANDEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;floss.h(floss_execl,floss_execlp,floss_execv,floss_execvp)&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;floss.h(floss_getpwuid)&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSIG</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__HP_cc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__HP_cc</name> <operator>&gt;=</operator> <literal type="number">61000</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro> <cpp:value>__attribute__((noreturn))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN_PTR</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_NORETURN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro> <cpp:value>__attribute__((__noreturn__))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN_PTR</name></cpp:macro> <cpp:value>__attribute__((__noreturn__))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro> <cpp:value>__declspec(noreturn)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN_PTR</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN_PTR</name></cpp:macro></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__attribute__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__attribute__</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_ARG_MUST_BE_NULL</name></cpp:macro> <cpp:value>__attribute__((sentinel))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_ARG_MUST_BE_NULL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAYBE_UNUSED</name></cpp:macro> <cpp:value>__attribute__((__unused__))</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/bswap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wildmatch.h"</cpp:file></cpp:include>

<struct_decl>struct <name>strbuf</name>;</struct_decl>


<function_decl><type><name>void</name></type> <name>vreportf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NORETURN</name> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NORETURN</name> <name>void</name></type> <name>usagef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>NORETURN</name> <name>void</name></type> <name>die</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>NORETURN</name> <name>void</name></type> <name>die_errno</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>int</name></type> <name>error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>int</name></type> <name>error_errno</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>warning_errno</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>1<operator>,</operator> 2</function_decl>)))<empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>APPLE_COMMON_CRYPTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/apple-common-crypto.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/evp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/hmac.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/x509v3.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>const_error</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>error</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(error(__VA_ARGS__), const_error())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>error_errno</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(error_errno(__VA_ARGS__), const_error())</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>void</name></type> <name>set_die_routine</name><argument_list>(<argument><expr><name>NORETURN_PTR</name> <macro><name>void</name> <argument_list>(<argument>*routine</argument>)</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><name>err</name><operator>,</operator> <name>va_list</name> <name>params</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>set_error_routine</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>routine</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<extern>extern void (*get_error_routine(void</extern>))<expr_stmt><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><name>err</name><operator>,</operator> <name>va_list</name> <name>params</name><operator>)</operator></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>set_warn_routine</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>routine</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>warn</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>params</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<extern>extern void (*get_warn_routine(void</extern>))<expr_stmt><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><name>warn</name><operator>,</operator> <name>va_list</name> <name>params</name><operator>)</operator></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>set_die_is_recursing_routine</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>routine</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>starts_with</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>istarts_with</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>

















<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>skip_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>prefix</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator> <operator>==</operator> <operator>*</operator><name>prefix</name><operator>++</operator></expr>)</condition>;</do>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>















<function_decl><type><name>int</name></type> <name>skip_to_optional_arg_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>skip_to_optional_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>skip_to_optional_arg_default</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>skip_prefix_mem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>outlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>prefix_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>&lt;=</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>prefix_len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>outlen</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>prefix_len</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strip_suffix_mem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>suflen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>len</name> <operator>&lt;</operator> <name>suflen</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>len</name> <operator>-</operator> <name>suflen</name><operator>)</operator></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>suflen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>-=</operator> <name>suflen</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strip_suffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strip_suffix_mem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ends_with</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<return>return <expr><call><name>strip_suffix</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { void *_swap_a_ptr = &amp;(a); void *_swap_b_ptr = &amp;(b); unsigned char _swap_buffer[sizeof(a)]; memcpy(_swap_buffer, _swap_a_ptr, sizeof(a)); memcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) + BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b))); memcpy(_swap_b_ptr, _swap_buffer, sizeof(a)); } while (0)</cpp:value></cpp:define>









<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_MMAP</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_WIN32_MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROT_READ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROT_READ</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROT_WRITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_PRIVATE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap</name></cpp:macro> <cpp:value>git_mmap</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>munmap</name></cpp:macro> <cpp:value>git_munmap</cpp:value></cpp:define>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>git_mmap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>git_munmap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PACKED_GIT_WINDOW_SIZE</name></cpp:macro> <cpp:value>(1 * 1024 * 1024)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PACKED_GIT_WINDOW_SIZE</name></cpp:macro> <cpp:value>(sizeof(void*) &gt;= 8 ? 1 * 1024 * 1024 * 1024 : 32 * 1024 * 1024)</cpp:value></cpp:define>




<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_FAILED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_FAILED</name></cpp:macro> <cpp:value>((void *)-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_ST_BLOCKS_IN_STRUCT_STAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>on_disk_bytes</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((st).st_size)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>on_disk_bytes</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((st).st_blocks * 512)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEEDS_MODE_TRANSLATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFMT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFREG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFDIR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFLNK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFBLK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFCHR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFIFO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_IFSOCK</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFMT</name></cpp:macro> <cpp:value>0170000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFREG</name></cpp:macro> <cpp:value>0100000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFDIR</name></cpp:macro> <cpp:value>0040000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFLNK</name></cpp:macro> <cpp:value>0120000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFBLK</name></cpp:macro> <cpp:value>0060000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFCHR</name></cpp:macro> <cpp:value>0020000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFIFO</name></cpp:macro> <cpp:value>0010000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFSOCK</name></cpp:macro> <cpp:value>0140000</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>stat</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stat</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_stat(path, buf)</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>fstat</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fstat</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstat</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_fstat(fd, buf)</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_fstat</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>lstat</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>lstat</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_lstat(path, buf)</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_lstat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PACKED_GIT_LIMIT</name></cpp:macro> <cpp:value>((1024L * 1024L) * (size_t)(sizeof(void*) &gt;= 8 ? (32 * 1024L * 1024L) : 256))</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pread</name></cpp:macro> <cpp:value>git_pread</cpp:value></cpp:define>
<function_decl><type><name>ssize_t</name></type> <name>git_pread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function_decl><type><name>ssize_t</name></type> <name>read_in_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setenv</name></cpp:macro> <cpp:value>gitsetenv</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>gitsetenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_MKDTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mkdtemp</name></cpp:macro> <cpp:value>gitmkdtemp</cpp:value></cpp:define>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>gitmkdtemp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unsetenv</name></cpp:macro> <cpp:value>gitunsetenv</cpp:value></cpp:define>
<function_decl><type><name>void</name></type> <name>gitunsetenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_STRCASESTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strcasestr</name></cpp:macro> <cpp:value>gitstrcasestr</cpp:value></cpp:define>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>gitstrcasestr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>haystack</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_STRLCPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strlcpy</name></cpp:macro> <cpp:value>gitstrlcpy</cpp:value></cpp:define>
<function_decl><type><name>size_t</name></type> <name>gitstrlcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_STRTOUMAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtoumax</name></cpp:macro> <cpp:value>gitstrtoumax</cpp:value></cpp:define>
<function_decl><type><name>uintmax_t</name></type> <name>gitstrtoumax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtoimax</name></cpp:macro> <cpp:value>gitstrtoimax</cpp:value></cpp:define>
<function_decl><type><name>intmax_t</name></type> <name>gitstrtoimax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_HSTRERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hstrerror</name></cpp:macro> <cpp:value>githstrerror</cpp:value></cpp:define>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>githstrerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>herror</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_MEMMEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memmem</name></cpp:macro> <cpp:value>gitmemmem</cpp:value></cpp:define>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>gitmemmem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>haystack</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>haystacklen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>needle</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>needlelen</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OVERRIDE_STRDUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>strdup</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>strdup</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strdup</name></cpp:macro> <cpp:value>gitstrdup</cpp:value></cpp:define>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>gitstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GETPAGESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getpagesize</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>sysconf(_SC_PAGESIZE)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_CLOEXEC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FREAD_READS_DIRECTORIES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SUPPRESS_FOPEN_REDEFINITION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>fopen</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fopen</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fopen</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_fopen(a,b)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>git_fopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SNPRINTF_RETURNS_BOGUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>snprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>snprintf</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>git_snprintf</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_snprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxsize</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>vsnprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>vsnprintf</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vsnprintf</name></cpp:macro> <cpp:value>git_vsnprintf</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_vsnprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxsize</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC_PREREQ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>__GLIBC_PREREQ</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STRCHRNUL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRCHRNUL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strchrnul</name></cpp:macro> <cpp:value>gitstrchrnul</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>gitstrchrnul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>inet_pton</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>af</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_INET_NTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inet_ntop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>af</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atexit</name></cpp:macro> <cpp:value>git_atexit</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>git_atexit</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>handler</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>st_add</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>unsigned_add_overflows</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"size_t overflow: %"</literal><name>PRIuMAX</name><literal type="string">" + %"</literal><name>PRIuMAX</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>a</name> <operator>+</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>st_add3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>st_add(st_add((a),(b)),(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>st_add4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>st_add(st_add3((a),(b),(c)),(d))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>st_mult</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>unsigned_mult_overflows</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"size_t overflow: %"</literal><name>PRIuMAX</name><literal type="string">" * %"</literal><name>PRIuMAX</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>a</name> <operator>*</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>st_sub</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"size_t underflow: %"</literal><name>PRIuMAX</name><literal type="string">" - %"</literal><name>PRIuMAX</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>a</name> <operator>-</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ALLOCA_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xalloca</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(alloca(size))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xalloca_free</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xalloca</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(xmalloc(size))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xalloca_free</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(free(p))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>xstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmallocz</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmallocz_gently</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmemdupz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>xstrndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xrealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xcalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmmap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmmap_gently</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>xopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ssize_t</name></type> <name>xread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ssize_t</name></type> <name>xwrite</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ssize_t</name></type> <name>xpread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>xdup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>xfopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>xfdopen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>xmkstemp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>xmkstemp_mode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>xgetcwd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>fopen_for_writing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>fopen_or_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_AND_NULL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { free(p); (p) = NULL; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC_ARRAY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>alloc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLOC_ARRAY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>alloc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = xcalloc((alloc), sizeof(*(x)));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALLOC_ARRAY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>alloc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_ARRAY</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>copy_array((dst), (src), (n), sizeof(*(dst)) + BUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>copy_array</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>st_mult</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOVE_ARRAY</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>move_array((dst), (src), (n), sizeof(*(dst)) + BUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>move_array</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>st_mult</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>










































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ALLOC_MEM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>flexname</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { size_t flex_array_len_ = (len); (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); memcpy((void *)(x)-&gt;flexname, (buf), flex_array_len_); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEXPTR_ALLOC_MEM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>ptrname</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { size_t flex_array_len_ = (len); (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); memcpy((x) + 1, (buf), flex_array_len_); (x)-&gt;ptrname = (void *)((x)+1); } while(0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_ALLOC_STR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>flexname</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FLEX_ALLOC_MEM((x), flexname, (str), strlen(str))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEXPTR_ALLOC_STR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>ptrname</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>xstrdup_or_null</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>str</name></expr> ?</condition><then> <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>xsize_t</name><parameter_list>(<parameter><decl><type><name>off_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"Cannot handle files this big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<macro><name>__attribute__</name><argument_list>(<argument>(format (printf, <literal type="number">3</literal>, <literal type="number">4</literal>))</argument>)</argument_list></macro>
<function_decl><type><name>int</name></type> <name>xsnprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HOST_NAME_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOST_NAME_MAX</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>int</name></type> <name>xgethostname</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>tolower_trans_tbl</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isascii</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isspace</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isdigit</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isalpha</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isalnum</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isprint</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>islower</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isupper</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tolower</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>toupper</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>iscntrl</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ispunct</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isxdigit</name></cpp:undef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>sane_ctype</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_SPACE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_DIGIT</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_ALPHA</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_GLOB_SPECIAL</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_REGEX_SPECIAL</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_PATHSPEC_MAGIC</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_CNTRL</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIT_PUNCT</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sane_istest</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sane_ctype[(unsigned char)(x)] &amp; (mask)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isascii</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) &amp; ~0x7f) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isspace</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_SPACE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_DIGIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isalpha</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_ALPHA)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isalnum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_ALPHA | GIT_DIGIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isprint</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &gt;= 0x20 &amp;&amp; (x) &lt;= 0x7e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>islower</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_iscase(x, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isupper</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_iscase(x, 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_glob_special</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_GLOB_SPECIAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_regex_special</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iscntrl</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sane_istest(x,GIT_CNTRL))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ispunct</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x, GIT_PUNCT | GIT_REGEX_SPECIAL | GIT_GLOB_SPECIAL | GIT_PATHSPEC_MAGIC)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isxdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hexval_table[(unsigned char)(x)] != -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tolower</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_case((unsigned char)(x), 0x20)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>toupper</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_case((unsigned char)(x), 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_pathspec_magic</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_istest(x,GIT_PATHSPEC_MAGIC)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>sane_case</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>high</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>sane_istest</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>GIT_ALPHA</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x20</literal><operator>)</operator> <operator>|</operator> <name>high</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>sane_iscase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_lower</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sane_istest</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>GIT_ALPHA</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_lower</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>skip_iprefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>prefix</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>str</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>prefix</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strtoul_ui</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ul</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>s</name> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>ul</name> <operator>!=</operator> <name>ul</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>ul</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>strtol_i</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>ul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ul</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>s</name> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ul</name> <operator>!=</operator> <name>ul</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>ul</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>git_stable_qsort</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>compar</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INTERNAL_QSORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>qsort</name></cpp:macro> <cpp:value>git_stable_qsort</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSORT</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>compar</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sane_qsort((base), (n), sizeof(*(base)), compar)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sane_qsort</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>compar</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nmemb</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>nmemb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>compar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STABLE_QSORT</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>compar</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_stable_qsort((base), (n), sizeof(*(base)), compar)</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ISO_QSORT_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>git_qsort_s</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>compar</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>qsort_s</name></cpp:macro> <cpp:value>git_qsort_s</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSORT_S</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>compar</name></type></parameter>, <parameter><type><name>ctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (qsort_s((base), (n), sizeof(*(base)), compar, ctx)) BUG("qsort_s() failed"); } while (0)</cpp:value></cpp:define>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>REG_STARTEND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>regexec_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>nmatch</name></decl></parameter>, <parameter><decl><type><name>regmatch_t</name></type> <name><name>pmatch</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nmatch</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<return>return <expr><call><name>regexec</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>eflags</name> <operator>|</operator> <name>REG_STARTEND</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DIR_HAS_BSD_GROUP_SEMANTICS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_DIR_SET_GID</name></cpp:macro> <cpp:value>S_ISGID</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_DIR_SET_GID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_NSEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_NSEC</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_CTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_MTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ST_TIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_CTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)((st).st_ctimespec.tv_nsec))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_MTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)((st).st_mtimespec.tv_nsec))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_CTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)((st).st_ctim.tv_nsec))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_MTIME_NSEC</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)((st).st_mtim.tv_nsec))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNRELIABLE_FSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstat_is_reliable</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstat_is_reliable</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>va_copy</name></expr></argument>)</argument_list></call></expr></cpp:if>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__va_copy</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>va_copy</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__va_copy(dst, src)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>va_copy</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dst) = (src))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__C99_MACRO_WITH_VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_VARIADIC_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>BUG_exit_code</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_VARIADIC_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>__attribute__</name><argument_list>(<argument>(format (printf, <literal type="number">3</literal>, <literal type="number">4</literal>))</argument>)</argument_list></macro> <function_decl><type><name>NORETURN</name>
<name>void</name></type> <name>BUG_fl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUG</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BUG_fl(__FILE__, __LINE__, __VA_ARGS__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>__attribute__</name><argument_list>(<argument>(format (printf, <literal type="number">1</literal>, <literal type="number">2</literal>))</argument>)</argument_list></macro> <function_decl><type><name>NORETURN</name>
<name>void</name></type> <name>BUG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function_decl><type><name>int</name></type> <name>unlink_or_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>int</name></type> <name>unlink_or_msg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>strbuf</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>int</name></type> <name>rmdir_or_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>int</name></type> <name>remove_or_warn</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_EACCES_OK</name></cpp:macro> <cpp:value>(1U &lt;&lt; 0)</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>access_or_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>access_or_die</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>int</name></type> <name>warn_on_fopen_errors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GMTIME_UNRELIABLE_ERRORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>git_gmtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>git_gmtime_r</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gmtime</name></cpp:macro> <cpp:value>git_gmtime</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gmtime_r</name></cpp:macro> <cpp:value>git_gmtime_r</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_PARENS_AROUND_GETTEXT_N</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_PARENS_AROUND_GETTEXT_N</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SHELL_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_PATH</name></cpp:macro> <cpp:value>"/bin/sh"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_THREAD_SAFE_FUNCTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flockfile</name><parameter_list>(<parameter><type><name>fh</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>funlockfile</name><parameter_list>(<parameter><type><name>fh</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getc_unlocked</name><parameter_list>(<parameter><type><name>fh</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>getc(fh)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILENO_IS_A_MACRO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>git_fileno</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>COMPAT_CODE_FILENO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fileno</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileno</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_fileno(p)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_ACCESS_ROOT_HANDLER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>git_access</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>COMPAT_CODE_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>access</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>access</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>access</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>git_access(path, mode)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>is_missing_file_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errno_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>errno_</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno_</name> <operator>==</operator> <name>ENOTDIR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>cmd_main</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>int</name></type> <name>trace2_cmd_exit_fl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>exit</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>exit(trace2_cmd_exit_fl(__FILE__, __LINE__, (code)))</cpp:value></cpp:define>














<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPRESS_ANNOTATED_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>unleak_memory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLEAK</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>unleak_memory(&amp;(var), sizeof(var))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLEAK</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"banned.h"</cpp:file></cpp:include>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>container_of</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *) ((char *)(ptr) - offsetof(type, member)))</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>container_of_or_null_offset</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>ptr</name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>-</operator> <name>offset</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>container_of_or_null</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(type *)container_of_or_null_offset(ptr, offsetof(type, member))</cpp:value></cpp:define>








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSETOF_VAR</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(__typeof__(*ptr), member)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSETOF_VAR</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uintptr_t)&amp;(ptr)-&gt;member - (uintptr_t)(ptr))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
