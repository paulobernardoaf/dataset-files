
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#if !defined(miniaudio_h)
#define miniaudio_h

#if defined(__cplusplus)
extern "C" {
#endif

#if defined(_MSC_VER) && !defined(__clang__)
#pragma warning(push)
#pragma warning(disable:4201) 
#pragma warning(disable:4324) 
#else
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic" 
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wc11-extensions" 
#endif
#endif


#if defined(_WIN32)
#define MA_WIN32
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PC_APP || WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)
#define MA_WIN32_UWP
#else
#define MA_WIN32_DESKTOP
#endif
#else
#define MA_POSIX
#include <pthread.h> 
#include <semaphore.h>

#if defined(__unix__)
#define MA_UNIX
#if defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
#define MA_BSD
#endif
#endif
#if defined(__linux__)
#define MA_LINUX
#endif
#if defined(__APPLE__)
#define MA_APPLE
#endif
#if defined(__ANDROID__)
#define MA_ANDROID
#endif
#if defined(__EMSCRIPTEN__)
#define MA_EMSCRIPTEN
#endif
#endif

#include <stddef.h> 


#if defined(_MSC_VER)
#if defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wlanguage-extension-token"
#pragma GCC diagnostic ignored "-Wlong-long" 
#pragma GCC diagnostic ignored "-Wc++11-long-long"
#endif
typedef signed __int8 ma_int8;
typedef unsigned __int8 ma_uint8;
typedef signed __int16 ma_int16;
typedef unsigned __int16 ma_uint16;
typedef signed __int32 ma_int32;
typedef unsigned __int32 ma_uint32;
typedef signed __int64 ma_int64;
typedef unsigned __int64 ma_uint64;
#if defined(__clang__)
#pragma GCC diagnostic pop
#endif
#else
#define MA_HAS_STDINT
#include <stdint.h>
typedef int8_t ma_int8;
typedef uint8_t ma_uint8;
typedef int16_t ma_int16;
typedef uint16_t ma_uint16;
typedef int32_t ma_int32;
typedef uint32_t ma_uint32;
typedef int64_t ma_int64;
typedef uint64_t ma_uint64;
#endif

#if defined(MA_HAS_STDINT)
typedef uintptr_t ma_uintptr;
#else
#if defined(_WIN32)
#if defined(_WIN64)
typedef ma_uint64 ma_uintptr;
#else
typedef ma_uint32 ma_uintptr;
#endif
#elif defined(__GNUC__)
#if defined(__LP64__)
typedef ma_uint64 ma_uintptr;
#else
typedef ma_uint32 ma_uintptr;
#endif
#else
typedef ma_uint64 ma_uintptr; 
#endif
#endif

typedef ma_uint8 ma_bool8;
typedef ma_uint32 ma_bool32;
#define MA_TRUE 1
#define MA_FALSE 0

typedef void* ma_handle;
typedef void* ma_ptr;
typedef void (* ma_proc)(void);

#if defined(_MSC_VER) && !defined(_WCHAR_T_DEFINED)
typedef ma_uint16 wchar_t;
#endif


#if !defined(NULL)
#define NULL 0
#endif

#if defined(SIZE_MAX)
#define MA_SIZE_MAX SIZE_MAX
#else
#define MA_SIZE_MAX 0xFFFFFFFF 
#endif


#if defined(_MSC_VER)
#define MA_INLINE __forceinline
#elif defined(__GNUC__)







#if defined(__STRICT_ANSI__)
#define MA_INLINE __inline__ __attribute__((always_inline))
#else
#define MA_INLINE inline __attribute__((always_inline))
#endif
#else
#define MA_INLINE
#endif

#if defined(_MSC_VER)
#if _MSC_VER >= 1400
#define MA_ALIGN(alignment) __declspec(align(alignment))
#endif
#elif !defined(__DMC__)
#define MA_ALIGN(alignment) __attribute__((aligned(alignment)))
#endif
#if !defined(MA_ALIGN)
#define MA_ALIGN(alignment)
#endif


#define MA_SIMD_ALIGNMENT 64



#define MA_LOG_LEVEL_VERBOSE 4
#define MA_LOG_LEVEL_INFO 3
#define MA_LOG_LEVEL_WARNING 2
#define MA_LOG_LEVEL_ERROR 1

#if !defined(MA_LOG_LEVEL)
#define MA_LOG_LEVEL MA_LOG_LEVEL_ERROR
#endif

typedef struct ma_context ma_context;
typedef struct ma_device ma_device;

typedef ma_uint8 ma_channel;
#define MA_CHANNEL_NONE 0
#define MA_CHANNEL_MONO 1
#define MA_CHANNEL_FRONT_LEFT 2
#define MA_CHANNEL_FRONT_RIGHT 3
#define MA_CHANNEL_FRONT_CENTER 4
#define MA_CHANNEL_LFE 5
#define MA_CHANNEL_BACK_LEFT 6
#define MA_CHANNEL_BACK_RIGHT 7
#define MA_CHANNEL_FRONT_LEFT_CENTER 8
#define MA_CHANNEL_FRONT_RIGHT_CENTER 9
#define MA_CHANNEL_BACK_CENTER 10
#define MA_CHANNEL_SIDE_LEFT 11
#define MA_CHANNEL_SIDE_RIGHT 12
#define MA_CHANNEL_TOP_CENTER 13
#define MA_CHANNEL_TOP_FRONT_LEFT 14
#define MA_CHANNEL_TOP_FRONT_CENTER 15
#define MA_CHANNEL_TOP_FRONT_RIGHT 16
#define MA_CHANNEL_TOP_BACK_LEFT 17
#define MA_CHANNEL_TOP_BACK_CENTER 18
#define MA_CHANNEL_TOP_BACK_RIGHT 19
#define MA_CHANNEL_AUX_0 20
#define MA_CHANNEL_AUX_1 21
#define MA_CHANNEL_AUX_2 22
#define MA_CHANNEL_AUX_3 23
#define MA_CHANNEL_AUX_4 24
#define MA_CHANNEL_AUX_5 25
#define MA_CHANNEL_AUX_6 26
#define MA_CHANNEL_AUX_7 27
#define MA_CHANNEL_AUX_8 28
#define MA_CHANNEL_AUX_9 29
#define MA_CHANNEL_AUX_10 30
#define MA_CHANNEL_AUX_11 31
#define MA_CHANNEL_AUX_12 32
#define MA_CHANNEL_AUX_13 33
#define MA_CHANNEL_AUX_14 34
#define MA_CHANNEL_AUX_15 35
#define MA_CHANNEL_AUX_16 36
#define MA_CHANNEL_AUX_17 37
#define MA_CHANNEL_AUX_18 38
#define MA_CHANNEL_AUX_19 39
#define MA_CHANNEL_AUX_20 40
#define MA_CHANNEL_AUX_21 41
#define MA_CHANNEL_AUX_22 42
#define MA_CHANNEL_AUX_23 43
#define MA_CHANNEL_AUX_24 44
#define MA_CHANNEL_AUX_25 45
#define MA_CHANNEL_AUX_26 46
#define MA_CHANNEL_AUX_27 47
#define MA_CHANNEL_AUX_28 48
#define MA_CHANNEL_AUX_29 49
#define MA_CHANNEL_AUX_30 50
#define MA_CHANNEL_AUX_31 51
#define MA_CHANNEL_LEFT MA_CHANNEL_FRONT_LEFT
#define MA_CHANNEL_RIGHT MA_CHANNEL_FRONT_RIGHT
#define MA_CHANNEL_POSITION_COUNT (MA_CHANNEL_AUX_31 + 1)


typedef int ma_result;
#define MA_SUCCESS 0


#define MA_ERROR -1 
#define MA_INVALID_ARGS -2
#define MA_INVALID_OPERATION -3
#define MA_OUT_OF_MEMORY -4
#define MA_ACCESS_DENIED -5
#define MA_TOO_LARGE -6
#define MA_TIMEOUT -7


#define MA_FORMAT_NOT_SUPPORTED -100
#define MA_DEVICE_TYPE_NOT_SUPPORTED -101
#define MA_SHARE_MODE_NOT_SUPPORTED -102
#define MA_NO_BACKEND -103
#define MA_NO_DEVICE -104
#define MA_API_NOT_FOUND -105
#define MA_INVALID_DEVICE_CONFIG -106


#define MA_DEVICE_BUSY -200
#define MA_DEVICE_NOT_INITIALIZED -201
#define MA_DEVICE_NOT_STARTED -202
#define MA_DEVICE_UNAVAILABLE -203


#define MA_FAILED_TO_MAP_DEVICE_BUFFER -300
#define MA_FAILED_TO_UNMAP_DEVICE_BUFFER -301
#define MA_FAILED_TO_INIT_BACKEND -302
#define MA_FAILED_TO_READ_DATA_FROM_CLIENT -303
#define MA_FAILED_TO_READ_DATA_FROM_DEVICE -304
#define MA_FAILED_TO_SEND_DATA_TO_CLIENT -305
#define MA_FAILED_TO_SEND_DATA_TO_DEVICE -306
#define MA_FAILED_TO_OPEN_BACKEND_DEVICE -307
#define MA_FAILED_TO_START_BACKEND_DEVICE -308
#define MA_FAILED_TO_STOP_BACKEND_DEVICE -309
#define MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE -310
#define MA_FAILED_TO_CREATE_MUTEX -311
#define MA_FAILED_TO_CREATE_EVENT -312
#define MA_FAILED_TO_CREATE_SEMAPHORE -313
#define MA_FAILED_TO_CREATE_THREAD -314



#define MA_SAMPLE_RATE_8000 8000
#define MA_SAMPLE_RATE_11025 11025
#define MA_SAMPLE_RATE_16000 16000
#define MA_SAMPLE_RATE_22050 22050
#define MA_SAMPLE_RATE_24000 24000
#define MA_SAMPLE_RATE_32000 32000
#define MA_SAMPLE_RATE_44100 44100
#define MA_SAMPLE_RATE_48000 48000
#define MA_SAMPLE_RATE_88200 88200
#define MA_SAMPLE_RATE_96000 96000
#define MA_SAMPLE_RATE_176400 176400
#define MA_SAMPLE_RATE_192000 192000
#define MA_SAMPLE_RATE_352800 352800
#define MA_SAMPLE_RATE_384000 384000

#define MA_MIN_CHANNELS 1
#define MA_MAX_CHANNELS 32
#define MA_MIN_SAMPLE_RATE MA_SAMPLE_RATE_8000
#define MA_MAX_SAMPLE_RATE MA_SAMPLE_RATE_384000

typedef enum
{
ma_stream_format_pcm = 0
} ma_stream_format;

typedef enum
{
ma_stream_layout_interleaved = 0,
ma_stream_layout_deinterleaved
} ma_stream_layout;

typedef enum
{
ma_dither_mode_none = 0,
ma_dither_mode_rectangle,
ma_dither_mode_triangle
} ma_dither_mode;

typedef enum
{




ma_format_unknown = 0, 
ma_format_u8 = 1,
ma_format_s16 = 2, 
ma_format_s24 = 3, 
ma_format_s32 = 4,
ma_format_f32 = 5,
ma_format_count
} ma_format;

typedef enum
{
ma_channel_mix_mode_rectangular = 0, 
ma_channel_mix_mode_simple, 
ma_channel_mix_mode_custom_weights, 
ma_channel_mix_mode_planar_blend = ma_channel_mix_mode_rectangular,
ma_channel_mix_mode_default = ma_channel_mix_mode_planar_blend
} ma_channel_mix_mode;

typedef enum
{
ma_standard_channel_map_microsoft,
ma_standard_channel_map_alsa,
ma_standard_channel_map_rfc3551, 
ma_standard_channel_map_flac,
ma_standard_channel_map_vorbis,
ma_standard_channel_map_sound4, 
ma_standard_channel_map_sndio, 
ma_standard_channel_map_webaudio = ma_standard_channel_map_flac, 
ma_standard_channel_map_default = ma_standard_channel_map_microsoft
} ma_standard_channel_map;

typedef enum
{
ma_performance_profile_low_latency = 0,
ma_performance_profile_conservative
} ma_performance_profile;


typedef struct
{
void* pUserData;
void* (* onMalloc)(size_t sz, void* pUserData);
void* (* onRealloc)(void* p, size_t sz, void* pUserData);
void (* onFree)(void* p, void* pUserData);
} ma_allocation_callbacks;







typedef union
{
float f32;
ma_int32 s32;
} ma_biquad_coefficient;

typedef struct
{
ma_format format;
ma_uint32 channels;
double b0;
double b1;
double b2;
double a0;
double a1;
double a2;
} ma_biquad_config;

ma_biquad_config ma_biquad_config_init(ma_format format, ma_uint32 channels, double b0, double b1, double b2, double a0, double a1, double a2);

typedef struct
{
ma_format format;
ma_uint32 channels;
ma_biquad_coefficient b0;
ma_biquad_coefficient b1;
ma_biquad_coefficient b2;
ma_biquad_coefficient a1;
ma_biquad_coefficient a2;
ma_biquad_coefficient r1[MA_MAX_CHANNELS];
ma_biquad_coefficient r2[MA_MAX_CHANNELS];
} ma_biquad;

ma_result ma_biquad_init(const ma_biquad_config* pConfig, ma_biquad* pBQ);
ma_result ma_biquad_reinit(const ma_biquad_config* pConfig, ma_biquad* pBQ);
ma_result ma_biquad_process_pcm_frames(ma_biquad* pBQ, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
ma_uint32 ma_biquad_get_latency(ma_biquad* pBQ);







typedef struct
{
ma_format format;
ma_uint32 channels;
ma_uint32 sampleRate;
double cutoffFrequency;
} ma_lpf_config;

ma_lpf_config ma_lpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency);

typedef struct
{
ma_biquad bq; 
} ma_lpf;

ma_result ma_lpf_init(const ma_lpf_config* pConfig, ma_lpf* pLPF);
ma_result ma_lpf_reinit(const ma_lpf_config* pConfig, ma_lpf* pLPF);
ma_result ma_lpf_process_pcm_frames(ma_lpf* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
ma_uint32 ma_lpf_get_latency(ma_lpf* pLPF);







typedef struct
{
ma_format format;
ma_uint32 channels;
ma_uint32 sampleRate;
double cutoffFrequency;
} ma_hpf_config;

ma_hpf_config ma_hpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency);

typedef struct
{
ma_biquad bq; 
} ma_hpf;

ma_result ma_hpf_init(const ma_hpf_config* pConfig, ma_hpf* pHPF);
ma_result ma_hpf_reinit(const ma_hpf_config* pConfig, ma_hpf* pHPF);
ma_result ma_hpf_process_pcm_frames(ma_hpf* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
ma_uint32 ma_hpf_get_latency(ma_hpf* pHPF);







typedef struct
{
ma_format format;
ma_uint32 channels;
ma_uint32 sampleRate;
double cutoffFrequency;
} ma_bpf_config;

ma_bpf_config ma_bpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency);

typedef struct
{
ma_biquad bq; 
} ma_bpf;

ma_result ma_bpf_init(const ma_bpf_config* pConfig, ma_bpf* pBPF);
ma_result ma_bpf_reinit(const ma_bpf_config* pConfig, ma_bpf* pBPF);
ma_result ma_bpf_process_pcm_frames(ma_bpf* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);
ma_uint32 ma_bpf_get_latency(ma_bpf* pBPF);


















#if !defined(MA_MAX_RESAMPLER_LPF_FILTERS)
#define MA_MAX_RESAMPLER_LPF_FILTERS 4
#endif

typedef struct
{
ma_format format;
ma_uint32 channels;
ma_uint32 sampleRateIn;
ma_uint32 sampleRateOut;
ma_uint32 lpfCount; 
double lpfNyquistFactor; 
} ma_linear_resampler_config;

ma_linear_resampler_config ma_linear_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);

typedef struct
{
ma_linear_resampler_config config;
ma_uint32 inAdvanceInt;
ma_uint32 inAdvanceFrac;
ma_uint32 inTimeInt;
ma_uint32 inTimeFrac;
union
{
float f32[MA_MAX_CHANNELS];
ma_int16 s16[MA_MAX_CHANNELS];
} x0; 
union
{
float f32[MA_MAX_CHANNELS];
ma_int16 s16[MA_MAX_CHANNELS];
} x1; 
ma_lpf lpf[MA_MAX_RESAMPLER_LPF_FILTERS];
} ma_linear_resampler;

ma_result ma_linear_resampler_init(const ma_linear_resampler_config* pConfig, ma_linear_resampler* pResampler);
void ma_linear_resampler_uninit(ma_linear_resampler* pResampler);
ma_result ma_linear_resampler_process_pcm_frames(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);
ma_result ma_linear_resampler_set_rate(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);
ma_result ma_linear_resampler_set_rate_ratio(ma_linear_resampler* pResampler, float ratioInOut);
ma_uint64 ma_linear_resampler_get_required_input_frame_count(ma_linear_resampler* pResampler, ma_uint64 outputFrameCount);
ma_uint64 ma_linear_resampler_get_expected_output_frame_count(ma_linear_resampler* pResampler, ma_uint64 inputFrameCount);
ma_uint64 ma_linear_resampler_get_input_latency(ma_linear_resampler* pResampler);
ma_uint64 ma_linear_resampler_get_output_latency(ma_linear_resampler* pResampler);

typedef enum
{
ma_resample_algorithm_linear = 0, 
ma_resample_algorithm_speex
} ma_resample_algorithm;

typedef struct
{
ma_format format; 
ma_uint32 channels;
ma_uint32 sampleRateIn;
ma_uint32 sampleRateOut;
ma_resample_algorithm algorithm;
struct
{
ma_uint32 lpfCount;
double lpfNyquistFactor;
} linear;
struct
{
int quality; 
} speex;
} ma_resampler_config;

ma_resampler_config ma_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_resample_algorithm algorithm);

typedef struct
{
ma_resampler_config config;
union
{
ma_linear_resampler linear;
struct
{
void* pSpeexResamplerState; 
} speex;
} state;
} ma_resampler;




ma_result ma_resampler_init(const ma_resampler_config* pConfig, ma_resampler* pResampler);




void ma_resampler_uninit(ma_resampler* pResampler);























ma_result ma_resampler_process_pcm_frames(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);





ma_result ma_resampler_set_rate(ma_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);






ma_result ma_resampler_set_rate_ratio(ma_resampler* pResampler, float ratio);









ma_uint64 ma_resampler_get_required_input_frame_count(ma_resampler* pResampler, ma_uint64 outputFrameCount);





ma_uint64 ma_resampler_get_expected_output_frame_count(ma_resampler* pResampler, ma_uint64 inputFrameCount);





ma_uint64 ma_resampler_get_input_latency(ma_resampler* pResampler);




ma_uint64 ma_resampler_get_output_latency(ma_resampler* pResampler);








typedef struct
{
ma_format format;
ma_uint32 channelsIn;
ma_uint32 channelsOut;
ma_channel channelMapIn[MA_MAX_CHANNELS];
ma_channel channelMapOut[MA_MAX_CHANNELS];
ma_channel_mix_mode mixingMode;
float weights[MA_MAX_CHANNELS][MA_MAX_CHANNELS]; 
} ma_channel_converter_config;

ma_channel_converter_config ma_channel_converter_config_init(ma_format format, ma_uint32 channelsIn, const ma_channel channelMapIn[MA_MAX_CHANNELS], ma_uint32 channelsOut, const ma_channel channelMapOut[MA_MAX_CHANNELS], ma_channel_mix_mode mixingMode);

typedef struct
{
ma_format format;
ma_uint32 channelsIn;
ma_uint32 channelsOut;
ma_channel channelMapIn[MA_MAX_CHANNELS];
ma_channel channelMapOut[MA_MAX_CHANNELS];
ma_channel_mix_mode mixingMode;
union
{
float f32[MA_MAX_CHANNELS][MA_MAX_CHANNELS];
ma_int32 s16[MA_MAX_CHANNELS][MA_MAX_CHANNELS];
} weights;
ma_bool32 isPassthrough : 1;
ma_bool32 isSimpleShuffle : 1;
ma_bool32 isSimpleMonoExpansion : 1;
ma_bool32 isStereoToMono : 1;
ma_uint8 shuffleTable[MA_MAX_CHANNELS];
} ma_channel_converter;

ma_result ma_channel_converter_init(const ma_channel_converter_config* pConfig, ma_channel_converter* pConverter);
void ma_channel_converter_uninit(ma_channel_converter* pConverter);
ma_result ma_channel_converter_process_pcm_frames(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount);







typedef struct
{
ma_format formatIn;
ma_format formatOut;
ma_uint32 channelsIn;
ma_uint32 channelsOut;
ma_uint32 sampleRateIn;
ma_uint32 sampleRateOut;
ma_channel channelMapIn[MA_MAX_CHANNELS];
ma_channel channelMapOut[MA_MAX_CHANNELS];
ma_dither_mode ditherMode;
ma_channel_mix_mode channelMixMode;
float channelWeights[MA_MAX_CHANNELS][MA_MAX_CHANNELS]; 
struct
{
ma_resample_algorithm algorithm;
ma_bool32 allowDynamicSampleRate;
struct
{
ma_uint32 lpfCount;
double lpfNyquistFactor;
} linear;
struct
{
int quality;
} speex;
} resampling;
} ma_data_converter_config;

ma_data_converter_config ma_data_converter_config_init_default(void);
ma_data_converter_config ma_data_converter_config_init(ma_format formatIn, ma_format formatOut, ma_uint32 channelsIn, ma_uint32 channelsOut, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);

typedef struct
{
ma_data_converter_config config;
ma_channel_converter channelConverter;
ma_resampler resampler;
ma_bool32 hasPreFormatConversion : 1;
ma_bool32 hasPostFormatConversion : 1;
ma_bool32 hasChannelConverter : 1;
ma_bool32 hasResampler : 1;
ma_bool32 isPassthrough : 1;
} ma_data_converter;

ma_result ma_data_converter_init(const ma_data_converter_config* pConfig, ma_data_converter* pConverter);
void ma_data_converter_uninit(ma_data_converter* pConverter);
ma_result ma_data_converter_process_pcm_frames(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut);
ma_result ma_data_converter_set_rate(ma_data_converter* pConverter, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut);
ma_result ma_data_converter_set_rate_ratio(ma_data_converter* pConverter, float ratioInOut);
ma_uint64 ma_data_converter_get_required_input_frame_count(ma_data_converter* pConverter, ma_uint64 outputFrameCount);
ma_uint64 ma_data_converter_get_expected_output_frame_count(ma_data_converter* pConverter, ma_uint64 inputFrameCount);
ma_uint64 ma_data_converter_get_input_latency(ma_data_converter* pConverter);
ma_uint64 ma_data_converter_get_output_latency(ma_data_converter* pConverter);







void ma_pcm_u8_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_u8_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_u8_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_u8_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s16_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s16_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s16_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s16_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s24_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s24_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s24_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s24_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_s32_to_f32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_f32_to_u8(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_f32_to_s16(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_f32_to_s24(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_f32_to_s32(void* pOut, const void* pIn, ma_uint64 count, ma_dither_mode ditherMode);
void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode);
void ma_convert_pcm_frames_format(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 frameCount, ma_uint32 channels, ma_dither_mode ditherMode);




void ma_deinterleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames);




void ma_interleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames);










void ma_get_standard_channel_map(ma_standard_channel_map standardChannelMap, ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS]);




void ma_channel_map_copy(ma_channel* pOut, const ma_channel* pIn, ma_uint32 channels);












ma_bool32 ma_channel_map_valid(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS]);






ma_bool32 ma_channel_map_equal(ma_uint32 channels, const ma_channel channelMapA[MA_MAX_CHANNELS], const ma_channel channelMapB[MA_MAX_CHANNELS]);




ma_bool32 ma_channel_map_blank(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS]);




ma_bool32 ma_channel_map_contains_channel_position(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS], ma_channel channelPosition);

















ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn);
ma_uint64 ma_convert_frames_ex(void* pOut, ma_uint64 frameCountOut, const void* pIn, ma_uint64 frameCountIn, const ma_data_converter_config* pConfig);







typedef struct
{
void* pBuffer;
ma_uint32 subbufferSizeInBytes;
ma_uint32 subbufferCount;
ma_uint32 subbufferStrideInBytes;
volatile ma_uint32 encodedReadOffset; 
volatile ma_uint32 encodedWriteOffset; 
ma_bool32 ownsBuffer : 1; 
ma_bool32 clearOnWriteAcquire : 1; 
ma_allocation_callbacks allocationCallbacks;
} ma_rb;

ma_result ma_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB);
ma_result ma_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB);
void ma_rb_uninit(ma_rb* pRB);
void ma_rb_reset(ma_rb* pRB);
ma_result ma_rb_acquire_read(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
ma_result ma_rb_commit_read(ma_rb* pRB, size_t sizeInBytes, void* pBufferOut);
ma_result ma_rb_acquire_write(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut);
ma_result ma_rb_commit_write(ma_rb* pRB, size_t sizeInBytes, void* pBufferOut);
ma_result ma_rb_seek_read(ma_rb* pRB, size_t offsetInBytes);
ma_result ma_rb_seek_write(ma_rb* pRB, size_t offsetInBytes);
ma_int32 ma_rb_pointer_distance(ma_rb* pRB); 
ma_uint32 ma_rb_available_read(ma_rb* pRB);
ma_uint32 ma_rb_available_write(ma_rb* pRB);
size_t ma_rb_get_subbuffer_size(ma_rb* pRB);
size_t ma_rb_get_subbuffer_stride(ma_rb* pRB);
size_t ma_rb_get_subbuffer_offset(ma_rb* pRB, size_t subbufferIndex);
void* ma_rb_get_subbuffer_ptr(ma_rb* pRB, size_t subbufferIndex, void* pBuffer);


typedef struct
{
ma_rb rb;
ma_format format;
ma_uint32 channels;
} ma_pcm_rb;

ma_result ma_pcm_rb_init_ex(ma_format format, ma_uint32 channels, ma_uint32 subbufferSizeInFrames, ma_uint32 subbufferCount, ma_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB);
ma_result ma_pcm_rb_init(ma_format format, ma_uint32 channels, ma_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB);
void ma_pcm_rb_uninit(ma_pcm_rb* pRB);
void ma_pcm_rb_reset(ma_pcm_rb* pRB);
ma_result ma_pcm_rb_acquire_read(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut);
ma_result ma_pcm_rb_commit_read(ma_pcm_rb* pRB, ma_uint32 sizeInFrames, void* pBufferOut);
ma_result ma_pcm_rb_acquire_write(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut);
ma_result ma_pcm_rb_commit_write(ma_pcm_rb* pRB, ma_uint32 sizeInFrames, void* pBufferOut);
ma_result ma_pcm_rb_seek_read(ma_pcm_rb* pRB, ma_uint32 offsetInFrames);
ma_result ma_pcm_rb_seek_write(ma_pcm_rb* pRB, ma_uint32 offsetInFrames);
ma_int32 ma_pcm_rb_pointer_disance(ma_pcm_rb* pRB); 
ma_uint32 ma_pcm_rb_available_read(ma_pcm_rb* pRB);
ma_uint32 ma_pcm_rb_available_write(ma_pcm_rb* pRB);
ma_uint32 ma_pcm_rb_get_subbuffer_size(ma_pcm_rb* pRB);
ma_uint32 ma_pcm_rb_get_subbuffer_stride(ma_pcm_rb* pRB);
ma_uint32 ma_pcm_rb_get_subbuffer_offset(ma_pcm_rb* pRB, ma_uint32 subbufferIndex);
void* ma_pcm_rb_get_subbuffer_ptr(ma_pcm_rb* pRB, ma_uint32 subbufferIndex, void* pBuffer);











void* ma_malloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks);




void* ma_realloc(void* p, size_t sz, const ma_allocation_callbacks* pAllocationCallbacks);




void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks);




void* ma_aligned_malloc(size_t sz, size_t alignment, const ma_allocation_callbacks* pAllocationCallbacks);




void ma_aligned_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks);




const char* ma_get_format_name(ma_format format);




void ma_blend_f32(float* pOut, float* pInA, float* pInB, float factor, ma_uint32 channels);









ma_uint32 ma_get_bytes_per_sample(ma_format format);
static MA_INLINE ma_uint32 ma_get_bytes_per_frame(ma_format format, ma_uint32 channels) { return ma_get_bytes_per_sample(format) * channels; }




const char* ma_log_level_to_string(ma_uint32 logLevel);













#if !defined(MA_NO_DEVICE_IO)

#if defined(MA_WIN32)
#define MA_SUPPORT_WASAPI
#if defined(MA_WIN32_DESKTOP) 
#define MA_SUPPORT_DSOUND
#define MA_SUPPORT_WINMM
#define MA_SUPPORT_JACK 
#endif
#endif
#if defined(MA_UNIX)
#if defined(MA_LINUX)
#if !defined(MA_ANDROID) 
#define MA_SUPPORT_ALSA
#endif
#endif
#if !defined(MA_BSD) && !defined(MA_ANDROID) && !defined(MA_EMSCRIPTEN)
#define MA_SUPPORT_PULSEAUDIO
#define MA_SUPPORT_JACK
#endif
#if defined(MA_ANDROID)
#define MA_SUPPORT_AAUDIO
#define MA_SUPPORT_OPENSL
#endif
#if defined(__OpenBSD__) 
#define MA_SUPPORT_SNDIO 
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define MA_SUPPORT_AUDIO4 
#endif
#if defined(__FreeBSD__) || defined(__DragonFly__)
#define MA_SUPPORT_OSS 
#endif
#endif
#if defined(MA_APPLE)
#define MA_SUPPORT_COREAUDIO
#endif
#if defined(MA_EMSCRIPTEN)
#define MA_SUPPORT_WEBAUDIO
#endif


#if !defined(MA_EMSCRIPTEN)
#define MA_SUPPORT_NULL
#endif


#if !defined(MA_NO_WASAPI) && defined(MA_SUPPORT_WASAPI)
#define MA_ENABLE_WASAPI
#endif
#if !defined(MA_NO_DSOUND) && defined(MA_SUPPORT_DSOUND)
#define MA_ENABLE_DSOUND
#endif
#if !defined(MA_NO_WINMM) && defined(MA_SUPPORT_WINMM)
#define MA_ENABLE_WINMM
#endif
#if !defined(MA_NO_ALSA) && defined(MA_SUPPORT_ALSA)
#define MA_ENABLE_ALSA
#endif
#if !defined(MA_NO_PULSEAUDIO) && defined(MA_SUPPORT_PULSEAUDIO)
#define MA_ENABLE_PULSEAUDIO
#endif
#if !defined(MA_NO_JACK) && defined(MA_SUPPORT_JACK)
#define MA_ENABLE_JACK
#endif
#if !defined(MA_NO_COREAUDIO) && defined(MA_SUPPORT_COREAUDIO)
#define MA_ENABLE_COREAUDIO
#endif
#if !defined(MA_NO_SNDIO) && defined(MA_SUPPORT_SNDIO)
#define MA_ENABLE_SNDIO
#endif
#if !defined(MA_NO_AUDIO4) && defined(MA_SUPPORT_AUDIO4)
#define MA_ENABLE_AUDIO4
#endif
#if !defined(MA_NO_OSS) && defined(MA_SUPPORT_OSS)
#define MA_ENABLE_OSS
#endif
#if !defined(MA_NO_AAUDIO) && defined(MA_SUPPORT_AAUDIO)
#define MA_ENABLE_AAUDIO
#endif
#if !defined(MA_NO_OPENSL) && defined(MA_SUPPORT_OPENSL)
#define MA_ENABLE_OPENSL
#endif
#if !defined(MA_NO_WEBAUDIO) && defined(MA_SUPPORT_WEBAUDIO)
#define MA_ENABLE_WEBAUDIO
#endif
#if !defined(MA_NO_NULL) && defined(MA_SUPPORT_NULL)
#define MA_ENABLE_NULL
#endif

#if defined(MA_SUPPORT_WASAPI)

typedef struct
{
void* lpVtbl;
ma_uint32 counter;
ma_device* pDevice;
} ma_IMMNotificationClient;
#endif


typedef enum
{
ma_backend_wasapi,
ma_backend_dsound,
ma_backend_winmm,
ma_backend_coreaudio,
ma_backend_sndio,
ma_backend_audio4,
ma_backend_oss,
ma_backend_pulseaudio,
ma_backend_alsa,
ma_backend_jack,
ma_backend_aaudio,
ma_backend_opensl,
ma_backend_webaudio,
ma_backend_null 
} ma_backend;


typedef enum
{
ma_thread_priority_idle = -5,
ma_thread_priority_lowest = -4,
ma_thread_priority_low = -3,
ma_thread_priority_normal = -2,
ma_thread_priority_high = -1,
ma_thread_priority_highest = 0,
ma_thread_priority_realtime = 1,
ma_thread_priority_default = 0
} ma_thread_priority;

typedef struct
{
ma_context* pContext;

union
{
#if defined(MA_WIN32)
struct
{
ma_handle hThread;
} win32;
#endif
#if defined(MA_POSIX)
struct
{
pthread_t thread;
} posix;
#endif
int _unused;
};
} ma_thread;

typedef struct
{
ma_context* pContext;

union
{
#if defined(MA_WIN32)
struct
{
ma_handle hMutex;
} win32;
#endif
#if defined(MA_POSIX)
struct
{
pthread_mutex_t mutex;
} posix;
#endif
int _unused;
};
} ma_mutex;

typedef struct
{
ma_context* pContext;

union
{
#if defined(MA_WIN32)
struct
{
ma_handle hEvent;
} win32;
#endif
#if defined(MA_POSIX)
struct
{
pthread_mutex_t mutex;
pthread_cond_t condition;
ma_uint32 value;
} posix;
#endif
int _unused;
};
} ma_event;

typedef struct
{
ma_context* pContext;

union
{
#if defined(MA_WIN32)
struct
{
ma_handle hSemaphore;
} win32;
#endif
#if defined(MA_POSIX)
struct
{
sem_t semaphore;
} posix;
#endif
int _unused;
};
} ma_semaphore;










































typedef void (* ma_device_callback_proc)(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount);


















typedef void (* ma_stop_proc)(ma_device* pDevice);

































typedef void (* ma_log_proc)(ma_context* pContext, ma_device* pDevice, ma_uint32 logLevel, const char* message);

typedef enum
{
ma_device_type_playback = 1,
ma_device_type_capture = 2,
ma_device_type_duplex = ma_device_type_playback | ma_device_type_capture, 
ma_device_type_loopback = 4
} ma_device_type;

typedef enum
{
ma_share_mode_shared = 0,
ma_share_mode_exclusive
} ma_share_mode;


typedef enum
{
ma_ios_session_category_default = 0, 
ma_ios_session_category_none, 
ma_ios_session_category_ambient, 
ma_ios_session_category_solo_ambient, 
ma_ios_session_category_playback, 
ma_ios_session_category_record, 
ma_ios_session_category_play_and_record, 
ma_ios_session_category_multi_route 
} ma_ios_session_category;


typedef enum
{
ma_ios_session_category_option_mix_with_others = 0x01, 
ma_ios_session_category_option_duck_others = 0x02, 
ma_ios_session_category_option_allow_bluetooth = 0x04, 
ma_ios_session_category_option_default_to_speaker = 0x08, 
ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others = 0x11, 
ma_ios_session_category_option_allow_bluetooth_a2dp = 0x20, 
ma_ios_session_category_option_allow_air_play = 0x40, 
} ma_ios_session_category_option;

typedef union
{
ma_int64 counter;
double counterD;
} ma_timer;

typedef union
{
wchar_t wasapi[64]; 
ma_uint8 dsound[16]; 
ma_uint32 winmm; 
char alsa[256]; 
char pulse[256]; 
int jack; 
char coreaudio[256]; 
char sndio[256]; 
char audio4[256]; 
char oss[64]; 
ma_int32 aaudio; 
ma_uint32 opensl; 
char webaudio[32]; 
int nullbackend; 
} ma_device_id;

typedef struct
{

ma_device_id id;
char name[256];









ma_uint32 formatCount;
ma_format formats[ma_format_count];
ma_uint32 minChannels;
ma_uint32 maxChannels;
ma_uint32 minSampleRate;
ma_uint32 maxSampleRate;

struct
{
ma_bool32 isDefault;
} _private;
} ma_device_info;

typedef struct
{
ma_device_type deviceType;
ma_uint32 sampleRate;
ma_uint32 periodSizeInFrames;
ma_uint32 periodSizeInMilliseconds;
ma_uint32 periods;
ma_performance_profile performanceProfile;
ma_bool32 noPreZeroedOutputBuffer; 
ma_bool32 noClip; 
ma_device_callback_proc dataCallback;
ma_stop_proc stopCallback;
void* pUserData;
struct
{
ma_resample_algorithm algorithm;
struct
{
ma_uint32 lpfCount;
} linear;
struct
{
int quality;
} speex;
} resampling;
struct
{
ma_device_id* pDeviceID;
ma_format format;
ma_uint32 channels;
ma_channel channelMap[MA_MAX_CHANNELS];
ma_share_mode shareMode;
} playback;
struct
{
ma_device_id* pDeviceID;
ma_format format;
ma_uint32 channels;
ma_channel channelMap[MA_MAX_CHANNELS];
ma_share_mode shareMode;
} capture;

struct
{
ma_bool32 noAutoConvertSRC; 
ma_bool32 noDefaultQualitySRC; 
ma_bool32 noAutoStreamRouting; 
ma_bool32 noHardwareOffloading; 
} wasapi;
struct
{
ma_bool32 noMMap; 
} alsa;
struct
{
const char* pStreamNamePlayback;
const char* pStreamNameCapture;
} pulse;
} ma_device_config;

typedef struct
{
ma_log_proc logCallback;
ma_thread_priority threadPriority;
void* pUserData;
ma_allocation_callbacks allocationCallbacks;
struct
{
ma_bool32 useVerboseDeviceEnumeration;
} alsa;
struct
{
const char* pApplicationName;
const char* pServerName;
ma_bool32 tryAutoSpawn; 
} pulse;
struct
{
ma_ios_session_category sessionCategory;
ma_uint32 sessionCategoryOptions;
} coreaudio;
struct
{
const char* pClientName;
ma_bool32 tryStartServer;
} jack;
} ma_context_config;





















typedef ma_bool32 (* ma_enum_devices_callback_proc)(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pInfo, void* pUserData);

struct ma_context
{
ma_backend backend; 
ma_log_proc logCallback;
ma_thread_priority threadPriority;
void* pUserData;
ma_allocation_callbacks allocationCallbacks;
ma_mutex deviceEnumLock; 
ma_mutex deviceInfoLock; 
ma_uint32 deviceInfoCapacity; 
ma_uint32 playbackDeviceInfoCount;
ma_uint32 captureDeviceInfoCount;
ma_device_info* pDeviceInfos; 
ma_bool32 isBackendAsynchronous : 1; 

ma_result (* onUninit )(ma_context* pContext);
ma_bool32 (* onDeviceIDEqual )(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1);
ma_result (* onEnumDevices )(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData); 
ma_result (* onGetDeviceInfo )(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo);
ma_result (* onDeviceInit )(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice);
void (* onDeviceUninit )(ma_device* pDevice);
ma_result (* onDeviceStart )(ma_device* pDevice);
ma_result (* onDeviceStop )(ma_device* pDevice);
ma_result (* onDeviceMainLoop)(ma_device* pDevice);

union
{
#if defined(MA_SUPPORT_WASAPI)
struct
{
int _unused;
} wasapi;
#endif
#if defined(MA_SUPPORT_DSOUND)
struct
{
ma_handle hDSoundDLL;
ma_proc DirectSoundCreate;
ma_proc DirectSoundEnumerateA;
ma_proc DirectSoundCaptureCreate;
ma_proc DirectSoundCaptureEnumerateA;
} dsound;
#endif
#if defined(MA_SUPPORT_WINMM)
struct
{
ma_handle hWinMM;
ma_proc waveOutGetNumDevs;
ma_proc waveOutGetDevCapsA;
ma_proc waveOutOpen;
ma_proc waveOutClose;
ma_proc waveOutPrepareHeader;
ma_proc waveOutUnprepareHeader;
ma_proc waveOutWrite;
ma_proc waveOutReset;
ma_proc waveInGetNumDevs;
ma_proc waveInGetDevCapsA;
ma_proc waveInOpen;
ma_proc waveInClose;
ma_proc waveInPrepareHeader;
ma_proc waveInUnprepareHeader;
ma_proc waveInAddBuffer;
ma_proc waveInStart;
ma_proc waveInReset;
} winmm;
#endif
#if defined(MA_SUPPORT_ALSA)
struct
{
ma_handle asoundSO;
ma_proc snd_pcm_open;
ma_proc snd_pcm_close;
ma_proc snd_pcm_hw_params_sizeof;
ma_proc snd_pcm_hw_params_any;
ma_proc snd_pcm_hw_params_set_format;
ma_proc snd_pcm_hw_params_set_format_first;
ma_proc snd_pcm_hw_params_get_format_mask;
ma_proc snd_pcm_hw_params_set_channels_near;
ma_proc snd_pcm_hw_params_set_rate_resample;
ma_proc snd_pcm_hw_params_set_rate_near;
ma_proc snd_pcm_hw_params_set_buffer_size_near;
ma_proc snd_pcm_hw_params_set_periods_near;
ma_proc snd_pcm_hw_params_set_access;
ma_proc snd_pcm_hw_params_get_format;
ma_proc snd_pcm_hw_params_get_channels;
ma_proc snd_pcm_hw_params_get_channels_min;
ma_proc snd_pcm_hw_params_get_channels_max;
ma_proc snd_pcm_hw_params_get_rate;
ma_proc snd_pcm_hw_params_get_rate_min;
ma_proc snd_pcm_hw_params_get_rate_max;
ma_proc snd_pcm_hw_params_get_buffer_size;
ma_proc snd_pcm_hw_params_get_periods;
ma_proc snd_pcm_hw_params_get_access;
ma_proc snd_pcm_hw_params;
ma_proc snd_pcm_sw_params_sizeof;
ma_proc snd_pcm_sw_params_current;
ma_proc snd_pcm_sw_params_get_boundary;
ma_proc snd_pcm_sw_params_set_avail_min;
ma_proc snd_pcm_sw_params_set_start_threshold;
ma_proc snd_pcm_sw_params_set_stop_threshold;
ma_proc snd_pcm_sw_params;
ma_proc snd_pcm_format_mask_sizeof;
ma_proc snd_pcm_format_mask_test;
ma_proc snd_pcm_get_chmap;
ma_proc snd_pcm_state;
ma_proc snd_pcm_prepare;
ma_proc snd_pcm_start;
ma_proc snd_pcm_drop;
ma_proc snd_pcm_drain;
ma_proc snd_device_name_hint;
ma_proc snd_device_name_get_hint;
ma_proc snd_card_get_index;
ma_proc snd_device_name_free_hint;
ma_proc snd_pcm_mmap_begin;
ma_proc snd_pcm_mmap_commit;
ma_proc snd_pcm_recover;
ma_proc snd_pcm_readi;
ma_proc snd_pcm_writei;
ma_proc snd_pcm_avail;
ma_proc snd_pcm_avail_update;
ma_proc snd_pcm_wait;
ma_proc snd_pcm_info;
ma_proc snd_pcm_info_sizeof;
ma_proc snd_pcm_info_get_name;
ma_proc snd_config_update_free_global;

ma_mutex internalDeviceEnumLock;
ma_bool32 useVerboseDeviceEnumeration;
} alsa;
#endif
#if defined(MA_SUPPORT_PULSEAUDIO)
struct
{
ma_handle pulseSO;
ma_proc pa_mainloop_new;
ma_proc pa_mainloop_free;
ma_proc pa_mainloop_get_api;
ma_proc pa_mainloop_iterate;
ma_proc pa_mainloop_wakeup;
ma_proc pa_context_new;
ma_proc pa_context_unref;
ma_proc pa_context_connect;
ma_proc pa_context_disconnect;
ma_proc pa_context_set_state_callback;
ma_proc pa_context_get_state;
ma_proc pa_context_get_sink_info_list;
ma_proc pa_context_get_source_info_list;
ma_proc pa_context_get_sink_info_by_name;
ma_proc pa_context_get_source_info_by_name;
ma_proc pa_operation_unref;
ma_proc pa_operation_get_state;
ma_proc pa_channel_map_init_extend;
ma_proc pa_channel_map_valid;
ma_proc pa_channel_map_compatible;
ma_proc pa_stream_new;
ma_proc pa_stream_unref;
ma_proc pa_stream_connect_playback;
ma_proc pa_stream_connect_record;
ma_proc pa_stream_disconnect;
ma_proc pa_stream_get_state;
ma_proc pa_stream_get_sample_spec;
ma_proc pa_stream_get_channel_map;
ma_proc pa_stream_get_buffer_attr;
ma_proc pa_stream_set_buffer_attr;
ma_proc pa_stream_get_device_name;
ma_proc pa_stream_set_write_callback;
ma_proc pa_stream_set_read_callback;
ma_proc pa_stream_flush;
ma_proc pa_stream_drain;
ma_proc pa_stream_is_corked;
ma_proc pa_stream_cork;
ma_proc pa_stream_trigger;
ma_proc pa_stream_begin_write;
ma_proc pa_stream_write;
ma_proc pa_stream_peek;
ma_proc pa_stream_drop;
ma_proc pa_stream_writable_size;
ma_proc pa_stream_readable_size;

char* pApplicationName;
char* pServerName;
ma_bool32 tryAutoSpawn;
} pulse;
#endif
#if defined(MA_SUPPORT_JACK)
struct
{
ma_handle jackSO;
ma_proc jack_client_open;
ma_proc jack_client_close;
ma_proc jack_client_name_size;
ma_proc jack_set_process_callback;
ma_proc jack_set_buffer_size_callback;
ma_proc jack_on_shutdown;
ma_proc jack_get_sample_rate;
ma_proc jack_get_buffer_size;
ma_proc jack_get_ports;
ma_proc jack_activate;
ma_proc jack_deactivate;
ma_proc jack_connect;
ma_proc jack_port_register;
ma_proc jack_port_name;
ma_proc jack_port_get_buffer;
ma_proc jack_free;

char* pClientName;
ma_bool32 tryStartServer;
} jack;
#endif
#if defined(MA_SUPPORT_COREAUDIO)
struct
{
ma_handle hCoreFoundation;
ma_proc CFStringGetCString;
ma_proc CFRelease;

ma_handle hCoreAudio;
ma_proc AudioObjectGetPropertyData;
ma_proc AudioObjectGetPropertyDataSize;
ma_proc AudioObjectSetPropertyData;
ma_proc AudioObjectAddPropertyListener;
ma_proc AudioObjectRemovePropertyListener;

ma_handle hAudioUnit; 
ma_proc AudioComponentFindNext;
ma_proc AudioComponentInstanceDispose;
ma_proc AudioComponentInstanceNew;
ma_proc AudioOutputUnitStart;
ma_proc AudioOutputUnitStop;
ma_proc AudioUnitAddPropertyListener;
ma_proc AudioUnitGetPropertyInfo;
ma_proc AudioUnitGetProperty;
ma_proc AudioUnitSetProperty;
ma_proc AudioUnitInitialize;
ma_proc AudioUnitRender;

ma_ptr component;
} coreaudio;
#endif
#if defined(MA_SUPPORT_SNDIO)
struct
{
ma_handle sndioSO;
ma_proc sio_open;
ma_proc sio_close;
ma_proc sio_setpar;
ma_proc sio_getpar;
ma_proc sio_getcap;
ma_proc sio_start;
ma_proc sio_stop;
ma_proc sio_read;
ma_proc sio_write;
ma_proc sio_onmove;
ma_proc sio_nfds;
ma_proc sio_pollfd;
ma_proc sio_revents;
ma_proc sio_eof;
ma_proc sio_setvol;
ma_proc sio_onvol;
ma_proc sio_initpar;
} sndio;
#endif
#if defined(MA_SUPPORT_AUDIO4)
struct
{
int _unused;
} audio4;
#endif
#if defined(MA_SUPPORT_OSS)
struct
{
int versionMajor;
int versionMinor;
} oss;
#endif
#if defined(MA_SUPPORT_AAUDIO)
struct
{
ma_handle hAAudio; 
ma_proc AAudio_createStreamBuilder;
ma_proc AAudioStreamBuilder_delete;
ma_proc AAudioStreamBuilder_setDeviceId;
ma_proc AAudioStreamBuilder_setDirection;
ma_proc AAudioStreamBuilder_setSharingMode;
ma_proc AAudioStreamBuilder_setFormat;
ma_proc AAudioStreamBuilder_setChannelCount;
ma_proc AAudioStreamBuilder_setSampleRate;
ma_proc AAudioStreamBuilder_setBufferCapacityInFrames;
ma_proc AAudioStreamBuilder_setFramesPerDataCallback;
ma_proc AAudioStreamBuilder_setDataCallback;
ma_proc AAudioStreamBuilder_setErrorCallback;
ma_proc AAudioStreamBuilder_setPerformanceMode;
ma_proc AAudioStreamBuilder_openStream;
ma_proc AAudioStream_close;
ma_proc AAudioStream_getState;
ma_proc AAudioStream_waitForStateChange;
ma_proc AAudioStream_getFormat;
ma_proc AAudioStream_getChannelCount;
ma_proc AAudioStream_getSampleRate;
ma_proc AAudioStream_getBufferCapacityInFrames;
ma_proc AAudioStream_getFramesPerDataCallback;
ma_proc AAudioStream_getFramesPerBurst;
ma_proc AAudioStream_requestStart;
ma_proc AAudioStream_requestStop;
} aaudio;
#endif
#if defined(MA_SUPPORT_OPENSL)
struct
{
int _unused;
} opensl;
#endif
#if defined(MA_SUPPORT_WEBAUDIO)
struct
{
int _unused;
} webaudio;
#endif
#if defined(MA_SUPPORT_NULL)
struct
{
int _unused;
} null_backend;
#endif
};

union
{
#if defined(MA_WIN32)
struct
{
ma_handle hOle32DLL;
ma_proc CoInitializeEx;
ma_proc CoUninitialize;
ma_proc CoCreateInstance;
ma_proc CoTaskMemFree;
ma_proc PropVariantClear;
ma_proc StringFromGUID2;

ma_handle hUser32DLL;
ma_proc GetForegroundWindow;
ma_proc GetDesktopWindow;

ma_handle hAdvapi32DLL;
ma_proc RegOpenKeyExA;
ma_proc RegCloseKey;
ma_proc RegQueryValueExA;
} win32;
#endif
#if defined(MA_POSIX)
struct
{
ma_handle pthreadSO;
ma_proc pthread_create;
ma_proc pthread_join;
ma_proc pthread_mutex_init;
ma_proc pthread_mutex_destroy;
ma_proc pthread_mutex_lock;
ma_proc pthread_mutex_unlock;
ma_proc pthread_cond_init;
ma_proc pthread_cond_destroy;
ma_proc pthread_cond_wait;
ma_proc pthread_cond_signal;
ma_proc pthread_attr_init;
ma_proc pthread_attr_destroy;
ma_proc pthread_attr_setschedpolicy;
ma_proc pthread_attr_getschedparam;
ma_proc pthread_attr_setschedparam;
} posix;
#endif
int _unused;
};
};

struct ma_device
{
ma_context* pContext;
ma_device_type type;
ma_uint32 sampleRate;
volatile ma_uint32 state; 
ma_device_callback_proc onData; 
ma_stop_proc onStop; 
void* pUserData; 
ma_mutex lock;
ma_event wakeupEvent;
ma_event startEvent;
ma_event stopEvent;
ma_thread thread;
ma_result workResult; 
ma_bool32 usingDefaultSampleRate : 1;
ma_bool32 usingDefaultBufferSize : 1;
ma_bool32 usingDefaultPeriods : 1;
ma_bool32 isOwnerOfContext : 1; 
ma_bool32 noPreZeroedOutputBuffer : 1;
ma_bool32 noClip : 1;
volatile float masterVolumeFactor; 
struct
{
ma_resample_algorithm algorithm;
struct
{
ma_uint32 lpfCount;
} linear;
struct
{
int quality;
} speex;
} resampling;
struct
{
char name[256]; 
ma_share_mode shareMode; 
ma_bool32 usingDefaultFormat : 1;
ma_bool32 usingDefaultChannels : 1;
ma_bool32 usingDefaultChannelMap : 1;
ma_format format;
ma_uint32 channels;
ma_channel channelMap[MA_MAX_CHANNELS];
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_channel internalChannelMap[MA_MAX_CHANNELS];
ma_uint32 internalPeriodSizeInFrames;
ma_uint32 internalPeriods;
ma_data_converter converter;
} playback;
struct
{
char name[256]; 
ma_share_mode shareMode; 
ma_bool32 usingDefaultFormat : 1;
ma_bool32 usingDefaultChannels : 1;
ma_bool32 usingDefaultChannelMap : 1;
ma_format format;
ma_uint32 channels;
ma_channel channelMap[MA_MAX_CHANNELS];
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_channel internalChannelMap[MA_MAX_CHANNELS];
ma_uint32 internalPeriodSizeInFrames;
ma_uint32 internalPeriods;
ma_data_converter converter;
} capture;

union
{
#if defined(MA_SUPPORT_WASAPI)
struct
{
ma_ptr pAudioClientPlayback;
ma_ptr pAudioClientCapture;
ma_ptr pRenderClient;
ma_ptr pCaptureClient;
ma_ptr pDeviceEnumerator; 
ma_IMMNotificationClient notificationClient;
ma_handle hEventPlayback; 
ma_handle hEventCapture; 
ma_uint32 actualPeriodSizeInFramesPlayback; 
ma_uint32 actualPeriodSizeInFramesCapture;
ma_uint32 originalPeriodSizeInFrames;
ma_uint32 originalPeriodSizeInMilliseconds;
ma_uint32 originalPeriods;
ma_bool32 hasDefaultPlaybackDeviceChanged; 
ma_bool32 hasDefaultCaptureDeviceChanged; 
ma_uint32 periodSizeInFramesPlayback;
ma_uint32 periodSizeInFramesCapture;
ma_bool32 isStartedCapture; 
ma_bool32 isStartedPlayback; 
ma_bool32 noAutoConvertSRC : 1; 
ma_bool32 noDefaultQualitySRC : 1; 
ma_bool32 noHardwareOffloading : 1;
ma_bool32 allowCaptureAutoStreamRouting : 1;
ma_bool32 allowPlaybackAutoStreamRouting : 1;
} wasapi;
#endif
#if defined(MA_SUPPORT_DSOUND)
struct
{
ma_ptr pPlayback;
ma_ptr pPlaybackPrimaryBuffer;
ma_ptr pPlaybackBuffer;
ma_ptr pCapture;
ma_ptr pCaptureBuffer;
} dsound;
#endif
#if defined(MA_SUPPORT_WINMM)
struct
{
ma_handle hDevicePlayback;
ma_handle hDeviceCapture;
ma_handle hEventPlayback;
ma_handle hEventCapture;
ma_uint32 fragmentSizeInFrames;
ma_uint32 fragmentSizeInBytes;
ma_uint32 iNextHeaderPlayback; 
ma_uint32 iNextHeaderCapture; 
ma_uint32 headerFramesConsumedPlayback; 
ma_uint32 headerFramesConsumedCapture; 
ma_uint8* pWAVEHDRPlayback; 
ma_uint8* pWAVEHDRCapture; 
ma_uint8* pIntermediaryBufferPlayback;
ma_uint8* pIntermediaryBufferCapture;
ma_uint8* _pHeapData; 
} winmm;
#endif
#if defined(MA_SUPPORT_ALSA)
struct
{
ma_ptr pPCMPlayback;
ma_ptr pPCMCapture;
ma_bool32 isUsingMMapPlayback : 1;
ma_bool32 isUsingMMapCapture : 1;
} alsa;
#endif
#if defined(MA_SUPPORT_PULSEAUDIO)
struct
{
ma_ptr pMainLoop;
ma_ptr pAPI;
ma_ptr pPulseContext;
ma_ptr pStreamPlayback;
ma_ptr pStreamCapture;
ma_uint32 pulseContextState;
void* pMappedBufferPlayback;
const void* pMappedBufferCapture;
ma_uint32 mappedBufferFramesRemainingPlayback;
ma_uint32 mappedBufferFramesRemainingCapture;
ma_uint32 mappedBufferFramesCapacityPlayback;
ma_uint32 mappedBufferFramesCapacityCapture;
ma_bool32 breakFromMainLoop : 1;
} pulse;
#endif
#if defined(MA_SUPPORT_JACK)
struct
{
ma_ptr pClient;
ma_ptr pPortsPlayback[MA_MAX_CHANNELS];
ma_ptr pPortsCapture[MA_MAX_CHANNELS];
float* pIntermediaryBufferPlayback; 
float* pIntermediaryBufferCapture;
ma_pcm_rb duplexRB;
} jack;
#endif
#if defined(MA_SUPPORT_COREAUDIO)
struct
{
ma_uint32 deviceObjectIDPlayback;
ma_uint32 deviceObjectIDCapture;
ma_ptr audioUnitPlayback;
ma_ptr audioUnitCapture;
ma_ptr pAudioBufferList; 
ma_event stopEvent;
ma_uint32 originalPeriodSizeInFrames;
ma_uint32 originalPeriodSizeInMilliseconds;
ma_uint32 originalPeriods;
ma_bool32 isDefaultPlaybackDevice;
ma_bool32 isDefaultCaptureDevice;
ma_bool32 isSwitchingPlaybackDevice; 
ma_bool32 isSwitchingCaptureDevice; 
ma_pcm_rb duplexRB;
void* pRouteChangeHandler; 
} coreaudio;
#endif
#if defined(MA_SUPPORT_SNDIO)
struct
{
ma_ptr handlePlayback;
ma_ptr handleCapture;
ma_bool32 isStartedPlayback;
ma_bool32 isStartedCapture;
} sndio;
#endif
#if defined(MA_SUPPORT_AUDIO4)
struct
{
int fdPlayback;
int fdCapture;
} audio4;
#endif
#if defined(MA_SUPPORT_OSS)
struct
{
int fdPlayback;
int fdCapture;
} oss;
#endif
#if defined(MA_SUPPORT_AAUDIO)
struct
{
ma_ptr pStreamPlayback;
ma_ptr pStreamCapture;
ma_pcm_rb duplexRB;
} aaudio;
#endif
#if defined(MA_SUPPORT_OPENSL)
struct
{
ma_ptr pOutputMixObj;
ma_ptr pOutputMix;
ma_ptr pAudioPlayerObj;
ma_ptr pAudioPlayer;
ma_ptr pAudioRecorderObj;
ma_ptr pAudioRecorder;
ma_ptr pBufferQueuePlayback;
ma_ptr pBufferQueueCapture;
ma_bool32 isDrainingCapture;
ma_bool32 isDrainingPlayback;
ma_uint32 currentBufferIndexPlayback;
ma_uint32 currentBufferIndexCapture;
ma_uint8* pBufferPlayback; 
ma_uint8* pBufferCapture;
ma_pcm_rb duplexRB;
} opensl;
#endif
#if defined(MA_SUPPORT_WEBAUDIO)
struct
{
int indexPlayback; 
int indexCapture;
ma_pcm_rb duplexRB; 
} webaudio;
#endif
#if defined(MA_SUPPORT_NULL)
struct
{
ma_thread deviceThread;
ma_event operationEvent;
ma_event operationCompletionEvent;
ma_uint32 operation;
ma_result operationResult;
ma_timer timer;
double priorRunTime;
ma_uint32 currentPeriodFramesRemainingPlayback;
ma_uint32 currentPeriodFramesRemainingCapture;
ma_uint64 lastProcessedFramePlayback;
ma_uint32 lastProcessedFrameCapture;
ma_bool32 isStarted;
} null_device;
#endif
};
};
#if defined(_MSC_VER) && !defined(__clang__)
#pragma warning(pop)
#else
#pragma GCC diagnostic pop 
#endif






















ma_context_config ma_context_config_init(void);



































































































































































































ma_result ma_context_init(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pConfig, ma_context* pContext);
























ma_result ma_context_uninit(ma_context* pContext);


































































ma_result ma_context_enumerate_devices(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData);


















































ma_result ma_context_get_devices(ma_context* pContext, ma_device_info** ppPlaybackDeviceInfos, ma_uint32* pPlaybackDeviceCount, ma_device_info** ppCaptureDeviceInfos, ma_uint32* pCaptureDeviceCount);













































ma_result ma_context_get_device_info(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo);















ma_bool32 ma_context_is_loopback_supported(ma_context* pContext);



































































ma_device_config ma_device_config_init(ma_device_type deviceType);



















































































































































































































































































ma_result ma_device_init(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice);

























































ma_result ma_device_init_ex(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pContextConfig, const ma_device_config* pConfig, ma_device* pDevice);

































void ma_device_uninit(ma_device* pDevice);










































ma_result ma_device_start(ma_device* pDevice);















































ma_result ma_device_stop(ma_device* pDevice);
































ma_bool32 ma_device_is_started(ma_device* pDevice);















































ma_result ma_device_set_master_volume(ma_device* pDevice, float volume);










































ma_result ma_device_get_master_volume(ma_device* pDevice, float* pVolume);














































ma_result ma_device_set_master_gain_db(ma_device* pDevice, float gainDB);










































ma_result ma_device_get_master_gain_db(ma_device* pDevice, float* pGainDB);














ma_result ma_mutex_init(ma_context* pContext, ma_mutex* pMutex);




void ma_mutex_uninit(ma_mutex* pMutex);




void ma_mutex_lock(ma_mutex* pMutex);




void ma_mutex_unlock(ma_mutex* pMutex);





const char* ma_get_backend_name(ma_backend backend);




ma_bool32 ma_is_loopback_supported(ma_backend backend);







ma_uint32 ma_scale_buffer_size(ma_uint32 baseBufferSize, float scale);




ma_uint32 ma_calculate_buffer_size_in_milliseconds_from_frames(ma_uint32 bufferSizeInFrames, ma_uint32 sampleRate);




ma_uint32 ma_calculate_buffer_size_in_frames_from_milliseconds(ma_uint32 bufferSizeInMilliseconds, ma_uint32 sampleRate);




void ma_zero_pcm_frames(void* p, ma_uint32 frameCount, ma_format format, ma_uint32 channels);




void ma_clip_samples_f32(float* p, ma_uint32 sampleCount);
MA_INLINE void ma_clip_pcm_frames_f32(float* p, ma_uint32 frameCount, ma_uint32 channels) { ma_clip_samples_f32(p, frameCount*channels); }






void ma_copy_and_apply_volume_factor_u8(ma_uint8* pSamplesOut, const ma_uint8* pSamplesIn, ma_uint32 sampleCount, float factor);
void ma_copy_and_apply_volume_factor_s16(ma_int16* pSamplesOut, const ma_int16* pSamplesIn, ma_uint32 sampleCount, float factor);
void ma_copy_and_apply_volume_factor_s24(void* pSamplesOut, const void* pSamplesIn, ma_uint32 sampleCount, float factor);
void ma_copy_and_apply_volume_factor_s32(ma_int32* pSamplesOut, const ma_int32* pSamplesIn, ma_uint32 sampleCount, float factor);
void ma_copy_and_apply_volume_factor_f32(float* pSamplesOut, const float* pSamplesIn, ma_uint32 sampleCount, float factor);

void ma_apply_volume_factor_u8(ma_uint8* pSamples, ma_uint32 sampleCount, float factor);
void ma_apply_volume_factor_s16(ma_int16* pSamples, ma_uint32 sampleCount, float factor);
void ma_apply_volume_factor_s24(void* pSamples, ma_uint32 sampleCount, float factor);
void ma_apply_volume_factor_s32(ma_int32* pSamples, ma_uint32 sampleCount, float factor);
void ma_apply_volume_factor_f32(float* pSamples, ma_uint32 sampleCount, float factor);

void ma_copy_and_apply_volume_factor_pcm_frames_u8(ma_uint8* pPCMFramesOut, const ma_uint8* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_copy_and_apply_volume_factor_pcm_frames_s16(ma_int16* pPCMFramesOut, const ma_int16* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_copy_and_apply_volume_factor_pcm_frames_s24(void* pPCMFramesOut, const void* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_copy_and_apply_volume_factor_pcm_frames_s32(ma_int32* pPCMFramesOut, const ma_int32* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_copy_and_apply_volume_factor_pcm_frames_f32(float* pPCMFramesOut, const float* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_copy_and_apply_volume_factor_pcm_frames(void* pFramesOut, const void* pFramesIn, ma_uint32 frameCount, ma_format format, ma_uint32 channels, float factor);

void ma_apply_volume_factor_pcm_frames_u8(ma_uint8* pFrames, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_apply_volume_factor_pcm_frames_s16(ma_int16* pFrames, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_apply_volume_factor_pcm_frames_s24(void* pFrames, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_apply_volume_factor_pcm_frames_s32(ma_int32* pFrames, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_apply_volume_factor_pcm_frames_f32(float* pFrames, ma_uint32 frameCount, ma_uint32 channels, float factor);
void ma_apply_volume_factor_pcm_frames(void* pFrames, ma_uint32 frameCount, ma_format format, ma_uint32 channels, float factor);





float ma_factor_to_gain_db(float factor);




float ma_gain_db_to_factor(float gain);

#endif 













#if !defined(MA_NO_DECODING)

typedef struct ma_decoder ma_decoder;

typedef enum
{
ma_seek_origin_start,
ma_seek_origin_current
} ma_seek_origin;

typedef size_t (* ma_decoder_read_proc) (ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead); 
typedef ma_bool32 (* ma_decoder_seek_proc) (ma_decoder* pDecoder, int byteOffset, ma_seek_origin origin);
typedef ma_uint64 (* ma_decoder_read_pcm_frames_proc) (ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount); 
typedef ma_result (* ma_decoder_seek_to_pcm_frame_proc) (ma_decoder* pDecoder, ma_uint64 frameIndex);
typedef ma_result (* ma_decoder_uninit_proc) (ma_decoder* pDecoder);
typedef ma_uint64 (* ma_decoder_get_length_in_pcm_frames_proc)(ma_decoder* pDecoder);

typedef struct
{
ma_format format; 
ma_uint32 channels; 
ma_uint32 sampleRate; 
ma_channel channelMap[MA_MAX_CHANNELS];
ma_channel_mix_mode channelMixMode;
ma_dither_mode ditherMode;
struct
{
ma_resample_algorithm algorithm;
struct
{
ma_uint32 lpfCount;
} linear;
struct
{
int quality;
} speex;
} resampling;
ma_allocation_callbacks allocationCallbacks;
} ma_decoder_config;

struct ma_decoder
{
ma_decoder_read_proc onRead;
ma_decoder_seek_proc onSeek;
void* pUserData;
ma_uint64 readPointer; 
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_channel internalChannelMap[MA_MAX_CHANNELS];
ma_format outputFormat;
ma_uint32 outputChannels;
ma_uint32 outputSampleRate;
ma_channel outputChannelMap[MA_MAX_CHANNELS];
ma_data_converter converter; 
ma_allocation_callbacks allocationCallbacks;
ma_decoder_read_pcm_frames_proc onReadPCMFrames;
ma_decoder_seek_to_pcm_frame_proc onSeekToPCMFrame;
ma_decoder_uninit_proc onUninit;
ma_decoder_get_length_in_pcm_frames_proc onGetLengthInPCMFrames;
void* pInternalDecoder; 
struct
{
const ma_uint8* pData;
size_t dataSize;
size_t currentReadPos;
} memory; 
};

ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate);

ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_wav(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_flac(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_vorbis(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_mp3(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_raw(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfigIn, const ma_decoder_config* pConfigOut, ma_decoder* pDecoder);

ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_memory_wav(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_memory_flac(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_memory_vorbis(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_memory_mp3(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_memory_raw(const void* pData, size_t dataSize, const ma_decoder_config* pConfigIn, const ma_decoder_config* pConfigOut, ma_decoder* pDecoder);

#if !defined(MA_NO_STDIO)
ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_wav(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_flac(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_vorbis(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_mp3(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);

ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_wav_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_flac_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_vorbis_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
ma_result ma_decoder_init_file_mp3_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
#endif

ma_result ma_decoder_uninit(ma_decoder* pDecoder);















ma_uint64 ma_decoder_get_length_in_pcm_frames(ma_decoder* pDecoder);






ma_uint64 ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount);






ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex);





#if !defined(MA_NO_STDIO)
ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppDataOut);
#endif
ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppDataOut);

#endif 







typedef enum
{
ma_waveform_type_sine,
ma_waveform_type_square,
ma_waveform_type_triangle,
ma_waveform_type_sawtooth
} ma_waveform_type;

typedef struct
{
ma_waveform_type type;
double amplitude;
double frequency;
double deltaTime;
double time;
} ma_waveform;

ma_result ma_waveform_init(ma_waveform_type type, double amplitude, double frequency, ma_uint32 sampleRate, ma_waveform* pWaveform);
ma_uint64 ma_waveform_read_pcm_frames(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels);
ma_result ma_waveform_set_amplitude(ma_waveform* pWaveform, double amplitude);
ma_result ma_waveform_set_frequency(ma_waveform* pWaveform, double frequency);
ma_result ma_waveform_set_sample_rate(ma_waveform* pWaveform, ma_uint32 sampleRate);

#if defined(__cplusplus)
}
#endif
#endif 










#if defined(MINIAUDIO_IMPLEMENTATION) || defined(MA_IMPLEMENTATION)
#include <assert.h>
#include <limits.h> 
#include <math.h> 

#if !defined(MA_NO_STDIO) || defined(MA_DEBUG_OUTPUT)
#include <stdio.h>
#if !defined(_MSC_VER) && !defined(__DMC__)
#include <strings.h> 
#include <wchar.h> 
#endif
#endif

#if defined(MA_WIN32)
#include <windows.h>
#include <objbase.h>
#include <mmreg.h>
#include <mmsystem.h>
#else
#include <stdlib.h> 
#include <string.h> 
#endif

#if defined(MA_APPLE) && (__MAC_OS_X_VERSION_MIN_REQUIRED < 101200)
#include <mach/mach_time.h> 
#endif

#if defined(MA_POSIX)
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <dlfcn.h>
#endif

#if defined(MA_EMSCRIPTEN)
#include <emscripten/emscripten.h>
#endif

#if !defined(MA_64BIT) && !defined(MA_32BIT)
#if defined(_WIN32)
#if defined(_WIN64)
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif
#endif

#if !defined(MA_64BIT) && !defined(MA_32BIT)
#if defined(__GNUC__)
#if defined(__LP64__)
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif
#endif

#if !defined(MA_64BIT) && !defined(MA_32BIT)
#include <stdint.h>
#if INTPTR_MAX == INT64_MAX
#define MA_64BIT
#else
#define MA_32BIT
#endif
#endif


#if defined(__x86_64__) || defined(_M_X64)
#define MA_X64
#elif defined(__i386) || defined(_M_IX86)
#define MA_X86
#elif defined(__arm__) || defined(_M_ARM)
#define MA_ARM
#endif


#if !defined(MA_NO_AVX512) && defined(MA_NO_AVX2)
#define MA_NO_AVX512
#endif


#if defined(MA_X64) || defined(MA_X86)
#if defined(_MSC_VER) && !defined(__clang__)

#if _MSC_VER >= 1400 && !defined(MA_NO_SSE2) 
#define MA_SUPPORT_SSE2
#endif



#if _MSC_VER >= 1700 && !defined(MA_NO_AVX2) 
#define MA_SUPPORT_AVX2
#endif
#if _MSC_VER >= 1910 && !defined(MA_NO_AVX512) 
#define MA_SUPPORT_AVX512
#endif
#else

#if defined(__SSE2__) && !defined(MA_NO_SSE2)
#define MA_SUPPORT_SSE2
#endif



#if defined(__AVX2__) && !defined(MA_NO_AVX2)
#define MA_SUPPORT_AVX2
#endif
#if defined(__AVX512F__) && !defined(MA_NO_AVX512)
#define MA_SUPPORT_AVX512
#endif
#endif


#if !defined(__GNUC__) && !defined(__clang__) && defined(__has_include)
#if !defined(MA_SUPPORT_SSE2) && !defined(MA_NO_SSE2) && __has_include(<emmintrin.h>)
#define MA_SUPPORT_SSE2
#endif



#if !defined(MA_SUPPORT_AVX2) && !defined(MA_NO_AVX2) && __has_include(<immintrin.h>)
#define MA_SUPPORT_AVX2
#endif
#if !defined(MA_SUPPORT_AVX512) && !defined(MA_NO_AVX512) && __has_include(<zmmintrin.h>)
#define MA_SUPPORT_AVX512
#endif
#endif

#if defined(MA_SUPPORT_AVX512)
#include <immintrin.h> 
#elif defined(MA_SUPPORT_AVX2) || defined(MA_SUPPORT_AVX)
#include <immintrin.h>
#elif defined(MA_SUPPORT_SSE2)
#include <emmintrin.h>
#endif
#endif

#if defined(MA_ARM)
#if !defined(MA_NO_NEON) && (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
#define MA_SUPPORT_NEON
#endif


#if !defined(__GNUC__) && !defined(__clang__) && defined(__has_include)
#if !defined(MA_SUPPORT_NEON) && !defined(MA_NO_NEON) && __has_include(<arm_neon.h>)
#define MA_SUPPORT_NEON
#endif
#endif

#if defined(MA_SUPPORT_NEON)
#include <arm_neon.h>
#endif
#endif


#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4752) 
#endif

#if defined(MA_X64) || defined(MA_X86)
#if defined(_MSC_VER) && !defined(__clang__)
#if _MSC_VER >= 1400
#include <intrin.h>
static MA_INLINE void ma_cpuid(int info[4], int fid)
{
__cpuid(info, fid);
}
#else
#define MA_NO_CPUID
#endif

#if _MSC_VER >= 1600 && (defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219)
static MA_INLINE unsigned __int64 ma_xgetbv(int reg)
{
return _xgetbv(reg);
}
#else
#define MA_NO_XGETBV
#endif
#elif (defined(__GNUC__) || defined(__clang__)) && !defined(MA_ANDROID)
static MA_INLINE void ma_cpuid(int info[4], int fid)
{







#if defined(DRFLAC_X86) && defined(__PIC__)
__asm__ __volatile__ (
"xchg{l} {%%}ebx, %k1;"
"cpuid;"
"xchg{l} {%%}ebx, %k1;"
: "=a"(info[0]), "=&r"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
);
#else
__asm__ __volatile__ (
"cpuid" : "=a"(info[0]), "=b"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(fid), "c"(0)
);
#endif
}

static MA_INLINE ma_uint64 ma_xgetbv(int reg)
{
unsigned int hi;
unsigned int lo;

__asm__ __volatile__ (
"xgetbv" : "=a"(lo), "=d"(hi) : "c"(reg)
);

return ((ma_uint64)hi << 32) | (ma_uint64)lo;
}
#else
#define MA_NO_CPUID
#define MA_NO_XGETBV
#endif
#else
#define MA_NO_CPUID
#define MA_NO_XGETBV
#endif

static MA_INLINE ma_bool32 ma_has_sse2()
{
#if defined(MA_SUPPORT_SSE2)
#if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_SSE2)
#if defined(MA_X64)
return MA_TRUE; 
#elif (defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__)
return MA_TRUE; 
#else
#if defined(MA_NO_CPUID)
return MA_FALSE;
#else
int info[4];
ma_cpuid(info, 1);
return (info[3] & (1 << 26)) != 0;
#endif
#endif
#else
return MA_FALSE; 
#endif
#else
return MA_FALSE; 
#endif
}

#if 0
static MA_INLINE ma_bool32 ma_has_avx()
{
#if defined(MA_SUPPORT_AVX)
#if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_AVX)
#if defined(_AVX_) || defined(__AVX__)
return MA_TRUE; 
#else

#if defined(MA_NO_CPUID) || defined(MA_NO_XGETBV)
return MA_FALSE;
#else
int info[4];
ma_cpuid(info, 1);
if (((info[2] & (1 << 27)) != 0) && ((info[2] & (1 << 28)) != 0)) {
ma_uint64 xrc = ma_xgetbv(0);
if ((xrc & 0x06) == 0x06) {
return MA_TRUE;
} else {
return MA_FALSE;
}
} else {
return MA_FALSE;
}
#endif
#endif
#else
return MA_FALSE; 
#endif
#else
return MA_FALSE; 
#endif
}
#endif

static MA_INLINE ma_bool32 ma_has_avx2()
{
#if defined(MA_SUPPORT_AVX2)
#if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_AVX2)
#if defined(_AVX2_) || defined(__AVX2__)
return MA_TRUE; 
#else

#if defined(MA_NO_CPUID) || defined(MA_NO_XGETBV)
return MA_FALSE;
#else
int info1[4];
int info7[4];
ma_cpuid(info1, 1);
ma_cpuid(info7, 7);
if (((info1[2] & (1 << 27)) != 0) && ((info7[1] & (1 << 5)) != 0)) {
ma_uint64 xrc = ma_xgetbv(0);
if ((xrc & 0x06) == 0x06) {
return MA_TRUE;
} else {
return MA_FALSE;
}
} else {
return MA_FALSE;
}
#endif
#endif
#else
return MA_FALSE; 
#endif
#else
return MA_FALSE; 
#endif
}

static MA_INLINE ma_bool32 ma_has_avx512f()
{
#if defined(MA_SUPPORT_AVX512)
#if (defined(MA_X64) || defined(MA_X86)) && !defined(MA_NO_AVX512)
#if defined(__AVX512F__)
return MA_TRUE; 
#else

#if defined(MA_NO_CPUID) || defined(MA_NO_XGETBV)
return MA_FALSE;
#else
int info1[4];
int info7[4];
ma_cpuid(info1, 1);
ma_cpuid(info7, 7);
if (((info1[2] & (1 << 27)) != 0) && ((info7[1] & (1 << 16)) != 0)) {
ma_uint64 xrc = ma_xgetbv(0);
if ((xrc & 0xE6) == 0xE6) {
return MA_TRUE;
} else {
return MA_FALSE;
}
} else {
return MA_FALSE;
}
#endif
#endif
#else
return MA_FALSE; 
#endif
#else
return MA_FALSE; 
#endif
}

static MA_INLINE ma_bool32 ma_has_neon()
{
#if defined(MA_SUPPORT_NEON)
#if defined(MA_ARM) && !defined(MA_NO_NEON)
#if (defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64))
return MA_TRUE; 
#else

return MA_FALSE;
#endif
#else
return MA_FALSE; 
#endif
#else
return MA_FALSE; 
#endif
}

#define MA_SIMD_NONE 0
#define MA_SIMD_SSE2 1
#define MA_SIMD_AVX2 2
#define MA_SIMD_NEON 3

#if !defined(MA_PREFERRED_SIMD)
#if defined(MA_SUPPORT_SSE2) && defined(MA_PREFER_SSE2)
#define MA_PREFERRED_SIMD MA_SIMD_SSE2
#elif defined(MA_SUPPORT_AVX2) && defined(MA_PREFER_AVX2)
#define MA_PREFERRED_SIMD MA_SIMD_AVX2
#elif defined(MA_SUPPORT_NEON) && defined(MA_PREFER_NEON)
#define MA_PREFERRED_SIMD MA_SIMD_NEON
#else
#define MA_PREFERRED_SIMD MA_SIMD_NONE
#endif
#endif


static MA_INLINE ma_bool32 ma_is_little_endian()
{
#if defined(MA_X86) || defined(MA_X64)
return MA_TRUE;
#else
int n = 1;
return (*(char*)&n) == 1;
#endif
}

static MA_INLINE ma_bool32 ma_is_big_endian()
{
return !ma_is_little_endian();
}


#if !defined(MA_COINIT_VALUE)
#define MA_COINIT_VALUE 0 
#endif



#if !defined(MA_PI)
#define MA_PI 3.14159265358979323846264f
#endif
#if !defined(MA_PI_D)
#define MA_PI_D 3.14159265358979323846264
#endif
#if !defined(MA_TAU)
#define MA_TAU 6.28318530717958647693f
#endif
#if !defined(MA_TAU_D)
#define MA_TAU_D 6.28318530717958647693
#endif



#if !defined(MA_DEFAULT_FORMAT)
#define MA_DEFAULT_FORMAT ma_format_f32
#endif


#if !defined(MA_DEFAULT_CHANNELS)
#define MA_DEFAULT_CHANNELS 2
#endif


#if !defined(MA_DEFAULT_SAMPLE_RATE)
#define MA_DEFAULT_SAMPLE_RATE 48000
#endif


#if !defined(MA_DEFAULT_PERIODS)
#define MA_DEFAULT_PERIODS 3
#endif


#if !defined(MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY)
#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY 10
#endif


#if !defined(MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE)
#define MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE 100
#endif


#if !defined(MA_DEFAULT_RESAMPLER_LPF_FILTERS)
#if MA_MAX_RESAMPLER_LPF_FILTERS >= 2
#define MA_DEFAULT_RESAMPLER_LPF_FILTERS 2
#else
#define MA_DEFAULT_RESAMPLER_LPF_FILTERS MA_MAX_RESAMPLER_LPF_FILTERS
#endif
#endif



ma_uint32 g_maStandardSampleRatePriorities[] = {
MA_SAMPLE_RATE_48000, 
MA_SAMPLE_RATE_44100,

MA_SAMPLE_RATE_32000, 
MA_SAMPLE_RATE_24000,
MA_SAMPLE_RATE_22050,

MA_SAMPLE_RATE_88200, 
MA_SAMPLE_RATE_96000,
MA_SAMPLE_RATE_176400,
MA_SAMPLE_RATE_192000,

MA_SAMPLE_RATE_16000, 
MA_SAMPLE_RATE_11025,
MA_SAMPLE_RATE_8000,

MA_SAMPLE_RATE_352800, 
MA_SAMPLE_RATE_384000
};

ma_format g_maFormatPriorities[] = {
ma_format_s16, 
ma_format_f32,


ma_format_s32,

ma_format_s24, 

ma_format_u8 
};








#if !defined(MA_MALLOC)
#if defined(MA_WIN32)
#define MA_MALLOC(sz) HeapAlloc(GetProcessHeap(), 0, (sz))
#else
#define MA_MALLOC(sz) malloc((sz))
#endif
#endif

#if !defined(MA_REALLOC)
#if defined(MA_WIN32)
#define MA_REALLOC(p, sz) (((sz) > 0) ? ((p) ? HeapReAlloc(GetProcessHeap(), 0, (p), (sz)) : HeapAlloc(GetProcessHeap(), 0, (sz))) : ((VOID*)(size_t)(HeapFree(GetProcessHeap(), 0, (p)) & 0)))
#else
#define MA_REALLOC(p, sz) realloc((p), (sz))
#endif
#endif

#if !defined(MA_FREE)
#if defined(MA_WIN32)
#define MA_FREE(p) HeapFree(GetProcessHeap(), 0, (p))
#else
#define MA_FREE(p) free((p))
#endif
#endif

#if !defined(MA_ZERO_MEMORY)
#if defined(MA_WIN32)
#define MA_ZERO_MEMORY(p, sz) ZeroMemory((p), (sz))
#else
#define MA_ZERO_MEMORY(p, sz) memset((p), 0, (sz))
#endif
#endif

#if !defined(MA_COPY_MEMORY)
#if defined(MA_WIN32)
#define MA_COPY_MEMORY(dst, src, sz) CopyMemory((dst), (src), (sz))
#else
#define MA_COPY_MEMORY(dst, src, sz) memcpy((dst), (src), (sz))
#endif
#endif

#if !defined(MA_ASSERT)
#if defined(MA_WIN32)
#define MA_ASSERT(condition) assert(condition)
#else
#define MA_ASSERT(condition) assert(condition)
#endif
#endif

#define MA_ZERO_OBJECT(p) MA_ZERO_MEMORY((p), sizeof(*(p)))

#define ma_countof(x) (sizeof(x) / sizeof(x[0]))
#define ma_max(x, y) (((x) > (y)) ? (x) : (y))
#define ma_min(x, y) (((x) < (y)) ? (x) : (y))
#define ma_abs(x) (((x) > 0) ? (x) : -(x))
#define ma_clamp(x, lo, hi) (ma_max(lo, ma_min(x, hi)))
#define ma_offset_ptr(p, offset) (((ma_uint8*)(p)) + (offset))

#define ma_buffer_frame_capacity(buffer, channels, format) (sizeof(buffer) / ma_get_bytes_per_sample(format) / (channels))

static MA_INLINE double ma_sin(double x)
{

return sin(x);
}

static MA_INLINE double ma_cos(double x)
{
return ma_sin((MA_PI*0.5) - x);
}

static MA_INLINE double ma_log(double x)
{

return log(x);
}

static MA_INLINE double ma_pow(double x, double y)
{

return pow(x, y);
}

static MA_INLINE double ma_log10(double x)
{
return ma_log(x) * 0.43429448190325182765;
}

static MA_INLINE float ma_powf(float x, float y)
{
return (float)ma_pow((double)x, (double)y);
}

static MA_INLINE float ma_log10f(float x)
{
return (float)ma_log10((double)x);
}










int ma_strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
{
size_t i;

if (dst == 0) {
return 22;
}
if (dstSizeInBytes == 0) {
return 34;
}
if (src == 0) {
dst[0] = '\0';
return 22;
}

for (i = 0; i < dstSizeInBytes && src[i] != '\0'; ++i) {
dst[i] = src[i];
}

if (i < dstSizeInBytes) {
dst[i] = '\0';
return 0;
}

dst[0] = '\0';
return 34;
}

int ma_strncpy_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
size_t maxcount;
size_t i;

if (dst == 0) {
return 22;
}
if (dstSizeInBytes == 0) {
return 34;
}
if (src == 0) {
dst[0] = '\0';
return 22;
}

maxcount = count;
if (count == ((size_t)-1) || count >= dstSizeInBytes) { 
maxcount = dstSizeInBytes - 1;
}

for (i = 0; i < maxcount && src[i] != '\0'; ++i) {
dst[i] = src[i];
}

if (src[i] == '\0' || i == count || count == ((size_t)-1)) {
dst[i] = '\0';
return 0;
}

dst[0] = '\0';
return 34;
}

int ma_strcat_s(char* dst, size_t dstSizeInBytes, const char* src)
{
char* dstorig;

if (dst == 0) {
return 22;
}
if (dstSizeInBytes == 0) {
return 34;
}
if (src == 0) {
dst[0] = '\0';
return 22;
}

dstorig = dst;

while (dstSizeInBytes > 0 && dst[0] != '\0') {
dst += 1;
dstSizeInBytes -= 1;
}

if (dstSizeInBytes == 0) {
return 22; 
}


while (dstSizeInBytes > 0 && src[0] != '\0') {
*dst++ = *src++;
dstSizeInBytes -= 1;
}

if (dstSizeInBytes > 0) {
dst[0] = '\0';
} else {
dstorig[0] = '\0';
return 34;
}

return 0;
}

int ma_strncat_s(char* dst, size_t dstSizeInBytes, const char* src, size_t count)
{
char* dstorig;

if (dst == 0) {
return 22;
}
if (dstSizeInBytes == 0) {
return 34;
}
if (src == 0) {
return 22;
}

dstorig = dst;

while (dstSizeInBytes > 0 && dst[0] != '\0') {
dst += 1;
dstSizeInBytes -= 1;
}

if (dstSizeInBytes == 0) {
return 22; 
}


if (count == ((size_t)-1)) { 
count = dstSizeInBytes - 1;
}

while (dstSizeInBytes > 0 && src[0] != '\0' && count > 0) {
*dst++ = *src++;
dstSizeInBytes -= 1;
count -= 1;
}

if (dstSizeInBytes > 0) {
dst[0] = '\0';
} else {
dstorig[0] = '\0';
return 34;
}

return 0;
}

int ma_itoa_s(int value, char* dst, size_t dstSizeInBytes, int radix)
{
int sign;
unsigned int valueU;
char* dstEnd;

if (dst == NULL || dstSizeInBytes == 0) {
return 22;
}
if (radix < 2 || radix > 36) {
dst[0] = '\0';
return 22;
}

sign = (value < 0 && radix == 10) ? -1 : 1; 

if (value < 0) {
valueU = -value;
} else {
valueU = value;
}

dstEnd = dst;
do
{
int remainder = valueU % radix;
if (remainder > 9) {
*dstEnd = (char)((remainder - 10) + 'a');
} else {
*dstEnd = (char)(remainder + '0');
}

dstEnd += 1;
dstSizeInBytes -= 1;
valueU /= radix;
} while (dstSizeInBytes > 0 && valueU > 0);

if (dstSizeInBytes == 0) {
dst[0] = '\0';
return 22; 
}

if (sign < 0) {
*dstEnd++ = '-';
dstSizeInBytes -= 1;
}

if (dstSizeInBytes == 0) {
dst[0] = '\0';
return 22; 
}

*dstEnd = '\0';



dstEnd -= 1;
while (dst < dstEnd) {
char temp = *dst;
*dst = *dstEnd;
*dstEnd = temp;

dst += 1;
dstEnd -= 1;
}

return 0;
}

int ma_strcmp(const char* str1, const char* str2)
{
if (str1 == str2) return 0;


if (str1 == NULL) return -1;
if (str2 == NULL) return 1;

for (;;) {
if (str1[0] == '\0') {
break;
}
if (str1[0] != str2[0]) {
break;
}

str1 += 1;
str2 += 1;
}

return ((unsigned char*)str1)[0] - ((unsigned char*)str2)[0];
}

int ma_strappend(char* dst, size_t dstSize, const char* srcA, const char* srcB)
{
int result;

result = ma_strncpy_s(dst, dstSize, srcA, (size_t)-1);
if (result != 0) {
return result;
}

result = ma_strncat_s(dst, dstSize, srcB, (size_t)-1);
if (result != 0) {
return result;
}

return result;
}

char* ma_copy_string(const char* src, const ma_allocation_callbacks* pAllocationCallbacks)
{
size_t sz = strlen(src)+1;
char* dst = (char*)ma_malloc(sz, pAllocationCallbacks);
if (dst == NULL) {
return NULL;
}

ma_strcpy_s(dst, sz, src);

return dst;
}


static MA_INLINE void ma_copy_memory_64(void* dst, const void* src, ma_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MA_SIZE_MAX
MA_COPY_MEMORY(dst, src, (size_t)sizeInBytes);
#else
while (sizeInBytes > 0) {
ma_uint64 bytesToCopyNow = sizeInBytes;
if (bytesToCopyNow > MA_SIZE_MAX) {
bytesToCopyNow = MA_SIZE_MAX;
}

MA_COPY_MEMORY(dst, src, (size_t)bytesToCopyNow); 

sizeInBytes -= bytesToCopyNow;
dst = ( void*)(( ma_uint8*)dst + bytesToCopyNow);
src = (const void*)((const ma_uint8*)src + bytesToCopyNow);
}
#endif
}

static MA_INLINE void ma_zero_memory_64(void* dst, ma_uint64 sizeInBytes)
{
#if 0xFFFFFFFFFFFFFFFF <= MA_SIZE_MAX
MA_ZERO_MEMORY(dst, (size_t)sizeInBytes);
#else
while (sizeInBytes > 0) {
ma_uint64 bytesToZeroNow = sizeInBytes;
if (bytesToZeroNow > MA_SIZE_MAX) {
bytesToZeroNow = MA_SIZE_MAX;
}

MA_ZERO_MEMORY(dst, (size_t)bytesToZeroNow); 

sizeInBytes -= bytesToZeroNow;
dst = (void*)((ma_uint8*)dst + bytesToZeroNow);
}
#endif
}



static MA_INLINE unsigned int ma_next_power_of_2(unsigned int x)
{
x--;
x |= x >> 1;
x |= x >> 2;
x |= x >> 4;
x |= x >> 8;
x |= x >> 16;
x++;

return x;
}

static MA_INLINE unsigned int ma_prev_power_of_2(unsigned int x)
{
return ma_next_power_of_2(x) >> 1;
}

static MA_INLINE unsigned int ma_round_to_power_of_2(unsigned int x)
{
unsigned int prev = ma_prev_power_of_2(x);
unsigned int next = ma_next_power_of_2(x);
if ((next - x) > (x - prev)) {
return prev;
} else {
return next;
}
}

static MA_INLINE unsigned int ma_count_set_bits(unsigned int x)
{
unsigned int count = 0;
while (x != 0) {
if (x & 1) {
count += 1;
}

x = x >> 1;
}

return count;
}




static MA_INLINE float ma_clip_f32(float x)
{
if (x < -1) return -1;
if (x > +1) return +1;
return x;
}

static MA_INLINE float ma_mix_f32(float x, float y, float a)
{
return x*(1-a) + y*a;
}
static MA_INLINE float ma_mix_f32_fast(float x, float y, float a)
{
float r0 = (y - x);
float r1 = r0*a;
return x + r1;

}


#if defined(MA_SUPPORT_SSE2)
static MA_INLINE __m128 ma_mix_f32_fast__sse2(__m128 x, __m128 y, __m128 a)
{
return _mm_add_ps(x, _mm_mul_ps(_mm_sub_ps(y, x), a));
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE __m256 ma_mix_f32_fast__avx2(__m256 x, __m256 y, __m256 a)
{
return _mm256_add_ps(x, _mm256_mul_ps(_mm256_sub_ps(y, x), a));
}
#endif
#if defined(MA_SUPPORT_AVX512)
static MA_INLINE __m512 ma_mix_f32_fast__avx512(__m512 x, __m512 y, __m512 a)
{
return _mm512_add_ps(x, _mm512_mul_ps(_mm512_sub_ps(y, x), a));
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE float32x4_t ma_mix_f32_fast__neon(float32x4_t x, float32x4_t y, float32x4_t a)
{
return vaddq_f32(x, vmulq_f32(vsubq_f32(y, x), a));
}
#endif


static MA_INLINE double ma_mix_f64(double x, double y, double a)
{
return x*(1-a) + y*a;
}
static MA_INLINE double ma_mix_f64_fast(double x, double y, double a)
{
return x + (y - x)*a;
}

static MA_INLINE float ma_scale_to_range_f32(float x, float lo, float hi)
{
return lo + x*(hi-lo);
}





static MA_INLINE ma_uint32 ma_gcf_u32(ma_uint32 a, ma_uint32 b)
{
for (;;) {
if (b == 0) {
break;
} else {
ma_uint32 t = a;
a = b;
b = t % a;
}
}

return a;
}











#define MA_LCG_M 2147483647
#define MA_LCG_A 48271
#define MA_LCG_C 0
static ma_int32 g_maLCG = 4321; 

static MA_INLINE void ma_seed(ma_int32 seed)
{
g_maLCG = seed;
}

static MA_INLINE ma_int32 ma_rand_s32()
{
ma_int32 lcg = g_maLCG;
ma_int32 r = (MA_LCG_A * lcg + MA_LCG_C) % MA_LCG_M;
g_maLCG = r;
return r;
}

static MA_INLINE ma_uint32 ma_rand_u32()
{
return (ma_uint32)ma_rand_s32();
}

static MA_INLINE double ma_rand_f64()
{
return ma_rand_s32() / (double)0x7FFFFFFF;
}

static MA_INLINE float ma_rand_f32()
{
return (float)ma_rand_f64();
}

static MA_INLINE float ma_rand_range_f32(float lo, float hi)
{
return ma_scale_to_range_f32(ma_rand_f32(), lo, hi);
}

static MA_INLINE ma_int32 ma_rand_range_s32(ma_int32 lo, ma_int32 hi)
{
if (lo == hi) {
return lo;
}

return lo + ma_rand_u32() / (0xFFFFFFFF / (hi - lo + 1) + 1);
}


static MA_INLINE float ma_dither_f32_rectangle(float ditherMin, float ditherMax)
{
return ma_rand_range_f32(ditherMin, ditherMax);
}

static MA_INLINE float ma_dither_f32_triangle(float ditherMin, float ditherMax)
{
float a = ma_rand_range_f32(ditherMin, 0);
float b = ma_rand_range_f32(0, ditherMax);
return a + b;
}

static MA_INLINE float ma_dither_f32(ma_dither_mode ditherMode, float ditherMin, float ditherMax)
{
if (ditherMode == ma_dither_mode_rectangle) {
return ma_dither_f32_rectangle(ditherMin, ditherMax);
}
if (ditherMode == ma_dither_mode_triangle) {
return ma_dither_f32_triangle(ditherMin, ditherMax);
}

return 0;
}

static MA_INLINE ma_int32 ma_dither_s32(ma_dither_mode ditherMode, ma_int32 ditherMin, ma_int32 ditherMax)
{
if (ditherMode == ma_dither_mode_rectangle) {
ma_int32 a = ma_rand_range_s32(ditherMin, ditherMax);
return a;
}
if (ditherMode == ma_dither_mode_triangle) {
ma_int32 a = ma_rand_range_s32(ditherMin, 0);
ma_int32 b = ma_rand_range_s32(0, ditherMax);
return a + b;
}

return 0;
}







#if defined(__clang__)
#if defined(__has_builtin)
#if __has_builtin(__sync_swap)
#define MA_HAS_SYNC_SWAP
#endif
#endif
#elif defined(__GNUC__)
#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC__ >= 7)
#define MA_HAS_GNUC_ATOMICS
#endif
#endif

#if defined(_WIN32) && !defined(__GNUC__) && !defined(__clang__)
#define ma_memory_barrier() MemoryBarrier()
#define ma_atomic_exchange_32(a, b) InterlockedExchange((LONG*)a, (LONG)b)
#define ma_atomic_exchange_64(a, b) InterlockedExchange64((LONGLONG*)a, (LONGLONG)b)
#define ma_atomic_increment_32(a) InterlockedIncrement((LONG*)a)
#define ma_atomic_decrement_32(a) InterlockedDecrement((LONG*)a)
#else
#define ma_memory_barrier() __sync_synchronize()
#if defined(MA_HAS_SYNC_SWAP)
#define ma_atomic_exchange_32(a, b) __sync_swap(a, b)
#define ma_atomic_exchange_64(a, b) __sync_swap(a, b)
#elif defined(MA_HAS_GNUC_ATOMICS)
#define ma_atomic_exchange_32(a, b) (void)__atomic_exchange_n(a, b, __ATOMIC_ACQ_REL)
#define ma_atomic_exchange_64(a, b) (void)__atomic_exchange_n(a, b, __ATOMIC_ACQ_REL)
#else
#define ma_atomic_exchange_32(a, b) __sync_synchronize(); (void)__sync_lock_test_and_set(a, b)
#define ma_atomic_exchange_64(a, b) __sync_synchronize(); (void)__sync_lock_test_and_set(a, b)
#endif
#define ma_atomic_increment_32(a) __sync_add_and_fetch(a, 1)
#define ma_atomic_decrement_32(a) __sync_sub_and_fetch(a, 1)
#endif

#if defined(MA_64BIT)
#define ma_atomic_exchange_ptr ma_atomic_exchange_64
#endif
#if defined(MA_32BIT)
#define ma_atomic_exchange_ptr ma_atomic_exchange_32
#endif


static void* ma__malloc_default(size_t sz, void* pUserData)
{
(void)pUserData;
return MA_MALLOC(sz);
}

static void* ma__realloc_default(void* p, size_t sz, void* pUserData)
{
(void)pUserData;
return MA_REALLOC(p, sz);
}

static void ma__free_default(void* p, void* pUserData)
{
(void)pUserData;
MA_FREE(p);
}


static void* ma__malloc_from_callbacks(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (pAllocationCallbacks == NULL) {
return NULL;
}

if (pAllocationCallbacks->onMalloc != NULL) {
return pAllocationCallbacks->onMalloc(sz, pAllocationCallbacks->pUserData);
}


if (pAllocationCallbacks->onRealloc != NULL) {
return pAllocationCallbacks->onRealloc(NULL, sz, pAllocationCallbacks->pUserData);
}

return NULL;
}

static void* ma__realloc_from_callbacks(void* p, size_t szNew, size_t szOld, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (pAllocationCallbacks == NULL) {
return NULL;
}

if (pAllocationCallbacks->onRealloc != NULL) {
return pAllocationCallbacks->onRealloc(p, szNew, pAllocationCallbacks->pUserData);
}


if (pAllocationCallbacks->onMalloc != NULL && pAllocationCallbacks->onFree != NULL) {
void* p2;

p2 = pAllocationCallbacks->onMalloc(szNew, pAllocationCallbacks->pUserData);
if (p2 == NULL) {
return NULL;
}

if (p != NULL) {
MA_COPY_MEMORY(p2, p, szOld);
pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);
}

return p2;
}

return NULL;
}

static MA_INLINE void* ma__calloc_from_callbacks(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
void* p = ma__malloc_from_callbacks(sz, pAllocationCallbacks);
if (p != NULL) {
MA_ZERO_MEMORY(p, sz);
}

return p;
}

static void ma__free_from_callbacks(void* p, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (p == NULL || pAllocationCallbacks == NULL) {
return;
}

if (pAllocationCallbacks->onFree != NULL) {
pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);
}
}

static ma_allocation_callbacks ma_allocation_callbacks_init_default()
{
ma_allocation_callbacks callbacks;
callbacks.pUserData = NULL;
callbacks.onMalloc = ma__malloc_default;
callbacks.onRealloc = ma__realloc_default;
callbacks.onFree = ma__free_default;

return callbacks;
}

static ma_result ma_allocation_callbacks_init_copy(ma_allocation_callbacks* pDst, const ma_allocation_callbacks* pSrc)
{
if (pDst == NULL) {
return MA_INVALID_ARGS;
}

if (pSrc == NULL) {
*pDst = ma_allocation_callbacks_init_default();
} else {
if (pSrc->pUserData == NULL && pSrc->onFree == NULL && pSrc->onMalloc == NULL && pSrc->onRealloc == NULL) {
*pDst = ma_allocation_callbacks_init_default();
} else {
if (pSrc->onFree == NULL || (pSrc->onMalloc == NULL && pSrc->onRealloc == NULL)) {
return MA_INVALID_ARGS; 
} else {
*pDst = *pSrc;
}
}
}

return MA_SUCCESS;
}


ma_uint64 ma_calculate_frame_count_after_resampling(ma_uint32 sampleRateOut, ma_uint32 sampleRateIn, ma_uint64 frameCountIn)
{

ma_result result;
ma_uint64 frameCountOut;
ma_resampler_config config;
ma_resampler resampler;

config = ma_resampler_config_init(ma_format_s16, 1, sampleRateIn, sampleRateOut, ma_resample_algorithm_linear);
result = ma_resampler_init(&config, &resampler);
if (result != MA_SUCCESS) {
return 0;
}

frameCountOut = ma_resampler_get_expected_output_frame_count(&resampler, frameCountIn);

ma_resampler_uninit(&resampler);
return frameCountOut;
}

#if !defined(MA_DATA_CONVERTER_STACK_BUFFER_SIZE)
#define MA_DATA_CONVERTER_STACK_BUFFER_SIZE 4096
#endif









#if !defined(MA_NO_DEVICE_IO)










#if !defined(MA_NO_RUNTIME_LINKING)
#if defined(MA_ANDROID) || defined(MA_EMSCRIPTEN)
#define MA_NO_RUNTIME_LINKING
#endif
#endif





#if defined(MA_ENABLE_WASAPI)
#define MA_HAS_WASAPI 
#endif
#if defined(MA_ENABLE_DSOUND)
#define MA_HAS_DSOUND 
#endif
#if defined(MA_ENABLE_WINMM)
#define MA_HAS_WINMM 
#endif
#if defined(MA_ENABLE_ALSA)
#define MA_HAS_ALSA
#if defined(MA_NO_RUNTIME_LINKING)
#if defined(__has_include)
#if !__has_include(<alsa/asoundlib.h>)
#undef MA_HAS_ALSA
#endif
#endif
#endif
#endif
#if defined(MA_ENABLE_PULSEAUDIO)
#define MA_HAS_PULSEAUDIO
#if defined(MA_NO_RUNTIME_LINKING)
#if defined(__has_include)
#if !__has_include(<pulse/pulseaudio.h>)
#undef MA_HAS_PULSEAUDIO
#endif
#endif
#endif
#endif
#if defined(MA_ENABLE_JACK)
#define MA_HAS_JACK
#if defined(MA_NO_RUNTIME_LINKING)
#if defined(__has_include)
#if !__has_include(<jack/jack.h>)
#undef MA_HAS_JACK
#endif
#endif
#endif
#endif
#if defined(MA_ENABLE_COREAUDIO)
#define MA_HAS_COREAUDIO
#endif
#if defined(MA_ENABLE_SNDIO)
#define MA_HAS_SNDIO
#endif
#if defined(MA_ENABLE_AUDIO4)
#define MA_HAS_AUDIO4
#endif
#if defined(MA_ENABLE_OSS)
#define MA_HAS_OSS
#endif
#if defined(MA_ENABLE_AAUDIO)
#define MA_HAS_AAUDIO
#endif
#if defined(MA_ENABLE_OPENSL)
#define MA_HAS_OPENSL
#endif
#if defined(MA_ENABLE_WEBAUDIO)
#define MA_HAS_WEBAUDIO
#endif
#if defined(MA_ENABLE_NULL)
#define MA_HAS_NULL 
#endif

const char* ma_get_backend_name(ma_backend backend)
{
switch (backend)
{
case ma_backend_wasapi: return "WASAPI";
case ma_backend_dsound: return "DirectSound";
case ma_backend_winmm: return "WinMM";
case ma_backend_coreaudio: return "Core Audio";
case ma_backend_sndio: return "sndio";
case ma_backend_audio4: return "audio(4)";
case ma_backend_oss: return "OSS";
case ma_backend_pulseaudio: return "PulseAudio";
case ma_backend_alsa: return "ALSA";
case ma_backend_jack: return "JACK";
case ma_backend_aaudio: return "AAudio";
case ma_backend_opensl: return "OpenSL|ES";
case ma_backend_webaudio: return "Web Audio";
case ma_backend_null: return "Null";
default: return "Unknown";
}
}

ma_bool32 ma_is_loopback_supported(ma_backend backend)
{
switch (backend)
{
case ma_backend_wasapi: return MA_TRUE;
case ma_backend_dsound: return MA_FALSE;
case ma_backend_winmm: return MA_FALSE;
case ma_backend_coreaudio: return MA_FALSE;
case ma_backend_sndio: return MA_FALSE;
case ma_backend_audio4: return MA_FALSE;
case ma_backend_oss: return MA_FALSE;
case ma_backend_pulseaudio: return MA_FALSE;
case ma_backend_alsa: return MA_FALSE;
case ma_backend_jack: return MA_FALSE;
case ma_backend_aaudio: return MA_FALSE;
case ma_backend_opensl: return MA_FALSE;
case ma_backend_webaudio: return MA_FALSE;
case ma_backend_null: return MA_FALSE;
default: return MA_FALSE;
}
}



#if defined(MA_WIN32)
#define MA_THREADCALL WINAPI
typedef unsigned long ma_thread_result;
#else
#define MA_THREADCALL
typedef void* ma_thread_result;
#endif
typedef ma_thread_result (MA_THREADCALL * ma_thread_entry_proc)(void* pData);

#if defined(MA_WIN32)
typedef HRESULT (WINAPI * MA_PFN_CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
typedef void (WINAPI * MA_PFN_CoUninitialize)();
typedef HRESULT (WINAPI * MA_PFN_CoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
typedef void (WINAPI * MA_PFN_CoTaskMemFree)(LPVOID pv);
typedef HRESULT (WINAPI * MA_PFN_PropVariantClear)(PROPVARIANT *pvar);
typedef int (WINAPI * MA_PFN_StringFromGUID2)(const GUID* const rguid, LPOLESTR lpsz, int cchMax);

typedef HWND (WINAPI * MA_PFN_GetForegroundWindow)();
typedef HWND (WINAPI * MA_PFN_GetDesktopWindow)();


typedef LONG (WINAPI * MA_PFN_RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
typedef LONG (WINAPI * MA_PFN_RegCloseKey)(HKEY hKey);
typedef LONG (WINAPI * MA_PFN_RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
#endif


#define MA_STATE_UNINITIALIZED 0
#define MA_STATE_STOPPED 1 
#define MA_STATE_STARTED 2 
#define MA_STATE_STARTING 3 
#define MA_STATE_STOPPING 4 

#define MA_DEFAULT_PLAYBACK_DEVICE_NAME "Default Playback Device"
#define MA_DEFAULT_CAPTURE_DEVICE_NAME "Default Capture Device"


const char* ma_log_level_to_string(ma_uint32 logLevel)
{
switch (logLevel)
{
case MA_LOG_LEVEL_VERBOSE: return "";
case MA_LOG_LEVEL_INFO: return "INFO";
case MA_LOG_LEVEL_WARNING: return "WARNING";
case MA_LOG_LEVEL_ERROR: return "ERROR";
default: return "ERROR";
}
}


static void ma_post_log_message(ma_context* pContext, ma_device* pDevice, ma_uint32 logLevel, const char* message)
{
if (pContext == NULL) {
return;
}

#if defined(MA_LOG_LEVEL)
if (logLevel <= MA_LOG_LEVEL) {
ma_log_proc onLog;

#if defined(MA_DEBUG_OUTPUT)
if (logLevel <= MA_LOG_LEVEL) {
printf("%s: %s\n", ma_log_level_to_string(logLevel), message);
}
#endif

onLog = pContext->logCallback;
if (onLog) {
onLog(pContext, pDevice, logLevel, message);
}
}
#endif
}


static ma_result ma_context_post_error(ma_context* pContext, ma_device* pDevice, ma_uint32 logLevel, const char* message, ma_result resultCode)
{

if (pContext == NULL) {
if (pDevice != NULL) {
pContext = pDevice->pContext;
}
}

ma_post_log_message(pContext, pDevice, logLevel, message);
return resultCode;
}

static ma_result ma_post_error(ma_device* pDevice, ma_uint32 logLevel, const char* message, ma_result resultCode)
{
return ma_context_post_error(NULL, pDevice, logLevel, message, resultCode);
}







#if defined(MA_WIN32)
LARGE_INTEGER g_ma_TimerFrequency = {{0}};
static void ma_timer_init(ma_timer* pTimer)
{
LARGE_INTEGER counter;

if (g_ma_TimerFrequency.QuadPart == 0) {
QueryPerformanceFrequency(&g_ma_TimerFrequency);
}

QueryPerformanceCounter(&counter);
pTimer->counter = counter.QuadPart;
}

static double ma_timer_get_time_in_seconds(ma_timer* pTimer)
{
LARGE_INTEGER counter;
if (!QueryPerformanceCounter(&counter)) {
return 0;
}

return (double)(counter.QuadPart - pTimer->counter) / g_ma_TimerFrequency.QuadPart;
}
#elif defined(MA_APPLE) && (__MAC_OS_X_VERSION_MIN_REQUIRED < 101200)
ma_uint64 g_ma_TimerFrequency = 0;
static void ma_timer_init(ma_timer* pTimer)
{
mach_timebase_info_data_t baseTime;
mach_timebase_info(&baseTime);
g_ma_TimerFrequency = (baseTime.denom * 1e9) / baseTime.numer;

pTimer->counter = mach_absolute_time();
}

static double ma_timer_get_time_in_seconds(ma_timer* pTimer)
{
ma_uint64 newTimeCounter = mach_absolute_time();
ma_uint64 oldTimeCounter = pTimer->counter;

return (newTimeCounter - oldTimeCounter) / g_ma_TimerFrequency;
}
#elif defined(MA_EMSCRIPTEN)
static MA_INLINE void ma_timer_init(ma_timer* pTimer)
{
pTimer->counterD = emscripten_get_now();
}

static MA_INLINE double ma_timer_get_time_in_seconds(ma_timer* pTimer)
{
return (emscripten_get_now() - pTimer->counterD) / 1000; 
}
#else
#if _POSIX_C_SOURCE >= 199309L
#if defined(CLOCK_MONOTONIC)
#define MA_CLOCK_ID CLOCK_MONOTONIC
#else
#define MA_CLOCK_ID CLOCK_REALTIME
#endif

static void ma_timer_init(ma_timer* pTimer)
{
struct timespec newTime;
clock_gettime(MA_CLOCK_ID, &newTime);

pTimer->counter = (newTime.tv_sec * 1000000000) + newTime.tv_nsec;
}

static double ma_timer_get_time_in_seconds(ma_timer* pTimer)
{
ma_uint64 newTimeCounter;
ma_uint64 oldTimeCounter;

struct timespec newTime;
clock_gettime(MA_CLOCK_ID, &newTime);

newTimeCounter = (newTime.tv_sec * 1000000000) + newTime.tv_nsec;
oldTimeCounter = pTimer->counter;

return (newTimeCounter - oldTimeCounter) / 1000000000.0;
}
#else
static void ma_timer_init(ma_timer* pTimer)
{
struct timeval newTime;
gettimeofday(&newTime, NULL);

pTimer->counter = (newTime.tv_sec * 1000000) + newTime.tv_usec;
}

static double ma_timer_get_time_in_seconds(ma_timer* pTimer)
{
ma_uint64 newTimeCounter;
ma_uint64 oldTimeCounter;

struct timeval newTime;
gettimeofday(&newTime, NULL);

newTimeCounter = (newTime.tv_sec * 1000000) + newTime.tv_usec;
oldTimeCounter = pTimer->counter;

return (newTimeCounter - oldTimeCounter) / 1000000.0;
}
#endif
#endif







ma_handle ma_dlopen(ma_context* pContext, const char* filename)
{
ma_handle handle;

#if MA_LOG_LEVEL >= MA_LOG_LEVEL_VERBOSE
if (pContext != NULL) {
char message[256];
ma_strappend(message, sizeof(message), "Loading library: ", filename);
ma_post_log_message(pContext, NULL, MA_LOG_LEVEL_VERBOSE, message);
}
#endif

#if defined(_WIN32)
#if defined(MA_WIN32_DESKTOP)
handle = (ma_handle)LoadLibraryA(filename);
#else

WCHAR filenameW[4096];
if (MultiByteToWideChar(CP_UTF8, 0, filename, -1, filenameW, sizeof(filenameW)) == 0) {
handle = NULL;
} else {
handle = (ma_handle)LoadPackagedLibrary(filenameW, 0);
}
#endif
#else
handle = (ma_handle)dlopen(filename, RTLD_NOW);
#endif





#if MA_LOG_LEVEL >= MA_LOG_LEVEL_INFO
if (handle == NULL) {
char message[256];
ma_strappend(message, sizeof(message), "Failed to load library: ", filename);
ma_post_log_message(pContext, NULL, MA_LOG_LEVEL_INFO, message);
}
#endif

(void)pContext; 
return handle;
}

void ma_dlclose(ma_context* pContext, ma_handle handle)
{
#if defined(_WIN32)
FreeLibrary((HMODULE)handle);
#else
dlclose((void*)handle);
#endif

(void)pContext;
}

ma_proc ma_dlsym(ma_context* pContext, ma_handle handle, const char* symbol)
{
ma_proc proc;

#if MA_LOG_LEVEL >= MA_LOG_LEVEL_VERBOSE
if (pContext != NULL) {
char message[256];
ma_strappend(message, sizeof(message), "Loading symbol: ", symbol);
ma_post_log_message(pContext, NULL, MA_LOG_LEVEL_VERBOSE, message);
}
#endif

#if defined(_WIN32)
proc = (ma_proc)GetProcAddress((HMODULE)handle, symbol);
#else
#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#endif
proc = (ma_proc)dlsym((void*)handle, symbol);
#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
#pragma GCC diagnostic pop
#endif
#endif

#if MA_LOG_LEVEL >= MA_LOG_LEVEL_WARNING
if (handle == NULL) {
char message[256];
ma_strappend(message, sizeof(message), "Failed to load symbol: ", symbol);
ma_post_log_message(pContext, NULL, MA_LOG_LEVEL_WARNING, message);
}
#endif

(void)pContext; 
return proc;
}







#if defined(MA_WIN32)
static int ma_thread_priority_to_win32(ma_thread_priority priority)
{
switch (priority) {
case ma_thread_priority_idle: return THREAD_PRIORITY_IDLE;
case ma_thread_priority_lowest: return THREAD_PRIORITY_LOWEST;
case ma_thread_priority_low: return THREAD_PRIORITY_BELOW_NORMAL;
case ma_thread_priority_normal: return THREAD_PRIORITY_NORMAL;
case ma_thread_priority_high: return THREAD_PRIORITY_ABOVE_NORMAL;
case ma_thread_priority_highest: return THREAD_PRIORITY_HIGHEST;
case ma_thread_priority_realtime: return THREAD_PRIORITY_TIME_CRITICAL;
default: return THREAD_PRIORITY_NORMAL;
}
}

static ma_result ma_thread_create__win32(ma_context* pContext, ma_thread* pThread, ma_thread_entry_proc entryProc, void* pData)
{
pThread->win32.hThread = CreateThread(NULL, 0, entryProc, pData, 0, NULL);
if (pThread->win32.hThread == NULL) {
return MA_FAILED_TO_CREATE_THREAD;
}

SetThreadPriority((HANDLE)pThread->win32.hThread, ma_thread_priority_to_win32(pContext->threadPriority));

return MA_SUCCESS;
}

static void ma_thread_wait__win32(ma_thread* pThread)
{
WaitForSingleObject(pThread->win32.hThread, INFINITE);
}

static void ma_sleep__win32(ma_uint32 milliseconds)
{
Sleep((DWORD)milliseconds);
}


static ma_result ma_mutex_init__win32(ma_context* pContext, ma_mutex* pMutex)
{
(void)pContext;

pMutex->win32.hMutex = CreateEventA(NULL, FALSE, TRUE, NULL);
if (pMutex->win32.hMutex == NULL) {
return MA_FAILED_TO_CREATE_MUTEX;
}

return MA_SUCCESS;
}

static void ma_mutex_uninit__win32(ma_mutex* pMutex)
{
CloseHandle(pMutex->win32.hMutex);
}

static void ma_mutex_lock__win32(ma_mutex* pMutex)
{
WaitForSingleObject(pMutex->win32.hMutex, INFINITE);
}

static void ma_mutex_unlock__win32(ma_mutex* pMutex)
{
SetEvent(pMutex->win32.hMutex);
}


static ma_result ma_event_init__win32(ma_context* pContext, ma_event* pEvent)
{
(void)pContext;

pEvent->win32.hEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
if (pEvent->win32.hEvent == NULL) {
return MA_FAILED_TO_CREATE_EVENT;
}

return MA_SUCCESS;
}

static void ma_event_uninit__win32(ma_event* pEvent)
{
CloseHandle(pEvent->win32.hEvent);
}

static ma_bool32 ma_event_wait__win32(ma_event* pEvent)
{
return WaitForSingleObject(pEvent->win32.hEvent, INFINITE) == WAIT_OBJECT_0;
}

static ma_bool32 ma_event_signal__win32(ma_event* pEvent)
{
return SetEvent(pEvent->win32.hEvent);
}


static ma_result ma_semaphore_init__win32(ma_context* pContext, int initialValue, ma_semaphore* pSemaphore)
{
(void)pContext;

pSemaphore->win32.hSemaphore = CreateSemaphoreA(NULL, (LONG)initialValue, LONG_MAX, NULL);
if (pSemaphore->win32.hSemaphore == NULL) {
return MA_FAILED_TO_CREATE_SEMAPHORE;
}

return MA_SUCCESS;
}

static void ma_semaphore_uninit__win32(ma_semaphore* pSemaphore)
{
CloseHandle((HANDLE)pSemaphore->win32.hSemaphore);
}

static ma_bool32 ma_semaphore_wait__win32(ma_semaphore* pSemaphore)
{
return WaitForSingleObject((HANDLE)pSemaphore->win32.hSemaphore, INFINITE) == WAIT_OBJECT_0;
}

static ma_bool32 ma_semaphore_release__win32(ma_semaphore* pSemaphore)
{
return ReleaseSemaphore((HANDLE)pSemaphore->win32.hSemaphore, 1, NULL) != 0;
}
#endif


#if defined(MA_POSIX)
#include <sched.h>

typedef int (* ma_pthread_create_proc)(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
typedef int (* ma_pthread_join_proc)(pthread_t thread, void **retval);
typedef int (* ma_pthread_mutex_init_proc)(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr);
typedef int (* ma_pthread_mutex_destroy_proc)(pthread_mutex_t *__mutex);
typedef int (* ma_pthread_mutex_lock_proc)(pthread_mutex_t *__mutex);
typedef int (* ma_pthread_mutex_unlock_proc)(pthread_mutex_t *__mutex);
typedef int (* ma_pthread_cond_init_proc)(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr);
typedef int (* ma_pthread_cond_destroy_proc)(pthread_cond_t *__cond);
typedef int (* ma_pthread_cond_signal_proc)(pthread_cond_t *__cond);
typedef int (* ma_pthread_cond_wait_proc)(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex);
typedef int (* ma_pthread_attr_init_proc)(pthread_attr_t *attr);
typedef int (* ma_pthread_attr_destroy_proc)(pthread_attr_t *attr);
typedef int (* ma_pthread_attr_setschedpolicy_proc)(pthread_attr_t *attr, int policy);
typedef int (* ma_pthread_attr_getschedparam_proc)(const pthread_attr_t *attr, struct sched_param *param);
typedef int (* ma_pthread_attr_setschedparam_proc)(pthread_attr_t *attr, const struct sched_param *param);

static ma_result ma_thread_create__posix(ma_context* pContext, ma_thread* pThread, ma_thread_entry_proc entryProc, void* pData)
{
int result;
pthread_attr_t* pAttr = NULL;

#if !defined(__EMSCRIPTEN__)

pthread_attr_t attr;
if (((ma_pthread_attr_init_proc)pContext->posix.pthread_attr_init)(&attr) == 0) {
int scheduler = -1;
if (pContext->threadPriority == ma_thread_priority_idle) {
#if defined(SCHED_IDLE)
if (((ma_pthread_attr_setschedpolicy_proc)pContext->posix.pthread_attr_setschedpolicy)(&attr, SCHED_IDLE) == 0) {
scheduler = SCHED_IDLE;
}
#endif
} else if (pContext->threadPriority == ma_thread_priority_realtime) {
#if defined(SCHED_FIFO)
if (((ma_pthread_attr_setschedpolicy_proc)pContext->posix.pthread_attr_setschedpolicy)(&attr, SCHED_FIFO) == 0) {
scheduler = SCHED_FIFO;
}
#endif
#if defined(MA_LINUX)
} else {
scheduler = sched_getscheduler(0);
#endif
}

if (scheduler != -1) {
int priorityMin = sched_get_priority_min(scheduler);
int priorityMax = sched_get_priority_max(scheduler);
int priorityStep = (priorityMax - priorityMin) / 7; 

struct sched_param sched;
if (((ma_pthread_attr_getschedparam_proc)pContext->posix.pthread_attr_getschedparam)(&attr, &sched) == 0) {
if (pContext->threadPriority == ma_thread_priority_idle) {
sched.sched_priority = priorityMin;
} else if (pContext->threadPriority == ma_thread_priority_realtime) {
sched.sched_priority = priorityMax;
} else {
sched.sched_priority += ((int)pContext->threadPriority + 5) * priorityStep; 
if (sched.sched_priority < priorityMin) {
sched.sched_priority = priorityMin;
}
if (sched.sched_priority > priorityMax) {
sched.sched_priority = priorityMax;
}
}

if (((ma_pthread_attr_setschedparam_proc)pContext->posix.pthread_attr_setschedparam)(&attr, &sched) == 0) {
pAttr = &attr;
}
}
}

((ma_pthread_attr_destroy_proc)pContext->posix.pthread_attr_destroy)(&attr);
}
#endif

result = ((ma_pthread_create_proc)pContext->posix.pthread_create)(&pThread->posix.thread, pAttr, entryProc, pData);
if (result != 0) {
return MA_FAILED_TO_CREATE_THREAD;
}

return MA_SUCCESS;
}

static void ma_thread_wait__posix(ma_thread* pThread)
{
((ma_pthread_join_proc)pThread->pContext->posix.pthread_join)(pThread->posix.thread, NULL);
}

#if !defined(MA_EMSCRIPTEN)
static void ma_sleep__posix(ma_uint32 milliseconds)
{
#if defined(MA_EMSCRIPTEN)
(void)milliseconds;
MA_ASSERT(MA_FALSE); 
#else
#if _POSIX_C_SOURCE >= 199309L
struct timespec ts;
ts.tv_sec = milliseconds / 1000000;
ts.tv_nsec = milliseconds % 1000000 * 1000000;
nanosleep(&ts, NULL);
#else
struct timeval tv;
tv.tv_sec = milliseconds / 1000;
tv.tv_usec = milliseconds % 1000 * 1000;
select(0, NULL, NULL, NULL, &tv);
#endif
#endif
}
#endif 


static ma_result ma_mutex_init__posix(ma_context* pContext, ma_mutex* pMutex)
{
int result = ((ma_pthread_mutex_init_proc)pContext->posix.pthread_mutex_init)(&pMutex->posix.mutex, NULL);
if (result != 0) {
return MA_FAILED_TO_CREATE_MUTEX;
}

return MA_SUCCESS;
}

static void ma_mutex_uninit__posix(ma_mutex* pMutex)
{
((ma_pthread_mutex_destroy_proc)pMutex->pContext->posix.pthread_mutex_destroy)(&pMutex->posix.mutex);
}

static void ma_mutex_lock__posix(ma_mutex* pMutex)
{
((ma_pthread_mutex_lock_proc)pMutex->pContext->posix.pthread_mutex_lock)(&pMutex->posix.mutex);
}

static void ma_mutex_unlock__posix(ma_mutex* pMutex)
{
((ma_pthread_mutex_unlock_proc)pMutex->pContext->posix.pthread_mutex_unlock)(&pMutex->posix.mutex);
}


static ma_result ma_event_init__posix(ma_context* pContext, ma_event* pEvent)
{
if (((ma_pthread_mutex_init_proc)pContext->posix.pthread_mutex_init)(&pEvent->posix.mutex, NULL) != 0) {
return MA_FAILED_TO_CREATE_MUTEX;
}

if (((ma_pthread_cond_init_proc)pContext->posix.pthread_cond_init)(&pEvent->posix.condition, NULL) != 0) {
return MA_FAILED_TO_CREATE_EVENT;
}

pEvent->posix.value = 0;
return MA_SUCCESS;
}

static void ma_event_uninit__posix(ma_event* pEvent)
{
((ma_pthread_cond_destroy_proc)pEvent->pContext->posix.pthread_cond_destroy)(&pEvent->posix.condition);
((ma_pthread_mutex_destroy_proc)pEvent->pContext->posix.pthread_mutex_destroy)(&pEvent->posix.mutex);
}

static ma_bool32 ma_event_wait__posix(ma_event* pEvent)
{
((ma_pthread_mutex_lock_proc)pEvent->pContext->posix.pthread_mutex_lock)(&pEvent->posix.mutex);
{
while (pEvent->posix.value == 0) {
((ma_pthread_cond_wait_proc)pEvent->pContext->posix.pthread_cond_wait)(&pEvent->posix.condition, &pEvent->posix.mutex);
}
pEvent->posix.value = 0; 
}
((ma_pthread_mutex_unlock_proc)pEvent->pContext->posix.pthread_mutex_unlock)(&pEvent->posix.mutex);

return MA_TRUE;
}

static ma_bool32 ma_event_signal__posix(ma_event* pEvent)
{
((ma_pthread_mutex_lock_proc)pEvent->pContext->posix.pthread_mutex_lock)(&pEvent->posix.mutex);
{
pEvent->posix.value = 1;
((ma_pthread_cond_signal_proc)pEvent->pContext->posix.pthread_cond_signal)(&pEvent->posix.condition);
}
((ma_pthread_mutex_unlock_proc)pEvent->pContext->posix.pthread_mutex_unlock)(&pEvent->posix.mutex);

return MA_TRUE;
}


static ma_result ma_semaphore_init__posix(ma_context* pContext, int initialValue, ma_semaphore* pSemaphore)
{
(void)pContext;

#if defined(MA_APPLE)

return MA_INVALID_OPERATION;
#else
if (sem_init(&pSemaphore->posix.semaphore, 0, (unsigned int)initialValue) == 0) {
return MA_FAILED_TO_CREATE_SEMAPHORE;
}
#endif

return MA_SUCCESS;
}

static void ma_semaphore_uninit__posix(ma_semaphore* pSemaphore)
{
sem_close(&pSemaphore->posix.semaphore);
}

static ma_bool32 ma_semaphore_wait__posix(ma_semaphore* pSemaphore)
{
return sem_wait(&pSemaphore->posix.semaphore) != -1;
}

static ma_bool32 ma_semaphore_release__posix(ma_semaphore* pSemaphore)
{
return sem_post(&pSemaphore->posix.semaphore) != -1;
}
#endif

static ma_result ma_thread_create(ma_context* pContext, ma_thread* pThread, ma_thread_entry_proc entryProc, void* pData)
{
if (pContext == NULL || pThread == NULL || entryProc == NULL) {
return MA_FALSE;
}

pThread->pContext = pContext;

#if defined(MA_WIN32)
return ma_thread_create__win32(pContext, pThread, entryProc, pData);
#endif
#if defined(MA_POSIX)
return ma_thread_create__posix(pContext, pThread, entryProc, pData);
#endif
}

static void ma_thread_wait(ma_thread* pThread)
{
if (pThread == NULL) {
return;
}

#if defined(MA_WIN32)
ma_thread_wait__win32(pThread);
#endif
#if defined(MA_POSIX)
ma_thread_wait__posix(pThread);
#endif
}

#if !defined(MA_EMSCRIPTEN)
static void ma_sleep(ma_uint32 milliseconds)
{
#if defined(MA_WIN32)
ma_sleep__win32(milliseconds);
#endif
#if defined(MA_POSIX)
ma_sleep__posix(milliseconds);
#endif
}
#endif


ma_result ma_mutex_init(ma_context* pContext, ma_mutex* pMutex)
{
if (pContext == NULL || pMutex == NULL) {
return MA_INVALID_ARGS;
}

pMutex->pContext = pContext;

#if defined(MA_WIN32)
return ma_mutex_init__win32(pContext, pMutex);
#endif
#if defined(MA_POSIX)
return ma_mutex_init__posix(pContext, pMutex);
#endif
}

void ma_mutex_uninit(ma_mutex* pMutex)
{
if (pMutex == NULL || pMutex->pContext == NULL) {
return;
}

#if defined(MA_WIN32)
ma_mutex_uninit__win32(pMutex);
#endif
#if defined(MA_POSIX)
ma_mutex_uninit__posix(pMutex);
#endif
}

void ma_mutex_lock(ma_mutex* pMutex)
{
if (pMutex == NULL || pMutex->pContext == NULL) {
return;
}

#if defined(MA_WIN32)
ma_mutex_lock__win32(pMutex);
#endif
#if defined(MA_POSIX)
ma_mutex_lock__posix(pMutex);
#endif
}

void ma_mutex_unlock(ma_mutex* pMutex)
{
if (pMutex == NULL || pMutex->pContext == NULL) {
return;
}

#if defined(MA_WIN32)
ma_mutex_unlock__win32(pMutex);
#endif
#if defined(MA_POSIX)
ma_mutex_unlock__posix(pMutex);
#endif
}


ma_result ma_event_init(ma_context* pContext, ma_event* pEvent)
{
if (pContext == NULL || pEvent == NULL) {
return MA_FALSE;
}

pEvent->pContext = pContext;

#if defined(MA_WIN32)
return ma_event_init__win32(pContext, pEvent);
#endif
#if defined(MA_POSIX)
return ma_event_init__posix(pContext, pEvent);
#endif
}

void ma_event_uninit(ma_event* pEvent)
{
if (pEvent == NULL || pEvent->pContext == NULL) {
return;
}

#if defined(MA_WIN32)
ma_event_uninit__win32(pEvent);
#endif
#if defined(MA_POSIX)
ma_event_uninit__posix(pEvent);
#endif
}

ma_bool32 ma_event_wait(ma_event* pEvent)
{
if (pEvent == NULL || pEvent->pContext == NULL) {
return MA_FALSE;
}

#if defined(MA_WIN32)
return ma_event_wait__win32(pEvent);
#endif
#if defined(MA_POSIX)
return ma_event_wait__posix(pEvent);
#endif
}

ma_bool32 ma_event_signal(ma_event* pEvent)
{
if (pEvent == NULL || pEvent->pContext == NULL) {
return MA_FALSE;
}

#if defined(MA_WIN32)
return ma_event_signal__win32(pEvent);
#endif
#if defined(MA_POSIX)
return ma_event_signal__posix(pEvent);
#endif
}


ma_result ma_semaphore_init(ma_context* pContext, int initialValue, ma_semaphore* pSemaphore)
{
if (pContext == NULL || pSemaphore == NULL) {
return MA_INVALID_ARGS;
}

#if defined(MA_WIN32)
return ma_semaphore_init__win32(pContext, initialValue, pSemaphore);
#endif
#if defined(MA_POSIX)
return ma_semaphore_init__posix(pContext, initialValue, pSemaphore);
#endif
}

void ma_semaphore_uninit(ma_semaphore* pSemaphore)
{
if (pSemaphore == NULL) {
return;
}

#if defined(MA_WIN32)
ma_semaphore_uninit__win32(pSemaphore);
#endif
#if defined(MA_POSIX)
ma_semaphore_uninit__posix(pSemaphore);
#endif
}

ma_bool32 ma_semaphore_wait(ma_semaphore* pSemaphore)
{
if (pSemaphore == NULL) {
return MA_FALSE;
}

#if defined(MA_WIN32)
return ma_semaphore_wait__win32(pSemaphore);
#endif
#if defined(MA_POSIX)
return ma_semaphore_wait__posix(pSemaphore);
#endif
}

ma_bool32 ma_semaphore_release(ma_semaphore* pSemaphore)
{
if (pSemaphore == NULL) {
return MA_FALSE;
}

#if defined(MA_WIN32)
return ma_semaphore_release__win32(pSemaphore);
#endif
#if defined(MA_POSIX)
return ma_semaphore_release__posix(pSemaphore);
#endif
}


#if 0
ma_uint32 ma_get_closest_standard_sample_rate(ma_uint32 sampleRateIn)
{
ma_uint32 closestRate = 0;
ma_uint32 closestDiff = 0xFFFFFFFF;
size_t iStandardRate;

for (iStandardRate = 0; iStandardRate < ma_countof(g_maStandardSampleRatePriorities); ++iStandardRate) {
ma_uint32 standardRate = g_maStandardSampleRatePriorities[iStandardRate];
ma_uint32 diff;

if (sampleRateIn > standardRate) {
diff = sampleRateIn - standardRate;
} else {
diff = standardRate - sampleRateIn;
}

if (diff == 0) {
return standardRate; 
}

if (closestDiff > diff) {
closestDiff = diff;
closestRate = standardRate;
}
}

return closestRate;
}
#endif

ma_uint32 ma_scale_buffer_size(ma_uint32 baseBufferSize, float scale)
{
return ma_max(1, (ma_uint32)(baseBufferSize*scale));
}

ma_uint32 ma_calculate_buffer_size_in_milliseconds_from_frames(ma_uint32 bufferSizeInFrames, ma_uint32 sampleRate)
{
return bufferSizeInFrames / (sampleRate/1000);
}

ma_uint32 ma_calculate_buffer_size_in_frames_from_milliseconds(ma_uint32 bufferSizeInMilliseconds, ma_uint32 sampleRate)
{
return bufferSizeInMilliseconds * (sampleRate/1000); 
}

void ma_zero_pcm_frames(void* p, ma_uint32 frameCount, ma_format format, ma_uint32 channels)
{
MA_ZERO_MEMORY(p, frameCount * ma_get_bytes_per_frame(format, channels));
}

void ma_clip_samples_f32(float* p, ma_uint32 sampleCount)
{
ma_uint32 iSample;


for (iSample = 0; iSample < sampleCount; iSample += 1) {
p[iSample] = ma_clip_f32(p[iSample]);
}
}


void ma_copy_and_apply_volume_factor_u8(ma_uint8* pSamplesOut, const ma_uint8* pSamplesIn, ma_uint32 sampleCount, float factor)
{
ma_uint32 iSample;

if (pSamplesOut == NULL || pSamplesIn == NULL) {
return;
}

for (iSample = 0; iSample < sampleCount; iSample += 1) {
pSamplesOut[iSample] = (ma_uint8)(pSamplesIn[iSample] * factor);
}
}

void ma_copy_and_apply_volume_factor_s16(ma_int16* pSamplesOut, const ma_int16* pSamplesIn, ma_uint32 sampleCount, float factor)
{
ma_uint32 iSample;

if (pSamplesOut == NULL || pSamplesIn == NULL) {
return;
}

for (iSample = 0; iSample < sampleCount; iSample += 1) {
pSamplesOut[iSample] = (ma_int16)(pSamplesIn[iSample] * factor);
}
}

void ma_copy_and_apply_volume_factor_s24(void* pSamplesOut, const void* pSamplesIn, ma_uint32 sampleCount, float factor)
{
ma_uint32 iSample;
ma_uint8* pSamplesOut8;
ma_uint8* pSamplesIn8;

if (pSamplesOut == NULL || pSamplesIn == NULL) {
return;
}

pSamplesOut8 = (ma_uint8*)pSamplesOut;
pSamplesIn8 = (ma_uint8*)pSamplesIn;

for (iSample = 0; iSample < sampleCount; iSample += 1) {
ma_int32 sampleS32;

sampleS32 = (ma_int32)(((ma_uint32)(pSamplesIn8[iSample*3+0]) << 8) | ((ma_uint32)(pSamplesIn8[iSample*3+1]) << 16) | ((ma_uint32)(pSamplesIn8[iSample*3+2])) << 24);
sampleS32 = (ma_int32)(sampleS32 * factor);

pSamplesOut8[iSample*3+0] = (ma_uint8)(((ma_uint32)sampleS32 & 0x0000FF00) >> 8);
pSamplesOut8[iSample*3+1] = (ma_uint8)(((ma_uint32)sampleS32 & 0x00FF0000) >> 16);
pSamplesOut8[iSample*3+2] = (ma_uint8)(((ma_uint32)sampleS32 & 0xFF000000) >> 24);
}
}

void ma_copy_and_apply_volume_factor_s32(ma_int32* pSamplesOut, const ma_int32* pSamplesIn, ma_uint32 sampleCount, float factor)
{
ma_uint32 iSample;

if (pSamplesOut == NULL || pSamplesIn == NULL) {
return;
}

for (iSample = 0; iSample < sampleCount; iSample += 1) {
pSamplesOut[iSample] = (ma_int32)(pSamplesIn[iSample] * factor);
}
}

void ma_copy_and_apply_volume_factor_f32(float* pSamplesOut, const float* pSamplesIn, ma_uint32 sampleCount, float factor)
{
ma_uint32 iSample;

if (pSamplesOut == NULL || pSamplesIn == NULL) {
return;
}

for (iSample = 0; iSample < sampleCount; iSample += 1) {
pSamplesOut[iSample] = pSamplesIn[iSample] * factor;
}
}

void ma_apply_volume_factor_u8(ma_uint8* pSamples, ma_uint32 sampleCount, float factor)
{
ma_copy_and_apply_volume_factor_u8(pSamples, pSamples, sampleCount, factor);
}

void ma_apply_volume_factor_s16(ma_int16* pSamples, ma_uint32 sampleCount, float factor)
{
ma_copy_and_apply_volume_factor_s16(pSamples, pSamples, sampleCount, factor);
}

void ma_apply_volume_factor_s24(void* pSamples, ma_uint32 sampleCount, float factor)
{
ma_copy_and_apply_volume_factor_s24(pSamples, pSamples, sampleCount, factor);
}

void ma_apply_volume_factor_s32(ma_int32* pSamples, ma_uint32 sampleCount, float factor)
{
ma_copy_and_apply_volume_factor_s32(pSamples, pSamples, sampleCount, factor);
}

void ma_apply_volume_factor_f32(float* pSamples, ma_uint32 sampleCount, float factor)
{
ma_copy_and_apply_volume_factor_f32(pSamples, pSamples, sampleCount, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames_u8(ma_uint8* pPCMFramesOut, const ma_uint8* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_u8(pPCMFramesOut, pPCMFramesIn, frameCount*channels, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames_s16(ma_int16* pPCMFramesOut, const ma_int16* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_s16(pPCMFramesOut, pPCMFramesIn, frameCount*channels, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames_s24(void* pPCMFramesOut, const void* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_s24(pPCMFramesOut, pPCMFramesIn, frameCount*channels, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames_s32(ma_int32* pPCMFramesOut, const ma_int32* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_s32(pPCMFramesOut, pPCMFramesIn, frameCount*channels, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames_f32(float* pPCMFramesOut, const float* pPCMFramesIn, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_f32(pPCMFramesOut, pPCMFramesIn, frameCount*channels, factor);
}

void ma_copy_and_apply_volume_factor_pcm_frames(void* pPCMFramesOut, const void* pPCMFramesIn, ma_uint32 frameCount, ma_format format, ma_uint32 channels, float factor)
{
switch (format)
{
case ma_format_u8: ma_copy_and_apply_volume_factor_pcm_frames_u8 ((ma_uint8*)pPCMFramesOut, (const ma_uint8*)pPCMFramesIn, frameCount, channels, factor); return;
case ma_format_s16: ma_copy_and_apply_volume_factor_pcm_frames_s16((ma_int16*)pPCMFramesOut, (const ma_int16*)pPCMFramesIn, frameCount, channels, factor); return;
case ma_format_s24: ma_copy_and_apply_volume_factor_pcm_frames_s24( pPCMFramesOut, pPCMFramesIn, frameCount, channels, factor); return;
case ma_format_s32: ma_copy_and_apply_volume_factor_pcm_frames_s32((ma_int32*)pPCMFramesOut, (const ma_int32*)pPCMFramesIn, frameCount, channels, factor); return;
case ma_format_f32: ma_copy_and_apply_volume_factor_pcm_frames_f32( (float*)pPCMFramesOut, (const float*)pPCMFramesIn, frameCount, channels, factor); return;
default: return; 
}
}

void ma_apply_volume_factor_pcm_frames_u8(ma_uint8* pPCMFrames, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames_u8(pPCMFrames, pPCMFrames, frameCount, channels, factor);
}

void ma_apply_volume_factor_pcm_frames_s16(ma_int16* pPCMFrames, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames_s16(pPCMFrames, pPCMFrames, frameCount, channels, factor);
}

void ma_apply_volume_factor_pcm_frames_s24(void* pPCMFrames, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames_s24(pPCMFrames, pPCMFrames, frameCount, channels, factor);
}

void ma_apply_volume_factor_pcm_frames_s32(ma_int32* pPCMFrames, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames_s32(pPCMFrames, pPCMFrames, frameCount, channels, factor);
}

void ma_apply_volume_factor_pcm_frames_f32(float* pPCMFrames, ma_uint32 frameCount, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames_f32(pPCMFrames, pPCMFrames, frameCount, channels, factor);
}

void ma_apply_volume_factor_pcm_frames(void* pPCMFrames, ma_uint32 frameCount, ma_format format, ma_uint32 channels, float factor)
{
ma_copy_and_apply_volume_factor_pcm_frames(pPCMFrames, pPCMFrames, frameCount, format, channels, factor);
}


float ma_factor_to_gain_db(float factor)
{
return (float)(20*ma_log10f(factor));
}

float ma_gain_db_to_factor(float gain)
{
return (float)ma_powf(10, gain/20.0f);
}


static void ma_device__on_data(ma_device* pDevice, void* pFramesOut, const void* pFramesIn, ma_uint32 frameCount)
{
float masterVolumeFactor;

masterVolumeFactor = pDevice->masterVolumeFactor;

if (pDevice->onData) {
if (!pDevice->noPreZeroedOutputBuffer && pFramesOut != NULL) {
ma_zero_pcm_frames(pFramesOut, frameCount, pDevice->playback.format, pDevice->playback.channels);
}


if (pFramesIn != NULL && masterVolumeFactor < 1) {
ma_uint8 tempFramesIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 bpfCapture = ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 bpfPlayback = ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint32 totalFramesProcessed = 0;
while (totalFramesProcessed < frameCount) {
ma_uint32 framesToProcessThisIteration = frameCount - totalFramesProcessed;
if (framesToProcessThisIteration > sizeof(tempFramesIn)/bpfCapture) {
framesToProcessThisIteration = sizeof(tempFramesIn)/bpfCapture;
}

ma_copy_and_apply_volume_factor_pcm_frames(tempFramesIn, ma_offset_ptr(pFramesIn, totalFramesProcessed*bpfCapture), framesToProcessThisIteration, pDevice->capture.format, pDevice->capture.channels, masterVolumeFactor);

pDevice->onData(pDevice, ma_offset_ptr(pFramesOut, totalFramesProcessed*bpfPlayback), tempFramesIn, framesToProcessThisIteration);

totalFramesProcessed += framesToProcessThisIteration;
}
} else {
pDevice->onData(pDevice, pFramesOut, pFramesIn, frameCount);
}


if (pFramesOut != NULL) {
if (masterVolumeFactor < 1) {
if (pFramesIn == NULL) { 
ma_apply_volume_factor_pcm_frames(pFramesOut, frameCount, pDevice->playback.format, pDevice->playback.channels, masterVolumeFactor);
}
}

if (!pDevice->noClip && pDevice->playback.format == ma_format_f32) {
ma_clip_pcm_frames_f32((float*)pFramesOut, frameCount, pDevice->playback.channels);
}
}
}
}




static void ma_device__read_frames_from_client(ma_device* pDevice, ma_uint32 frameCount, void* pFramesOut)
{
MA_ASSERT(pDevice != NULL);
MA_ASSERT(frameCount > 0);
MA_ASSERT(pFramesOut != NULL);

if (pDevice->playback.converter.isPassthrough) {
ma_device__on_data(pDevice, pFramesOut, NULL, frameCount);
} else {
ma_result result;
ma_uint64 totalFramesReadOut;
ma_uint64 totalFramesReadIn;
void* pRunningFramesOut;

totalFramesReadOut = 0;
totalFramesReadIn = 0;
pRunningFramesOut = pFramesOut;

while (totalFramesReadOut < frameCount) {
ma_uint8 pIntermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 intermediaryBufferCap = sizeof(pIntermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 framesToReadThisIterationIn;
ma_uint64 framesReadThisIterationIn;
ma_uint64 framesToReadThisIterationOut;
ma_uint64 framesReadThisIterationOut;
ma_uint64 requiredInputFrameCount;

framesToReadThisIterationOut = (frameCount - totalFramesReadOut);
framesToReadThisIterationIn = framesToReadThisIterationOut;
if (framesToReadThisIterationIn > intermediaryBufferCap) {
framesToReadThisIterationIn = intermediaryBufferCap;
}

requiredInputFrameCount = ma_data_converter_get_required_input_frame_count(&pDevice->playback.converter, frameCount);
if (framesToReadThisIterationIn > requiredInputFrameCount) {
framesToReadThisIterationIn = requiredInputFrameCount;
}

if (framesToReadThisIterationIn > 0) {
ma_device__on_data(pDevice, pIntermediaryBuffer, NULL, (ma_uint32)framesToReadThisIterationIn);
totalFramesReadIn += framesToReadThisIterationIn;
}





framesReadThisIterationIn = framesToReadThisIterationIn;
framesReadThisIterationOut = framesToReadThisIterationOut;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, pIntermediaryBuffer, &framesReadThisIterationIn, pRunningFramesOut, &framesReadThisIterationOut);
if (result != MA_SUCCESS) {
break;
}

totalFramesReadOut += framesReadThisIterationOut;
pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesReadThisIterationOut * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));

if (framesReadThisIterationIn == 0 && framesReadThisIterationOut == 0) {
break; 
}
}
}
}


static void ma_device__send_frames_to_client(ma_device* pDevice, ma_uint32 frameCountInDeviceFormat, const void* pFramesInDeviceFormat)
{
MA_ASSERT(pDevice != NULL);
MA_ASSERT(frameCountInDeviceFormat > 0);
MA_ASSERT(pFramesInDeviceFormat != NULL);

if (pDevice->capture.converter.isPassthrough) {
ma_device__on_data(pDevice, NULL, pFramesInDeviceFormat, frameCountInDeviceFormat);
} else {
ma_result result;
ma_uint8 pFramesInClientFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint64 framesInClientFormatCap = sizeof(pFramesInClientFormat) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint64 totalDeviceFramesProcessed = 0;
ma_uint64 totalClientFramesProcessed = 0;
const void* pRunningFramesInDeviceFormat = pFramesInDeviceFormat;


for (;;) {
ma_uint64 deviceFramesProcessedThisIteration;
ma_uint64 clientFramesProcessedThisIteration;

deviceFramesProcessedThisIteration = (frameCountInDeviceFormat - totalDeviceFramesProcessed);
clientFramesProcessedThisIteration = framesInClientFormatCap;

result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningFramesInDeviceFormat, &deviceFramesProcessedThisIteration, pFramesInClientFormat, &clientFramesProcessedThisIteration);
if (result != MA_SUCCESS) {
break;
}

if (clientFramesProcessedThisIteration > 0) {
ma_device__on_data(pDevice, NULL, pFramesInClientFormat, (ma_uint32)clientFramesProcessedThisIteration); 
}

pRunningFramesInDeviceFormat = ma_offset_ptr(pRunningFramesInDeviceFormat, deviceFramesProcessedThisIteration * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
totalDeviceFramesProcessed += deviceFramesProcessedThisIteration;
totalClientFramesProcessed += clientFramesProcessedThisIteration;

if (deviceFramesProcessedThisIteration == 0 && clientFramesProcessedThisIteration == 0) {
break; 
}
}
}
}



#if defined(MA_HAS_JACK) || defined(MA_HAS_COREAUDIO) || defined(MA_HAS_AAUDIO) || defined(MA_HAS_OPENSL) || defined(MA_HAS_WEBAUDIO)




static ma_result ma_device__handle_duplex_callback_capture(ma_device* pDevice, ma_uint32 frameCountInDeviceFormat, const void* pFramesInDeviceFormat, ma_pcm_rb* pRB)
{
ma_result result;
ma_uint32 totalDeviceFramesProcessed = 0;
const void* pRunningFramesInDeviceFormat = pFramesInDeviceFormat;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(frameCountInDeviceFormat > 0);
MA_ASSERT(pFramesInDeviceFormat != NULL);
MA_ASSERT(pRB != NULL);


for (;;) {
ma_uint32 framesToProcessInDeviceFormat = (frameCountInDeviceFormat - totalDeviceFramesProcessed);
ma_uint32 framesToProcessInClientFormat = MA_DATA_CONVERTER_STACK_BUFFER_SIZE / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint64 framesProcessedInDeviceFormat;
ma_uint64 framesProcessedInClientFormat;
void* pFramesInClientFormat;

result = ma_pcm_rb_acquire_write(pRB, &framesToProcessInClientFormat, &pFramesInClientFormat);
if (result != MA_SUCCESS) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "Failed to acquire capture PCM frames from ring buffer.", result);
break;
}

if (framesToProcessInClientFormat == 0) {
if (ma_pcm_rb_pointer_disance(pRB) == (ma_int32)ma_pcm_rb_get_subbuffer_size(pRB)) {
break; 
}
}


framesProcessedInDeviceFormat = framesToProcessInDeviceFormat;
framesProcessedInClientFormat = framesToProcessInClientFormat;
result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningFramesInDeviceFormat, &framesProcessedInDeviceFormat, pFramesInClientFormat, &framesProcessedInClientFormat);
if (result != MA_SUCCESS) {
break;
}

result = ma_pcm_rb_commit_write(pRB, (ma_uint32)framesProcessedInDeviceFormat, pFramesInClientFormat); 
if (result != MA_SUCCESS) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "Failed to commit capture PCM frames to ring buffer.", result);
break;
}

pRunningFramesInDeviceFormat = ma_offset_ptr(pRunningFramesInDeviceFormat, framesProcessedInDeviceFormat * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
totalDeviceFramesProcessed += (ma_uint32)framesProcessedInDeviceFormat; 


if (framesProcessedInClientFormat == 0 && framesProcessedInDeviceFormat == 0) {
break; 
}
}

return MA_SUCCESS;
}

static ma_result ma_device__handle_duplex_callback_playback(ma_device* pDevice, ma_uint32 frameCount, void* pFramesInInternalFormat, ma_pcm_rb* pRB)
{
ma_result result;
ma_uint8 playbackFramesInExternalFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 silentInputFrames[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 totalFramesToReadFromClient;
ma_uint32 totalFramesReadFromClient;
ma_uint32 totalFramesReadOut = 0;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(frameCount > 0);
MA_ASSERT(pFramesInInternalFormat != NULL);
MA_ASSERT(pRB != NULL);





MA_ZERO_MEMORY(silentInputFrames, sizeof(silentInputFrames));


totalFramesToReadFromClient = (ma_uint32)ma_data_converter_get_required_input_frame_count(&pDevice->playback.converter, frameCount);
totalFramesReadFromClient = 0;
while (totalFramesReadFromClient < totalFramesToReadFromClient && ma_device_is_started(pDevice)) {
ma_uint32 framesRemainingFromClient;
ma_uint32 framesToProcessFromClient;
ma_uint32 inputFrameCount;
void* pInputFrames;

framesRemainingFromClient = (totalFramesToReadFromClient - totalFramesReadFromClient);
framesToProcessFromClient = sizeof(playbackFramesInExternalFormat) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
if (framesToProcessFromClient > framesRemainingFromClient) {
framesToProcessFromClient = framesRemainingFromClient;
}


inputFrameCount = framesToProcessFromClient;
result = ma_pcm_rb_acquire_read(pRB, &inputFrameCount, &pInputFrames);
if (result == MA_SUCCESS) {
if (inputFrameCount > 0) {

ma_device__on_data(pDevice, playbackFramesInExternalFormat, pInputFrames, inputFrameCount);
} else {
if (ma_pcm_rb_pointer_disance(pRB) == 0) {
break; 
}
}


result = ma_pcm_rb_commit_read(pRB, inputFrameCount, pInputFrames);
if (result != MA_SUCCESS) {
break; 
}
} else {

inputFrameCount = ma_min(
sizeof(playbackFramesInExternalFormat) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels),
sizeof(silentInputFrames) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels)
);

ma_device__on_data(pDevice, playbackFramesInExternalFormat, silentInputFrames, inputFrameCount);
}


{
ma_uint64 framesConvertedIn = inputFrameCount;
ma_uint64 framesConvertedOut = (frameCount - totalFramesReadOut);
ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackFramesInExternalFormat, &framesConvertedIn, pFramesInInternalFormat, &framesConvertedOut);

totalFramesReadFromClient += (ma_uint32)framesConvertedIn; 
totalFramesReadOut += (ma_uint32)framesConvertedOut; 
pFramesInInternalFormat = ma_offset_ptr(pFramesInInternalFormat, framesConvertedOut * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
}
}

return MA_SUCCESS;
}
#endif 


static MA_INLINE void ma_device__set_state(ma_device* pDevice, ma_uint32 newState)
{
ma_atomic_exchange_32(&pDevice->state, newState);
}


static MA_INLINE ma_uint32 ma_device__get_state(ma_device* pDevice)
{
return pDevice->state;
}


#if defined(MA_WIN32)
GUID MA_GUID_KSDATAFORMAT_SUBTYPE_PCM = {0x00000001, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
GUID MA_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = {0x00000003, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};


#endif


typedef struct
{
ma_device_type deviceType;
const ma_device_id* pDeviceID;
char* pName;
size_t nameBufferSize;
ma_bool32 foundDevice;
} ma_context__try_get_device_name_by_id__enum_callback_data;

static ma_bool32 ma_context__try_get_device_name_by_id__enum_callback(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pDeviceInfo, void* pUserData)
{
ma_context__try_get_device_name_by_id__enum_callback_data* pData = (ma_context__try_get_device_name_by_id__enum_callback_data*)pUserData;
MA_ASSERT(pData != NULL);

if (pData->deviceType == deviceType) {
if (pContext->onDeviceIDEqual(pContext, pData->pDeviceID, &pDeviceInfo->id)) {
ma_strncpy_s(pData->pName, pData->nameBufferSize, pDeviceInfo->name, (size_t)-1);
pData->foundDevice = MA_TRUE;
}
}

return !pData->foundDevice;
}






static ma_result ma_context__try_get_device_name_by_id(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, char* pName, size_t nameBufferSize)
{
ma_result result;
ma_context__try_get_device_name_by_id__enum_callback_data data;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pName != NULL);

if (pDeviceID == NULL) {
return MA_NO_DEVICE;
}

data.deviceType = deviceType;
data.pDeviceID = pDeviceID;
data.pName = pName;
data.nameBufferSize = nameBufferSize;
data.foundDevice = MA_FALSE;
result = ma_context_enumerate_devices(pContext, ma_context__try_get_device_name_by_id__enum_callback, &data);
if (result != MA_SUCCESS) {
return result;
}

if (!data.foundDevice) {
return MA_NO_DEVICE;
} else {
return MA_SUCCESS;
}
}


ma_uint32 ma_get_format_priority_index(ma_format format) 
{
ma_uint32 i;
for (i = 0; i < ma_countof(g_maFormatPriorities); ++i) {
if (g_maFormatPriorities[i] == format) {
return i;
}
}


return (ma_uint32)-1;
}

static ma_result ma_device__post_init_setup(ma_device* pDevice, ma_device_type deviceType);







#if defined(MA_HAS_NULL)

#define MA_DEVICE_OP_NONE__NULL 0
#define MA_DEVICE_OP_START__NULL 1
#define MA_DEVICE_OP_SUSPEND__NULL 2
#define MA_DEVICE_OP_KILL__NULL 3

static ma_thread_result MA_THREADCALL ma_device_thread__null(void* pData)
{
ma_device* pDevice = (ma_device*)pData;
MA_ASSERT(pDevice != NULL);

for (;;) { 

ma_event_wait(&pDevice->null_device.operationEvent);




if (pDevice->null_device.operation == MA_DEVICE_OP_START__NULL) {
ma_atomic_exchange_32(&pDevice->null_device.operation, MA_DEVICE_OP_NONE__NULL);


ma_timer_init(&pDevice->null_device.timer);


while (pDevice->null_device.operation != MA_DEVICE_OP_NONE__NULL && pDevice->null_device.operation != MA_DEVICE_OP_START__NULL) {
ma_sleep(10); 
}


ma_atomic_exchange_32(&pDevice->null_device.operationResult, MA_SUCCESS);
ma_event_signal(&pDevice->null_device.operationCompletionEvent);
continue;
}


if (pDevice->null_device.operation == MA_DEVICE_OP_SUSPEND__NULL) {
ma_atomic_exchange_32(&pDevice->null_device.operation, MA_DEVICE_OP_NONE__NULL);


pDevice->null_device.priorRunTime += ma_timer_get_time_in_seconds(&pDevice->null_device.timer);
ma_timer_init(&pDevice->null_device.timer);


ma_atomic_exchange_32(&pDevice->null_device.operationResult, MA_SUCCESS);
ma_event_signal(&pDevice->null_device.operationCompletionEvent);
continue;
}


if (pDevice->null_device.operation == MA_DEVICE_OP_KILL__NULL) {
ma_atomic_exchange_32(&pDevice->null_device.operation, MA_DEVICE_OP_NONE__NULL);
ma_atomic_exchange_32(&pDevice->null_device.operationResult, MA_SUCCESS);
ma_event_signal(&pDevice->null_device.operationCompletionEvent);
break;
}


if (pDevice->null_device.operation == MA_DEVICE_OP_NONE__NULL) {
MA_ASSERT(MA_FALSE); 
ma_atomic_exchange_32(&pDevice->null_device.operationResult, MA_INVALID_OPERATION);
ma_event_signal(&pDevice->null_device.operationCompletionEvent);
continue; 
}
}

return (ma_thread_result)0;
}

static ma_result ma_device_do_operation__null(ma_device* pDevice, ma_uint32 operation)
{
ma_atomic_exchange_32(&pDevice->null_device.operation, operation);
if (!ma_event_signal(&pDevice->null_device.operationEvent)) {
return MA_ERROR;
}

if (!ma_event_wait(&pDevice->null_device.operationCompletionEvent)) {
return MA_ERROR;
}

return pDevice->null_device.operationResult;
}

static ma_uint64 ma_device_get_total_run_time_in_frames__null(ma_device* pDevice)
{
ma_uint32 internalSampleRate;
if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
internalSampleRate = pDevice->capture.internalSampleRate;
} else {
internalSampleRate = pDevice->playback.internalSampleRate;
}


return (ma_uint64)((pDevice->null_device.priorRunTime + ma_timer_get_time_in_seconds(&pDevice->null_device.timer)) * internalSampleRate);
}

static ma_bool32 ma_context_is_device_id_equal__null(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return pID0->nullbackend == pID1->nullbackend;
}

static ma_result ma_context_enumerate_devices__null(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult = MA_TRUE;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), "NULL Playback Device", (size_t)-1);
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), "NULL Capture Device", (size_t)-1);
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__null(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_uint32 iFormat;

MA_ASSERT(pContext != NULL);

if (pDeviceID != NULL && pDeviceID->nullbackend != 0) {
return MA_NO_DEVICE; 
}


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), "NULL Playback Device", (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), "NULL Capture Device", (size_t)-1);
}


pDeviceInfo->formatCount = ma_format_count - 1; 
for (iFormat = 0; iFormat < pDeviceInfo->formatCount; ++iFormat) {
pDeviceInfo->formats[iFormat] = (ma_format)(iFormat + 1); 
}

pDeviceInfo->minChannels = 1;
pDeviceInfo->maxChannels = MA_MAX_CHANNELS;
pDeviceInfo->minSampleRate = MA_SAMPLE_RATE_8000;
pDeviceInfo->maxSampleRate = MA_SAMPLE_RATE_384000;

(void)pContext;
(void)shareMode;
return MA_SUCCESS;
}


static void ma_device_uninit__null(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);


ma_device_do_operation__null(pDevice, MA_DEVICE_OP_KILL__NULL);


ma_event_uninit(&pDevice->null_device.operationCompletionEvent);
ma_event_uninit(&pDevice->null_device.operationEvent);
}

static ma_result ma_device_init__null(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;
ma_uint32 periodSizeInFrames;

MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->null_device);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

periodSizeInFrames = pConfig->periodSizeInFrames;
if (periodSizeInFrames == 0) {
periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, pConfig->sampleRate);
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_strncpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), "NULL Capture Device", (size_t)-1);
pDevice->capture.internalFormat = pConfig->capture.format;
pDevice->capture.internalChannels = pConfig->capture.channels;
ma_channel_map_copy(pDevice->capture.internalChannelMap, pConfig->capture.channelMap, pConfig->capture.channels);
pDevice->capture.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->capture.internalPeriods = pConfig->periods;
}
if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), "NULL Playback Device", (size_t)-1);
pDevice->playback.internalFormat = pConfig->playback.format;
pDevice->playback.internalChannels = pConfig->playback.channels;
ma_channel_map_copy(pDevice->playback.internalChannelMap, pConfig->playback.channelMap, pConfig->playback.channels);
pDevice->playback.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->playback.internalPeriods = pConfig->periods;
}





result = ma_event_init(pContext, &pDevice->null_device.operationEvent);
if (result != MA_SUCCESS) {
return result;
}

result = ma_event_init(pContext, &pDevice->null_device.operationCompletionEvent);
if (result != MA_SUCCESS) {
return result;
}

result = ma_thread_create(pContext, &pDevice->thread, ma_device_thread__null, pDevice);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

static ma_result ma_device_start__null(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

ma_device_do_operation__null(pDevice, MA_DEVICE_OP_START__NULL);

ma_atomic_exchange_32(&pDevice->null_device.isStarted, MA_TRUE);
return MA_SUCCESS;
}

static ma_result ma_device_stop__null(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

ma_device_do_operation__null(pDevice, MA_DEVICE_OP_SUSPEND__NULL);

ma_atomic_exchange_32(&pDevice->null_device.isStarted, MA_FALSE);
return MA_SUCCESS;
}

static ma_result ma_device_write__null(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
ma_result result = MA_SUCCESS;
ma_uint32 totalPCMFramesProcessed;
ma_bool32 wasStartedOnEntry;

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

wasStartedOnEntry = pDevice->null_device.isStarted;


totalPCMFramesProcessed = 0;
while (totalPCMFramesProcessed < frameCount) {
ma_uint64 targetFrame;


if (pDevice->null_device.currentPeriodFramesRemainingPlayback > 0) {
ma_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);
ma_uint32 framesToProcess = pDevice->null_device.currentPeriodFramesRemainingPlayback;
if (framesToProcess > framesRemaining) {
framesToProcess = framesRemaining;
}


(void)pPCMFrames;

pDevice->null_device.currentPeriodFramesRemainingPlayback -= framesToProcess;
totalPCMFramesProcessed += framesToProcess;
}


if (pDevice->null_device.currentPeriodFramesRemainingPlayback == 0) {
pDevice->null_device.currentPeriodFramesRemainingPlayback = 0;

if (!pDevice->null_device.isStarted && !wasStartedOnEntry) {
result = ma_device_start__null(pDevice);
if (result != MA_SUCCESS) {
break;
}
}
}


MA_ASSERT(totalPCMFramesProcessed <= frameCount);
if (totalPCMFramesProcessed == frameCount) {
break;
}


targetFrame = pDevice->null_device.lastProcessedFramePlayback;
for (;;) {
ma_uint64 currentFrame;


if (!pDevice->null_device.isStarted) {
break;
}

currentFrame = ma_device_get_total_run_time_in_frames__null(pDevice);
if (currentFrame >= targetFrame) {
break;
}


ma_sleep(10);
}

pDevice->null_device.lastProcessedFramePlayback += pDevice->playback.internalPeriodSizeInFrames;
pDevice->null_device.currentPeriodFramesRemainingPlayback = pDevice->playback.internalPeriodSizeInFrames;
}

if (pFramesWritten != NULL) {
*pFramesWritten = totalPCMFramesProcessed;
}

return result;
}

static ma_result ma_device_read__null(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
ma_result result = MA_SUCCESS;
ma_uint32 totalPCMFramesProcessed;

if (pFramesRead != NULL) {
*pFramesRead = 0;
}


totalPCMFramesProcessed = 0;
while (totalPCMFramesProcessed < frameCount) {
ma_uint64 targetFrame;


if (pDevice->null_device.currentPeriodFramesRemainingCapture > 0) {
ma_uint32 bpf = ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 framesRemaining = (frameCount - totalPCMFramesProcessed);
ma_uint32 framesToProcess = pDevice->null_device.currentPeriodFramesRemainingCapture;
if (framesToProcess > framesRemaining) {
framesToProcess = framesRemaining;
}


MA_ZERO_MEMORY(ma_offset_ptr(pPCMFrames, totalPCMFramesProcessed*bpf), framesToProcess*bpf);

pDevice->null_device.currentPeriodFramesRemainingCapture -= framesToProcess;
totalPCMFramesProcessed += framesToProcess;
}


if (pDevice->null_device.currentPeriodFramesRemainingCapture == 0) {
pDevice->null_device.currentPeriodFramesRemainingCapture = 0;
}


MA_ASSERT(totalPCMFramesProcessed <= frameCount);
if (totalPCMFramesProcessed == frameCount) {
break;
}


targetFrame = pDevice->null_device.lastProcessedFrameCapture + pDevice->capture.internalPeriodSizeInFrames;
for (;;) {
ma_uint64 currentFrame;


if (!pDevice->null_device.isStarted) {
break;
}

currentFrame = ma_device_get_total_run_time_in_frames__null(pDevice);
if (currentFrame >= targetFrame) {
break;
}


ma_sleep(10);
}

pDevice->null_device.lastProcessedFrameCapture += pDevice->capture.internalPeriodSizeInFrames;
pDevice->null_device.currentPeriodFramesRemainingCapture = pDevice->capture.internalPeriodSizeInFrames;
}

if (pFramesRead != NULL) {
*pFramesRead = totalPCMFramesProcessed;
}

return result;
}

static ma_result ma_device_main_loop__null(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
result = ma_device_start__null(pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__null(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;


for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__null(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__null(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__null(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}



ma_device_stop__null(pDevice);

return result;
}

static ma_result ma_context_uninit__null(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_null);

(void)pContext;
return MA_SUCCESS;
}

static ma_result ma_context_init__null(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

(void)pConfig;

pContext->onUninit = ma_context_uninit__null;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__null;
pContext->onEnumDevices = ma_context_enumerate_devices__null;
pContext->onGetDeviceInfo = ma_context_get_device_info__null;
pContext->onDeviceInit = ma_device_init__null;
pContext->onDeviceUninit = ma_device_uninit__null;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__null;


return MA_SUCCESS;
}
#endif







#if defined(MA_WIN32)
#if defined(MA_WIN32_DESKTOP)
#define ma_CoInitializeEx(pContext, pvReserved, dwCoInit) ((MA_PFN_CoInitializeEx)pContext->win32.CoInitializeEx)(pvReserved, dwCoInit)
#define ma_CoUninitialize(pContext) ((MA_PFN_CoUninitialize)pContext->win32.CoUninitialize)()
#define ma_CoCreateInstance(pContext, rclsid, pUnkOuter, dwClsContext, riid, ppv) ((MA_PFN_CoCreateInstance)pContext->win32.CoCreateInstance)(rclsid, pUnkOuter, dwClsContext, riid, ppv)
#define ma_CoTaskMemFree(pContext, pv) ((MA_PFN_CoTaskMemFree)pContext->win32.CoTaskMemFree)(pv)
#define ma_PropVariantClear(pContext, pvar) ((MA_PFN_PropVariantClear)pContext->win32.PropVariantClear)(pvar)
#else
#define ma_CoInitializeEx(pContext, pvReserved, dwCoInit) CoInitializeEx(pvReserved, dwCoInit)
#define ma_CoUninitialize(pContext) CoUninitialize()
#define ma_CoCreateInstance(pContext, rclsid, pUnkOuter, dwClsContext, riid, ppv) CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv)
#define ma_CoTaskMemFree(pContext, pv) CoTaskMemFree(pv)
#define ma_PropVariantClear(pContext, pvar) PropVariantClear(pvar)
#endif

#if !defined(MAXULONG_PTR)
typedef size_t DWORD_PTR;
#endif

#if !defined(WAVE_FORMAT_44M08)
#define WAVE_FORMAT_44M08 0x00000100
#define WAVE_FORMAT_44S08 0x00000200
#define WAVE_FORMAT_44M16 0x00000400
#define WAVE_FORMAT_44S16 0x00000800
#define WAVE_FORMAT_48M08 0x00001000
#define WAVE_FORMAT_48S08 0x00002000
#define WAVE_FORMAT_48M16 0x00004000
#define WAVE_FORMAT_48S16 0x00008000
#define WAVE_FORMAT_96M08 0x00010000
#define WAVE_FORMAT_96S08 0x00020000
#define WAVE_FORMAT_96M16 0x00040000
#define WAVE_FORMAT_96S16 0x00080000
#endif

#if !defined(SPEAKER_FRONT_LEFT)
#define SPEAKER_FRONT_LEFT 0x1
#define SPEAKER_FRONT_RIGHT 0x2
#define SPEAKER_FRONT_CENTER 0x4
#define SPEAKER_LOW_FREQUENCY 0x8
#define SPEAKER_BACK_LEFT 0x10
#define SPEAKER_BACK_RIGHT 0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER 0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER 0x80
#define SPEAKER_BACK_CENTER 0x100
#define SPEAKER_SIDE_LEFT 0x200
#define SPEAKER_SIDE_RIGHT 0x400
#define SPEAKER_TOP_CENTER 0x800
#define SPEAKER_TOP_FRONT_LEFT 0x1000
#define SPEAKER_TOP_FRONT_CENTER 0x2000
#define SPEAKER_TOP_FRONT_RIGHT 0x4000
#define SPEAKER_TOP_BACK_LEFT 0x8000
#define SPEAKER_TOP_BACK_CENTER 0x10000
#define SPEAKER_TOP_BACK_RIGHT 0x20000
#endif





#if (defined(_MSC_VER) && !defined(_WAVEFORMATEXTENSIBLE_)) || defined(__DMC__)
typedef struct
{
WAVEFORMATEX Format;
union
{
WORD wValidBitsPerSample;
WORD wSamplesPerBlock;
WORD wReserved;
} Samples;
DWORD dwChannelMask;
GUID SubFormat;
} WAVEFORMATEXTENSIBLE;
#endif

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define WAVE_FORMAT_EXTENSIBLE 0xFFFE
#endif

#if !defined(WAVE_FORMAT_IEEE_FLOAT)
#define WAVE_FORMAT_IEEE_FLOAT 0x0003
#endif

static GUID MA_GUID_NULL = {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};


static ma_uint8 ma_channel_id_to_ma__win32(DWORD id)
{
switch (id)
{
case SPEAKER_FRONT_LEFT: return MA_CHANNEL_FRONT_LEFT;
case SPEAKER_FRONT_RIGHT: return MA_CHANNEL_FRONT_RIGHT;
case SPEAKER_FRONT_CENTER: return MA_CHANNEL_FRONT_CENTER;
case SPEAKER_LOW_FREQUENCY: return MA_CHANNEL_LFE;
case SPEAKER_BACK_LEFT: return MA_CHANNEL_BACK_LEFT;
case SPEAKER_BACK_RIGHT: return MA_CHANNEL_BACK_RIGHT;
case SPEAKER_FRONT_LEFT_OF_CENTER: return MA_CHANNEL_FRONT_LEFT_CENTER;
case SPEAKER_FRONT_RIGHT_OF_CENTER: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case SPEAKER_BACK_CENTER: return MA_CHANNEL_BACK_CENTER;
case SPEAKER_SIDE_LEFT: return MA_CHANNEL_SIDE_LEFT;
case SPEAKER_SIDE_RIGHT: return MA_CHANNEL_SIDE_RIGHT;
case SPEAKER_TOP_CENTER: return MA_CHANNEL_TOP_CENTER;
case SPEAKER_TOP_FRONT_LEFT: return MA_CHANNEL_TOP_FRONT_LEFT;
case SPEAKER_TOP_FRONT_CENTER: return MA_CHANNEL_TOP_FRONT_CENTER;
case SPEAKER_TOP_FRONT_RIGHT: return MA_CHANNEL_TOP_FRONT_RIGHT;
case SPEAKER_TOP_BACK_LEFT: return MA_CHANNEL_TOP_BACK_LEFT;
case SPEAKER_TOP_BACK_CENTER: return MA_CHANNEL_TOP_BACK_CENTER;
case SPEAKER_TOP_BACK_RIGHT: return MA_CHANNEL_TOP_BACK_RIGHT;
default: return 0;
}
}


static DWORD ma_channel_id_to_win32(DWORD id)
{
switch (id)
{
case MA_CHANNEL_MONO: return SPEAKER_FRONT_CENTER;
case MA_CHANNEL_FRONT_LEFT: return SPEAKER_FRONT_LEFT;
case MA_CHANNEL_FRONT_RIGHT: return SPEAKER_FRONT_RIGHT;
case MA_CHANNEL_FRONT_CENTER: return SPEAKER_FRONT_CENTER;
case MA_CHANNEL_LFE: return SPEAKER_LOW_FREQUENCY;
case MA_CHANNEL_BACK_LEFT: return SPEAKER_BACK_LEFT;
case MA_CHANNEL_BACK_RIGHT: return SPEAKER_BACK_RIGHT;
case MA_CHANNEL_FRONT_LEFT_CENTER: return SPEAKER_FRONT_LEFT_OF_CENTER;
case MA_CHANNEL_FRONT_RIGHT_CENTER: return SPEAKER_FRONT_RIGHT_OF_CENTER;
case MA_CHANNEL_BACK_CENTER: return SPEAKER_BACK_CENTER;
case MA_CHANNEL_SIDE_LEFT: return SPEAKER_SIDE_LEFT;
case MA_CHANNEL_SIDE_RIGHT: return SPEAKER_SIDE_RIGHT;
case MA_CHANNEL_TOP_CENTER: return SPEAKER_TOP_CENTER;
case MA_CHANNEL_TOP_FRONT_LEFT: return SPEAKER_TOP_FRONT_LEFT;
case MA_CHANNEL_TOP_FRONT_CENTER: return SPEAKER_TOP_FRONT_CENTER;
case MA_CHANNEL_TOP_FRONT_RIGHT: return SPEAKER_TOP_FRONT_RIGHT;
case MA_CHANNEL_TOP_BACK_LEFT: return SPEAKER_TOP_BACK_LEFT;
case MA_CHANNEL_TOP_BACK_CENTER: return SPEAKER_TOP_BACK_CENTER;
case MA_CHANNEL_TOP_BACK_RIGHT: return SPEAKER_TOP_BACK_RIGHT;
default: return 0;
}
}


static DWORD ma_channel_map_to_channel_mask__win32(const ma_channel channelMap[MA_MAX_CHANNELS], ma_uint32 channels)
{
DWORD dwChannelMask = 0;
ma_uint32 iChannel;

for (iChannel = 0; iChannel < channels; ++iChannel) {
dwChannelMask |= ma_channel_id_to_win32(channelMap[iChannel]);
}

return dwChannelMask;
}


static void ma_channel_mask_to_channel_map__win32(DWORD dwChannelMask, ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
if (channels == 1 && dwChannelMask == 0) {
channelMap[0] = MA_CHANNEL_MONO;
} else if (channels == 2 && dwChannelMask == 0) {
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
} else {
if (channels == 1 && (dwChannelMask & SPEAKER_FRONT_CENTER) != 0) {
channelMap[0] = MA_CHANNEL_MONO;
} else {

ma_uint32 iChannel = 0;
ma_uint32 iBit;

for (iBit = 0; iBit < 32; ++iBit) {
DWORD bitValue = (dwChannelMask & (1UL << iBit));
if (bitValue != 0) {

channelMap[iChannel] = ma_channel_id_to_ma__win32(bitValue);
iChannel += 1;
}
}
}
}
}

#if defined(__cplusplus)
static ma_bool32 ma_is_guid_equal(const void* a, const void* b)
{
return IsEqualGUID(*(const GUID*)a, *(const GUID*)b);
}
#else
#define ma_is_guid_equal(a, b) IsEqualGUID((const GUID*)a, (const GUID*)b)
#endif

static ma_format ma_format_from_WAVEFORMATEX(const WAVEFORMATEX* pWF)
{
MA_ASSERT(pWF != NULL);

if (pWF->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
const WAVEFORMATEXTENSIBLE* pWFEX = (const WAVEFORMATEXTENSIBLE*)pWF;
if (ma_is_guid_equal(&pWFEX->SubFormat, &MA_GUID_KSDATAFORMAT_SUBTYPE_PCM)) {
if (pWFEX->Samples.wValidBitsPerSample == 32) {
return ma_format_s32;
}
if (pWFEX->Samples.wValidBitsPerSample == 24) {
if (pWFEX->Format.wBitsPerSample == 32) {

}
if (pWFEX->Format.wBitsPerSample == 24) {
return ma_format_s24;
}
}
if (pWFEX->Samples.wValidBitsPerSample == 16) {
return ma_format_s16;
}
if (pWFEX->Samples.wValidBitsPerSample == 8) {
return ma_format_u8;
}
}
if (ma_is_guid_equal(&pWFEX->SubFormat, &MA_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
if (pWFEX->Samples.wValidBitsPerSample == 32) {
return ma_format_f32;
}





}
} else {
if (pWF->wFormatTag == WAVE_FORMAT_PCM) {
if (pWF->wBitsPerSample == 32) {
return ma_format_s32;
}
if (pWF->wBitsPerSample == 24) {
return ma_format_s24;
}
if (pWF->wBitsPerSample == 16) {
return ma_format_s16;
}
if (pWF->wBitsPerSample == 8) {
return ma_format_u8;
}
}
if (pWF->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
if (pWF->wBitsPerSample == 32) {
return ma_format_f32;
}
if (pWF->wBitsPerSample == 64) {

}
}
}

return ma_format_unknown;
}
#endif







#if defined(MA_HAS_WASAPI)
#if 0
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4091) 
#endif
#include <audioclient.h>
#include <mmdeviceapi.h>
#if defined(_MSC_VER)
#pragma warning(pop)
#endif
#endif 


#define MA_WIN32_WINNT_VISTA 0x0600
#define MA_VER_MINORVERSION 0x01
#define MA_VER_MAJORVERSION 0x02
#define MA_VER_SERVICEPACKMAJOR 0x20
#define MA_VER_GREATER_EQUAL 0x03

typedef struct {
DWORD dwOSVersionInfoSize;
DWORD dwMajorVersion;
DWORD dwMinorVersion;
DWORD dwBuildNumber;
DWORD dwPlatformId;
WCHAR szCSDVersion[128];
WORD wServicePackMajor;
WORD wServicePackMinor;
WORD wSuiteMask;
BYTE wProductType;
BYTE wReserved;
} ma_OSVERSIONINFOEXW;

typedef BOOL (WINAPI * ma_PFNVerifyVersionInfoW) (ma_OSVERSIONINFOEXW* lpVersionInfo, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
typedef ULONGLONG (WINAPI * ma_PFNVerSetConditionMask)(ULONGLONG dwlConditionMask, DWORD dwTypeBitMask, BYTE dwConditionMask);


#if !defined(PROPERTYKEY_DEFINED)
#define PROPERTYKEY_DEFINED
typedef struct
{
GUID fmtid;
DWORD pid;
} PROPERTYKEY;
#endif


static MA_INLINE void ma_PropVariantInit(PROPVARIANT* pProp)
{
MA_ZERO_OBJECT(pProp);
}


static const PROPERTYKEY MA_PKEY_Device_FriendlyName = {{0xA45C254E, 0xDF1C, 0x4EFD, {0x80, 0x20, 0x67, 0xD1, 0x46, 0xA8, 0x50, 0xE0}}, 14};
static const PROPERTYKEY MA_PKEY_AudioEngine_DeviceFormat = {{0xF19F064D, 0x82C, 0x4E27, {0xBC, 0x73, 0x68, 0x82, 0xA1, 0xBB, 0x8E, 0x4C}}, 0};

static const IID MA_IID_IUnknown = {0x00000000, 0x0000, 0x0000, {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}}; 
static const IID MA_IID_IAgileObject = {0x94EA2B94, 0xE9CC, 0x49E0, {0xC0, 0xFF, 0xEE, 0x64, 0xCA, 0x8F, 0x5B, 0x90}}; 

static const IID MA_IID_IAudioClient = {0x1CB9AD4C, 0xDBFA, 0x4C32, {0xB1, 0x78, 0xC2, 0xF5, 0x68, 0xA7, 0x03, 0xB2}}; 
static const IID MA_IID_IAudioClient2 = {0x726778CD, 0xF60A, 0x4EDA, {0x82, 0xDE, 0xE4, 0x76, 0x10, 0xCD, 0x78, 0xAA}}; 
static const IID MA_IID_IAudioClient3 = {0x7ED4EE07, 0x8E67, 0x4CD4, {0x8C, 0x1A, 0x2B, 0x7A, 0x59, 0x87, 0xAD, 0x42}}; 
static const IID MA_IID_IAudioRenderClient = {0xF294ACFC, 0x3146, 0x4483, {0xA7, 0xBF, 0xAD, 0xDC, 0xA7, 0xC2, 0x60, 0xE2}}; 
static const IID MA_IID_IAudioCaptureClient = {0xC8ADBD64, 0xE71E, 0x48A0, {0xA4, 0xDE, 0x18, 0x5C, 0x39, 0x5C, 0xD3, 0x17}}; 
static const IID MA_IID_IMMNotificationClient = {0x7991EEC9, 0x7E89, 0x4D85, {0x83, 0x90, 0x6C, 0x70, 0x3C, 0xEC, 0x60, 0xC0}}; 
#if !defined(MA_WIN32_DESKTOP)
static const IID MA_IID_DEVINTERFACE_AUDIO_RENDER = {0xE6327CAD, 0xDCEC, 0x4949, {0xAE, 0x8A, 0x99, 0x1E, 0x97, 0x6A, 0x79, 0xD2}}; 
static const IID MA_IID_DEVINTERFACE_AUDIO_CAPTURE = {0x2EEF81BE, 0x33FA, 0x4800, {0x96, 0x70, 0x1C, 0xD4, 0x74, 0x97, 0x2C, 0x3F}}; 
static const IID MA_IID_IActivateAudioInterfaceCompletionHandler = {0x41D949AB, 0x9862, 0x444A, {0x80, 0xF6, 0xC2, 0x61, 0x33, 0x4D, 0xA5, 0xEB}}; 
#endif

static const IID MA_CLSID_MMDeviceEnumerator_Instance = {0xBCDE0395, 0xE52F, 0x467C, {0x8E, 0x3D, 0xC4, 0x57, 0x92, 0x91, 0x69, 0x2E}}; 
static const IID MA_IID_IMMDeviceEnumerator_Instance = {0xA95664D2, 0x9614, 0x4F35, {0xA7, 0x46, 0xDE, 0x8D, 0xB6, 0x36, 0x17, 0xE6}}; 
#if defined(__cplusplus)
#define MA_CLSID_MMDeviceEnumerator MA_CLSID_MMDeviceEnumerator_Instance
#define MA_IID_IMMDeviceEnumerator MA_IID_IMMDeviceEnumerator_Instance
#else
#define MA_CLSID_MMDeviceEnumerator &MA_CLSID_MMDeviceEnumerator_Instance
#define MA_IID_IMMDeviceEnumerator &MA_IID_IMMDeviceEnumerator_Instance
#endif

typedef struct ma_IUnknown ma_IUnknown;
#if defined(MA_WIN32_DESKTOP)
#define MA_MM_DEVICE_STATE_ACTIVE 1
#define MA_MM_DEVICE_STATE_DISABLED 2
#define MA_MM_DEVICE_STATE_NOTPRESENT 4
#define MA_MM_DEVICE_STATE_UNPLUGGED 8

typedef struct ma_IMMDeviceEnumerator ma_IMMDeviceEnumerator;
typedef struct ma_IMMDeviceCollection ma_IMMDeviceCollection;
typedef struct ma_IMMDevice ma_IMMDevice;
#else
typedef struct ma_IActivateAudioInterfaceCompletionHandler ma_IActivateAudioInterfaceCompletionHandler;
typedef struct ma_IActivateAudioInterfaceAsyncOperation ma_IActivateAudioInterfaceAsyncOperation;
#endif
typedef struct ma_IPropertyStore ma_IPropertyStore;
typedef struct ma_IAudioClient ma_IAudioClient;
typedef struct ma_IAudioClient2 ma_IAudioClient2;
typedef struct ma_IAudioClient3 ma_IAudioClient3;
typedef struct ma_IAudioRenderClient ma_IAudioRenderClient;
typedef struct ma_IAudioCaptureClient ma_IAudioCaptureClient;

typedef ma_int64 MA_REFERENCE_TIME;

#define MA_AUDCLNT_STREAMFLAGS_CROSSPROCESS 0x00010000
#define MA_AUDCLNT_STREAMFLAGS_LOOPBACK 0x00020000
#define MA_AUDCLNT_STREAMFLAGS_EVENTCALLBACK 0x00040000
#define MA_AUDCLNT_STREAMFLAGS_NOPERSIST 0x00080000
#define MA_AUDCLNT_STREAMFLAGS_RATEADJUST 0x00100000
#define MA_AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY 0x08000000
#define MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM 0x80000000
#define MA_AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED 0x10000000
#define MA_AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE 0x20000000
#define MA_AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED 0x40000000


#define MA_AUDCLNT_E_INVALID_DEVICE_PERIOD (-2004287456)
#define MA_AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED (-2004287463)
#define MA_AUDCLNT_S_BUFFER_EMPTY (143196161)
#define MA_AUDCLNT_E_DEVICE_IN_USE (-2004287478)


#define MA_AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY 1
#define MA_AUDCLNT_BUFFERFLAGS_SILENT 2
#define MA_AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR 4

typedef enum
{
ma_eRender = 0,
ma_eCapture = 1,
ma_eAll = 2
} ma_EDataFlow;

typedef enum
{
ma_eConsole = 0,
ma_eMultimedia = 1,
ma_eCommunications = 2
} ma_ERole;

typedef enum
{
MA_AUDCLNT_SHAREMODE_SHARED,
MA_AUDCLNT_SHAREMODE_EXCLUSIVE
} MA_AUDCLNT_SHAREMODE;

typedef enum
{
MA_AudioCategory_Other = 0 
} MA_AUDIO_STREAM_CATEGORY;

typedef struct
{
UINT32 cbSize;
BOOL bIsOffload;
MA_AUDIO_STREAM_CATEGORY eCategory;
} ma_AudioClientProperties;


typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IUnknown* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IUnknown* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IUnknown* pThis);
} ma_IUnknownVtbl;
struct ma_IUnknown
{
ma_IUnknownVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IUnknown_QueryInterface(ma_IUnknown* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IUnknown_AddRef(ma_IUnknown* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IUnknown_Release(ma_IUnknown* pThis) { return pThis->lpVtbl->Release(pThis); }

#if defined(MA_WIN32_DESKTOP)

typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IMMNotificationClient* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IMMNotificationClient* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IMMNotificationClient* pThis);


HRESULT (STDMETHODCALLTYPE * OnDeviceStateChanged) (ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID, DWORD dwNewState);
HRESULT (STDMETHODCALLTYPE * OnDeviceAdded) (ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID);
HRESULT (STDMETHODCALLTYPE * OnDeviceRemoved) (ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID);
HRESULT (STDMETHODCALLTYPE * OnDefaultDeviceChanged)(ma_IMMNotificationClient* pThis, ma_EDataFlow dataFlow, ma_ERole role, LPCWSTR pDefaultDeviceID);
HRESULT (STDMETHODCALLTYPE * OnPropertyValueChanged)(ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID, const PROPERTYKEY key);
} ma_IMMNotificationClientVtbl;


typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IMMDeviceEnumerator* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IMMDeviceEnumerator* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IMMDeviceEnumerator* pThis);


HRESULT (STDMETHODCALLTYPE * EnumAudioEndpoints) (ma_IMMDeviceEnumerator* pThis, ma_EDataFlow dataFlow, DWORD dwStateMask, ma_IMMDeviceCollection** ppDevices);
HRESULT (STDMETHODCALLTYPE * GetDefaultAudioEndpoint) (ma_IMMDeviceEnumerator* pThis, ma_EDataFlow dataFlow, ma_ERole role, ma_IMMDevice** ppEndpoint);
HRESULT (STDMETHODCALLTYPE * GetDevice) (ma_IMMDeviceEnumerator* pThis, LPCWSTR pID, ma_IMMDevice** ppDevice);
HRESULT (STDMETHODCALLTYPE * RegisterEndpointNotificationCallback) (ma_IMMDeviceEnumerator* pThis, ma_IMMNotificationClient* pClient);
HRESULT (STDMETHODCALLTYPE * UnregisterEndpointNotificationCallback)(ma_IMMDeviceEnumerator* pThis, ma_IMMNotificationClient* pClient);
} ma_IMMDeviceEnumeratorVtbl;
struct ma_IMMDeviceEnumerator
{
ma_IMMDeviceEnumeratorVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_QueryInterface(ma_IMMDeviceEnumerator* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IMMDeviceEnumerator_AddRef(ma_IMMDeviceEnumerator* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IMMDeviceEnumerator_Release(ma_IMMDeviceEnumerator* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_EnumAudioEndpoints(ma_IMMDeviceEnumerator* pThis, ma_EDataFlow dataFlow, DWORD dwStateMask, ma_IMMDeviceCollection** ppDevices) { return pThis->lpVtbl->EnumAudioEndpoints(pThis, dataFlow, dwStateMask, ppDevices); }
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_GetDefaultAudioEndpoint(ma_IMMDeviceEnumerator* pThis, ma_EDataFlow dataFlow, ma_ERole role, ma_IMMDevice** ppEndpoint) { return pThis->lpVtbl->GetDefaultAudioEndpoint(pThis, dataFlow, role, ppEndpoint); }
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_GetDevice(ma_IMMDeviceEnumerator* pThis, LPCWSTR pID, ma_IMMDevice** ppDevice) { return pThis->lpVtbl->GetDevice(pThis, pID, ppDevice); }
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_RegisterEndpointNotificationCallback(ma_IMMDeviceEnumerator* pThis, ma_IMMNotificationClient* pClient) { return pThis->lpVtbl->RegisterEndpointNotificationCallback(pThis, pClient); }
static MA_INLINE HRESULT ma_IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(ma_IMMDeviceEnumerator* pThis, ma_IMMNotificationClient* pClient) { return pThis->lpVtbl->UnregisterEndpointNotificationCallback(pThis, pClient); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IMMDeviceCollection* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IMMDeviceCollection* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IMMDeviceCollection* pThis);


HRESULT (STDMETHODCALLTYPE * GetCount)(ma_IMMDeviceCollection* pThis, UINT* pDevices);
HRESULT (STDMETHODCALLTYPE * Item) (ma_IMMDeviceCollection* pThis, UINT nDevice, ma_IMMDevice** ppDevice);
} ma_IMMDeviceCollectionVtbl;
struct ma_IMMDeviceCollection
{
ma_IMMDeviceCollectionVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IMMDeviceCollection_QueryInterface(ma_IMMDeviceCollection* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IMMDeviceCollection_AddRef(ma_IMMDeviceCollection* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IMMDeviceCollection_Release(ma_IMMDeviceCollection* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IMMDeviceCollection_GetCount(ma_IMMDeviceCollection* pThis, UINT* pDevices) { return pThis->lpVtbl->GetCount(pThis, pDevices); }
static MA_INLINE HRESULT ma_IMMDeviceCollection_Item(ma_IMMDeviceCollection* pThis, UINT nDevice, ma_IMMDevice** ppDevice) { return pThis->lpVtbl->Item(pThis, nDevice, ppDevice); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IMMDevice* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IMMDevice* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IMMDevice* pThis);


HRESULT (STDMETHODCALLTYPE * Activate) (ma_IMMDevice* pThis, const IID* const iid, DWORD dwClsCtx, PROPVARIANT* pActivationParams, void** ppInterface);
HRESULT (STDMETHODCALLTYPE * OpenPropertyStore)(ma_IMMDevice* pThis, DWORD stgmAccess, ma_IPropertyStore** ppProperties);
HRESULT (STDMETHODCALLTYPE * GetId) (ma_IMMDevice* pThis, LPWSTR *pID);
HRESULT (STDMETHODCALLTYPE * GetState) (ma_IMMDevice* pThis, DWORD *pState);
} ma_IMMDeviceVtbl;
struct ma_IMMDevice
{
ma_IMMDeviceVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IMMDevice_QueryInterface(ma_IMMDevice* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IMMDevice_AddRef(ma_IMMDevice* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IMMDevice_Release(ma_IMMDevice* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IMMDevice_Activate(ma_IMMDevice* pThis, const IID* const iid, DWORD dwClsCtx, PROPVARIANT* pActivationParams, void** ppInterface) { return pThis->lpVtbl->Activate(pThis, iid, dwClsCtx, pActivationParams, ppInterface); }
static MA_INLINE HRESULT ma_IMMDevice_OpenPropertyStore(ma_IMMDevice* pThis, DWORD stgmAccess, ma_IPropertyStore** ppProperties) { return pThis->lpVtbl->OpenPropertyStore(pThis, stgmAccess, ppProperties); }
static MA_INLINE HRESULT ma_IMMDevice_GetId(ma_IMMDevice* pThis, LPWSTR *pID) { return pThis->lpVtbl->GetId(pThis, pID); }
static MA_INLINE HRESULT ma_IMMDevice_GetState(ma_IMMDevice* pThis, DWORD *pState) { return pThis->lpVtbl->GetState(pThis, pState); }
#else

typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IActivateAudioInterfaceAsyncOperation* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IActivateAudioInterfaceAsyncOperation* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IActivateAudioInterfaceAsyncOperation* pThis);


HRESULT (STDMETHODCALLTYPE * GetActivateResult)(ma_IActivateAudioInterfaceAsyncOperation* pThis, HRESULT *pActivateResult, ma_IUnknown** ppActivatedInterface);
} ma_IActivateAudioInterfaceAsyncOperationVtbl;
struct ma_IActivateAudioInterfaceAsyncOperation
{
ma_IActivateAudioInterfaceAsyncOperationVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IActivateAudioInterfaceAsyncOperation_QueryInterface(ma_IActivateAudioInterfaceAsyncOperation* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IActivateAudioInterfaceAsyncOperation_AddRef(ma_IActivateAudioInterfaceAsyncOperation* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IActivateAudioInterfaceAsyncOperation_Release(ma_IActivateAudioInterfaceAsyncOperation* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IActivateAudioInterfaceAsyncOperation_GetActivateResult(ma_IActivateAudioInterfaceAsyncOperation* pThis, HRESULT *pActivateResult, ma_IUnknown** ppActivatedInterface) { return pThis->lpVtbl->GetActivateResult(pThis, pActivateResult, ppActivatedInterface); }
#endif


typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IPropertyStore* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IPropertyStore* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IPropertyStore* pThis);


HRESULT (STDMETHODCALLTYPE * GetCount)(ma_IPropertyStore* pThis, DWORD* pPropCount);
HRESULT (STDMETHODCALLTYPE * GetAt) (ma_IPropertyStore* pThis, DWORD propIndex, PROPERTYKEY* pPropKey);
HRESULT (STDMETHODCALLTYPE * GetValue)(ma_IPropertyStore* pThis, const PROPERTYKEY* const pKey, PROPVARIANT* pPropVar);
HRESULT (STDMETHODCALLTYPE * SetValue)(ma_IPropertyStore* pThis, const PROPERTYKEY* const pKey, const PROPVARIANT* const pPropVar);
HRESULT (STDMETHODCALLTYPE * Commit) (ma_IPropertyStore* pThis);
} ma_IPropertyStoreVtbl;
struct ma_IPropertyStore
{
ma_IPropertyStoreVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IPropertyStore_QueryInterface(ma_IPropertyStore* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IPropertyStore_AddRef(ma_IPropertyStore* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IPropertyStore_Release(ma_IPropertyStore* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IPropertyStore_GetCount(ma_IPropertyStore* pThis, DWORD* pPropCount) { return pThis->lpVtbl->GetCount(pThis, pPropCount); }
static MA_INLINE HRESULT ma_IPropertyStore_GetAt(ma_IPropertyStore* pThis, DWORD propIndex, PROPERTYKEY* pPropKey) { return pThis->lpVtbl->GetAt(pThis, propIndex, pPropKey); }
static MA_INLINE HRESULT ma_IPropertyStore_GetValue(ma_IPropertyStore* pThis, const PROPERTYKEY* const pKey, PROPVARIANT* pPropVar) { return pThis->lpVtbl->GetValue(pThis, pKey, pPropVar); }
static MA_INLINE HRESULT ma_IPropertyStore_SetValue(ma_IPropertyStore* pThis, const PROPERTYKEY* const pKey, const PROPVARIANT* const pPropVar) { return pThis->lpVtbl->SetValue(pThis, pKey, pPropVar); }
static MA_INLINE HRESULT ma_IPropertyStore_Commit(ma_IPropertyStore* pThis) { return pThis->lpVtbl->Commit(pThis); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IAudioClient* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IAudioClient* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IAudioClient* pThis);


HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IAudioClient* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
HRESULT (STDMETHODCALLTYPE * GetBufferSize) (ma_IAudioClient* pThis, ma_uint32* pNumBufferFrames);
HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (ma_IAudioClient* pThis, MA_REFERENCE_TIME* pLatency);
HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(ma_IAudioClient* pThis, ma_uint32* pNumPaddingFrames);
HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(ma_IAudioClient* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
HRESULT (STDMETHODCALLTYPE * GetMixFormat) (ma_IAudioClient* pThis, WAVEFORMATEX** ppDeviceFormat);
HRESULT (STDMETHODCALLTYPE * GetDevicePeriod) (ma_IAudioClient* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod);
HRESULT (STDMETHODCALLTYPE * Start) (ma_IAudioClient* pThis);
HRESULT (STDMETHODCALLTYPE * Stop) (ma_IAudioClient* pThis);
HRESULT (STDMETHODCALLTYPE * Reset) (ma_IAudioClient* pThis);
HRESULT (STDMETHODCALLTYPE * SetEventHandle) (ma_IAudioClient* pThis, HANDLE eventHandle);
HRESULT (STDMETHODCALLTYPE * GetService) (ma_IAudioClient* pThis, const IID* const riid, void** pp);
} ma_IAudioClientVtbl;
struct ma_IAudioClient
{
ma_IAudioClientVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IAudioClient_QueryInterface(ma_IAudioClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IAudioClient_AddRef(ma_IAudioClient* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IAudioClient_Release(ma_IAudioClient* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IAudioClient_Initialize(ma_IAudioClient* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
static MA_INLINE HRESULT ma_IAudioClient_GetBufferSize(ma_IAudioClient* pThis, ma_uint32* pNumBufferFrames) { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
static MA_INLINE HRESULT ma_IAudioClient_GetStreamLatency(ma_IAudioClient* pThis, MA_REFERENCE_TIME* pLatency) { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
static MA_INLINE HRESULT ma_IAudioClient_GetCurrentPadding(ma_IAudioClient* pThis, ma_uint32* pNumPaddingFrames) { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
static MA_INLINE HRESULT ma_IAudioClient_IsFormatSupported(ma_IAudioClient* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
static MA_INLINE HRESULT ma_IAudioClient_GetMixFormat(ma_IAudioClient* pThis, WAVEFORMATEX** ppDeviceFormat) { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
static MA_INLINE HRESULT ma_IAudioClient_GetDevicePeriod(ma_IAudioClient* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
static MA_INLINE HRESULT ma_IAudioClient_Start(ma_IAudioClient* pThis) { return pThis->lpVtbl->Start(pThis); }
static MA_INLINE HRESULT ma_IAudioClient_Stop(ma_IAudioClient* pThis) { return pThis->lpVtbl->Stop(pThis); }
static MA_INLINE HRESULT ma_IAudioClient_Reset(ma_IAudioClient* pThis) { return pThis->lpVtbl->Reset(pThis); }
static MA_INLINE HRESULT ma_IAudioClient_SetEventHandle(ma_IAudioClient* pThis, HANDLE eventHandle) { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
static MA_INLINE HRESULT ma_IAudioClient_GetService(ma_IAudioClient* pThis, const IID* const riid, void** pp) { return pThis->lpVtbl->GetService(pThis, riid, pp); }


typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IAudioClient2* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IAudioClient2* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IAudioClient2* pThis);


HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IAudioClient2* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
HRESULT (STDMETHODCALLTYPE * GetBufferSize) (ma_IAudioClient2* pThis, ma_uint32* pNumBufferFrames);
HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (ma_IAudioClient2* pThis, MA_REFERENCE_TIME* pLatency);
HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(ma_IAudioClient2* pThis, ma_uint32* pNumPaddingFrames);
HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(ma_IAudioClient2* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
HRESULT (STDMETHODCALLTYPE * GetMixFormat) (ma_IAudioClient2* pThis, WAVEFORMATEX** ppDeviceFormat);
HRESULT (STDMETHODCALLTYPE * GetDevicePeriod) (ma_IAudioClient2* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod);
HRESULT (STDMETHODCALLTYPE * Start) (ma_IAudioClient2* pThis);
HRESULT (STDMETHODCALLTYPE * Stop) (ma_IAudioClient2* pThis);
HRESULT (STDMETHODCALLTYPE * Reset) (ma_IAudioClient2* pThis);
HRESULT (STDMETHODCALLTYPE * SetEventHandle) (ma_IAudioClient2* pThis, HANDLE eventHandle);
HRESULT (STDMETHODCALLTYPE * GetService) (ma_IAudioClient2* pThis, const IID* const riid, void** pp);


HRESULT (STDMETHODCALLTYPE * IsOffloadCapable) (ma_IAudioClient2* pThis, MA_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable);
HRESULT (STDMETHODCALLTYPE * SetClientProperties)(ma_IAudioClient2* pThis, const ma_AudioClientProperties* pProperties);
HRESULT (STDMETHODCALLTYPE * GetBufferSizeLimits)(ma_IAudioClient2* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MA_REFERENCE_TIME* pMinBufferDuration, MA_REFERENCE_TIME* pMaxBufferDuration);
} ma_IAudioClient2Vtbl;
struct ma_IAudioClient2
{
ma_IAudioClient2Vtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IAudioClient2_QueryInterface(ma_IAudioClient2* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IAudioClient2_AddRef(ma_IAudioClient2* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IAudioClient2_Release(ma_IAudioClient2* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IAudioClient2_Initialize(ma_IAudioClient2* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
static MA_INLINE HRESULT ma_IAudioClient2_GetBufferSize(ma_IAudioClient2* pThis, ma_uint32* pNumBufferFrames) { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
static MA_INLINE HRESULT ma_IAudioClient2_GetStreamLatency(ma_IAudioClient2* pThis, MA_REFERENCE_TIME* pLatency) { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
static MA_INLINE HRESULT ma_IAudioClient2_GetCurrentPadding(ma_IAudioClient2* pThis, ma_uint32* pNumPaddingFrames) { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
static MA_INLINE HRESULT ma_IAudioClient2_IsFormatSupported(ma_IAudioClient2* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
static MA_INLINE HRESULT ma_IAudioClient2_GetMixFormat(ma_IAudioClient2* pThis, WAVEFORMATEX** ppDeviceFormat) { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
static MA_INLINE HRESULT ma_IAudioClient2_GetDevicePeriod(ma_IAudioClient2* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
static MA_INLINE HRESULT ma_IAudioClient2_Start(ma_IAudioClient2* pThis) { return pThis->lpVtbl->Start(pThis); }
static MA_INLINE HRESULT ma_IAudioClient2_Stop(ma_IAudioClient2* pThis) { return pThis->lpVtbl->Stop(pThis); }
static MA_INLINE HRESULT ma_IAudioClient2_Reset(ma_IAudioClient2* pThis) { return pThis->lpVtbl->Reset(pThis); }
static MA_INLINE HRESULT ma_IAudioClient2_SetEventHandle(ma_IAudioClient2* pThis, HANDLE eventHandle) { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
static MA_INLINE HRESULT ma_IAudioClient2_GetService(ma_IAudioClient2* pThis, const IID* const riid, void** pp) { return pThis->lpVtbl->GetService(pThis, riid, pp); }
static MA_INLINE HRESULT ma_IAudioClient2_IsOffloadCapable(ma_IAudioClient2* pThis, MA_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable) { return pThis->lpVtbl->IsOffloadCapable(pThis, category, pOffloadCapable); }
static MA_INLINE HRESULT ma_IAudioClient2_SetClientProperties(ma_IAudioClient2* pThis, const ma_AudioClientProperties* pProperties) { return pThis->lpVtbl->SetClientProperties(pThis, pProperties); }
static MA_INLINE HRESULT ma_IAudioClient2_GetBufferSizeLimits(ma_IAudioClient2* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MA_REFERENCE_TIME* pMinBufferDuration, MA_REFERENCE_TIME* pMaxBufferDuration) { return pThis->lpVtbl->GetBufferSizeLimits(pThis, pFormat, eventDriven, pMinBufferDuration, pMaxBufferDuration); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IAudioClient3* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IAudioClient3* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IAudioClient3* pThis);


HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IAudioClient3* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
HRESULT (STDMETHODCALLTYPE * GetBufferSize) (ma_IAudioClient3* pThis, ma_uint32* pNumBufferFrames);
HRESULT (STDMETHODCALLTYPE * GetStreamLatency) (ma_IAudioClient3* pThis, MA_REFERENCE_TIME* pLatency);
HRESULT (STDMETHODCALLTYPE * GetCurrentPadding)(ma_IAudioClient3* pThis, ma_uint32* pNumPaddingFrames);
HRESULT (STDMETHODCALLTYPE * IsFormatSupported)(ma_IAudioClient3* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch);
HRESULT (STDMETHODCALLTYPE * GetMixFormat) (ma_IAudioClient3* pThis, WAVEFORMATEX** ppDeviceFormat);
HRESULT (STDMETHODCALLTYPE * GetDevicePeriod) (ma_IAudioClient3* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod);
HRESULT (STDMETHODCALLTYPE * Start) (ma_IAudioClient3* pThis);
HRESULT (STDMETHODCALLTYPE * Stop) (ma_IAudioClient3* pThis);
HRESULT (STDMETHODCALLTYPE * Reset) (ma_IAudioClient3* pThis);
HRESULT (STDMETHODCALLTYPE * SetEventHandle) (ma_IAudioClient3* pThis, HANDLE eventHandle);
HRESULT (STDMETHODCALLTYPE * GetService) (ma_IAudioClient3* pThis, const IID* const riid, void** pp);


HRESULT (STDMETHODCALLTYPE * IsOffloadCapable) (ma_IAudioClient3* pThis, MA_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable);
HRESULT (STDMETHODCALLTYPE * SetClientProperties)(ma_IAudioClient3* pThis, const ma_AudioClientProperties* pProperties);
HRESULT (STDMETHODCALLTYPE * GetBufferSizeLimits)(ma_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MA_REFERENCE_TIME* pMinBufferDuration, MA_REFERENCE_TIME* pMaxBufferDuration);


HRESULT (STDMETHODCALLTYPE * GetSharedModeEnginePeriod) (ma_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, UINT32* pDefaultPeriodInFrames, UINT32* pFundamentalPeriodInFrames, UINT32* pMinPeriodInFrames, UINT32* pMaxPeriodInFrames);
HRESULT (STDMETHODCALLTYPE * GetCurrentSharedModeEnginePeriod)(ma_IAudioClient3* pThis, WAVEFORMATEX** ppFormat, UINT32* pCurrentPeriodInFrames);
HRESULT (STDMETHODCALLTYPE * InitializeSharedAudioStream) (ma_IAudioClient3* pThis, DWORD streamFlags, UINT32 periodInFrames, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid);
} ma_IAudioClient3Vtbl;
struct ma_IAudioClient3
{
ma_IAudioClient3Vtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IAudioClient3_QueryInterface(ma_IAudioClient3* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IAudioClient3_AddRef(ma_IAudioClient3* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IAudioClient3_Release(ma_IAudioClient3* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IAudioClient3_Initialize(ma_IAudioClient3* pThis, MA_AUDCLNT_SHAREMODE shareMode, DWORD streamFlags, MA_REFERENCE_TIME bufferDuration, MA_REFERENCE_TIME periodicity, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGuid) { return pThis->lpVtbl->Initialize(pThis, shareMode, streamFlags, bufferDuration, periodicity, pFormat, pAudioSessionGuid); }
static MA_INLINE HRESULT ma_IAudioClient3_GetBufferSize(ma_IAudioClient3* pThis, ma_uint32* pNumBufferFrames) { return pThis->lpVtbl->GetBufferSize(pThis, pNumBufferFrames); }
static MA_INLINE HRESULT ma_IAudioClient3_GetStreamLatency(ma_IAudioClient3* pThis, MA_REFERENCE_TIME* pLatency) { return pThis->lpVtbl->GetStreamLatency(pThis, pLatency); }
static MA_INLINE HRESULT ma_IAudioClient3_GetCurrentPadding(ma_IAudioClient3* pThis, ma_uint32* pNumPaddingFrames) { return pThis->lpVtbl->GetCurrentPadding(pThis, pNumPaddingFrames); }
static MA_INLINE HRESULT ma_IAudioClient3_IsFormatSupported(ma_IAudioClient3* pThis, MA_AUDCLNT_SHAREMODE shareMode, const WAVEFORMATEX* pFormat, WAVEFORMATEX** ppClosestMatch) { return pThis->lpVtbl->IsFormatSupported(pThis, shareMode, pFormat, ppClosestMatch); }
static MA_INLINE HRESULT ma_IAudioClient3_GetMixFormat(ma_IAudioClient3* pThis, WAVEFORMATEX** ppDeviceFormat) { return pThis->lpVtbl->GetMixFormat(pThis, ppDeviceFormat); }
static MA_INLINE HRESULT ma_IAudioClient3_GetDevicePeriod(ma_IAudioClient3* pThis, MA_REFERENCE_TIME* pDefaultDevicePeriod, MA_REFERENCE_TIME* pMinimumDevicePeriod) { return pThis->lpVtbl->GetDevicePeriod(pThis, pDefaultDevicePeriod, pMinimumDevicePeriod); }
static MA_INLINE HRESULT ma_IAudioClient3_Start(ma_IAudioClient3* pThis) { return pThis->lpVtbl->Start(pThis); }
static MA_INLINE HRESULT ma_IAudioClient3_Stop(ma_IAudioClient3* pThis) { return pThis->lpVtbl->Stop(pThis); }
static MA_INLINE HRESULT ma_IAudioClient3_Reset(ma_IAudioClient3* pThis) { return pThis->lpVtbl->Reset(pThis); }
static MA_INLINE HRESULT ma_IAudioClient3_SetEventHandle(ma_IAudioClient3* pThis, HANDLE eventHandle) { return pThis->lpVtbl->SetEventHandle(pThis, eventHandle); }
static MA_INLINE HRESULT ma_IAudioClient3_GetService(ma_IAudioClient3* pThis, const IID* const riid, void** pp) { return pThis->lpVtbl->GetService(pThis, riid, pp); }
static MA_INLINE HRESULT ma_IAudioClient3_IsOffloadCapable(ma_IAudioClient3* pThis, MA_AUDIO_STREAM_CATEGORY category, BOOL* pOffloadCapable) { return pThis->lpVtbl->IsOffloadCapable(pThis, category, pOffloadCapable); }
static MA_INLINE HRESULT ma_IAudioClient3_SetClientProperties(ma_IAudioClient3* pThis, const ma_AudioClientProperties* pProperties) { return pThis->lpVtbl->SetClientProperties(pThis, pProperties); }
static MA_INLINE HRESULT ma_IAudioClient3_GetBufferSizeLimits(ma_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, BOOL eventDriven, MA_REFERENCE_TIME* pMinBufferDuration, MA_REFERENCE_TIME* pMaxBufferDuration) { return pThis->lpVtbl->GetBufferSizeLimits(pThis, pFormat, eventDriven, pMinBufferDuration, pMaxBufferDuration); }
static MA_INLINE HRESULT ma_IAudioClient3_GetSharedModeEnginePeriod(ma_IAudioClient3* pThis, const WAVEFORMATEX* pFormat, UINT32* pDefaultPeriodInFrames, UINT32* pFundamentalPeriodInFrames, UINT32* pMinPeriodInFrames, UINT32* pMaxPeriodInFrames) { return pThis->lpVtbl->GetSharedModeEnginePeriod(pThis, pFormat, pDefaultPeriodInFrames, pFundamentalPeriodInFrames, pMinPeriodInFrames, pMaxPeriodInFrames); }
static MA_INLINE HRESULT ma_IAudioClient3_GetCurrentSharedModeEnginePeriod(ma_IAudioClient3* pThis, WAVEFORMATEX** ppFormat, UINT32* pCurrentPeriodInFrames) { return pThis->lpVtbl->GetCurrentSharedModeEnginePeriod(pThis, ppFormat, pCurrentPeriodInFrames); }
static MA_INLINE HRESULT ma_IAudioClient3_InitializeSharedAudioStream(ma_IAudioClient3* pThis, DWORD streamFlags, UINT32 periodInFrames, const WAVEFORMATEX* pFormat, const GUID* pAudioSessionGUID) { return pThis->lpVtbl->InitializeSharedAudioStream(pThis, streamFlags, periodInFrames, pFormat, pAudioSessionGUID); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IAudioRenderClient* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IAudioRenderClient* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IAudioRenderClient* pThis);


HRESULT (STDMETHODCALLTYPE * GetBuffer) (ma_IAudioRenderClient* pThis, ma_uint32 numFramesRequested, BYTE** ppData);
HRESULT (STDMETHODCALLTYPE * ReleaseBuffer)(ma_IAudioRenderClient* pThis, ma_uint32 numFramesWritten, DWORD dwFlags);
} ma_IAudioRenderClientVtbl;
struct ma_IAudioRenderClient
{
ma_IAudioRenderClientVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IAudioRenderClient_QueryInterface(ma_IAudioRenderClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IAudioRenderClient_AddRef(ma_IAudioRenderClient* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IAudioRenderClient_Release(ma_IAudioRenderClient* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IAudioRenderClient_GetBuffer(ma_IAudioRenderClient* pThis, ma_uint32 numFramesRequested, BYTE** ppData) { return pThis->lpVtbl->GetBuffer(pThis, numFramesRequested, ppData); }
static MA_INLINE HRESULT ma_IAudioRenderClient_ReleaseBuffer(ma_IAudioRenderClient* pThis, ma_uint32 numFramesWritten, DWORD dwFlags) { return pThis->lpVtbl->ReleaseBuffer(pThis, numFramesWritten, dwFlags); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IAudioCaptureClient* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IAudioCaptureClient* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IAudioCaptureClient* pThis);


HRESULT (STDMETHODCALLTYPE * GetBuffer) (ma_IAudioCaptureClient* pThis, BYTE** ppData, ma_uint32* pNumFramesToRead, DWORD* pFlags, ma_uint64* pDevicePosition, ma_uint64* pQPCPosition);
HRESULT (STDMETHODCALLTYPE * ReleaseBuffer) (ma_IAudioCaptureClient* pThis, ma_uint32 numFramesRead);
HRESULT (STDMETHODCALLTYPE * GetNextPacketSize)(ma_IAudioCaptureClient* pThis, ma_uint32* pNumFramesInNextPacket);
} ma_IAudioCaptureClientVtbl;
struct ma_IAudioCaptureClient
{
ma_IAudioCaptureClientVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IAudioCaptureClient_QueryInterface(ma_IAudioCaptureClient* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IAudioCaptureClient_AddRef(ma_IAudioCaptureClient* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IAudioCaptureClient_Release(ma_IAudioCaptureClient* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IAudioCaptureClient_GetBuffer(ma_IAudioCaptureClient* pThis, BYTE** ppData, ma_uint32* pNumFramesToRead, DWORD* pFlags, ma_uint64* pDevicePosition, ma_uint64* pQPCPosition) { return pThis->lpVtbl->GetBuffer(pThis, ppData, pNumFramesToRead, pFlags, pDevicePosition, pQPCPosition); }
static MA_INLINE HRESULT ma_IAudioCaptureClient_ReleaseBuffer(ma_IAudioCaptureClient* pThis, ma_uint32 numFramesRead) { return pThis->lpVtbl->ReleaseBuffer(pThis, numFramesRead); }
static MA_INLINE HRESULT ma_IAudioCaptureClient_GetNextPacketSize(ma_IAudioCaptureClient* pThis, ma_uint32* pNumFramesInNextPacket) { return pThis->lpVtbl->GetNextPacketSize(pThis, pNumFramesInNextPacket); }

#if !defined(MA_WIN32_DESKTOP)
#include <mmdeviceapi.h>
typedef struct ma_completion_handler_uwp ma_completion_handler_uwp;

typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_completion_handler_uwp* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_completion_handler_uwp* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_completion_handler_uwp* pThis);


HRESULT (STDMETHODCALLTYPE * ActivateCompleted)(ma_completion_handler_uwp* pThis, ma_IActivateAudioInterfaceAsyncOperation* pActivateOperation);
} ma_completion_handler_uwp_vtbl;
struct ma_completion_handler_uwp
{
ma_completion_handler_uwp_vtbl* lpVtbl;
ma_uint32 counter;
HANDLE hEvent;
};

static HRESULT STDMETHODCALLTYPE ma_completion_handler_uwp_QueryInterface(ma_completion_handler_uwp* pThis, const IID* const riid, void** ppObject)
{




if (!ma_is_guid_equal(riid, &MA_IID_IUnknown) && !ma_is_guid_equal(riid, &MA_IID_IActivateAudioInterfaceCompletionHandler) && !ma_is_guid_equal(riid, &MA_IID_IAgileObject)) {
*ppObject = NULL;
return E_NOINTERFACE;
}


*ppObject = (void*)pThis;
((ma_completion_handler_uwp_vtbl*)pThis->lpVtbl)->AddRef(pThis);
return S_OK;
}

static ULONG STDMETHODCALLTYPE ma_completion_handler_uwp_AddRef(ma_completion_handler_uwp* pThis)
{
return (ULONG)ma_atomic_increment_32(&pThis->counter);
}

static ULONG STDMETHODCALLTYPE ma_completion_handler_uwp_Release(ma_completion_handler_uwp* pThis)
{
ma_uint32 newRefCount = ma_atomic_decrement_32(&pThis->counter);
if (newRefCount == 0) {
return 0; 
}

return (ULONG)newRefCount;
}

static HRESULT STDMETHODCALLTYPE ma_completion_handler_uwp_ActivateCompleted(ma_completion_handler_uwp* pThis, ma_IActivateAudioInterfaceAsyncOperation* pActivateOperation)
{
(void)pActivateOperation;
SetEvent(pThis->hEvent);
return S_OK;
}


static ma_completion_handler_uwp_vtbl g_maCompletionHandlerVtblInstance = {
ma_completion_handler_uwp_QueryInterface,
ma_completion_handler_uwp_AddRef,
ma_completion_handler_uwp_Release,
ma_completion_handler_uwp_ActivateCompleted
};

static ma_result ma_completion_handler_uwp_init(ma_completion_handler_uwp* pHandler)
{
MA_ASSERT(pHandler != NULL);
MA_ZERO_OBJECT(pHandler);

pHandler->lpVtbl = &g_maCompletionHandlerVtblInstance;
pHandler->counter = 1;
pHandler->hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
if (pHandler->hEvent == NULL) {
return MA_ERROR;
}

return MA_SUCCESS;
}

static void ma_completion_handler_uwp_uninit(ma_completion_handler_uwp* pHandler)
{
if (pHandler->hEvent != NULL) {
CloseHandle(pHandler->hEvent);
}
}

static void ma_completion_handler_uwp_wait(ma_completion_handler_uwp* pHandler)
{
WaitForSingleObject(pHandler->hEvent, INFINITE);
}
#endif 


#if defined(MA_WIN32_DESKTOP)
static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_QueryInterface(ma_IMMNotificationClient* pThis, const IID* const riid, void** ppObject)
{




if (!ma_is_guid_equal(riid, &MA_IID_IUnknown) && !ma_is_guid_equal(riid, &MA_IID_IMMNotificationClient)) {
*ppObject = NULL;
return E_NOINTERFACE;
}


*ppObject = (void*)pThis;
((ma_IMMNotificationClientVtbl*)pThis->lpVtbl)->AddRef(pThis);
return S_OK;
}

static ULONG STDMETHODCALLTYPE ma_IMMNotificationClient_AddRef(ma_IMMNotificationClient* pThis)
{
return (ULONG)ma_atomic_increment_32(&pThis->counter);
}

static ULONG STDMETHODCALLTYPE ma_IMMNotificationClient_Release(ma_IMMNotificationClient* pThis)
{
ma_uint32 newRefCount = ma_atomic_decrement_32(&pThis->counter);
if (newRefCount == 0) {
return 0; 
}

return (ULONG)newRefCount;
}


static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_OnDeviceStateChanged(ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID, DWORD dwNewState)
{
#if defined(MA_DEBUG_OUTPUT)
printf("IMMNotificationClient_OnDeviceStateChanged(pDeviceID=%S, dwNewState=%u)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)", (unsigned int)dwNewState);
#endif

(void)pThis;
(void)pDeviceID;
(void)dwNewState;
return S_OK;
}

static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_OnDeviceAdded(ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID)
{
#if defined(MA_DEBUG_OUTPUT)
printf("IMMNotificationClient_OnDeviceAdded(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif


(void)pThis;
(void)pDeviceID;
return S_OK;
}

static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_OnDeviceRemoved(ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID)
{
#if defined(MA_DEBUG_OUTPUT)
printf("IMMNotificationClient_OnDeviceRemoved(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif


(void)pThis;
(void)pDeviceID;
return S_OK;
}

static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_OnDefaultDeviceChanged(ma_IMMNotificationClient* pThis, ma_EDataFlow dataFlow, ma_ERole role, LPCWSTR pDefaultDeviceID)
{
#if defined(MA_DEBUG_OUTPUT)
printf("IMMNotificationClient_OnDefaultDeviceChanged(dataFlow=%d, role=%d, pDefaultDeviceID=%S)\n", dataFlow, role, (pDefaultDeviceID != NULL) ? pDefaultDeviceID : L"(NULL)");
#endif


if (role != ma_eConsole) {
return S_OK;
}


if ((pThis->pDevice->type == ma_device_type_playback && dataFlow != ma_eRender) ||
(pThis->pDevice->type == ma_device_type_capture && dataFlow != ma_eCapture)) {
return S_OK;
}


if ((dataFlow == ma_eRender && pThis->pDevice->wasapi.allowPlaybackAutoStreamRouting == MA_FALSE) ||
(dataFlow == ma_eCapture && pThis->pDevice->wasapi.allowCaptureAutoStreamRouting == MA_FALSE)) {
return S_OK;
}






if ((dataFlow == ma_eRender && pThis->pDevice->playback.shareMode == ma_share_mode_exclusive) ||
(dataFlow == ma_eCapture && pThis->pDevice->capture.shareMode == ma_share_mode_exclusive)) {
return S_OK;
}






if (dataFlow == ma_eRender && pThis->pDevice->type != ma_device_type_loopback) {
ma_atomic_exchange_32(&pThis->pDevice->wasapi.hasDefaultPlaybackDeviceChanged, MA_TRUE);
}
if (dataFlow == ma_eCapture || pThis->pDevice->type == ma_device_type_loopback) {
ma_atomic_exchange_32(&pThis->pDevice->wasapi.hasDefaultCaptureDeviceChanged, MA_TRUE);
}

(void)pDefaultDeviceID;
return S_OK;
}

static HRESULT STDMETHODCALLTYPE ma_IMMNotificationClient_OnPropertyValueChanged(ma_IMMNotificationClient* pThis, LPCWSTR pDeviceID, const PROPERTYKEY key)
{
#if defined(MA_DEBUG_OUTPUT)
printf("IMMNotificationClient_OnPropertyValueChanged(pDeviceID=%S)\n", (pDeviceID != NULL) ? pDeviceID : L"(NULL)");
#endif

(void)pThis;
(void)pDeviceID;
(void)key;
return S_OK;
}

static ma_IMMNotificationClientVtbl g_maNotificationCientVtbl = {
ma_IMMNotificationClient_QueryInterface,
ma_IMMNotificationClient_AddRef,
ma_IMMNotificationClient_Release,
ma_IMMNotificationClient_OnDeviceStateChanged,
ma_IMMNotificationClient_OnDeviceAdded,
ma_IMMNotificationClient_OnDeviceRemoved,
ma_IMMNotificationClient_OnDefaultDeviceChanged,
ma_IMMNotificationClient_OnPropertyValueChanged
};
#endif 

#if defined(MA_WIN32_DESKTOP)
typedef ma_IMMDevice ma_WASAPIDeviceInterface;
#else
typedef ma_IUnknown ma_WASAPIDeviceInterface;
#endif



static ma_bool32 ma_context_is_device_id_equal__wasapi(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return memcmp(pID0->wasapi, pID1->wasapi, sizeof(pID0->wasapi)) == 0;
}

static void ma_set_device_info_from_WAVEFORMATEX(const WAVEFORMATEX* pWF, ma_device_info* pInfo)
{
MA_ASSERT(pWF != NULL);
MA_ASSERT(pInfo != NULL);

pInfo->formatCount = 1;
pInfo->formats[0] = ma_format_from_WAVEFORMATEX(pWF);
pInfo->minChannels = pWF->nChannels;
pInfo->maxChannels = pWF->nChannels;
pInfo->minSampleRate = pWF->nSamplesPerSec;
pInfo->maxSampleRate = pWF->nSamplesPerSec;
}

static ma_result ma_context_get_device_info_from_IAudioClient__wasapi(ma_context* pContext, void* pMMDevice, ma_IAudioClient* pAudioClient, ma_share_mode shareMode, ma_device_info* pInfo)
{
MA_ASSERT(pAudioClient != NULL);
MA_ASSERT(pInfo != NULL);


if (shareMode == ma_share_mode_shared) {

WAVEFORMATEX* pWF = NULL;
HRESULT hr = ma_IAudioClient_GetMixFormat((ma_IAudioClient*)pAudioClient, (WAVEFORMATEX**)&pWF);
if (SUCCEEDED(hr)) {
ma_set_device_info_from_WAVEFORMATEX(pWF, pInfo);
return MA_SUCCESS;
} else {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve mix format for device info retrieval.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
} else {

#if defined(MA_WIN32_DESKTOP)




ma_IPropertyStore *pProperties;
HRESULT hr = ma_IMMDevice_OpenPropertyStore((ma_IMMDevice*)pMMDevice, STGM_READ, &pProperties);
if (SUCCEEDED(hr)) {
PROPVARIANT var;
ma_PropVariantInit(&var);

hr = ma_IPropertyStore_GetValue(pProperties, &MA_PKEY_AudioEngine_DeviceFormat, &var);
if (SUCCEEDED(hr)) {
WAVEFORMATEX* pWF = (WAVEFORMATEX*)var.blob.pBlobData;
ma_set_device_info_from_WAVEFORMATEX(pWF, pInfo);





hr = ma_IAudioClient_IsFormatSupported((ma_IAudioClient*)pAudioClient, MA_AUDCLNT_SHAREMODE_EXCLUSIVE, pWF, NULL);
ma_PropVariantClear(pContext, &var);

if (FAILED(hr)) {




ma_uint32 channels = pInfo->minChannels;
ma_format formatsToSearch[] = {
ma_format_s16,
ma_format_s24,

ma_format_f32,
ma_format_s32,
ma_format_u8
};
ma_channel defaultChannelMap[MA_MAX_CHANNELS];
WAVEFORMATEXTENSIBLE wf;
ma_bool32 found;
ma_uint32 iFormat;

ma_get_standard_channel_map(ma_standard_channel_map_microsoft, channels, defaultChannelMap);

MA_ZERO_OBJECT(&wf);
wf.Format.cbSize = sizeof(wf);
wf.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
wf.Format.nChannels = (WORD)channels;
wf.dwChannelMask = ma_channel_map_to_channel_mask__win32(defaultChannelMap, channels);

found = MA_FALSE;
for (iFormat = 0; iFormat < ma_countof(formatsToSearch); ++iFormat) {
ma_format format = formatsToSearch[iFormat];
ma_uint32 iSampleRate;

wf.Format.wBitsPerSample = (WORD)ma_get_bytes_per_sample(format)*8;
wf.Format.nBlockAlign = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
wf.Format.nAvgBytesPerSec = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;
wf.Samples.wValidBitsPerSample = wf.Format.wBitsPerSample;
if (format == ma_format_f32) {
wf.SubFormat = MA_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
} else {
wf.SubFormat = MA_GUID_KSDATAFORMAT_SUBTYPE_PCM;
}

for (iSampleRate = 0; iSampleRate < ma_countof(g_maStandardSampleRatePriorities); ++iSampleRate) {
wf.Format.nSamplesPerSec = g_maStandardSampleRatePriorities[iSampleRate];

hr = ma_IAudioClient_IsFormatSupported((ma_IAudioClient*)pAudioClient, MA_AUDCLNT_SHAREMODE_EXCLUSIVE, (WAVEFORMATEX*)&wf, NULL);
if (SUCCEEDED(hr)) {
ma_set_device_info_from_WAVEFORMATEX((WAVEFORMATEX*)&wf, pInfo);
found = MA_TRUE;
break;
}
}

if (found) {
break;
}
}

if (!found) {
ma_IPropertyStore_Release(pProperties);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to find suitable device format for device info retrieval.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}
} else {
ma_IPropertyStore_Release(pProperties);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve device format for device info retrieval.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

ma_IPropertyStore_Release(pProperties);
} else {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to open property store for device info retrieval.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

return MA_SUCCESS;
#else

return MA_ERROR;
#endif
}
}

#if defined(MA_WIN32_DESKTOP)
static ma_EDataFlow ma_device_type_to_EDataFlow(ma_device_type deviceType)
{
if (deviceType == ma_device_type_playback) {
return ma_eRender;
} else if (deviceType == ma_device_type_capture) {
return ma_eCapture;
} else {
MA_ASSERT(MA_FALSE);
return ma_eRender; 
}
}

static ma_result ma_context_create_IMMDeviceEnumerator__wasapi(ma_context* pContext, ma_IMMDeviceEnumerator** ppDeviceEnumerator)
{
HRESULT hr;
ma_IMMDeviceEnumerator* pDeviceEnumerator;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppDeviceEnumerator != NULL);

hr = ma_CoCreateInstance(pContext, MA_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MA_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create device enumerator.", MA_ERROR);
}

*ppDeviceEnumerator = pDeviceEnumerator;

return MA_SUCCESS;
}

static LPWSTR ma_context_get_default_device_id_from_IMMDeviceEnumerator__wasapi(ma_context* pContext, ma_IMMDeviceEnumerator* pDeviceEnumerator, ma_device_type deviceType)
{
HRESULT hr;
ma_IMMDevice* pMMDefaultDevice = NULL;
LPWSTR pDefaultDeviceID = NULL;
ma_EDataFlow dataFlow;
ma_ERole role;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pDeviceEnumerator != NULL);


dataFlow = ma_device_type_to_EDataFlow(deviceType);


role = ma_eConsole;

hr = ma_IMMDeviceEnumerator_GetDefaultAudioEndpoint(pDeviceEnumerator, dataFlow, role, &pMMDefaultDevice);
if (FAILED(hr)) {
return NULL;
}

hr = ma_IMMDevice_GetId(pMMDefaultDevice, &pDefaultDeviceID);

ma_IMMDevice_Release(pMMDefaultDevice);
pMMDefaultDevice = NULL;

if (FAILED(hr)) {
return NULL;
}

return pDefaultDeviceID;
}

static LPWSTR ma_context_get_default_device_id__wasapi(ma_context* pContext, ma_device_type deviceType) 
{
ma_result result;
ma_IMMDeviceEnumerator* pDeviceEnumerator;
LPWSTR pDefaultDeviceID = NULL;

MA_ASSERT(pContext != NULL);

result = ma_context_create_IMMDeviceEnumerator__wasapi(pContext, &pDeviceEnumerator);
if (result != MA_SUCCESS) {
return NULL;
}

pDefaultDeviceID = ma_context_get_default_device_id_from_IMMDeviceEnumerator__wasapi(pContext, pDeviceEnumerator, deviceType);

ma_IMMDeviceEnumerator_Release(pDeviceEnumerator);
return pDefaultDeviceID;
}

static ma_result ma_context_get_MMDevice__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_IMMDevice** ppMMDevice)
{
ma_IMMDeviceEnumerator* pDeviceEnumerator;
HRESULT hr;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppMMDevice != NULL);

hr = ma_CoCreateInstance(pContext, MA_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MA_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create IMMDeviceEnumerator.", MA_FAILED_TO_INIT_BACKEND);
}

if (pDeviceID == NULL) {
hr = ma_IMMDeviceEnumerator_GetDefaultAudioEndpoint(pDeviceEnumerator, (deviceType == ma_device_type_capture) ? ma_eCapture : ma_eRender, ma_eConsole, ppMMDevice);
} else {
hr = ma_IMMDeviceEnumerator_GetDevice(pDeviceEnumerator, pDeviceID->wasapi, ppMMDevice);
}

ma_IMMDeviceEnumerator_Release(pDeviceEnumerator);
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve IMMDevice.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info_from_MMDevice__wasapi(ma_context* pContext, ma_IMMDevice* pMMDevice, ma_share_mode shareMode, LPWSTR pDefaultDeviceID, ma_bool32 onlySimpleInfo, ma_device_info* pInfo)
{
LPWSTR pDeviceID;
HRESULT hr;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pMMDevice != NULL);
MA_ASSERT(pInfo != NULL);


hr = ma_IMMDevice_GetId(pMMDevice, &pDeviceID);
if (SUCCEEDED(hr)) {
size_t idlen = wcslen(pDeviceID);
if (idlen+1 > ma_countof(pInfo->id.wasapi)) {
ma_CoTaskMemFree(pContext, pDeviceID);
MA_ASSERT(MA_FALSE); 
return MA_ERROR;
}

MA_COPY_MEMORY(pInfo->id.wasapi, pDeviceID, idlen * sizeof(wchar_t));
pInfo->id.wasapi[idlen] = '\0';

if (pDefaultDeviceID != NULL) {
if (wcscmp(pDeviceID, pDefaultDeviceID) == 0) {

pInfo->_private.isDefault = MA_TRUE;
}
}

ma_CoTaskMemFree(pContext, pDeviceID);
}

{
ma_IPropertyStore *pProperties;
hr = ma_IMMDevice_OpenPropertyStore(pMMDevice, STGM_READ, &pProperties);
if (SUCCEEDED(hr)) {
PROPVARIANT var;


ma_PropVariantInit(&var);
hr = ma_IPropertyStore_GetValue(pProperties, &MA_PKEY_Device_FriendlyName, &var);
if (SUCCEEDED(hr)) {
WideCharToMultiByte(CP_UTF8, 0, var.pwszVal, -1, pInfo->name, sizeof(pInfo->name), 0, FALSE);
ma_PropVariantClear(pContext, &var);
}

ma_IPropertyStore_Release(pProperties);
}
}


if (!onlySimpleInfo) {
ma_IAudioClient* pAudioClient;
hr = ma_IMMDevice_Activate(pMMDevice, &MA_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&pAudioClient);
if (SUCCEEDED(hr)) {
ma_result result = ma_context_get_device_info_from_IAudioClient__wasapi(pContext, pMMDevice, pAudioClient, shareMode, pInfo);

ma_IAudioClient_Release(pAudioClient);
return result;
} else {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to activate audio client for device info retrieval.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}

return MA_SUCCESS;
}

static ma_result ma_context_enumerate_devices_by_type__wasapi(ma_context* pContext, ma_IMMDeviceEnumerator* pDeviceEnumerator, ma_device_type deviceType, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_result result = MA_SUCCESS;
UINT deviceCount;
HRESULT hr;
ma_uint32 iDevice;
LPWSTR pDefaultDeviceID = NULL;
ma_IMMDeviceCollection* pDeviceCollection = NULL;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);


pDefaultDeviceID = ma_context_get_default_device_id_from_IMMDeviceEnumerator__wasapi(pContext, pDeviceEnumerator, deviceType);


hr = ma_IMMDeviceEnumerator_EnumAudioEndpoints(pDeviceEnumerator, ma_device_type_to_EDataFlow(deviceType), MA_MM_DEVICE_STATE_ACTIVE, &pDeviceCollection);
if (SUCCEEDED(hr)) {
hr = ma_IMMDeviceCollection_GetCount(pDeviceCollection, &deviceCount);
if (FAILED(hr)) {
result = ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to get device count.", MA_NO_DEVICE);
goto done;
}

for (iDevice = 0; iDevice < deviceCount; ++iDevice) {
ma_device_info deviceInfo;
ma_IMMDevice* pMMDevice;

MA_ZERO_OBJECT(&deviceInfo);

hr = ma_IMMDeviceCollection_Item(pDeviceCollection, iDevice, &pMMDevice);
if (SUCCEEDED(hr)) {
result = ma_context_get_device_info_from_MMDevice__wasapi(pContext, pMMDevice, ma_share_mode_shared, pDefaultDeviceID, MA_TRUE, &deviceInfo); 

ma_IMMDevice_Release(pMMDevice);
if (result == MA_SUCCESS) {
ma_bool32 cbResult = callback(pContext, deviceType, &deviceInfo, pUserData);
if (cbResult == MA_FALSE) {
break;
}
}
}
}
}

done:
if (pDefaultDeviceID != NULL) {
ma_CoTaskMemFree(pContext, pDefaultDeviceID);
pDefaultDeviceID = NULL;
}

if (pDeviceCollection != NULL) {
ma_IMMDeviceCollection_Release(pDeviceCollection);
pDeviceCollection = NULL;
}

return result;
}

static ma_result ma_context_get_IAudioClient_Desktop__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_IAudioClient** ppAudioClient, ma_IMMDevice** ppMMDevice)
{
ma_result result;
HRESULT hr;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppAudioClient != NULL);
MA_ASSERT(ppMMDevice != NULL);

result = ma_context_get_MMDevice__wasapi(pContext, deviceType, pDeviceID, ppMMDevice);
if (result != MA_SUCCESS) {
return result;
}

hr = ma_IMMDevice_Activate(*ppMMDevice, &MA_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)ppAudioClient);
if (FAILED(hr)) {
return MA_FAILED_TO_OPEN_BACKEND_DEVICE;
}

return MA_SUCCESS;
}
#else
static ma_result ma_context_get_IAudioClient_UWP__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_IAudioClient** ppAudioClient, ma_IUnknown** ppActivatedInterface)
{
ma_IActivateAudioInterfaceAsyncOperation *pAsyncOp = NULL;
ma_completion_handler_uwp completionHandler;
IID iid;
LPOLESTR iidStr;
HRESULT hr;
ma_result result;
HRESULT activateResult;
ma_IUnknown* pActivatedInterface;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppAudioClient != NULL);

if (pDeviceID != NULL) {
MA_COPY_MEMORY(&iid, pDeviceID->wasapi, sizeof(iid));
} else {
if (deviceType == ma_device_type_playback) {
iid = MA_IID_DEVINTERFACE_AUDIO_RENDER;
} else {
iid = MA_IID_DEVINTERFACE_AUDIO_CAPTURE;
}
}

#if defined(__cplusplus)
hr = StringFromIID(iid, &iidStr);
#else
hr = StringFromIID(&iid, &iidStr);
#endif
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to convert device IID to string for ActivateAudioInterfaceAsync(). Out of memory.", MA_OUT_OF_MEMORY);
}

result = ma_completion_handler_uwp_init(&completionHandler);
if (result != MA_SUCCESS) {
ma_CoTaskMemFree(pContext, iidStr);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for waiting for ActivateAudioInterfaceAsync().", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

#if defined(__cplusplus)
hr = ActivateAudioInterfaceAsync(iidStr, MA_IID_IAudioClient, NULL, (IActivateAudioInterfaceCompletionHandler*)&completionHandler, (IActivateAudioInterfaceAsyncOperation**)&pAsyncOp);
#else
hr = ActivateAudioInterfaceAsync(iidStr, &MA_IID_IAudioClient, NULL, (IActivateAudioInterfaceCompletionHandler*)&completionHandler, (IActivateAudioInterfaceAsyncOperation**)&pAsyncOp);
#endif
if (FAILED(hr)) {
ma_completion_handler_uwp_uninit(&completionHandler);
ma_CoTaskMemFree(pContext, iidStr);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] ActivateAudioInterfaceAsync() failed.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

ma_CoTaskMemFree(pContext, iidStr);


ma_completion_handler_uwp_wait(&completionHandler);
ma_completion_handler_uwp_uninit(&completionHandler);

hr = ma_IActivateAudioInterfaceAsyncOperation_GetActivateResult(pAsyncOp, &activateResult, &pActivatedInterface);
ma_IActivateAudioInterfaceAsyncOperation_Release(pAsyncOp);

if (FAILED(hr) || FAILED(activateResult)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to activate device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


hr = ma_IUnknown_QueryInterface(pActivatedInterface, &MA_IID_IAudioClient, (void**)ppAudioClient);
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to query IAudioClient interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (ppActivatedInterface) {
*ppActivatedInterface = pActivatedInterface;
} else {
ma_IUnknown_Release(pActivatedInterface);
}

return MA_SUCCESS;
}
#endif

static ma_result ma_context_get_IAudioClient__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_IAudioClient** ppAudioClient, ma_WASAPIDeviceInterface** ppDeviceInterface)
{
#if defined(MA_WIN32_DESKTOP)
return ma_context_get_IAudioClient_Desktop__wasapi(pContext, deviceType, pDeviceID, ppAudioClient, ppDeviceInterface);
#else
return ma_context_get_IAudioClient_UWP__wasapi(pContext, deviceType, pDeviceID, ppAudioClient, ppDeviceInterface);
#endif
}


static ma_result ma_context_enumerate_devices__wasapi(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{

#if defined(MA_WIN32_DESKTOP)

HRESULT hr;
ma_IMMDeviceEnumerator* pDeviceEnumerator;

hr = ma_CoCreateInstance(pContext, MA_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MA_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
if (FAILED(hr)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create device enumerator.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

ma_context_enumerate_devices_by_type__wasapi(pContext, pDeviceEnumerator, ma_device_type_playback, callback, pUserData);
ma_context_enumerate_devices_by_type__wasapi(pContext, pDeviceEnumerator, ma_device_type_capture, callback, pUserData);

ma_IMMDeviceEnumerator_Release(pDeviceEnumerator);
#else








if (callback) {
ma_bool32 cbResult = MA_TRUE;


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
deviceInfo._private.isDefault = MA_TRUE;
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
deviceInfo._private.isDefault = MA_TRUE;
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}
}
#endif

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
#if defined(MA_WIN32_DESKTOP)
ma_result result;
ma_IMMDevice* pMMDevice = NULL;
LPWSTR pDefaultDeviceID = NULL;

result = ma_context_get_MMDevice__wasapi(pContext, deviceType, pDeviceID, &pMMDevice);
if (result != MA_SUCCESS) {
return result;
}


pDefaultDeviceID = ma_context_get_default_device_id__wasapi(pContext, deviceType);

result = ma_context_get_device_info_from_MMDevice__wasapi(pContext, pMMDevice, shareMode, pDefaultDeviceID, MA_FALSE, pDeviceInfo); 

if (pDefaultDeviceID != NULL) {
ma_CoTaskMemFree(pContext, pDefaultDeviceID);
pDefaultDeviceID = NULL;
}

ma_IMMDevice_Release(pMMDevice);

return result;
#else
ma_IAudioClient* pAudioClient;
ma_result result;


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}


if (shareMode == ma_share_mode_exclusive) {
return MA_ERROR;
}

result = ma_context_get_IAudioClient_UWP__wasapi(pContext, deviceType, pDeviceID, &pAudioClient, NULL);
if (result != MA_SUCCESS) {
return result;
}

result = ma_context_get_device_info_from_IAudioClient__wasapi(pContext, NULL, pAudioClient, shareMode, pDeviceInfo);

pDeviceInfo->_private.isDefault = MA_TRUE; 

ma_IAudioClient_Release(pAudioClient);
return result;
#endif
}

static void ma_device_uninit__wasapi(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

#if defined(MA_WIN32_DESKTOP)
if (pDevice->wasapi.pDeviceEnumerator) {
((ma_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator)->lpVtbl->UnregisterEndpointNotificationCallback((ma_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator, &pDevice->wasapi.notificationClient);
ma_IMMDeviceEnumerator_Release((ma_IMMDeviceEnumerator*)pDevice->wasapi.pDeviceEnumerator);
}
#endif

if (pDevice->wasapi.pRenderClient) {
ma_IAudioRenderClient_Release((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
}
if (pDevice->wasapi.pCaptureClient) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
}

if (pDevice->wasapi.pAudioClientPlayback) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
}
if (pDevice->wasapi.pAudioClientCapture) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
}

if (pDevice->wasapi.hEventPlayback) {
CloseHandle(pDevice->wasapi.hEventPlayback);
}
if (pDevice->wasapi.hEventCapture) {
CloseHandle(pDevice->wasapi.hEventCapture);
}
}


typedef struct
{

ma_format formatIn;
ma_uint32 channelsIn;
ma_uint32 sampleRateIn;
ma_channel channelMapIn[MA_MAX_CHANNELS];
ma_uint32 periodSizeInFramesIn;
ma_uint32 periodSizeInMillisecondsIn;
ma_uint32 periodsIn;
ma_bool32 usingDefaultFormat;
ma_bool32 usingDefaultChannels;
ma_bool32 usingDefaultSampleRate;
ma_bool32 usingDefaultChannelMap;
ma_share_mode shareMode;
ma_bool32 noAutoConvertSRC;
ma_bool32 noDefaultQualitySRC;
ma_bool32 noHardwareOffloading;


ma_IAudioClient* pAudioClient;
ma_IAudioRenderClient* pRenderClient;
ma_IAudioCaptureClient* pCaptureClient;
ma_format formatOut;
ma_uint32 channelsOut;
ma_uint32 sampleRateOut;
ma_channel channelMapOut[MA_MAX_CHANNELS];
ma_uint32 periodSizeInFramesOut;
ma_uint32 periodsOut;
ma_bool32 usingAudioClient3;
char deviceName[256];
} ma_device_init_internal_data__wasapi;

static ma_result ma_device_init_internal__wasapi(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_device_init_internal_data__wasapi* pData)
{
HRESULT hr;
ma_result result = MA_SUCCESS;
const char* errorMsg = "";
MA_AUDCLNT_SHAREMODE shareMode = MA_AUDCLNT_SHAREMODE_SHARED;
DWORD streamFlags = 0;
MA_REFERENCE_TIME periodDurationInMicroseconds;
ma_bool32 wasInitializedUsingIAudioClient3 = MA_FALSE;
WAVEFORMATEXTENSIBLE wf = {0};
ma_WASAPIDeviceInterface* pDeviceInterface = NULL;
ma_IAudioClient2* pAudioClient2;
ma_uint32 nativeSampleRate;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pData != NULL);


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

pData->pAudioClient = NULL;
pData->pRenderClient = NULL;
pData->pCaptureClient = NULL;

streamFlags = MA_AUDCLNT_STREAMFLAGS_EVENTCALLBACK;
if (!pData->noAutoConvertSRC && !pData->usingDefaultSampleRate && pData->shareMode != ma_share_mode_exclusive) { 
streamFlags |= MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM;
}
if (!pData->noDefaultQualitySRC && !pData->usingDefaultSampleRate && (streamFlags & MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM) != 0) {
streamFlags |= MA_AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY;
}
if (deviceType == ma_device_type_loopback) {
streamFlags |= MA_AUDCLNT_STREAMFLAGS_LOOPBACK;
}

result = ma_context_get_IAudioClient__wasapi(pContext, deviceType, pDeviceID, &pData->pAudioClient, &pDeviceInterface);
if (result != MA_SUCCESS) {
goto done;
}



if (!pData->noHardwareOffloading) {
hr = ma_IAudioClient_QueryInterface(pData->pAudioClient, &MA_IID_IAudioClient2, (void**)&pAudioClient2);
if (SUCCEEDED(hr)) {
BOOL isHardwareOffloadingSupported = 0;
hr = ma_IAudioClient2_IsOffloadCapable(pAudioClient2, MA_AudioCategory_Other, &isHardwareOffloadingSupported);
if (SUCCEEDED(hr) && isHardwareOffloadingSupported) {
ma_AudioClientProperties clientProperties;
MA_ZERO_OBJECT(&clientProperties);
clientProperties.cbSize = sizeof(clientProperties);
clientProperties.bIsOffload = 1;
clientProperties.eCategory = MA_AudioCategory_Other;
ma_IAudioClient2_SetClientProperties(pAudioClient2, &clientProperties);
}

pAudioClient2->lpVtbl->Release(pAudioClient2);
}
}


result = MA_FORMAT_NOT_SUPPORTED;
if (pData->shareMode == ma_share_mode_exclusive) {
#if defined(MA_WIN32_DESKTOP)

ma_IPropertyStore* pStore = NULL;
hr = ma_IMMDevice_OpenPropertyStore(pDeviceInterface, STGM_READ, &pStore);
if (SUCCEEDED(hr)) {
PROPVARIANT prop;
ma_PropVariantInit(&prop);
hr = ma_IPropertyStore_GetValue(pStore, &MA_PKEY_AudioEngine_DeviceFormat, &prop);
if (SUCCEEDED(hr)) {
WAVEFORMATEX* pActualFormat = (WAVEFORMATEX*)prop.blob.pBlobData;
hr = ma_IAudioClient_IsFormatSupported((ma_IAudioClient*)pData->pAudioClient, MA_AUDCLNT_SHAREMODE_EXCLUSIVE, pActualFormat, NULL);
if (SUCCEEDED(hr)) {
MA_COPY_MEMORY(&wf, pActualFormat, sizeof(WAVEFORMATEXTENSIBLE));
}

ma_PropVariantClear(pContext, &prop);
}

ma_IPropertyStore_Release(pStore);
}
#else







hr = S_FALSE;
#endif

if (hr == S_OK) {
shareMode = MA_AUDCLNT_SHAREMODE_EXCLUSIVE;
result = MA_SUCCESS;
} else {
result = MA_SHARE_MODE_NOT_SUPPORTED;
}
} else {

WAVEFORMATEXTENSIBLE* pNativeFormat = NULL;
hr = ma_IAudioClient_GetMixFormat((ma_IAudioClient*)pData->pAudioClient, (WAVEFORMATEX**)&pNativeFormat);
if (hr != S_OK) {
result = MA_FORMAT_NOT_SUPPORTED;
} else {
MA_COPY_MEMORY(&wf, pNativeFormat, sizeof(wf));
result = MA_SUCCESS;
}

ma_CoTaskMemFree(pContext, pNativeFormat);

shareMode = MA_AUDCLNT_SHAREMODE_SHARED;
}


if (result != MA_SUCCESS) {
errorMsg = "[WASAPI] Failed to find best device mix format.";
goto done;
}





nativeSampleRate = wf.Format.nSamplesPerSec;
if (streamFlags & MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM) {
wf.Format.nSamplesPerSec = pData->sampleRateIn;
wf.Format.nAvgBytesPerSec = wf.Format.nSamplesPerSec * wf.Format.nBlockAlign;
}

pData->formatOut = ma_format_from_WAVEFORMATEX((WAVEFORMATEX*)&wf);
pData->channelsOut = wf.Format.nChannels;
pData->sampleRateOut = wf.Format.nSamplesPerSec;


ma_channel_mask_to_channel_map__win32(wf.dwChannelMask, pData->channelsOut, pData->channelMapOut);


pData->periodsOut = pData->periodsIn;
pData->periodSizeInFramesOut = pData->periodSizeInFramesIn;
if (pData->periodSizeInFramesOut == 0) {
pData->periodSizeInFramesOut = ma_calculate_buffer_size_in_frames_from_milliseconds(pData->periodSizeInMillisecondsIn, wf.Format.nSamplesPerSec);
}

periodDurationInMicroseconds = ((ma_uint64)pData->periodSizeInFramesOut * 1000 * 1000) / wf.Format.nSamplesPerSec;



if (shareMode == MA_AUDCLNT_SHAREMODE_EXCLUSIVE) {
MA_REFERENCE_TIME bufferDuration = periodDurationInMicroseconds * 10;





hr = E_FAIL;
for (;;) {
hr = ma_IAudioClient_Initialize((ma_IAudioClient*)pData->pAudioClient, shareMode, streamFlags, bufferDuration, bufferDuration, (WAVEFORMATEX*)&wf, NULL);
if (hr == MA_AUDCLNT_E_INVALID_DEVICE_PERIOD) {
if (bufferDuration > 500*10000) {
break;
} else {
if (bufferDuration == 0) { 
break;
}

bufferDuration = bufferDuration * 2;
continue;
}
} else {
break;
}
}

if (hr == MA_AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED) {
ma_uint32 bufferSizeInFrames;
hr = ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pData->pAudioClient, &bufferSizeInFrames);
if (SUCCEEDED(hr)) {
bufferDuration = (MA_REFERENCE_TIME)((10000.0 * 1000 / wf.Format.nSamplesPerSec * bufferSizeInFrames) + 0.5);


ma_IAudioClient_Release((ma_IAudioClient*)pData->pAudioClient);

#if defined(MA_WIN32_DESKTOP)
hr = ma_IMMDevice_Activate(pDeviceInterface, &MA_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&pData->pAudioClient);
#else
hr = ma_IUnknown_QueryInterface(pDeviceInterface, &MA_IID_IAudioClient, (void**)&pData->pAudioClient);
#endif

if (SUCCEEDED(hr)) {
hr = ma_IAudioClient_Initialize((ma_IAudioClient*)pData->pAudioClient, shareMode, streamFlags, bufferDuration, bufferDuration, (WAVEFORMATEX*)&wf, NULL);
}
}
}

if (FAILED(hr)) {

if (hr == E_ACCESSDENIED) {
errorMsg = "[WASAPI] Failed to initialize device in exclusive mode. Access denied.", result = MA_ACCESS_DENIED;
} else if (hr == MA_AUDCLNT_E_DEVICE_IN_USE) {
errorMsg = "[WASAPI] Failed to initialize device in exclusive mode. Device in use.", result = MA_DEVICE_BUSY;
} else {
errorMsg = "[WASAPI] Failed to initialize device in exclusive mode."; result = MA_SHARE_MODE_NOT_SUPPORTED;
}
goto done;
}
}

if (shareMode == MA_AUDCLNT_SHAREMODE_SHARED) {










#if !defined(MA_WASAPI_NO_LOW_LATENCY_SHARED_MODE)
if ((streamFlags & MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM) == 0 || nativeSampleRate == wf.Format.nSamplesPerSec) {
ma_IAudioClient3* pAudioClient3 = NULL;
hr = ma_IAudioClient_QueryInterface(pData->pAudioClient, &MA_IID_IAudioClient3, (void**)&pAudioClient3);
if (SUCCEEDED(hr)) {
UINT32 defaultPeriodInFrames;
UINT32 fundamentalPeriodInFrames;
UINT32 minPeriodInFrames;
UINT32 maxPeriodInFrames;
hr = ma_IAudioClient3_GetSharedModeEnginePeriod(pAudioClient3, (WAVEFORMATEX*)&wf, &defaultPeriodInFrames, &fundamentalPeriodInFrames, &minPeriodInFrames, &maxPeriodInFrames);
if (SUCCEEDED(hr)) {
UINT32 desiredPeriodInFrames = pData->periodSizeInFramesOut;
UINT32 actualPeriodInFrames = desiredPeriodInFrames;


actualPeriodInFrames = actualPeriodInFrames / fundamentalPeriodInFrames;
actualPeriodInFrames = actualPeriodInFrames * fundamentalPeriodInFrames;


actualPeriodInFrames = ma_clamp(actualPeriodInFrames, minPeriodInFrames, maxPeriodInFrames);

#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Trying IAudioClient3_InitializeSharedAudioStream(actualPeriodInFrames=%d)\n", actualPeriodInFrames);
printf(" defaultPeriodInFrames=%d\n", defaultPeriodInFrames);
printf(" fundamentalPeriodInFrames=%d\n", fundamentalPeriodInFrames);
printf(" minPeriodInFrames=%d\n", minPeriodInFrames);
printf(" maxPeriodInFrames=%d\n", maxPeriodInFrames);
#endif


if (actualPeriodInFrames >= desiredPeriodInFrames) {




hr = ma_IAudioClient3_InitializeSharedAudioStream(pAudioClient3, streamFlags & ~(MA_AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM | MA_AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY), actualPeriodInFrames, (WAVEFORMATEX*)&wf, NULL);
if (SUCCEEDED(hr)) {
wasInitializedUsingIAudioClient3 = MA_TRUE;
pData->periodSizeInFramesOut = actualPeriodInFrames;
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Using IAudioClient3\n");
printf(" periodSizeInFramesOut=%d\n", pData->periodSizeInFramesOut);
#endif
} else {
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] IAudioClient3_InitializeSharedAudioStream failed. Falling back to IAudioClient.\n");
#endif 
}
} else {
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Not using IAudioClient3 because the desired period size is larger than the maximum supported by IAudioClient3.\n");
#endif
}
} else {
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] IAudioClient3_GetSharedModeEnginePeriod failed. Falling back to IAudioClient.\n");
#endif
}

ma_IAudioClient3_Release(pAudioClient3);
pAudioClient3 = NULL;
}
}
#else
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Not using IAudioClient3 because MA_WASAPI_NO_LOW_LATENCY_SHARED_MODE is enabled.\n");
#endif
#endif


if (!wasInitializedUsingIAudioClient3) {
MA_REFERENCE_TIME bufferDuration = periodDurationInMicroseconds * pData->periodsOut * 10; 
hr = ma_IAudioClient_Initialize((ma_IAudioClient*)pData->pAudioClient, shareMode, streamFlags, bufferDuration, 0, (WAVEFORMATEX*)&wf, NULL);
if (FAILED(hr)) {
if (hr == E_ACCESSDENIED) {
errorMsg = "[WASAPI] Failed to initialize device. Access denied.", result = MA_ACCESS_DENIED;
} else if (hr == MA_AUDCLNT_E_DEVICE_IN_USE) {
errorMsg = "[WASAPI] Failed to initialize device. Device in use.", result = MA_DEVICE_BUSY;
} else {
errorMsg = "[WASAPI] Failed to initialize device.", result = MA_FAILED_TO_OPEN_BACKEND_DEVICE;
}

goto done;
}
}
}

if (!wasInitializedUsingIAudioClient3) {
ma_uint32 bufferSizeInFrames;
hr = ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pData->pAudioClient, &bufferSizeInFrames);
if (FAILED(hr)) {
errorMsg = "[WASAPI] Failed to get audio client's actual buffer size.", result = MA_FAILED_TO_OPEN_BACKEND_DEVICE;
goto done;
}

pData->periodSizeInFramesOut = bufferSizeInFrames / pData->periodsOut;
}

pData->usingAudioClient3 = wasInitializedUsingIAudioClient3;

if (deviceType == ma_device_type_playback) {
hr = ma_IAudioClient_GetService((ma_IAudioClient*)pData->pAudioClient, &MA_IID_IAudioRenderClient, (void**)&pData->pRenderClient);
} else {
hr = ma_IAudioClient_GetService((ma_IAudioClient*)pData->pAudioClient, &MA_IID_IAudioCaptureClient, (void**)&pData->pCaptureClient);
}

if (FAILED(hr)) {
errorMsg = "[WASAPI] Failed to get audio client service.", result = MA_API_NOT_FOUND;
goto done;
}



#if defined(MA_WIN32_DESKTOP)
{
ma_IPropertyStore *pProperties;
hr = ma_IMMDevice_OpenPropertyStore(pDeviceInterface, STGM_READ, &pProperties);
if (SUCCEEDED(hr)) {
PROPVARIANT varName;
ma_PropVariantInit(&varName);
hr = ma_IPropertyStore_GetValue(pProperties, &MA_PKEY_Device_FriendlyName, &varName);
if (SUCCEEDED(hr)) {
WideCharToMultiByte(CP_UTF8, 0, varName.pwszVal, -1, pData->deviceName, sizeof(pData->deviceName), 0, FALSE);
ma_PropVariantClear(pContext, &varName);
}

ma_IPropertyStore_Release(pProperties);
}
}
#endif

done:

#if defined(MA_WIN32_DESKTOP)
if (pDeviceInterface != NULL) {
ma_IMMDevice_Release(pDeviceInterface);
}
#else
if (pDeviceInterface != NULL) {
ma_IUnknown_Release(pDeviceInterface);
}
#endif

if (result != MA_SUCCESS) {
if (pData->pRenderClient) {
ma_IAudioRenderClient_Release((ma_IAudioRenderClient*)pData->pRenderClient);
pData->pRenderClient = NULL;
}
if (pData->pCaptureClient) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pData->pCaptureClient);
pData->pCaptureClient = NULL;
}
if (pData->pAudioClient) {
ma_IAudioClient_Release((ma_IAudioClient*)pData->pAudioClient);
pData->pAudioClient = NULL;
}

return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, errorMsg, result);
} else {
return MA_SUCCESS;
}
}

static ma_result ma_device_reinit__wasapi(ma_device* pDevice, ma_device_type deviceType)
{
ma_device_init_internal_data__wasapi data;
ma_result result;

MA_ASSERT(pDevice != NULL);


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

if (deviceType == ma_device_type_playback) {
data.formatIn = pDevice->playback.format;
data.channelsIn = pDevice->playback.channels;
MA_COPY_MEMORY(data.channelMapIn, pDevice->playback.channelMap, sizeof(pDevice->playback.channelMap));
data.shareMode = pDevice->playback.shareMode;
data.usingDefaultFormat = pDevice->playback.usingDefaultFormat;
data.usingDefaultChannels = pDevice->playback.usingDefaultChannels;
data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
} else {
data.formatIn = pDevice->capture.format;
data.channelsIn = pDevice->capture.channels;
MA_COPY_MEMORY(data.channelMapIn, pDevice->capture.channelMap, sizeof(pDevice->capture.channelMap));
data.shareMode = pDevice->capture.shareMode;
data.usingDefaultFormat = pDevice->capture.usingDefaultFormat;
data.usingDefaultChannels = pDevice->capture.usingDefaultChannels;
data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
}

data.sampleRateIn = pDevice->sampleRate;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.periodSizeInFramesIn = pDevice->wasapi.originalPeriodSizeInFrames;
data.periodSizeInMillisecondsIn = pDevice->wasapi.originalPeriodSizeInMilliseconds;
data.periodsIn = pDevice->wasapi.originalPeriods;
data.noAutoConvertSRC = pDevice->wasapi.noAutoConvertSRC;
data.noDefaultQualitySRC = pDevice->wasapi.noDefaultQualitySRC;
data.noHardwareOffloading = pDevice->wasapi.noHardwareOffloading;
result = ma_device_init_internal__wasapi(pDevice->pContext, deviceType, NULL, &data);
if (result != MA_SUCCESS) {
return result;
}


if (deviceType == ma_device_type_capture || deviceType == ma_device_type_loopback) {
if (pDevice->wasapi.pCaptureClient) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
pDevice->wasapi.pCaptureClient = NULL;
}

if (pDevice->wasapi.pAudioClientCapture) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
pDevice->wasapi.pAudioClientCapture = NULL;
}

pDevice->wasapi.pAudioClientCapture = data.pAudioClient;
pDevice->wasapi.pCaptureClient = data.pCaptureClient;

pDevice->capture.internalFormat = data.formatOut;
pDevice->capture.internalChannels = data.channelsOut;
pDevice->capture.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->capture.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->capture.internalPeriods = data.periodsOut;
ma_strcpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), data.deviceName);

ma_IAudioClient_SetEventHandle((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, pDevice->wasapi.hEventCapture);

pDevice->wasapi.periodSizeInFramesCapture = data.periodSizeInFramesOut;
ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &pDevice->wasapi.actualPeriodSizeInFramesCapture);


if (pDevice->wasapi.isStartedCapture) {
HRESULT hr = ma_IAudioClient_Start((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal capture device after reinitialization.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}
}

if (deviceType == ma_device_type_playback) {
if (pDevice->wasapi.pRenderClient) {
ma_IAudioRenderClient_Release((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
pDevice->wasapi.pRenderClient = NULL;
}

if (pDevice->wasapi.pAudioClientPlayback) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
pDevice->wasapi.pAudioClientPlayback = NULL;
}

pDevice->wasapi.pAudioClientPlayback = data.pAudioClient;
pDevice->wasapi.pRenderClient = data.pRenderClient;

pDevice->playback.internalFormat = data.formatOut;
pDevice->playback.internalChannels = data.channelsOut;
pDevice->playback.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->playback.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->playback.internalPeriods = data.periodsOut;
ma_strcpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), data.deviceName);

ma_IAudioClient_SetEventHandle((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, pDevice->wasapi.hEventPlayback);

pDevice->wasapi.periodSizeInFramesPlayback = data.periodSizeInFramesOut;
ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &pDevice->wasapi.actualPeriodSizeInFramesPlayback);


if (pDevice->wasapi.isStartedPlayback) {
HRESULT hr = ma_IAudioClient_Start((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal playback device after reinitialization.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}
}

return MA_SUCCESS;
}

static ma_result ma_device_init__wasapi(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result = MA_SUCCESS;

(void)pContext;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->wasapi);
pDevice->wasapi.originalPeriodSizeInFrames = pConfig->periodSizeInFrames;
pDevice->wasapi.originalPeriodSizeInMilliseconds = pConfig->periodSizeInMilliseconds;
pDevice->wasapi.originalPeriods = pConfig->periods;
pDevice->wasapi.noAutoConvertSRC = pConfig->wasapi.noAutoConvertSRC;
pDevice->wasapi.noDefaultQualitySRC = pConfig->wasapi.noDefaultQualitySRC;
pDevice->wasapi.noHardwareOffloading = pConfig->wasapi.noHardwareOffloading;


if (pConfig->deviceType == ma_device_type_loopback && pConfig->playback.shareMode == ma_share_mode_exclusive) {
return MA_INVALID_DEVICE_CONFIG;
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex || pConfig->deviceType == ma_device_type_loopback) {
ma_device_init_internal_data__wasapi data;
data.formatIn = pConfig->capture.format;
data.channelsIn = pConfig->capture.channels;
data.sampleRateIn = pConfig->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pConfig->capture.channelMap, sizeof(pConfig->capture.channelMap));
data.usingDefaultFormat = pDevice->capture.usingDefaultFormat;
data.usingDefaultChannels = pDevice->capture.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
data.shareMode = pConfig->capture.shareMode;
data.periodSizeInFramesIn = pConfig->periodSizeInFrames;
data.periodSizeInMillisecondsIn = pConfig->periodSizeInMilliseconds;
data.periodsIn = pConfig->periods;
data.noAutoConvertSRC = pConfig->wasapi.noAutoConvertSRC;
data.noDefaultQualitySRC = pConfig->wasapi.noDefaultQualitySRC;
data.noHardwareOffloading = pConfig->wasapi.noHardwareOffloading;

result = ma_device_init_internal__wasapi(pDevice->pContext, (pConfig->deviceType == ma_device_type_loopback) ? ma_device_type_loopback : ma_device_type_capture, pConfig->capture.pDeviceID, &data);
if (result != MA_SUCCESS) {
return result;
}

pDevice->wasapi.pAudioClientCapture = data.pAudioClient;
pDevice->wasapi.pCaptureClient = data.pCaptureClient;

pDevice->capture.internalFormat = data.formatOut;
pDevice->capture.internalChannels = data.channelsOut;
pDevice->capture.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->capture.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->capture.internalPeriods = data.periodsOut;
ma_strcpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), data.deviceName);





pDevice->wasapi.hEventCapture = CreateEventA(NULL, FALSE, FALSE, NULL); 
if (pDevice->wasapi.hEventCapture == NULL) {
if (pDevice->wasapi.pCaptureClient != NULL) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
pDevice->wasapi.pCaptureClient = NULL;
}
if (pDevice->wasapi.pAudioClientCapture != NULL) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
pDevice->wasapi.pAudioClientCapture = NULL;
}

return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for capture.", MA_FAILED_TO_CREATE_EVENT);
}
ma_IAudioClient_SetEventHandle((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, pDevice->wasapi.hEventCapture);

pDevice->wasapi.periodSizeInFramesCapture = data.periodSizeInFramesOut;
ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &pDevice->wasapi.actualPeriodSizeInFramesCapture);
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_device_init_internal_data__wasapi data;
data.formatIn = pConfig->playback.format;
data.channelsIn = pConfig->playback.channels;
data.sampleRateIn = pConfig->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pConfig->playback.channelMap, sizeof(pConfig->playback.channelMap));
data.usingDefaultFormat = pDevice->playback.usingDefaultFormat;
data.usingDefaultChannels = pDevice->playback.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
data.shareMode = pConfig->playback.shareMode;
data.periodSizeInFramesIn = pConfig->periodSizeInFrames;
data.periodSizeInMillisecondsIn = pConfig->periodSizeInMilliseconds;
data.periodsIn = pConfig->periods;
data.noAutoConvertSRC = pConfig->wasapi.noAutoConvertSRC;
data.noDefaultQualitySRC = pConfig->wasapi.noDefaultQualitySRC;
data.noHardwareOffloading = pConfig->wasapi.noHardwareOffloading;

result = ma_device_init_internal__wasapi(pDevice->pContext, ma_device_type_playback, pConfig->playback.pDeviceID, &data);
if (result != MA_SUCCESS) {
if (pConfig->deviceType == ma_device_type_duplex) {
if (pDevice->wasapi.pCaptureClient != NULL) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
pDevice->wasapi.pCaptureClient = NULL;
}
if (pDevice->wasapi.pAudioClientCapture != NULL) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
pDevice->wasapi.pAudioClientCapture = NULL;
}

CloseHandle(pDevice->wasapi.hEventCapture);
pDevice->wasapi.hEventCapture = NULL;
}
return result;
}

pDevice->wasapi.pAudioClientPlayback = data.pAudioClient;
pDevice->wasapi.pRenderClient = data.pRenderClient;

pDevice->playback.internalFormat = data.formatOut;
pDevice->playback.internalChannels = data.channelsOut;
pDevice->playback.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->playback.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->playback.internalPeriods = data.periodsOut;
ma_strcpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), data.deviceName);








pDevice->wasapi.hEventPlayback = CreateEventA(NULL, FALSE, TRUE, NULL); 
if (pDevice->wasapi.hEventPlayback == NULL) {
if (pConfig->deviceType == ma_device_type_duplex) {
if (pDevice->wasapi.pCaptureClient != NULL) {
ma_IAudioCaptureClient_Release((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient);
pDevice->wasapi.pCaptureClient = NULL;
}
if (pDevice->wasapi.pAudioClientCapture != NULL) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
pDevice->wasapi.pAudioClientCapture = NULL;
}

CloseHandle(pDevice->wasapi.hEventCapture);
pDevice->wasapi.hEventCapture = NULL;
}

if (pDevice->wasapi.pRenderClient != NULL) {
ma_IAudioRenderClient_Release((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient);
pDevice->wasapi.pRenderClient = NULL;
}
if (pDevice->wasapi.pAudioClientPlayback != NULL) {
ma_IAudioClient_Release((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
pDevice->wasapi.pAudioClientPlayback = NULL;
}

return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create event for playback.", MA_FAILED_TO_CREATE_EVENT);
}
ma_IAudioClient_SetEventHandle((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, pDevice->wasapi.hEventPlayback);

pDevice->wasapi.periodSizeInFramesPlayback = data.periodSizeInFramesOut;
ma_IAudioClient_GetBufferSize((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &pDevice->wasapi.actualPeriodSizeInFramesPlayback);
}





#if defined(MA_WIN32_DESKTOP)
if (pConfig->wasapi.noAutoStreamRouting == MA_FALSE) {
if ((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.pDeviceID == NULL) {
pDevice->wasapi.allowCaptureAutoStreamRouting = MA_TRUE;
}
if ((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.pDeviceID == NULL) {
pDevice->wasapi.allowPlaybackAutoStreamRouting = MA_TRUE;
}

if (pDevice->wasapi.allowCaptureAutoStreamRouting || pDevice->wasapi.allowPlaybackAutoStreamRouting) {
ma_IMMDeviceEnumerator* pDeviceEnumerator;
HRESULT hr = ma_CoCreateInstance(pContext, MA_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, MA_IID_IMMDeviceEnumerator, (void**)&pDeviceEnumerator);
if (FAILED(hr)) {
ma_device_uninit__wasapi(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to create device enumerator.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

pDevice->wasapi.notificationClient.lpVtbl = (void*)&g_maNotificationCientVtbl;
pDevice->wasapi.notificationClient.counter = 1;
pDevice->wasapi.notificationClient.pDevice = pDevice;

hr = pDeviceEnumerator->lpVtbl->RegisterEndpointNotificationCallback(pDeviceEnumerator, &pDevice->wasapi.notificationClient);
if (SUCCEEDED(hr)) {
pDevice->wasapi.pDeviceEnumerator = (ma_ptr)pDeviceEnumerator;
} else {

ma_IMMDeviceEnumerator_Release(pDeviceEnumerator);
}
}
}
#endif

ma_atomic_exchange_32(&pDevice->wasapi.isStartedCapture, MA_FALSE);
ma_atomic_exchange_32(&pDevice->wasapi.isStartedPlayback, MA_FALSE);

return MA_SUCCESS;
}

static ma_result ma_device__get_available_frames__wasapi(ma_device* pDevice, ma_IAudioClient* pAudioClient, ma_uint32* pFrameCount)
{
ma_uint32 paddingFramesCount;
HRESULT hr;
ma_share_mode shareMode;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pFrameCount != NULL);

*pFrameCount = 0;

if ((ma_ptr)pAudioClient != pDevice->wasapi.pAudioClientPlayback && (ma_ptr)pAudioClient != pDevice->wasapi.pAudioClientCapture) {
return MA_INVALID_OPERATION;
}

hr = ma_IAudioClient_GetCurrentPadding(pAudioClient, &paddingFramesCount);
if (FAILED(hr)) {
return MA_DEVICE_UNAVAILABLE;
}


shareMode = ((ma_ptr)pAudioClient == pDevice->wasapi.pAudioClientPlayback) ? pDevice->playback.shareMode : pDevice->capture.shareMode;
if (shareMode == ma_share_mode_exclusive) {
*pFrameCount = paddingFramesCount;
} else {
if ((ma_ptr)pAudioClient == pDevice->wasapi.pAudioClientPlayback) {
*pFrameCount = pDevice->wasapi.actualPeriodSizeInFramesPlayback - paddingFramesCount;
} else {
*pFrameCount = paddingFramesCount;
}
}

return MA_SUCCESS;
}

static ma_bool32 ma_device_is_reroute_required__wasapi(ma_device* pDevice, ma_device_type deviceType)
{
MA_ASSERT(pDevice != NULL);

if (deviceType == ma_device_type_playback) {
return pDevice->wasapi.hasDefaultPlaybackDeviceChanged;
}

if (deviceType == ma_device_type_capture || deviceType == ma_device_type_loopback) {
return pDevice->wasapi.hasDefaultCaptureDeviceChanged;
}

return MA_FALSE;
}

static ma_result ma_device_reroute__wasapi(ma_device* pDevice, ma_device_type deviceType)
{
ma_result result;

if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

if (deviceType == ma_device_type_playback) {
ma_atomic_exchange_32(&pDevice->wasapi.hasDefaultPlaybackDeviceChanged, MA_FALSE);
}
if (deviceType == ma_device_type_capture || deviceType == ma_device_type_loopback) {
ma_atomic_exchange_32(&pDevice->wasapi.hasDefaultCaptureDeviceChanged, MA_FALSE);
}


#if defined(MA_DEBUG_OUTPUT)
printf("=== CHANGING DEVICE ===\n");
#endif

result = ma_device_reinit__wasapi(pDevice, deviceType);
if (result != MA_SUCCESS) {
return result;
}

ma_device__post_init_setup(pDevice, deviceType);

return MA_SUCCESS;
}


static ma_result ma_device_stop__wasapi(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);





if (pDevice->type == ma_device_type_loopback) {
SetEvent((HANDLE)pDevice->wasapi.hEventCapture);
}

return MA_SUCCESS;
}


static ma_result ma_device_main_loop__wasapi(ma_device* pDevice)
{
ma_result result;
HRESULT hr;
ma_bool32 exitLoop = MA_FALSE;
ma_uint32 framesWrittenToPlaybackDevice = 0;
ma_uint32 mappedDeviceBufferSizeInFramesCapture = 0;
ma_uint32 mappedDeviceBufferSizeInFramesPlayback = 0;
ma_uint32 mappedDeviceBufferFramesRemainingCapture = 0;
ma_uint32 mappedDeviceBufferFramesRemainingPlayback = 0;
BYTE* pMappedDeviceBufferCapture = NULL;
BYTE* pMappedDeviceBufferPlayback = NULL;
ma_uint32 bpfCaptureDevice = ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 bpfPlaybackDevice = ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 bpfCaptureClient = ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 bpfPlaybackClient = ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint8 inputDataInClientFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 inputDataInClientFormatCap = sizeof(inputDataInClientFormat) / bpfCaptureClient;
ma_uint8 outputDataInClientFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 outputDataInClientFormatCap = sizeof(outputDataInClientFormat) / bpfPlaybackClient;
ma_uint32 outputDataInClientFormatCount = 0;
ma_uint32 outputDataInClientFormatConsumed = 0;
ma_uint32 periodSizeInFramesCapture = 0;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex || pDevice->type == ma_device_type_loopback) {
periodSizeInFramesCapture = pDevice->capture.internalPeriodSizeInFrames;

hr = ma_IAudioClient_Start((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal capture device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
ma_atomic_exchange_32(&pDevice->wasapi.isStartedCapture, MA_TRUE);
}

while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {

if (ma_device_is_reroute_required__wasapi(pDevice, ma_device_type_playback)) {
result = ma_device_reroute__wasapi(pDevice, ma_device_type_playback);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}
if (ma_device_is_reroute_required__wasapi(pDevice, ma_device_type_capture)) {
result = ma_device_reroute__wasapi(pDevice, (pDevice->type == ma_device_type_loopback) ? ma_device_type_loopback : ma_device_type_capture);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

switch (pDevice->type)
{
case ma_device_type_duplex:
{
ma_uint32 framesAvailableCapture;
ma_uint32 framesAvailablePlayback;
DWORD flagsCapture; 


if (pMappedDeviceBufferPlayback == NULL) {

if (pDevice->playback.shareMode == ma_share_mode_exclusive) {
if (WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE) == WAIT_FAILED) {
return MA_ERROR; 
}
}

result = ma_device__get_available_frames__wasapi(pDevice, (ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &framesAvailablePlayback);
if (result != MA_SUCCESS) {
return result;
}





if (pDevice->playback.shareMode != ma_share_mode_exclusive) {
if (framesAvailablePlayback > pDevice->wasapi.periodSizeInFramesPlayback) {
framesAvailablePlayback = pDevice->wasapi.periodSizeInFramesPlayback;
}
}


if (framesAvailablePlayback == 0) {

if (pDevice->playback.shareMode != ma_share_mode_exclusive) {
if (WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE) == WAIT_FAILED) {
return MA_ERROR; 
}
}

continue;
}


hr = ma_IAudioRenderClient_GetBuffer((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient, framesAvailablePlayback, &pMappedDeviceBufferPlayback);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from playback device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}

mappedDeviceBufferSizeInFramesPlayback = framesAvailablePlayback;
mappedDeviceBufferFramesRemainingPlayback = framesAvailablePlayback;
}


for (;;) {

if (pMappedDeviceBufferCapture == NULL) {
if (pDevice->capture.shareMode == ma_share_mode_shared) {
if (WaitForSingleObject(pDevice->wasapi.hEventCapture, INFINITE) == WAIT_FAILED) {
return MA_ERROR; 
}
}

result = ma_device__get_available_frames__wasapi(pDevice, (ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &framesAvailableCapture);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}




if (framesAvailableCapture == 0) {

if (pDevice->capture.shareMode != ma_share_mode_shared) {
if (WaitForSingleObject(pDevice->wasapi.hEventCapture, INFINITE) == WAIT_FAILED) {
return MA_ERROR; 
}
}

continue;
}


mappedDeviceBufferSizeInFramesCapture = ma_min(framesAvailableCapture, periodSizeInFramesCapture);
hr = ma_IAudioCaptureClient_GetBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, (BYTE**)&pMappedDeviceBufferCapture, &mappedDeviceBufferSizeInFramesCapture, &flagsCapture, NULL, NULL);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from capture device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}



if ((flagsCapture & MA_AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY) != 0) {

#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Data discontinuity (possible overrun). framesAvailableCapture=%d, mappedBufferSizeInFramesCapture=%d\n", framesAvailableCapture, mappedDeviceBufferSizeInFramesCapture);
#endif






if (framesAvailableCapture >= pDevice->wasapi.actualPeriodSizeInFramesCapture) {
#if defined(MA_DEBUG_OUTPUT)
printf("[WASAPI] Synchronizing capture stream. ");
#endif
do
{
hr = ma_IAudioCaptureClient_ReleaseBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, mappedDeviceBufferSizeInFramesCapture);
if (FAILED(hr)) {
break;
}

framesAvailableCapture -= mappedDeviceBufferSizeInFramesCapture;

if (framesAvailableCapture > 0) {
mappedDeviceBufferSizeInFramesCapture = ma_min(framesAvailableCapture, periodSizeInFramesCapture);
hr = ma_IAudioCaptureClient_GetBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, (BYTE**)&pMappedDeviceBufferCapture, &mappedDeviceBufferSizeInFramesCapture, &flagsCapture, NULL, NULL);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from capture device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}
} else {
pMappedDeviceBufferCapture = NULL;
mappedDeviceBufferSizeInFramesCapture = 0;
}
} while (framesAvailableCapture > periodSizeInFramesCapture);
#if defined(MA_DEBUG_OUTPUT)
printf("framesAvailableCapture=%d, mappedBufferSizeInFramesCapture=%d\n", framesAvailableCapture, mappedDeviceBufferSizeInFramesCapture);
#endif
}
} else {
#if defined(MA_DEBUG_OUTPUT)
if (flagsCapture != 0) {
printf("[WASAPI] Capture Flags: %d\n", flagsCapture);
}
#endif
}

mappedDeviceBufferFramesRemainingCapture = mappedDeviceBufferSizeInFramesCapture;
}



for (;;) {
BYTE* pRunningDeviceBufferCapture;
BYTE* pRunningDeviceBufferPlayback;
ma_uint32 framesToProcess;
ma_uint32 framesProcessed;

pRunningDeviceBufferCapture = pMappedDeviceBufferCapture + ((mappedDeviceBufferSizeInFramesCapture - mappedDeviceBufferFramesRemainingCapture ) * bpfCaptureDevice);
pRunningDeviceBufferPlayback = pMappedDeviceBufferPlayback + ((mappedDeviceBufferSizeInFramesPlayback - mappedDeviceBufferFramesRemainingPlayback) * bpfPlaybackDevice);


if (!pDevice->playback.converter.isPassthrough && outputDataInClientFormatConsumed < outputDataInClientFormatCount) {
ma_uint64 convertedFrameCountClient = (outputDataInClientFormatCount - outputDataInClientFormatConsumed);
ma_uint64 convertedFrameCountDevice = mappedDeviceBufferFramesRemainingPlayback;
void* pConvertedFramesClient = outputDataInClientFormat + (outputDataInClientFormatConsumed * bpfPlaybackClient);
void* pConvertedFramesDevice = pRunningDeviceBufferPlayback;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, pConvertedFramesClient, &convertedFrameCountClient, pConvertedFramesDevice, &convertedFrameCountDevice);
if (result != MA_SUCCESS) {
break;
}

outputDataInClientFormatConsumed += (ma_uint32)convertedFrameCountClient; 
mappedDeviceBufferFramesRemainingPlayback -= (ma_uint32)convertedFrameCountDevice; 

if (mappedDeviceBufferFramesRemainingPlayback == 0) {
break;
}
}





if (pDevice->capture.converter.isPassthrough && pDevice->playback.converter.isPassthrough) {

framesToProcess = ma_min(mappedDeviceBufferFramesRemainingCapture, mappedDeviceBufferFramesRemainingPlayback);
framesProcessed = framesToProcess;

ma_device__on_data(pDevice, pRunningDeviceBufferPlayback, pRunningDeviceBufferCapture, framesToProcess);

mappedDeviceBufferFramesRemainingCapture -= framesProcessed;
mappedDeviceBufferFramesRemainingPlayback -= framesProcessed;

if (mappedDeviceBufferFramesRemainingCapture == 0) {
break; 
}
if (mappedDeviceBufferFramesRemainingPlayback == 0) {
break; 
}
} else if (pDevice->capture.converter.isPassthrough) {

framesToProcess = ma_min(mappedDeviceBufferFramesRemainingCapture, outputDataInClientFormatCap);
framesProcessed = framesToProcess;

ma_device__on_data(pDevice, outputDataInClientFormat, pRunningDeviceBufferCapture, framesToProcess);
outputDataInClientFormatCount = framesProcessed;
outputDataInClientFormatConsumed = 0;

mappedDeviceBufferFramesRemainingCapture -= framesProcessed;
if (mappedDeviceBufferFramesRemainingCapture == 0) {
break; 
}
} else if (pDevice->playback.converter.isPassthrough) {

ma_uint64 capturedDeviceFramesToProcess = mappedDeviceBufferFramesRemainingCapture;
ma_uint64 capturedClientFramesToProcess = ma_min(inputDataInClientFormatCap, mappedDeviceBufferFramesRemainingPlayback);

result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningDeviceBufferCapture, &capturedDeviceFramesToProcess, inputDataInClientFormat, &capturedClientFramesToProcess);
if (result != MA_SUCCESS) {
break;
}

if (capturedClientFramesToProcess == 0) {
break;
}

ma_device__on_data(pDevice, pRunningDeviceBufferPlayback, inputDataInClientFormat, (ma_uint32)capturedClientFramesToProcess); 

mappedDeviceBufferFramesRemainingCapture -= (ma_uint32)capturedDeviceFramesToProcess;
mappedDeviceBufferFramesRemainingPlayback -= (ma_uint32)capturedClientFramesToProcess;
} else {
ma_uint64 capturedDeviceFramesToProcess = mappedDeviceBufferFramesRemainingCapture;
ma_uint64 capturedClientFramesToProcess = ma_min(inputDataInClientFormatCap, outputDataInClientFormatCap);

result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningDeviceBufferCapture, &capturedDeviceFramesToProcess, inputDataInClientFormat, &capturedClientFramesToProcess);
if (result != MA_SUCCESS) {
break;
}

if (capturedClientFramesToProcess == 0) {
break;
}

ma_device__on_data(pDevice, outputDataInClientFormat, inputDataInClientFormat, (ma_uint32)capturedClientFramesToProcess);

mappedDeviceBufferFramesRemainingCapture -= (ma_uint32)capturedDeviceFramesToProcess;
outputDataInClientFormatCount = (ma_uint32)capturedClientFramesToProcess;
outputDataInClientFormatConsumed = 0;
}
}



if (mappedDeviceBufferFramesRemainingCapture == 0 && pMappedDeviceBufferCapture != NULL) {
hr = ma_IAudioCaptureClient_ReleaseBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, mappedDeviceBufferSizeInFramesCapture);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from capture device after reading from the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}



pMappedDeviceBufferCapture = NULL;
mappedDeviceBufferFramesRemainingCapture = 0;
mappedDeviceBufferSizeInFramesCapture = 0;
}


if (mappedDeviceBufferFramesRemainingPlayback == 0) {
break;
}
}



if (mappedDeviceBufferFramesRemainingPlayback == 0 && pMappedDeviceBufferPlayback != NULL) {
hr = ma_IAudioRenderClient_ReleaseBuffer((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient, mappedDeviceBufferSizeInFramesPlayback, 0);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from playback device after writing to the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}


framesWrittenToPlaybackDevice += mappedDeviceBufferSizeInFramesPlayback;

pMappedDeviceBufferPlayback = NULL;
mappedDeviceBufferFramesRemainingPlayback = 0;
mappedDeviceBufferSizeInFramesPlayback = 0;
}

if (!pDevice->wasapi.isStartedPlayback) {
ma_uint32 startThreshold = pDevice->playback.internalPeriodSizeInFrames * 1;


if (startThreshold > pDevice->wasapi.actualPeriodSizeInFramesPlayback) {
startThreshold = pDevice->wasapi.actualPeriodSizeInFramesPlayback;
}

if (pDevice->playback.shareMode == ma_share_mode_exclusive || framesWrittenToPlaybackDevice >= startThreshold) {
hr = ma_IAudioClient_Start((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
if (FAILED(hr)) {
ma_IAudioClient_Stop((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
ma_IAudioClient_Reset((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal playback device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
ma_atomic_exchange_32(&pDevice->wasapi.isStartedPlayback, MA_TRUE);
}
}
} break;



case ma_device_type_capture:
case ma_device_type_loopback:
{
ma_uint32 framesAvailableCapture;
DWORD flagsCapture; 


if (WaitForSingleObject(pDevice->wasapi.hEventCapture, INFINITE) == WAIT_FAILED) {
exitLoop = MA_TRUE;
break; 
}


result = ma_device__get_available_frames__wasapi(pDevice, (ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture, &framesAvailableCapture);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

if (framesAvailableCapture < pDevice->wasapi.periodSizeInFramesCapture) {
continue; 
}


mappedDeviceBufferSizeInFramesCapture = framesAvailableCapture;
hr = ma_IAudioCaptureClient_GetBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, (BYTE**)&pMappedDeviceBufferCapture, &mappedDeviceBufferSizeInFramesCapture, &flagsCapture, NULL, NULL);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from capture device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}


ma_device__send_frames_to_client(pDevice, mappedDeviceBufferSizeInFramesCapture, pMappedDeviceBufferCapture);


hr = ma_IAudioCaptureClient_ReleaseBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, mappedDeviceBufferSizeInFramesCapture);
pMappedDeviceBufferCapture = NULL; 
mappedDeviceBufferSizeInFramesCapture = 0;
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from capture device after reading from the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}
} break;



case ma_device_type_playback:
{
ma_uint32 framesAvailablePlayback;


if (WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE) == WAIT_FAILED) {
exitLoop = MA_TRUE;
break; 
}


result = ma_device__get_available_frames__wasapi(pDevice, (ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &framesAvailablePlayback);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

if (framesAvailablePlayback < pDevice->wasapi.periodSizeInFramesPlayback) {
continue; 
}


hr = ma_IAudioRenderClient_GetBuffer((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient, framesAvailablePlayback, &pMappedDeviceBufferPlayback);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to retrieve internal buffer from playback device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}


ma_device__read_frames_from_client(pDevice, framesAvailablePlayback, pMappedDeviceBufferPlayback);


hr = ma_IAudioRenderClient_ReleaseBuffer((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient, framesAvailablePlayback, 0);
pMappedDeviceBufferPlayback = NULL; 
mappedDeviceBufferSizeInFramesPlayback = 0;

if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to release internal buffer from playback device after writing to the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
exitLoop = MA_TRUE;
break;
}

framesWrittenToPlaybackDevice += framesAvailablePlayback;
if (!pDevice->wasapi.isStartedPlayback) {
if (pDevice->playback.shareMode == ma_share_mode_exclusive || framesWrittenToPlaybackDevice >= pDevice->playback.internalPeriodSizeInFrames*1) {
hr = ma_IAudioClient_Start((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
if (FAILED(hr)) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to start internal playback device.", MA_FAILED_TO_START_BACKEND_DEVICE);
exitLoop = MA_TRUE;
break;
}
ma_atomic_exchange_32(&pDevice->wasapi.isStartedPlayback, MA_TRUE);
}
}
} break;

default: return MA_INVALID_ARGS;
}
}


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex || pDevice->type == ma_device_type_loopback) {

if (pMappedDeviceBufferCapture != NULL) {
hr = ma_IAudioCaptureClient_ReleaseBuffer((ma_IAudioCaptureClient*)pDevice->wasapi.pCaptureClient, mappedDeviceBufferSizeInFramesCapture);
}

hr = ma_IAudioClient_Stop((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to stop internal capture device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}


hr = ma_IAudioClient_Reset((ma_IAudioClient*)pDevice->wasapi.pAudioClientCapture);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to reset internal capture device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

ma_atomic_exchange_32(&pDevice->wasapi.isStartedCapture, MA_FALSE);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {

if (pMappedDeviceBufferPlayback != NULL) {
hr = ma_IAudioRenderClient_ReleaseBuffer((ma_IAudioRenderClient*)pDevice->wasapi.pRenderClient, mappedDeviceBufferSizeInFramesPlayback, 0);
}





if (pDevice->wasapi.isStartedPlayback) {
if (pDevice->playback.shareMode == ma_share_mode_exclusive) {
WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE);
} else {
ma_uint32 prevFramesAvaialablePlayback = (ma_uint32)-1;
ma_uint32 framesAvailablePlayback;
for (;;) {
result = ma_device__get_available_frames__wasapi(pDevice, (ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback, &framesAvailablePlayback);
if (result != MA_SUCCESS) {
break;
}

if (framesAvailablePlayback >= pDevice->wasapi.actualPeriodSizeInFramesPlayback) {
break;
}





if (framesAvailablePlayback == prevFramesAvaialablePlayback) {
break;
}
prevFramesAvaialablePlayback = framesAvailablePlayback;

WaitForSingleObject(pDevice->wasapi.hEventPlayback, INFINITE);
ResetEvent(pDevice->wasapi.hEventPlayback); 
}
}
}

hr = ma_IAudioClient_Stop((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to stop internal playback device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}


hr = ma_IAudioClient_Reset((ma_IAudioClient*)pDevice->wasapi.pAudioClientPlayback);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WASAPI] Failed to reset internal playback device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

ma_atomic_exchange_32(&pDevice->wasapi.isStartedPlayback, MA_FALSE);
}

return MA_SUCCESS;
}

static ma_result ma_context_uninit__wasapi(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_wasapi);
(void)pContext;

return MA_SUCCESS;
}

static ma_result ma_context_init__wasapi(const ma_context_config* pConfig, ma_context* pContext)
{
ma_result result = MA_SUCCESS;

MA_ASSERT(pContext != NULL);

(void)pConfig;

#if defined(MA_WIN32_DESKTOP)






{
ma_OSVERSIONINFOEXW osvi;
ma_handle kernel32DLL;
ma_PFNVerifyVersionInfoW _VerifyVersionInfoW;
ma_PFNVerSetConditionMask _VerSetConditionMask;

kernel32DLL = ma_dlopen(pContext, "kernel32.dll");
if (kernel32DLL == NULL) {
return MA_NO_BACKEND;
}

_VerifyVersionInfoW = (ma_PFNVerifyVersionInfoW)ma_dlsym(pContext, kernel32DLL, "VerifyVersionInfoW");
_VerSetConditionMask = (ma_PFNVerSetConditionMask)ma_dlsym(pContext, kernel32DLL, "VerSetConditionMask");
if (_VerifyVersionInfoW == NULL || _VerSetConditionMask == NULL) {
ma_dlclose(pContext, kernel32DLL);
return MA_NO_BACKEND;
}

MA_ZERO_OBJECT(&osvi);
osvi.dwOSVersionInfoSize = sizeof(osvi);
osvi.dwMajorVersion = HIBYTE(MA_WIN32_WINNT_VISTA);
osvi.dwMinorVersion = LOBYTE(MA_WIN32_WINNT_VISTA);
osvi.wServicePackMajor = 1;
if (_VerifyVersionInfoW(&osvi, MA_VER_MAJORVERSION | MA_VER_MINORVERSION | MA_VER_SERVICEPACKMAJOR, _VerSetConditionMask(_VerSetConditionMask(_VerSetConditionMask(0, MA_VER_MAJORVERSION, MA_VER_GREATER_EQUAL), MA_VER_MINORVERSION, MA_VER_GREATER_EQUAL), MA_VER_SERVICEPACKMAJOR, MA_VER_GREATER_EQUAL))) {
result = MA_SUCCESS;
} else {
result = MA_NO_BACKEND;
}

ma_dlclose(pContext, kernel32DLL);
}
#endif

if (result != MA_SUCCESS) {
return result;
}

pContext->onUninit = ma_context_uninit__wasapi;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__wasapi;
pContext->onEnumDevices = ma_context_enumerate_devices__wasapi;
pContext->onGetDeviceInfo = ma_context_get_device_info__wasapi;
pContext->onDeviceInit = ma_device_init__wasapi;
pContext->onDeviceUninit = ma_device_uninit__wasapi;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = ma_device_stop__wasapi; 
pContext->onDeviceMainLoop = ma_device_main_loop__wasapi;

return result;
}
#endif






#if defined(MA_HAS_DSOUND)


static const GUID MA_GUID_IID_DirectSoundNotify = {0xb0210783, 0x89cd, 0x11d0, {0xaf, 0x08, 0x00, 0xa0, 0xc9, 0x25, 0xcd, 0x16}};


#define MA_DSSCL_NORMAL 1
#define MA_DSSCL_PRIORITY 2
#define MA_DSSCL_EXCLUSIVE 3
#define MA_DSSCL_WRITEPRIMARY 4

#define MA_DSCAPS_PRIMARYMONO 0x00000001
#define MA_DSCAPS_PRIMARYSTEREO 0x00000002
#define MA_DSCAPS_PRIMARY8BIT 0x00000004
#define MA_DSCAPS_PRIMARY16BIT 0x00000008
#define MA_DSCAPS_CONTINUOUSRATE 0x00000010
#define MA_DSCAPS_EMULDRIVER 0x00000020
#define MA_DSCAPS_CERTIFIED 0x00000040
#define MA_DSCAPS_SECONDARYMONO 0x00000100
#define MA_DSCAPS_SECONDARYSTEREO 0x00000200
#define MA_DSCAPS_SECONDARY8BIT 0x00000400
#define MA_DSCAPS_SECONDARY16BIT 0x00000800

#define MA_DSBCAPS_PRIMARYBUFFER 0x00000001
#define MA_DSBCAPS_STATIC 0x00000002
#define MA_DSBCAPS_LOCHARDWARE 0x00000004
#define MA_DSBCAPS_LOCSOFTWARE 0x00000008
#define MA_DSBCAPS_CTRL3D 0x00000010
#define MA_DSBCAPS_CTRLFREQUENCY 0x00000020
#define MA_DSBCAPS_CTRLPAN 0x00000040
#define MA_DSBCAPS_CTRLVOLUME 0x00000080
#define MA_DSBCAPS_CTRLPOSITIONNOTIFY 0x00000100
#define MA_DSBCAPS_CTRLFX 0x00000200
#define MA_DSBCAPS_STICKYFOCUS 0x00004000
#define MA_DSBCAPS_GLOBALFOCUS 0x00008000
#define MA_DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define MA_DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define MA_DSBCAPS_LOCDEFER 0x00040000
#define MA_DSBCAPS_TRUEPLAYPOSITION 0x00080000

#define MA_DSBPLAY_LOOPING 0x00000001
#define MA_DSBPLAY_LOCHARDWARE 0x00000002
#define MA_DSBPLAY_LOCSOFTWARE 0x00000004
#define MA_DSBPLAY_TERMINATEBY_TIME 0x00000008
#define MA_DSBPLAY_TERMINATEBY_DISTANCE 0x00000010
#define MA_DSBPLAY_TERMINATEBY_PRIORITY 0x00000020

#define MA_DSCBSTART_LOOPING 0x00000001

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwBufferBytes;
DWORD dwReserved;
WAVEFORMATEX* lpwfxFormat;
GUID guid3DAlgorithm;
} MA_DSBUFFERDESC;

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwBufferBytes;
DWORD dwReserved;
WAVEFORMATEX* lpwfxFormat;
DWORD dwFXCount;
void* lpDSCFXDesc; 
} MA_DSCBUFFERDESC;

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwMinSecondarySampleRate;
DWORD dwMaxSecondarySampleRate;
DWORD dwPrimaryBuffers;
DWORD dwMaxHwMixingAllBuffers;
DWORD dwMaxHwMixingStaticBuffers;
DWORD dwMaxHwMixingStreamingBuffers;
DWORD dwFreeHwMixingAllBuffers;
DWORD dwFreeHwMixingStaticBuffers;
DWORD dwFreeHwMixingStreamingBuffers;
DWORD dwMaxHw3DAllBuffers;
DWORD dwMaxHw3DStaticBuffers;
DWORD dwMaxHw3DStreamingBuffers;
DWORD dwFreeHw3DAllBuffers;
DWORD dwFreeHw3DStaticBuffers;
DWORD dwFreeHw3DStreamingBuffers;
DWORD dwTotalHwMemBytes;
DWORD dwFreeHwMemBytes;
DWORD dwMaxContigFreeHwMemBytes;
DWORD dwUnlockTransferRateHwBuffers;
DWORD dwPlayCpuOverheadSwBuffers;
DWORD dwReserved1;
DWORD dwReserved2;
} MA_DSCAPS;

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwBufferBytes;
DWORD dwUnlockTransferRate;
DWORD dwPlayCpuOverhead;
} MA_DSBCAPS;

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwFormats;
DWORD dwChannels;
} MA_DSCCAPS;

typedef struct
{
DWORD dwSize;
DWORD dwFlags;
DWORD dwBufferBytes;
DWORD dwReserved;
} MA_DSCBCAPS;

typedef struct
{
DWORD dwOffset;
HANDLE hEventNotify;
} MA_DSBPOSITIONNOTIFY;

typedef struct ma_IDirectSound ma_IDirectSound;
typedef struct ma_IDirectSoundBuffer ma_IDirectSoundBuffer;
typedef struct ma_IDirectSoundCapture ma_IDirectSoundCapture;
typedef struct ma_IDirectSoundCaptureBuffer ma_IDirectSoundCaptureBuffer;
typedef struct ma_IDirectSoundNotify ma_IDirectSoundNotify;










typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IDirectSound* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IDirectSound* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IDirectSound* pThis);


HRESULT (STDMETHODCALLTYPE * CreateSoundBuffer) (ma_IDirectSound* pThis, const MA_DSBUFFERDESC* pDSBufferDesc, ma_IDirectSoundBuffer** ppDSBuffer, void* pUnkOuter);
HRESULT (STDMETHODCALLTYPE * GetCaps) (ma_IDirectSound* pThis, MA_DSCAPS* pDSCaps);
HRESULT (STDMETHODCALLTYPE * DuplicateSoundBuffer)(ma_IDirectSound* pThis, ma_IDirectSoundBuffer* pDSBufferOriginal, ma_IDirectSoundBuffer** ppDSBufferDuplicate);
HRESULT (STDMETHODCALLTYPE * SetCooperativeLevel) (ma_IDirectSound* pThis, HWND hwnd, DWORD dwLevel);
HRESULT (STDMETHODCALLTYPE * Compact) (ma_IDirectSound* pThis);
HRESULT (STDMETHODCALLTYPE * GetSpeakerConfig) (ma_IDirectSound* pThis, DWORD* pSpeakerConfig);
HRESULT (STDMETHODCALLTYPE * SetSpeakerConfig) (ma_IDirectSound* pThis, DWORD dwSpeakerConfig);
HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IDirectSound* pThis, const GUID* pGuidDevice);
} ma_IDirectSoundVtbl;
struct ma_IDirectSound
{
ma_IDirectSoundVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IDirectSound_QueryInterface(ma_IDirectSound* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IDirectSound_AddRef(ma_IDirectSound* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IDirectSound_Release(ma_IDirectSound* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IDirectSound_CreateSoundBuffer(ma_IDirectSound* pThis, const MA_DSBUFFERDESC* pDSBufferDesc, ma_IDirectSoundBuffer** ppDSBuffer, void* pUnkOuter) { return pThis->lpVtbl->CreateSoundBuffer(pThis, pDSBufferDesc, ppDSBuffer, pUnkOuter); }
static MA_INLINE HRESULT ma_IDirectSound_GetCaps(ma_IDirectSound* pThis, MA_DSCAPS* pDSCaps) { return pThis->lpVtbl->GetCaps(pThis, pDSCaps); }
static MA_INLINE HRESULT ma_IDirectSound_DuplicateSoundBuffer(ma_IDirectSound* pThis, ma_IDirectSoundBuffer* pDSBufferOriginal, ma_IDirectSoundBuffer** ppDSBufferDuplicate) { return pThis->lpVtbl->DuplicateSoundBuffer(pThis, pDSBufferOriginal, ppDSBufferDuplicate); }
static MA_INLINE HRESULT ma_IDirectSound_SetCooperativeLevel(ma_IDirectSound* pThis, HWND hwnd, DWORD dwLevel) { return pThis->lpVtbl->SetCooperativeLevel(pThis, hwnd, dwLevel); }
static MA_INLINE HRESULT ma_IDirectSound_Compact(ma_IDirectSound* pThis) { return pThis->lpVtbl->Compact(pThis); }
static MA_INLINE HRESULT ma_IDirectSound_GetSpeakerConfig(ma_IDirectSound* pThis, DWORD* pSpeakerConfig) { return pThis->lpVtbl->GetSpeakerConfig(pThis, pSpeakerConfig); }
static MA_INLINE HRESULT ma_IDirectSound_SetSpeakerConfig(ma_IDirectSound* pThis, DWORD dwSpeakerConfig) { return pThis->lpVtbl->SetSpeakerConfig(pThis, dwSpeakerConfig); }
static MA_INLINE HRESULT ma_IDirectSound_Initialize(ma_IDirectSound* pThis, const GUID* pGuidDevice) { return pThis->lpVtbl->Initialize(pThis, pGuidDevice); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IDirectSoundBuffer* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IDirectSoundBuffer* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IDirectSoundBuffer* pThis);


HRESULT (STDMETHODCALLTYPE * GetCaps) (ma_IDirectSoundBuffer* pThis, MA_DSBCAPS* pDSBufferCaps);
HRESULT (STDMETHODCALLTYPE * GetCurrentPosition)(ma_IDirectSoundBuffer* pThis, DWORD* pCurrentPlayCursor, DWORD* pCurrentWriteCursor);
HRESULT (STDMETHODCALLTYPE * GetFormat) (ma_IDirectSoundBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten);
HRESULT (STDMETHODCALLTYPE * GetVolume) (ma_IDirectSoundBuffer* pThis, LONG* pVolume);
HRESULT (STDMETHODCALLTYPE * GetPan) (ma_IDirectSoundBuffer* pThis, LONG* pPan);
HRESULT (STDMETHODCALLTYPE * GetFrequency) (ma_IDirectSoundBuffer* pThis, DWORD* pFrequency);
HRESULT (STDMETHODCALLTYPE * GetStatus) (ma_IDirectSoundBuffer* pThis, DWORD* pStatus);
HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IDirectSoundBuffer* pThis, ma_IDirectSound* pDirectSound, const MA_DSBUFFERDESC* pDSBufferDesc);
HRESULT (STDMETHODCALLTYPE * Lock) (ma_IDirectSoundBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags);
HRESULT (STDMETHODCALLTYPE * Play) (ma_IDirectSoundBuffer* pThis, DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags);
HRESULT (STDMETHODCALLTYPE * SetCurrentPosition)(ma_IDirectSoundBuffer* pThis, DWORD dwNewPosition);
HRESULT (STDMETHODCALLTYPE * SetFormat) (ma_IDirectSoundBuffer* pThis, const WAVEFORMATEX* pFormat);
HRESULT (STDMETHODCALLTYPE * SetVolume) (ma_IDirectSoundBuffer* pThis, LONG volume);
HRESULT (STDMETHODCALLTYPE * SetPan) (ma_IDirectSoundBuffer* pThis, LONG pan);
HRESULT (STDMETHODCALLTYPE * SetFrequency) (ma_IDirectSoundBuffer* pThis, DWORD dwFrequency);
HRESULT (STDMETHODCALLTYPE * Stop) (ma_IDirectSoundBuffer* pThis);
HRESULT (STDMETHODCALLTYPE * Unlock) (ma_IDirectSoundBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2);
HRESULT (STDMETHODCALLTYPE * Restore) (ma_IDirectSoundBuffer* pThis);
} ma_IDirectSoundBufferVtbl;
struct ma_IDirectSoundBuffer
{
ma_IDirectSoundBufferVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IDirectSoundBuffer_QueryInterface(ma_IDirectSoundBuffer* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IDirectSoundBuffer_AddRef(ma_IDirectSoundBuffer* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IDirectSoundBuffer_Release(ma_IDirectSoundBuffer* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetCaps(ma_IDirectSoundBuffer* pThis, MA_DSBCAPS* pDSBufferCaps) { return pThis->lpVtbl->GetCaps(pThis, pDSBufferCaps); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetCurrentPosition(ma_IDirectSoundBuffer* pThis, DWORD* pCurrentPlayCursor, DWORD* pCurrentWriteCursor) { return pThis->lpVtbl->GetCurrentPosition(pThis, pCurrentPlayCursor, pCurrentWriteCursor); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetFormat(ma_IDirectSoundBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten) { return pThis->lpVtbl->GetFormat(pThis, pFormat, dwSizeAllocated, pSizeWritten); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetVolume(ma_IDirectSoundBuffer* pThis, LONG* pVolume) { return pThis->lpVtbl->GetVolume(pThis, pVolume); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetPan(ma_IDirectSoundBuffer* pThis, LONG* pPan) { return pThis->lpVtbl->GetPan(pThis, pPan); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetFrequency(ma_IDirectSoundBuffer* pThis, DWORD* pFrequency) { return pThis->lpVtbl->GetFrequency(pThis, pFrequency); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_GetStatus(ma_IDirectSoundBuffer* pThis, DWORD* pStatus) { return pThis->lpVtbl->GetStatus(pThis, pStatus); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Initialize(ma_IDirectSoundBuffer* pThis, ma_IDirectSound* pDirectSound, const MA_DSBUFFERDESC* pDSBufferDesc) { return pThis->lpVtbl->Initialize(pThis, pDirectSound, pDSBufferDesc); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Lock(ma_IDirectSoundBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags) { return pThis->lpVtbl->Lock(pThis, dwOffset, dwBytes, ppAudioPtr1, pAudioBytes1, ppAudioPtr2, pAudioBytes2, dwFlags); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Play(ma_IDirectSoundBuffer* pThis, DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) { return pThis->lpVtbl->Play(pThis, dwReserved1, dwPriority, dwFlags); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_SetCurrentPosition(ma_IDirectSoundBuffer* pThis, DWORD dwNewPosition) { return pThis->lpVtbl->SetCurrentPosition(pThis, dwNewPosition); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_SetFormat(ma_IDirectSoundBuffer* pThis, const WAVEFORMATEX* pFormat) { return pThis->lpVtbl->SetFormat(pThis, pFormat); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_SetVolume(ma_IDirectSoundBuffer* pThis, LONG volume) { return pThis->lpVtbl->SetVolume(pThis, volume); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_SetPan(ma_IDirectSoundBuffer* pThis, LONG pan) { return pThis->lpVtbl->SetPan(pThis, pan); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_SetFrequency(ma_IDirectSoundBuffer* pThis, DWORD dwFrequency) { return pThis->lpVtbl->SetFrequency(pThis, dwFrequency); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Stop(ma_IDirectSoundBuffer* pThis) { return pThis->lpVtbl->Stop(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Unlock(ma_IDirectSoundBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2) { return pThis->lpVtbl->Unlock(pThis, pAudioPtr1, dwAudioBytes1, pAudioPtr2, dwAudioBytes2); }
static MA_INLINE HRESULT ma_IDirectSoundBuffer_Restore(ma_IDirectSoundBuffer* pThis) { return pThis->lpVtbl->Restore(pThis); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IDirectSoundCapture* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IDirectSoundCapture* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IDirectSoundCapture* pThis);


HRESULT (STDMETHODCALLTYPE * CreateCaptureBuffer)(ma_IDirectSoundCapture* pThis, const MA_DSCBUFFERDESC* pDSCBufferDesc, ma_IDirectSoundCaptureBuffer** ppDSCBuffer, void* pUnkOuter);
HRESULT (STDMETHODCALLTYPE * GetCaps) (ma_IDirectSoundCapture* pThis, MA_DSCCAPS* pDSCCaps);
HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IDirectSoundCapture* pThis, const GUID* pGuidDevice);
} ma_IDirectSoundCaptureVtbl;
struct ma_IDirectSoundCapture
{
ma_IDirectSoundCaptureVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IDirectSoundCapture_QueryInterface(ma_IDirectSoundCapture* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IDirectSoundCapture_AddRef(ma_IDirectSoundCapture* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IDirectSoundCapture_Release(ma_IDirectSoundCapture* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundCapture_CreateCaptureBuffer(ma_IDirectSoundCapture* pThis, const MA_DSCBUFFERDESC* pDSCBufferDesc, ma_IDirectSoundCaptureBuffer** ppDSCBuffer, void* pUnkOuter) { return pThis->lpVtbl->CreateCaptureBuffer(pThis, pDSCBufferDesc, ppDSCBuffer, pUnkOuter); }
static MA_INLINE HRESULT ma_IDirectSoundCapture_GetCaps (ma_IDirectSoundCapture* pThis, MA_DSCCAPS* pDSCCaps) { return pThis->lpVtbl->GetCaps(pThis, pDSCCaps); }
static MA_INLINE HRESULT ma_IDirectSoundCapture_Initialize (ma_IDirectSoundCapture* pThis, const GUID* pGuidDevice) { return pThis->lpVtbl->Initialize(pThis, pGuidDevice); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IDirectSoundCaptureBuffer* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IDirectSoundCaptureBuffer* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IDirectSoundCaptureBuffer* pThis);


HRESULT (STDMETHODCALLTYPE * GetCaps) (ma_IDirectSoundCaptureBuffer* pThis, MA_DSCBCAPS* pDSCBCaps);
HRESULT (STDMETHODCALLTYPE * GetCurrentPosition)(ma_IDirectSoundCaptureBuffer* pThis, DWORD* pCapturePosition, DWORD* pReadPosition);
HRESULT (STDMETHODCALLTYPE * GetFormat) (ma_IDirectSoundCaptureBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten);
HRESULT (STDMETHODCALLTYPE * GetStatus) (ma_IDirectSoundCaptureBuffer* pThis, DWORD* pStatus);
HRESULT (STDMETHODCALLTYPE * Initialize) (ma_IDirectSoundCaptureBuffer* pThis, ma_IDirectSoundCapture* pDirectSoundCapture, const MA_DSCBUFFERDESC* pDSCBufferDesc);
HRESULT (STDMETHODCALLTYPE * Lock) (ma_IDirectSoundCaptureBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags);
HRESULT (STDMETHODCALLTYPE * Start) (ma_IDirectSoundCaptureBuffer* pThis, DWORD dwFlags);
HRESULT (STDMETHODCALLTYPE * Stop) (ma_IDirectSoundCaptureBuffer* pThis);
HRESULT (STDMETHODCALLTYPE * Unlock) (ma_IDirectSoundCaptureBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2);
} ma_IDirectSoundCaptureBufferVtbl;
struct ma_IDirectSoundCaptureBuffer
{
ma_IDirectSoundCaptureBufferVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_QueryInterface(ma_IDirectSoundCaptureBuffer* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IDirectSoundCaptureBuffer_AddRef(ma_IDirectSoundCaptureBuffer* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IDirectSoundCaptureBuffer_Release(ma_IDirectSoundCaptureBuffer* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_GetCaps(ma_IDirectSoundCaptureBuffer* pThis, MA_DSCBCAPS* pDSCBCaps) { return pThis->lpVtbl->GetCaps(pThis, pDSCBCaps); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_GetCurrentPosition(ma_IDirectSoundCaptureBuffer* pThis, DWORD* pCapturePosition, DWORD* pReadPosition) { return pThis->lpVtbl->GetCurrentPosition(pThis, pCapturePosition, pReadPosition); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_GetFormat(ma_IDirectSoundCaptureBuffer* pThis, WAVEFORMATEX* pFormat, DWORD dwSizeAllocated, DWORD* pSizeWritten) { return pThis->lpVtbl->GetFormat(pThis, pFormat, dwSizeAllocated, pSizeWritten); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_GetStatus(ma_IDirectSoundCaptureBuffer* pThis, DWORD* pStatus) { return pThis->lpVtbl->GetStatus(pThis, pStatus); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_Initialize(ma_IDirectSoundCaptureBuffer* pThis, ma_IDirectSoundCapture* pDirectSoundCapture, const MA_DSCBUFFERDESC* pDSCBufferDesc) { return pThis->lpVtbl->Initialize(pThis, pDirectSoundCapture, pDSCBufferDesc); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_Lock(ma_IDirectSoundCaptureBuffer* pThis, DWORD dwOffset, DWORD dwBytes, void** ppAudioPtr1, DWORD* pAudioBytes1, void** ppAudioPtr2, DWORD* pAudioBytes2, DWORD dwFlags) { return pThis->lpVtbl->Lock(pThis, dwOffset, dwBytes, ppAudioPtr1, pAudioBytes1, ppAudioPtr2, pAudioBytes2, dwFlags); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_Start(ma_IDirectSoundCaptureBuffer* pThis, DWORD dwFlags) { return pThis->lpVtbl->Start(pThis, dwFlags); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_Stop(ma_IDirectSoundCaptureBuffer* pThis) { return pThis->lpVtbl->Stop(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundCaptureBuffer_Unlock(ma_IDirectSoundCaptureBuffer* pThis, void* pAudioPtr1, DWORD dwAudioBytes1, void* pAudioPtr2, DWORD dwAudioBytes2) { return pThis->lpVtbl->Unlock(pThis, pAudioPtr1, dwAudioBytes1, pAudioPtr2, dwAudioBytes2); }



typedef struct
{

HRESULT (STDMETHODCALLTYPE * QueryInterface)(ma_IDirectSoundNotify* pThis, const IID* const riid, void** ppObject);
ULONG (STDMETHODCALLTYPE * AddRef) (ma_IDirectSoundNotify* pThis);
ULONG (STDMETHODCALLTYPE * Release) (ma_IDirectSoundNotify* pThis);


HRESULT (STDMETHODCALLTYPE * SetNotificationPositions)(ma_IDirectSoundNotify* pThis, DWORD dwPositionNotifies, const MA_DSBPOSITIONNOTIFY* pPositionNotifies);
} ma_IDirectSoundNotifyVtbl;
struct ma_IDirectSoundNotify
{
ma_IDirectSoundNotifyVtbl* lpVtbl;
};
static MA_INLINE HRESULT ma_IDirectSoundNotify_QueryInterface(ma_IDirectSoundNotify* pThis, const IID* const riid, void** ppObject) { return pThis->lpVtbl->QueryInterface(pThis, riid, ppObject); }
static MA_INLINE ULONG ma_IDirectSoundNotify_AddRef(ma_IDirectSoundNotify* pThis) { return pThis->lpVtbl->AddRef(pThis); }
static MA_INLINE ULONG ma_IDirectSoundNotify_Release(ma_IDirectSoundNotify* pThis) { return pThis->lpVtbl->Release(pThis); }
static MA_INLINE HRESULT ma_IDirectSoundNotify_SetNotificationPositions(ma_IDirectSoundNotify* pThis, DWORD dwPositionNotifies, const MA_DSBPOSITIONNOTIFY* pPositionNotifies) { return pThis->lpVtbl->SetNotificationPositions(pThis, dwPositionNotifies, pPositionNotifies); }


typedef BOOL (CALLBACK * ma_DSEnumCallbackAProc) (LPGUID pDeviceGUID, LPCSTR pDeviceDescription, LPCSTR pModule, LPVOID pContext);
typedef HRESULT (WINAPI * ma_DirectSoundCreateProc) (const GUID* pcGuidDevice, ma_IDirectSound** ppDS8, LPUNKNOWN pUnkOuter);
typedef HRESULT (WINAPI * ma_DirectSoundEnumerateAProc) (ma_DSEnumCallbackAProc pDSEnumCallback, LPVOID pContext);
typedef HRESULT (WINAPI * ma_DirectSoundCaptureCreateProc) (const GUID* pcGuidDevice, ma_IDirectSoundCapture** ppDSC8, LPUNKNOWN pUnkOuter);
typedef HRESULT (WINAPI * ma_DirectSoundCaptureEnumerateAProc)(ma_DSEnumCallbackAProc pDSEnumCallback, LPVOID pContext);

static ma_uint32 ma_get_best_sample_rate_within_range(ma_uint32 sampleRateMin, ma_uint32 sampleRateMax)
{

if (sampleRateMin < MA_MIN_SAMPLE_RATE) {
sampleRateMin = MA_MIN_SAMPLE_RATE;
}
if (sampleRateMax > MA_MAX_SAMPLE_RATE) {
sampleRateMax = MA_MAX_SAMPLE_RATE;
}
if (sampleRateMin > sampleRateMax) {
sampleRateMin = sampleRateMax;
}

if (sampleRateMin == sampleRateMax) {
return sampleRateMax;
} else {
size_t iStandardRate;
for (iStandardRate = 0; iStandardRate < ma_countof(g_maStandardSampleRatePriorities); ++iStandardRate) {
ma_uint32 standardRate = g_maStandardSampleRatePriorities[iStandardRate];
if (standardRate >= sampleRateMin && standardRate <= sampleRateMax) {
return standardRate;
}
}
}


MA_ASSERT(MA_FALSE);
return 0;
}





static void ma_get_channels_from_speaker_config__dsound(DWORD speakerConfig, WORD* pChannelsOut, DWORD* pChannelMapOut)
{
WORD channels;
DWORD channelMap;

channels = 0;
if (pChannelsOut != NULL) {
channels = *pChannelsOut;
}

channelMap = 0;
if (pChannelMapOut != NULL) {
channelMap = *pChannelMapOut;
}





switch ((BYTE)(speakerConfig)) {
case 1 : channels = 2; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT; break;
case 2 : channels = 1; channelMap = SPEAKER_FRONT_CENTER; break;
case 3 : channels = 4; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT; break;
case 4 : channels = 2; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT; break;
case 5 : channels = 4; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER; break;
case 6 : channels = 6; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT; break;
case 7 : channels = 8; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER; break;
case 8 : channels = 8; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT; break;
case 9 : channels = 6; channelMap = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT; break;
default: break;
}

if (pChannelsOut != NULL) {
*pChannelsOut = channels;
}

if (pChannelMapOut != NULL) {
*pChannelMapOut = channelMap;
}
}


static ma_result ma_context_create_IDirectSound__dsound(ma_context* pContext, ma_share_mode shareMode, const ma_device_id* pDeviceID, ma_IDirectSound** ppDirectSound)
{
ma_IDirectSound* pDirectSound;
HWND hWnd;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppDirectSound != NULL);

*ppDirectSound = NULL;
pDirectSound = NULL;

if (FAILED(((ma_DirectSoundCreateProc)pContext->dsound.DirectSoundCreate)((pDeviceID == NULL) ? NULL : (const GUID*)pDeviceID->dsound, &pDirectSound, NULL))) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[DirectSound] DirectSoundCreate() failed for playback device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


hWnd = ((MA_PFN_GetForegroundWindow)pContext->win32.GetForegroundWindow)();
if (hWnd == NULL) {
hWnd = ((MA_PFN_GetDesktopWindow)pContext->win32.GetDesktopWindow)();
}
if (FAILED(ma_IDirectSound_SetCooperativeLevel(pDirectSound, hWnd, (shareMode == ma_share_mode_exclusive) ? MA_DSSCL_EXCLUSIVE : MA_DSSCL_PRIORITY))) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_SetCooperateiveLevel() failed for playback device.", MA_SHARE_MODE_NOT_SUPPORTED);
}

*ppDirectSound = pDirectSound;
return MA_SUCCESS;
}

static ma_result ma_context_create_IDirectSoundCapture__dsound(ma_context* pContext, ma_share_mode shareMode, const ma_device_id* pDeviceID, ma_IDirectSoundCapture** ppDirectSoundCapture)
{
ma_IDirectSoundCapture* pDirectSoundCapture;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppDirectSoundCapture != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

*ppDirectSoundCapture = NULL;
pDirectSoundCapture = NULL;

if (FAILED(((ma_DirectSoundCaptureCreateProc)pContext->dsound.DirectSoundCaptureCreate)((pDeviceID == NULL) ? NULL : (const GUID*)pDeviceID->dsound, &pDirectSoundCapture, NULL))) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[DirectSound] DirectSoundCaptureCreate() failed for capture device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

*ppDirectSoundCapture = pDirectSoundCapture;
return MA_SUCCESS;
}

static ma_result ma_context_get_format_info_for_IDirectSoundCapture__dsound(ma_context* pContext, ma_IDirectSoundCapture* pDirectSoundCapture, WORD* pChannels, WORD* pBitsPerSample, DWORD* pSampleRate)
{
MA_DSCCAPS caps;
WORD bitsPerSample;
DWORD sampleRate;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pDirectSoundCapture != NULL);

if (pChannels) {
*pChannels = 0;
}
if (pBitsPerSample) {
*pBitsPerSample = 0;
}
if (pSampleRate) {
*pSampleRate = 0;
}

MA_ZERO_OBJECT(&caps);
caps.dwSize = sizeof(caps);
if (FAILED(ma_IDirectSoundCapture_GetCaps(pDirectSoundCapture, &caps))) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCapture_GetCaps() failed for capture device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (pChannels) {
*pChannels = (WORD)caps.dwChannels;
}


bitsPerSample = 16;
sampleRate = 48000;

if (caps.dwChannels == 1) {
if ((caps.dwFormats & WAVE_FORMAT_48M16) != 0) {
sampleRate = 48000;
} else if ((caps.dwFormats & WAVE_FORMAT_44M16) != 0) {
sampleRate = 44100;
} else if ((caps.dwFormats & WAVE_FORMAT_2M16) != 0) {
sampleRate = 22050;
} else if ((caps.dwFormats & WAVE_FORMAT_1M16) != 0) {
sampleRate = 11025;
} else if ((caps.dwFormats & WAVE_FORMAT_96M16) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 8;
if ((caps.dwFormats & WAVE_FORMAT_48M08) != 0) {
sampleRate = 48000;
} else if ((caps.dwFormats & WAVE_FORMAT_44M08) != 0) {
sampleRate = 44100;
} else if ((caps.dwFormats & WAVE_FORMAT_2M08) != 0) {
sampleRate = 22050;
} else if ((caps.dwFormats & WAVE_FORMAT_1M08) != 0) {
sampleRate = 11025;
} else if ((caps.dwFormats & WAVE_FORMAT_96M08) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 16; 
}
}
} else if (caps.dwChannels == 2) {
if ((caps.dwFormats & WAVE_FORMAT_48S16) != 0) {
sampleRate = 48000;
} else if ((caps.dwFormats & WAVE_FORMAT_44S16) != 0) {
sampleRate = 44100;
} else if ((caps.dwFormats & WAVE_FORMAT_2S16) != 0) {
sampleRate = 22050;
} else if ((caps.dwFormats & WAVE_FORMAT_1S16) != 0) {
sampleRate = 11025;
} else if ((caps.dwFormats & WAVE_FORMAT_96S16) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 8;
if ((caps.dwFormats & WAVE_FORMAT_48S08) != 0) {
sampleRate = 48000;
} else if ((caps.dwFormats & WAVE_FORMAT_44S08) != 0) {
sampleRate = 44100;
} else if ((caps.dwFormats & WAVE_FORMAT_2S08) != 0) {
sampleRate = 22050;
} else if ((caps.dwFormats & WAVE_FORMAT_1S08) != 0) {
sampleRate = 11025;
} else if ((caps.dwFormats & WAVE_FORMAT_96S08) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 16; 
}
}
}

if (pBitsPerSample) {
*pBitsPerSample = bitsPerSample;
}
if (pSampleRate) {
*pSampleRate = sampleRate;
}

return MA_SUCCESS;
}

static ma_bool32 ma_context_is_device_id_equal__dsound(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return memcmp(pID0->dsound, pID1->dsound, sizeof(pID0->dsound)) == 0;
}


typedef struct
{
ma_context* pContext;
ma_device_type deviceType;
ma_enum_devices_callback_proc callback;
void* pUserData;
ma_bool32 terminated;
} ma_context_enumerate_devices_callback_data__dsound;

static BOOL CALLBACK ma_context_enumerate_devices_callback__dsound(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
ma_context_enumerate_devices_callback_data__dsound* pData = (ma_context_enumerate_devices_callback_data__dsound*)lpContext;
ma_device_info deviceInfo; 

MA_ZERO_OBJECT(&deviceInfo);


if (lpGuid != NULL) {
MA_COPY_MEMORY(deviceInfo.id.dsound, lpGuid, 16);
} else {
MA_ZERO_MEMORY(deviceInfo.id.dsound, 16);
}


ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), lpcstrDescription, (size_t)-1);



MA_ASSERT(pData != NULL);
pData->terminated = !pData->callback(pData->pContext, pData->deviceType, &deviceInfo, pData->pUserData);
if (pData->terminated) {
return FALSE; 
} else {
return TRUE; 
}

(void)lpcstrModule;
}

static ma_result ma_context_enumerate_devices__dsound(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_context_enumerate_devices_callback_data__dsound data;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);

data.pContext = pContext;
data.callback = callback;
data.pUserData = pUserData;
data.terminated = MA_FALSE;


if (!data.terminated) {
data.deviceType = ma_device_type_playback;
((ma_DirectSoundEnumerateAProc)pContext->dsound.DirectSoundEnumerateA)(ma_context_enumerate_devices_callback__dsound, &data);
}


if (!data.terminated) {
data.deviceType = ma_device_type_capture;
((ma_DirectSoundCaptureEnumerateAProc)pContext->dsound.DirectSoundCaptureEnumerateA)(ma_context_enumerate_devices_callback__dsound, &data);
}

return MA_SUCCESS;
}


typedef struct
{
const ma_device_id* pDeviceID;
ma_device_info* pDeviceInfo;
ma_bool32 found;
} ma_context_get_device_info_callback_data__dsound;

static BOOL CALLBACK ma_context_get_device_info_callback__dsound(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
ma_context_get_device_info_callback_data__dsound* pData = (ma_context_get_device_info_callback_data__dsound*)lpContext;
MA_ASSERT(pData != NULL);

if ((pData->pDeviceID == NULL || ma_is_guid_equal(pData->pDeviceID->dsound, &MA_GUID_NULL)) && (lpGuid == NULL || ma_is_guid_equal(lpGuid, &MA_GUID_NULL))) {

ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), lpcstrDescription, (size_t)-1);
pData->found = MA_TRUE;
return FALSE; 
} else {

if (lpGuid != NULL && pData->pDeviceID != NULL) {
if (memcmp(pData->pDeviceID->dsound, lpGuid, sizeof(pData->pDeviceID->dsound)) == 0) {
ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), lpcstrDescription, (size_t)-1);
pData->found = MA_TRUE;
return FALSE; 
}
}
}

(void)lpcstrModule;
return TRUE;
}

static ma_result ma_context_get_device_info__dsound(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{

if (deviceType == ma_device_type_capture && shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

if (pDeviceID != NULL) {
ma_context_get_device_info_callback_data__dsound data;


MA_COPY_MEMORY(pDeviceInfo->id.dsound, pDeviceID->dsound, 16);


data.pDeviceID = pDeviceID;
data.pDeviceInfo = pDeviceInfo;
data.found = MA_FALSE;
if (deviceType == ma_device_type_playback) {
((ma_DirectSoundEnumerateAProc)pContext->dsound.DirectSoundEnumerateA)(ma_context_get_device_info_callback__dsound, &data);
} else {
((ma_DirectSoundCaptureEnumerateAProc)pContext->dsound.DirectSoundCaptureEnumerateA)(ma_context_get_device_info_callback__dsound, &data);
}

if (!data.found) {
return MA_NO_DEVICE;
}
} else {



MA_ZERO_MEMORY(pDeviceInfo->id.dsound, 16);


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}
}


if (deviceType == ma_device_type_playback) {

ma_IDirectSound* pDirectSound;
ma_result result;
MA_DSCAPS caps;
ma_uint32 iFormat;

result = ma_context_create_IDirectSound__dsound(pContext, shareMode, pDeviceID, &pDirectSound);
if (result != MA_SUCCESS) {
return result;
}

MA_ZERO_OBJECT(&caps);
caps.dwSize = sizeof(caps);
if (FAILED(ma_IDirectSound_GetCaps(pDirectSound, &caps))) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_GetCaps() failed for playback device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if ((caps.dwFlags & MA_DSCAPS_PRIMARYSTEREO) != 0) {

WORD channels = 2;


DWORD speakerConfig;
if (SUCCEEDED(ma_IDirectSound_GetSpeakerConfig(pDirectSound, &speakerConfig))) {
ma_get_channels_from_speaker_config__dsound(speakerConfig, &channels, NULL);
}

pDeviceInfo->minChannels = channels;
pDeviceInfo->maxChannels = channels;
} else {

pDeviceInfo->minChannels = 1;
pDeviceInfo->maxChannels = 1;
}


if ((caps.dwFlags & MA_DSCAPS_CONTINUOUSRATE) != 0) {
pDeviceInfo->minSampleRate = caps.dwMinSecondarySampleRate;
pDeviceInfo->maxSampleRate = caps.dwMaxSecondarySampleRate;





if (caps.dwMinSecondarySampleRate < MA_MIN_SAMPLE_RATE && caps.dwMaxSecondarySampleRate >= MA_MIN_SAMPLE_RATE) {
pDeviceInfo->minSampleRate = MA_MIN_SAMPLE_RATE;
}
if (caps.dwMaxSecondarySampleRate > MA_MAX_SAMPLE_RATE && caps.dwMinSecondarySampleRate <= MA_MAX_SAMPLE_RATE) {
pDeviceInfo->maxSampleRate = MA_MAX_SAMPLE_RATE;
}
} else {

pDeviceInfo->minSampleRate = caps.dwMaxSecondarySampleRate;
pDeviceInfo->maxSampleRate = caps.dwMaxSecondarySampleRate;
}


pDeviceInfo->formatCount = ma_format_count - 1; 
for (iFormat = 0; iFormat < pDeviceInfo->formatCount; ++iFormat) {
pDeviceInfo->formats[iFormat] = (ma_format)(iFormat + 1); 
}

ma_IDirectSound_Release(pDirectSound);
} else {





ma_IDirectSoundCapture* pDirectSoundCapture;
ma_result result;
WORD channels;
WORD bitsPerSample;
DWORD sampleRate;

result = ma_context_create_IDirectSoundCapture__dsound(pContext, shareMode, pDeviceID, &pDirectSoundCapture);
if (result != MA_SUCCESS) {
return result;
}

result = ma_context_get_format_info_for_IDirectSoundCapture__dsound(pContext, pDirectSoundCapture, &channels, &bitsPerSample, &sampleRate);
if (result != MA_SUCCESS) {
ma_IDirectSoundCapture_Release(pDirectSoundCapture);
return result;
}

pDeviceInfo->minChannels = channels;
pDeviceInfo->maxChannels = channels;
pDeviceInfo->minSampleRate = sampleRate;
pDeviceInfo->maxSampleRate = sampleRate;
pDeviceInfo->formatCount = 1;
if (bitsPerSample == 8) {
pDeviceInfo->formats[0] = ma_format_u8;
} else if (bitsPerSample == 16) {
pDeviceInfo->formats[0] = ma_format_s16;
} else if (bitsPerSample == 24) {
pDeviceInfo->formats[0] = ma_format_s24;
} else if (bitsPerSample == 32) {
pDeviceInfo->formats[0] = ma_format_s32;
} else {
ma_IDirectSoundCapture_Release(pDirectSoundCapture);
return MA_FORMAT_NOT_SUPPORTED;
}

ma_IDirectSoundCapture_Release(pDirectSoundCapture);
}

return MA_SUCCESS;
}



static void ma_device_uninit__dsound(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->dsound.pCaptureBuffer != NULL) {
ma_IDirectSoundCaptureBuffer_Release((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
}
if (pDevice->dsound.pCapture != NULL) {
ma_IDirectSoundCapture_Release((ma_IDirectSoundCapture*)pDevice->dsound.pCapture);
}

if (pDevice->dsound.pPlaybackBuffer != NULL) {
ma_IDirectSoundBuffer_Release((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer);
}
if (pDevice->dsound.pPlaybackPrimaryBuffer != NULL) {
ma_IDirectSoundBuffer_Release((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer);
}
if (pDevice->dsound.pPlayback != NULL) {
ma_IDirectSound_Release((ma_IDirectSound*)pDevice->dsound.pPlayback);
}
}

static ma_result ma_config_to_WAVEFORMATEXTENSIBLE(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, const ma_channel* pChannelMap, WAVEFORMATEXTENSIBLE* pWF)
{
GUID subformat;

switch (format)
{
case ma_format_u8:
case ma_format_s16:
case ma_format_s24:

case ma_format_s32:
{
subformat = MA_GUID_KSDATAFORMAT_SUBTYPE_PCM;
} break;

case ma_format_f32:
{
subformat = MA_GUID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
} break;

default:
return MA_FORMAT_NOT_SUPPORTED;
}

MA_ZERO_OBJECT(pWF);
pWF->Format.cbSize = sizeof(*pWF);
pWF->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
pWF->Format.nChannels = (WORD)channels;
pWF->Format.nSamplesPerSec = (DWORD)sampleRate;
pWF->Format.wBitsPerSample = (WORD)ma_get_bytes_per_sample(format)*8;
pWF->Format.nBlockAlign = (pWF->Format.nChannels * pWF->Format.wBitsPerSample) / 8;
pWF->Format.nAvgBytesPerSec = pWF->Format.nBlockAlign * pWF->Format.nSamplesPerSec;
pWF->Samples.wValidBitsPerSample = pWF->Format.wBitsPerSample;
pWF->dwChannelMask = ma_channel_map_to_channel_mask__win32(pChannelMap, channels);
pWF->SubFormat = subformat;

return MA_SUCCESS;
}

static ma_result ma_device_init__dsound(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;
ma_uint32 periodSizeInMilliseconds;

MA_ASSERT(pDevice != NULL);
MA_ZERO_OBJECT(&pDevice->dsound);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

periodSizeInMilliseconds = pConfig->periodSizeInMilliseconds;
if (periodSizeInMilliseconds == 0) {
periodSizeInMilliseconds = ma_calculate_buffer_size_in_milliseconds_from_frames(pConfig->periodSizeInFrames, pConfig->sampleRate);
}


if (pDevice->usingDefaultBufferSize) {
if (pConfig->performanceProfile == ma_performance_profile_low_latency) {
periodSizeInMilliseconds = 20;
} else {
periodSizeInMilliseconds = 200;
}
}


if (periodSizeInMilliseconds < 20) {
periodSizeInMilliseconds = 20;
}






if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
WAVEFORMATEXTENSIBLE wf;
MA_DSCBUFFERDESC descDS;
ma_uint32 periodSizeInFrames;
char rawdata[1024]; 
WAVEFORMATEXTENSIBLE* pActualFormat;

result = ma_config_to_WAVEFORMATEXTENSIBLE(pConfig->capture.format, pConfig->capture.channels, pConfig->sampleRate, pConfig->capture.channelMap, &wf);
if (result != MA_SUCCESS) {
return result;
}

result = ma_context_create_IDirectSoundCapture__dsound(pContext, pConfig->capture.shareMode, pConfig->capture.pDeviceID, (ma_IDirectSoundCapture**)&pDevice->dsound.pCapture);
if (result != MA_SUCCESS) {
ma_device_uninit__dsound(pDevice);
return result;
}

result = ma_context_get_format_info_for_IDirectSoundCapture__dsound(pContext, (ma_IDirectSoundCapture*)pDevice->dsound.pCapture, &wf.Format.nChannels, &wf.Format.wBitsPerSample, &wf.Format.nSamplesPerSec);
if (result != MA_SUCCESS) {
ma_device_uninit__dsound(pDevice);
return result;
}

wf.Format.nBlockAlign = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
wf.Format.nAvgBytesPerSec = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;
wf.Samples.wValidBitsPerSample = wf.Format.wBitsPerSample;
wf.SubFormat = MA_GUID_KSDATAFORMAT_SUBTYPE_PCM;


periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, wf.Format.nSamplesPerSec);

MA_ZERO_OBJECT(&descDS);
descDS.dwSize = sizeof(descDS);
descDS.dwFlags = 0;
descDS.dwBufferBytes = periodSizeInFrames * pConfig->periods * ma_get_bytes_per_frame(pDevice->capture.internalFormat, wf.Format.nChannels);
descDS.lpwfxFormat = (WAVEFORMATEX*)&wf;
if (FAILED(ma_IDirectSoundCapture_CreateCaptureBuffer((ma_IDirectSoundCapture*)pDevice->dsound.pCapture, &descDS, (ma_IDirectSoundCaptureBuffer**)&pDevice->dsound.pCaptureBuffer, NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCapture_CreateCaptureBuffer() failed for capture device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


pActualFormat = (WAVEFORMATEXTENSIBLE*)rawdata;
if (FAILED(ma_IDirectSoundCaptureBuffer_GetFormat((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, (WAVEFORMATEX*)pActualFormat, sizeof(rawdata), NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to retrieve the actual format of the capture device's buffer.", MA_FORMAT_NOT_SUPPORTED);
}

pDevice->capture.internalFormat = ma_format_from_WAVEFORMATEX((WAVEFORMATEX*)pActualFormat);
pDevice->capture.internalChannels = pActualFormat->Format.nChannels;
pDevice->capture.internalSampleRate = pActualFormat->Format.nSamplesPerSec;


if (pActualFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
ma_channel_mask_to_channel_map__win32(pActualFormat->dwChannelMask, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
} else {
ma_channel_mask_to_channel_map__win32(wf.dwChannelMask, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
}





if (periodSizeInFrames != (descDS.dwBufferBytes / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels) / pConfig->periods)) {
descDS.dwBufferBytes = periodSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.internalFormat, wf.Format.nChannels) * pConfig->periods;
ma_IDirectSoundCaptureBuffer_Release((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);

if (FAILED(ma_IDirectSoundCapture_CreateCaptureBuffer((ma_IDirectSoundCapture*)pDevice->dsound.pCapture, &descDS, (ma_IDirectSoundCaptureBuffer**)&pDevice->dsound.pCaptureBuffer, NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Second attempt at IDirectSoundCapture_CreateCaptureBuffer() failed for capture device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}


pDevice->capture.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->capture.internalPeriods = pConfig->periods;
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
WAVEFORMATEXTENSIBLE wf;
MA_DSBUFFERDESC descDSPrimary;
MA_DSCAPS caps;
char rawdata[1024]; 
WAVEFORMATEXTENSIBLE* pActualFormat;
ma_uint32 periodSizeInFrames;
MA_DSBUFFERDESC descDS;

result = ma_config_to_WAVEFORMATEXTENSIBLE(pConfig->playback.format, pConfig->playback.channels, pConfig->sampleRate, pConfig->playback.channelMap, &wf);
if (result != MA_SUCCESS) {
return result;
}

result = ma_context_create_IDirectSound__dsound(pContext, pConfig->playback.shareMode, pConfig->playback.pDeviceID, (ma_IDirectSound**)&pDevice->dsound.pPlayback);
if (result != MA_SUCCESS) {
ma_device_uninit__dsound(pDevice);
return result;
}

MA_ZERO_OBJECT(&descDSPrimary);
descDSPrimary.dwSize = sizeof(MA_DSBUFFERDESC);
descDSPrimary.dwFlags = MA_DSBCAPS_PRIMARYBUFFER | MA_DSBCAPS_CTRLVOLUME;
if (FAILED(ma_IDirectSound_CreateSoundBuffer((ma_IDirectSound*)pDevice->dsound.pPlayback, &descDSPrimary, (ma_IDirectSoundBuffer**)&pDevice->dsound.pPlaybackPrimaryBuffer, NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_CreateSoundBuffer() failed for playback device's primary buffer.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}



MA_ZERO_OBJECT(&caps);
caps.dwSize = sizeof(caps);
if (FAILED(ma_IDirectSound_GetCaps((ma_IDirectSound*)pDevice->dsound.pPlayback, &caps))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_GetCaps() failed for playback device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (pDevice->playback.usingDefaultChannels) {
if ((caps.dwFlags & MA_DSCAPS_PRIMARYSTEREO) != 0) {
DWORD speakerConfig;


wf.Format.nChannels = 2;


if (SUCCEEDED(ma_IDirectSound_GetSpeakerConfig((ma_IDirectSound*)pDevice->dsound.pPlayback, &speakerConfig))) {
ma_get_channels_from_speaker_config__dsound(speakerConfig, &wf.Format.nChannels, &wf.dwChannelMask);
}
} else {

wf.Format.nChannels = 1;
}
}

if (pDevice->usingDefaultSampleRate) {

if ((caps.dwFlags & MA_DSCAPS_CONTINUOUSRATE) != 0) {
wf.Format.nSamplesPerSec = ma_get_best_sample_rate_within_range(caps.dwMinSecondarySampleRate, caps.dwMaxSecondarySampleRate);
} else {
wf.Format.nSamplesPerSec = caps.dwMaxSecondarySampleRate;
}
}

wf.Format.nBlockAlign = (wf.Format.nChannels * wf.Format.wBitsPerSample) / 8;
wf.Format.nAvgBytesPerSec = wf.Format.nBlockAlign * wf.Format.nSamplesPerSec;








if (FAILED(ma_IDirectSoundBuffer_SetFormat((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer, (WAVEFORMATEX*)&wf))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to set format of playback device's primary buffer.", MA_FORMAT_NOT_SUPPORTED);
}


pActualFormat = (WAVEFORMATEXTENSIBLE*)rawdata;
if (FAILED(ma_IDirectSoundBuffer_GetFormat((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackPrimaryBuffer, (WAVEFORMATEX*)pActualFormat, sizeof(rawdata), NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to retrieve the actual format of the playback device's primary buffer.", MA_FORMAT_NOT_SUPPORTED);
}

pDevice->playback.internalFormat = ma_format_from_WAVEFORMATEX((WAVEFORMATEX*)pActualFormat);
pDevice->playback.internalChannels = pActualFormat->Format.nChannels;
pDevice->playback.internalSampleRate = pActualFormat->Format.nSamplesPerSec;


if (pActualFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
ma_channel_mask_to_channel_map__win32(pActualFormat->dwChannelMask, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
} else {
ma_channel_mask_to_channel_map__win32(wf.dwChannelMask, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
}


periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, pDevice->playback.internalSampleRate);
















MA_ZERO_OBJECT(&descDS);
descDS.dwSize = sizeof(descDS);
descDS.dwFlags = MA_DSBCAPS_CTRLPOSITIONNOTIFY | MA_DSBCAPS_GLOBALFOCUS | MA_DSBCAPS_GETCURRENTPOSITION2;
descDS.dwBufferBytes = periodSizeInFrames * pConfig->periods * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
descDS.lpwfxFormat = (WAVEFORMATEX*)&wf;
if (FAILED(ma_IDirectSound_CreateSoundBuffer((ma_IDirectSound*)pDevice->dsound.pPlayback, &descDS, (ma_IDirectSoundBuffer**)&pDevice->dsound.pPlaybackBuffer, NULL))) {
ma_device_uninit__dsound(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSound_CreateSoundBuffer() failed for playback device's secondary buffer.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


pDevice->playback.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->playback.internalPeriods = pConfig->periods;
}

(void)pContext;
return MA_SUCCESS;
}


static ma_result ma_device_main_loop__dsound(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_uint32 bpfDeviceCapture = ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 bpfDevicePlayback = ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
HRESULT hr;
DWORD lockOffsetInBytesCapture;
DWORD lockSizeInBytesCapture;
DWORD mappedSizeInBytesCapture;
DWORD mappedDeviceFramesProcessedCapture;
void* pMappedDeviceBufferCapture;
DWORD lockOffsetInBytesPlayback;
DWORD lockSizeInBytesPlayback;
DWORD mappedSizeInBytesPlayback;
void* pMappedDeviceBufferPlayback;
DWORD prevReadCursorInBytesCapture = 0;
DWORD prevPlayCursorInBytesPlayback = 0;
ma_bool32 physicalPlayCursorLoopFlagPlayback = 0;
DWORD virtualWriteCursorInBytesPlayback = 0;
ma_bool32 virtualWriteCursorLoopFlagPlayback = 0;
ma_bool32 isPlaybackDeviceStarted = MA_FALSE;
ma_uint32 framesWrittenToPlaybackDevice = 0; 
ma_uint32 waitTimeInMilliseconds = 1;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (FAILED(ma_IDirectSoundCaptureBuffer_Start((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, MA_DSCBSTART_LOOPING))) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCaptureBuffer_Start() failed.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}

while (ma_device__get_state(pDevice) == MA_STATE_STARTED) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{
DWORD physicalCaptureCursorInBytes;
DWORD physicalReadCursorInBytes;
if (FAILED(ma_IDirectSoundCaptureBuffer_GetCurrentPosition((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, &physicalCaptureCursorInBytes, &physicalReadCursorInBytes))) {
return MA_ERROR;
}


if (physicalReadCursorInBytes == prevReadCursorInBytesCapture) {
ma_sleep(waitTimeInMilliseconds);
continue; 
}





if (prevReadCursorInBytesCapture < physicalReadCursorInBytes) {

lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
lockSizeInBytesCapture = (physicalReadCursorInBytes - prevReadCursorInBytesCapture);
} else {




if (prevReadCursorInBytesCapture < pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*bpfDeviceCapture) {

lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
lockSizeInBytesCapture = (pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*bpfDeviceCapture) - prevReadCursorInBytesCapture;
} else {

lockOffsetInBytesCapture = 0;
lockSizeInBytesCapture = physicalReadCursorInBytes;
}
}

if (lockSizeInBytesCapture == 0) {
ma_sleep(waitTimeInMilliseconds);
continue; 
}

hr = ma_IDirectSoundCaptureBuffer_Lock((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, lockOffsetInBytesCapture, lockSizeInBytesCapture, &pMappedDeviceBufferCapture, &mappedSizeInBytesCapture, NULL, NULL, 0);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
}



mappedDeviceFramesProcessedCapture = 0;

for (;;) { 
ma_uint8 inputFramesInClientFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 inputFramesInClientFormatCap = sizeof(inputFramesInClientFormat) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint8 outputFramesInClientFormat[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 outputFramesInClientFormatCap = sizeof(outputFramesInClientFormat) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint32 outputFramesInClientFormatCount;
ma_uint32 outputFramesInClientFormatConsumed = 0;
ma_uint64 clientCapturedFramesToProcess = ma_min(inputFramesInClientFormatCap, outputFramesInClientFormatCap);
ma_uint64 deviceCapturedFramesToProcess = (mappedSizeInBytesCapture / bpfDeviceCapture) - mappedDeviceFramesProcessedCapture;
void* pRunningMappedDeviceBufferCapture = ma_offset_ptr(pMappedDeviceBufferCapture, mappedDeviceFramesProcessedCapture * bpfDeviceCapture);

result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningMappedDeviceBufferCapture, &deviceCapturedFramesToProcess, inputFramesInClientFormat, &clientCapturedFramesToProcess);
if (result != MA_SUCCESS) {
break;
}

outputFramesInClientFormatCount = (ma_uint32)clientCapturedFramesToProcess;
mappedDeviceFramesProcessedCapture += (ma_uint32)deviceCapturedFramesToProcess;

ma_device__on_data(pDevice, outputFramesInClientFormat, inputFramesInClientFormat, (ma_uint32)clientCapturedFramesToProcess);


for (;;) {
ma_uint32 framesWrittenThisIteration;
DWORD physicalPlayCursorInBytes;
DWORD physicalWriteCursorInBytes;
DWORD availableBytesPlayback;
DWORD silentPaddingInBytes = 0; 


if (FAILED(ma_IDirectSoundBuffer_GetCurrentPosition((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, &physicalPlayCursorInBytes, &physicalWriteCursorInBytes))) {
break;
}

if (physicalPlayCursorInBytes < prevPlayCursorInBytesPlayback) {
physicalPlayCursorLoopFlagPlayback = !physicalPlayCursorLoopFlagPlayback;
}
prevPlayCursorInBytesPlayback = physicalPlayCursorInBytes;


if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {

if (physicalPlayCursorInBytes <= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - virtualWriteCursorInBytesPlayback;
availableBytesPlayback += physicalPlayCursorInBytes; 
} else {

#if defined(MA_DEBUG_OUTPUT)
printf("[DirectSound] (Duplex/Playback) WARNING: Play cursor has moved in front of the write cursor (same loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
#endif
availableBytesPlayback = 0;
}
} else {

if (physicalPlayCursorInBytes >= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
} else {

#if defined(MA_DEBUG_OUTPUT)
printf("[DirectSound] (Duplex/Playback) WARNING: Write cursor has moved behind the play cursor (different loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
#endif
availableBytesPlayback = 0;
}
}

#if defined(MA_DEBUG_OUTPUT)

#endif


if (availableBytesPlayback == 0) {

if (!isPlaybackDeviceStarted) {
if (FAILED(ma_IDirectSoundBuffer_Play((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MA_DSBPLAY_LOOPING))) {
ma_IDirectSoundCaptureBuffer_Stop((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
isPlaybackDeviceStarted = MA_TRUE;
} else {
ma_sleep(waitTimeInMilliseconds);
continue;
}
}



lockOffsetInBytesPlayback = virtualWriteCursorInBytesPlayback;
if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {

lockSizeInBytesPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - virtualWriteCursorInBytesPlayback;
} else {

lockSizeInBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
}

hr = ma_IDirectSoundBuffer_Lock((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, lockOffsetInBytesPlayback, lockSizeInBytesPlayback, &pMappedDeviceBufferPlayback, &mappedSizeInBytesPlayback, NULL, NULL, 0);
if (FAILED(hr)) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
break;
}





if (isPlaybackDeviceStarted) {
DWORD bytesQueuedForPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - availableBytesPlayback;
if (bytesQueuedForPlayback < (pDevice->playback.internalPeriodSizeInFrames*bpfDevicePlayback)) {
silentPaddingInBytes = (pDevice->playback.internalPeriodSizeInFrames*2*bpfDevicePlayback) - bytesQueuedForPlayback;
if (silentPaddingInBytes > lockSizeInBytesPlayback) {
silentPaddingInBytes = lockSizeInBytesPlayback;
}

#if defined(MA_DEBUG_OUTPUT)
printf("[DirectSound] (Duplex/Playback) Playback buffer starved. availableBytesPlayback=%d, silentPaddingInBytes=%d\n", availableBytesPlayback, silentPaddingInBytes);
#endif
}
}


if (silentPaddingInBytes > 0) {
MA_ZERO_MEMORY(pMappedDeviceBufferPlayback, silentPaddingInBytes);
framesWrittenThisIteration = silentPaddingInBytes/bpfDevicePlayback;
} else {
ma_uint64 convertedFrameCountIn = (outputFramesInClientFormatCount - outputFramesInClientFormatConsumed);
ma_uint64 convertedFrameCountOut = mappedSizeInBytesPlayback/bpfDevicePlayback;
void* pConvertedFramesIn = ma_offset_ptr(outputFramesInClientFormat, outputFramesInClientFormatConsumed * bpfDevicePlayback);
void* pConvertedFramesOut = pMappedDeviceBufferPlayback;

result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, pConvertedFramesIn, &convertedFrameCountIn, pConvertedFramesOut, &convertedFrameCountOut);
if (result != MA_SUCCESS) {
break;
}

outputFramesInClientFormatConsumed += (ma_uint32)convertedFrameCountOut;
framesWrittenThisIteration = (ma_uint32)convertedFrameCountOut;
}


hr = ma_IDirectSoundBuffer_Unlock((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, pMappedDeviceBufferPlayback, framesWrittenThisIteration*bpfDevicePlayback, NULL, 0);
if (FAILED(hr)) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from playback device after writing to the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
break;
}

virtualWriteCursorInBytesPlayback += framesWrittenThisIteration*bpfDevicePlayback;
if ((virtualWriteCursorInBytesPlayback/bpfDevicePlayback) == pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods) {
virtualWriteCursorInBytesPlayback = 0;
virtualWriteCursorLoopFlagPlayback = !virtualWriteCursorLoopFlagPlayback;
}





framesWrittenToPlaybackDevice += framesWrittenThisIteration;
if (!isPlaybackDeviceStarted && framesWrittenToPlaybackDevice >= (pDevice->playback.internalPeriodSizeInFrames*2)) {
if (FAILED(ma_IDirectSoundBuffer_Play((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MA_DSBPLAY_LOOPING))) {
ma_IDirectSoundCaptureBuffer_Stop((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
isPlaybackDeviceStarted = MA_TRUE;
}

if (framesWrittenThisIteration < mappedSizeInBytesPlayback/bpfDevicePlayback) {
break; 
}
}

if (clientCapturedFramesToProcess == 0) {
break; 
}
}



hr = ma_IDirectSoundCaptureBuffer_Unlock((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, pMappedDeviceBufferCapture, mappedSizeInBytesCapture, NULL, 0);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from capture device after reading from the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
}
prevReadCursorInBytesCapture = (lockOffsetInBytesCapture + mappedSizeInBytesCapture);
} break;



case ma_device_type_capture:
{
DWORD physicalCaptureCursorInBytes;
DWORD physicalReadCursorInBytes;
if (FAILED(ma_IDirectSoundCaptureBuffer_GetCurrentPosition((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, &physicalCaptureCursorInBytes, &physicalReadCursorInBytes))) {
return MA_ERROR;
}


if (prevReadCursorInBytesCapture == physicalReadCursorInBytes) {
ma_sleep(waitTimeInMilliseconds);
continue;
}


if (prevReadCursorInBytesCapture < physicalReadCursorInBytes) {

lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
lockSizeInBytesCapture = (physicalReadCursorInBytes - prevReadCursorInBytesCapture);
} else {




if (prevReadCursorInBytesCapture < pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*bpfDeviceCapture) {

lockOffsetInBytesCapture = prevReadCursorInBytesCapture;
lockSizeInBytesCapture = (pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*bpfDeviceCapture) - prevReadCursorInBytesCapture;
} else {

lockOffsetInBytesCapture = 0;
lockSizeInBytesCapture = physicalReadCursorInBytes;
}
}

#if defined(MA_DEBUG_OUTPUT)


#endif

if (lockSizeInBytesCapture < pDevice->capture.internalPeriodSizeInFrames) {
ma_sleep(waitTimeInMilliseconds);
continue; 
}

hr = ma_IDirectSoundCaptureBuffer_Lock((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, lockOffsetInBytesCapture, lockSizeInBytesCapture, &pMappedDeviceBufferCapture, &mappedSizeInBytesCapture, NULL, NULL, 0);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from capture device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
}

#if defined(MA_DEBUG_OUTPUT)
if (lockSizeInBytesCapture != mappedSizeInBytesCapture) {
printf("[DirectSound] (Capture) lockSizeInBytesCapture=%d != mappedSizeInBytesCapture=%d\n", lockSizeInBytesCapture, mappedSizeInBytesCapture);
}
#endif

ma_device__send_frames_to_client(pDevice, mappedSizeInBytesCapture/bpfDeviceCapture, pMappedDeviceBufferCapture);

hr = ma_IDirectSoundCaptureBuffer_Unlock((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer, pMappedDeviceBufferCapture, mappedSizeInBytesCapture, NULL, 0);
if (FAILED(hr)) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from capture device after reading from the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
}
prevReadCursorInBytesCapture = lockOffsetInBytesCapture + mappedSizeInBytesCapture;

if (prevReadCursorInBytesCapture == (pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*bpfDeviceCapture)) {
prevReadCursorInBytesCapture = 0;
}
} break;



case ma_device_type_playback:
{
DWORD availableBytesPlayback;
DWORD physicalPlayCursorInBytes;
DWORD physicalWriteCursorInBytes;
if (FAILED(ma_IDirectSoundBuffer_GetCurrentPosition((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, &physicalPlayCursorInBytes, &physicalWriteCursorInBytes))) {
break;
}

if (physicalPlayCursorInBytes < prevPlayCursorInBytesPlayback) {
physicalPlayCursorLoopFlagPlayback = !physicalPlayCursorLoopFlagPlayback;
}
prevPlayCursorInBytesPlayback = physicalPlayCursorInBytes;


if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {

if (physicalPlayCursorInBytes <= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - virtualWriteCursorInBytesPlayback;
availableBytesPlayback += physicalPlayCursorInBytes; 
} else {

#if defined(MA_DEBUG_OUTPUT)
printf("[DirectSound] (Playback) WARNING: Play cursor has moved in front of the write cursor (same loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
#endif
availableBytesPlayback = 0;
}
} else {

if (physicalPlayCursorInBytes >= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
} else {

#if defined(MA_DEBUG_OUTPUT)
printf("[DirectSound] (Playback) WARNING: Write cursor has moved behind the play cursor (different loop iterations). physicalPlayCursorInBytes=%d, virtualWriteCursorInBytes=%d.\n", physicalPlayCursorInBytes, virtualWriteCursorInBytesPlayback);
#endif
availableBytesPlayback = 0;
}
}

#if defined(MA_DEBUG_OUTPUT)

#endif


if (availableBytesPlayback < pDevice->playback.internalPeriodSizeInFrames) {

if (availableBytesPlayback == 0 && !isPlaybackDeviceStarted) {
if (FAILED(ma_IDirectSoundBuffer_Play((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MA_DSBPLAY_LOOPING))) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
isPlaybackDeviceStarted = MA_TRUE;
} else {
ma_sleep(waitTimeInMilliseconds);
continue;
}
}


lockOffsetInBytesPlayback = virtualWriteCursorInBytesPlayback;
if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {

lockSizeInBytesPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - virtualWriteCursorInBytesPlayback;
} else {

lockSizeInBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
}

hr = ma_IDirectSoundBuffer_Lock((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, lockOffsetInBytesPlayback, lockSizeInBytesPlayback, &pMappedDeviceBufferPlayback, &mappedSizeInBytesPlayback, NULL, NULL, 0);
if (FAILED(hr)) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to map buffer from playback device in preparation for writing to the device.", MA_FAILED_TO_MAP_DEVICE_BUFFER);
break;
}


ma_device__read_frames_from_client(pDevice, (mappedSizeInBytesPlayback/bpfDevicePlayback), pMappedDeviceBufferPlayback);

hr = ma_IDirectSoundBuffer_Unlock((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, pMappedDeviceBufferPlayback, mappedSizeInBytesPlayback, NULL, 0);
if (FAILED(hr)) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] Failed to unlock internal buffer from playback device after writing to the device.", MA_FAILED_TO_UNMAP_DEVICE_BUFFER);
break;
}

virtualWriteCursorInBytesPlayback += mappedSizeInBytesPlayback;
if (virtualWriteCursorInBytesPlayback == pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) {
virtualWriteCursorInBytesPlayback = 0;
virtualWriteCursorLoopFlagPlayback = !virtualWriteCursorLoopFlagPlayback;
}





framesWrittenToPlaybackDevice += mappedSizeInBytesPlayback/bpfDevicePlayback;
if (!isPlaybackDeviceStarted && framesWrittenToPlaybackDevice >= pDevice->playback.internalPeriodSizeInFrames) {
if (FAILED(ma_IDirectSoundBuffer_Play((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0, 0, MA_DSBPLAY_LOOPING))) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Play() failed.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
isPlaybackDeviceStarted = MA_TRUE;
}
} break;


default: return MA_INVALID_ARGS; 
}

if (result != MA_SUCCESS) {
return result;
}
}


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (FAILED(ma_IDirectSoundCaptureBuffer_Stop((ma_IDirectSoundCaptureBuffer*)pDevice->dsound.pCaptureBuffer))) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundCaptureBuffer_Stop() failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {

if (isPlaybackDeviceStarted) {
for (;;) {
DWORD availableBytesPlayback = 0;
DWORD physicalPlayCursorInBytes;
DWORD physicalWriteCursorInBytes;
if (FAILED(ma_IDirectSoundBuffer_GetCurrentPosition((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, &physicalPlayCursorInBytes, &physicalWriteCursorInBytes))) {
break;
}

if (physicalPlayCursorInBytes < prevPlayCursorInBytesPlayback) {
physicalPlayCursorLoopFlagPlayback = !physicalPlayCursorLoopFlagPlayback;
}
prevPlayCursorInBytesPlayback = physicalPlayCursorInBytes;

if (physicalPlayCursorLoopFlagPlayback == virtualWriteCursorLoopFlagPlayback) {

if (physicalPlayCursorInBytes <= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback) - virtualWriteCursorInBytesPlayback;
availableBytesPlayback += physicalPlayCursorInBytes; 
} else {
break;
}
} else {

if (physicalPlayCursorInBytes >= virtualWriteCursorInBytesPlayback) {
availableBytesPlayback = physicalPlayCursorInBytes - virtualWriteCursorInBytesPlayback;
} else {
break;
}
}

if (availableBytesPlayback >= (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*bpfDevicePlayback)) {
break;
}

ma_sleep(waitTimeInMilliseconds);
}
}

if (FAILED(ma_IDirectSoundBuffer_Stop((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer))) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[DirectSound] IDirectSoundBuffer_Stop() failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

ma_IDirectSoundBuffer_SetCurrentPosition((ma_IDirectSoundBuffer*)pDevice->dsound.pPlaybackBuffer, 0);
}

return MA_SUCCESS;
}

static ma_result ma_context_uninit__dsound(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_dsound);

ma_dlclose(pContext, pContext->dsound.hDSoundDLL);

return MA_SUCCESS;
}

static ma_result ma_context_init__dsound(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

(void)pConfig;

pContext->dsound.hDSoundDLL = ma_dlopen(pContext, "dsound.dll");
if (pContext->dsound.hDSoundDLL == NULL) {
return MA_API_NOT_FOUND;
}

pContext->dsound.DirectSoundCreate = ma_dlsym(pContext, pContext->dsound.hDSoundDLL, "DirectSoundCreate");
pContext->dsound.DirectSoundEnumerateA = ma_dlsym(pContext, pContext->dsound.hDSoundDLL, "DirectSoundEnumerateA");
pContext->dsound.DirectSoundCaptureCreate = ma_dlsym(pContext, pContext->dsound.hDSoundDLL, "DirectSoundCaptureCreate");
pContext->dsound.DirectSoundCaptureEnumerateA = ma_dlsym(pContext, pContext->dsound.hDSoundDLL, "DirectSoundCaptureEnumerateA");

pContext->onUninit = ma_context_uninit__dsound;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__dsound;
pContext->onEnumDevices = ma_context_enumerate_devices__dsound;
pContext->onGetDeviceInfo = ma_context_get_device_info__dsound;
pContext->onDeviceInit = ma_device_init__dsound;
pContext->onDeviceUninit = ma_device_uninit__dsound;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__dsound;

return MA_SUCCESS;
}
#endif








#if defined(MA_HAS_WINMM)






typedef struct
{
WORD wMid;
WORD wPid;
MMVERSION vDriverVersion;
CHAR szPname[MAXPNAMELEN];
DWORD dwFormats;
WORD wChannels;
WORD wReserved1;
DWORD dwSupport;
GUID ManufacturerGuid;
GUID ProductGuid;
GUID NameGuid;
} MA_WAVEOUTCAPS2A;
typedef struct
{
WORD wMid;
WORD wPid;
MMVERSION vDriverVersion;
CHAR szPname[MAXPNAMELEN];
DWORD dwFormats;
WORD wChannels;
WORD wReserved1;
GUID ManufacturerGuid;
GUID ProductGuid;
GUID NameGuid;
} MA_WAVEINCAPS2A;

typedef UINT (WINAPI * MA_PFN_waveOutGetNumDevs)(void);
typedef MMRESULT (WINAPI * MA_PFN_waveOutGetDevCapsA)(ma_uintptr uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
typedef MMRESULT (WINAPI * MA_PFN_waveOutOpen)(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
typedef MMRESULT (WINAPI * MA_PFN_waveOutClose)(HWAVEOUT hwo);
typedef MMRESULT (WINAPI * MA_PFN_waveOutPrepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveOutUnprepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveOutWrite)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveOutReset)(HWAVEOUT hwo);
typedef UINT (WINAPI * MA_PFN_waveInGetNumDevs)(void);
typedef MMRESULT (WINAPI * MA_PFN_waveInGetDevCapsA)(ma_uintptr uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
typedef MMRESULT (WINAPI * MA_PFN_waveInOpen)(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
typedef MMRESULT (WINAPI * MA_PFN_waveInClose)(HWAVEIN hwi);
typedef MMRESULT (WINAPI * MA_PFN_waveInPrepareHeader)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveInUnprepareHeader)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveInAddBuffer)(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
typedef MMRESULT (WINAPI * MA_PFN_waveInStart)(HWAVEIN hwi);
typedef MMRESULT (WINAPI * MA_PFN_waveInReset)(HWAVEIN hwi);

static ma_result ma_result_from_MMRESULT(MMRESULT resultMM)
{
switch (resultMM) {
case MMSYSERR_NOERROR: return MA_SUCCESS;
case MMSYSERR_BADDEVICEID: return MA_INVALID_ARGS;
case MMSYSERR_INVALHANDLE: return MA_INVALID_ARGS;
case MMSYSERR_NOMEM: return MA_OUT_OF_MEMORY;
case MMSYSERR_INVALFLAG: return MA_INVALID_ARGS;
case MMSYSERR_INVALPARAM: return MA_INVALID_ARGS;
case MMSYSERR_HANDLEBUSY: return MA_DEVICE_BUSY;
case MMSYSERR_ERROR: return MA_ERROR;
default: return MA_ERROR;
}
}

static char* ma_find_last_character(char* str, char ch)
{
char* last;

if (str == NULL) {
return NULL;
}

last = NULL;
while (*str != '\0') {
if (*str == ch) {
last = str;
}

str += 1;
}

return last;
}

static ma_uint32 ma_get_period_size_in_bytes(ma_uint32 periodSizeInFrames, ma_format format, ma_uint32 channels)
{
return periodSizeInFrames * ma_get_bytes_per_frame(format, channels);
}






typedef struct
{
CHAR szPname[MAXPNAMELEN];
DWORD dwFormats;
WORD wChannels;
GUID NameGuid;
} MA_WAVECAPSA;

static ma_result ma_get_best_info_from_formats_flags__winmm(DWORD dwFormats, WORD channels, WORD* pBitsPerSample, DWORD* pSampleRate)
{
WORD bitsPerSample = 0;
DWORD sampleRate = 0;

if (pBitsPerSample) {
*pBitsPerSample = 0;
}
if (pSampleRate) {
*pSampleRate = 0;
}

if (channels == 1) {
bitsPerSample = 16;
if ((dwFormats & WAVE_FORMAT_48M16) != 0) {
sampleRate = 48000;
} else if ((dwFormats & WAVE_FORMAT_44M16) != 0) {
sampleRate = 44100;
} else if ((dwFormats & WAVE_FORMAT_2M16) != 0) {
sampleRate = 22050;
} else if ((dwFormats & WAVE_FORMAT_1M16) != 0) {
sampleRate = 11025;
} else if ((dwFormats & WAVE_FORMAT_96M16) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 8;
if ((dwFormats & WAVE_FORMAT_48M08) != 0) {
sampleRate = 48000;
} else if ((dwFormats & WAVE_FORMAT_44M08) != 0) {
sampleRate = 44100;
} else if ((dwFormats & WAVE_FORMAT_2M08) != 0) {
sampleRate = 22050;
} else if ((dwFormats & WAVE_FORMAT_1M08) != 0) {
sampleRate = 11025;
} else if ((dwFormats & WAVE_FORMAT_96M08) != 0) {
sampleRate = 96000;
} else {
return MA_FORMAT_NOT_SUPPORTED;
}
}
} else {
bitsPerSample = 16;
if ((dwFormats & WAVE_FORMAT_48S16) != 0) {
sampleRate = 48000;
} else if ((dwFormats & WAVE_FORMAT_44S16) != 0) {
sampleRate = 44100;
} else if ((dwFormats & WAVE_FORMAT_2S16) != 0) {
sampleRate = 22050;
} else if ((dwFormats & WAVE_FORMAT_1S16) != 0) {
sampleRate = 11025;
} else if ((dwFormats & WAVE_FORMAT_96S16) != 0) {
sampleRate = 96000;
} else {
bitsPerSample = 8;
if ((dwFormats & WAVE_FORMAT_48S08) != 0) {
sampleRate = 48000;
} else if ((dwFormats & WAVE_FORMAT_44S08) != 0) {
sampleRate = 44100;
} else if ((dwFormats & WAVE_FORMAT_2S08) != 0) {
sampleRate = 22050;
} else if ((dwFormats & WAVE_FORMAT_1S08) != 0) {
sampleRate = 11025;
} else if ((dwFormats & WAVE_FORMAT_96S08) != 0) {
sampleRate = 96000;
} else {
return MA_FORMAT_NOT_SUPPORTED;
}
}
}

if (pBitsPerSample) {
*pBitsPerSample = bitsPerSample;
}
if (pSampleRate) {
*pSampleRate = sampleRate;
}

return MA_SUCCESS;
}

static ma_result ma_formats_flags_to_WAVEFORMATEX__winmm(DWORD dwFormats, WORD channels, WAVEFORMATEX* pWF)
{
MA_ASSERT(pWF != NULL);

MA_ZERO_OBJECT(pWF);
pWF->cbSize = sizeof(*pWF);
pWF->wFormatTag = WAVE_FORMAT_PCM;
pWF->nChannels = (WORD)channels;
if (pWF->nChannels > 2) {
pWF->nChannels = 2;
}

if (channels == 1) {
pWF->wBitsPerSample = 16;
if ((dwFormats & WAVE_FORMAT_48M16) != 0) {
pWF->nSamplesPerSec = 48000;
} else if ((dwFormats & WAVE_FORMAT_44M16) != 0) {
pWF->nSamplesPerSec = 44100;
} else if ((dwFormats & WAVE_FORMAT_2M16) != 0) {
pWF->nSamplesPerSec = 22050;
} else if ((dwFormats & WAVE_FORMAT_1M16) != 0) {
pWF->nSamplesPerSec = 11025;
} else if ((dwFormats & WAVE_FORMAT_96M16) != 0) {
pWF->nSamplesPerSec = 96000;
} else {
pWF->wBitsPerSample = 8;
if ((dwFormats & WAVE_FORMAT_48M08) != 0) {
pWF->nSamplesPerSec = 48000;
} else if ((dwFormats & WAVE_FORMAT_44M08) != 0) {
pWF->nSamplesPerSec = 44100;
} else if ((dwFormats & WAVE_FORMAT_2M08) != 0) {
pWF->nSamplesPerSec = 22050;
} else if ((dwFormats & WAVE_FORMAT_1M08) != 0) {
pWF->nSamplesPerSec = 11025;
} else if ((dwFormats & WAVE_FORMAT_96M08) != 0) {
pWF->nSamplesPerSec = 96000;
} else {
return MA_FORMAT_NOT_SUPPORTED;
}
}
} else {
pWF->wBitsPerSample = 16;
if ((dwFormats & WAVE_FORMAT_48S16) != 0) {
pWF->nSamplesPerSec = 48000;
} else if ((dwFormats & WAVE_FORMAT_44S16) != 0) {
pWF->nSamplesPerSec = 44100;
} else if ((dwFormats & WAVE_FORMAT_2S16) != 0) {
pWF->nSamplesPerSec = 22050;
} else if ((dwFormats & WAVE_FORMAT_1S16) != 0) {
pWF->nSamplesPerSec = 11025;
} else if ((dwFormats & WAVE_FORMAT_96S16) != 0) {
pWF->nSamplesPerSec = 96000;
} else {
pWF->wBitsPerSample = 8;
if ((dwFormats & WAVE_FORMAT_48S08) != 0) {
pWF->nSamplesPerSec = 48000;
} else if ((dwFormats & WAVE_FORMAT_44S08) != 0) {
pWF->nSamplesPerSec = 44100;
} else if ((dwFormats & WAVE_FORMAT_2S08) != 0) {
pWF->nSamplesPerSec = 22050;
} else if ((dwFormats & WAVE_FORMAT_1S08) != 0) {
pWF->nSamplesPerSec = 11025;
} else if ((dwFormats & WAVE_FORMAT_96S08) != 0) {
pWF->nSamplesPerSec = 96000;
} else {
return MA_FORMAT_NOT_SUPPORTED;
}
}
}

pWF->nBlockAlign = (pWF->nChannels * pWF->wBitsPerSample) / 8;
pWF->nAvgBytesPerSec = pWF->nBlockAlign * pWF->nSamplesPerSec;

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info_from_WAVECAPS(ma_context* pContext, MA_WAVECAPSA* pCaps, ma_device_info* pDeviceInfo)
{
WORD bitsPerSample;
DWORD sampleRate;
ma_result result;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pCaps != NULL);
MA_ASSERT(pDeviceInfo != NULL);










ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), pCaps->szPname, (size_t)-1);











if (!ma_is_guid_equal(&pCaps->NameGuid, &MA_GUID_NULL)) {
wchar_t guidStrW[256];
if (((MA_PFN_StringFromGUID2)pContext->win32.StringFromGUID2)(&pCaps->NameGuid, guidStrW, ma_countof(guidStrW)) > 0) {
char guidStr[256];
char keyStr[1024];
HKEY hKey;

WideCharToMultiByte(CP_UTF8, 0, guidStrW, -1, guidStr, sizeof(guidStr), 0, FALSE);

ma_strcpy_s(keyStr, sizeof(keyStr), "SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\");
ma_strcat_s(keyStr, sizeof(keyStr), guidStr);

if (((MA_PFN_RegOpenKeyExA)pContext->win32.RegOpenKeyExA)(HKEY_LOCAL_MACHINE, keyStr, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
BYTE nameFromReg[512];
DWORD nameFromRegSize = sizeof(nameFromReg);
result = ((MA_PFN_RegQueryValueExA)pContext->win32.RegQueryValueExA)(hKey, "Name", 0, NULL, (LPBYTE)nameFromReg, (LPDWORD)&nameFromRegSize);
((MA_PFN_RegCloseKey)pContext->win32.RegCloseKey)(hKey);

if (result == ERROR_SUCCESS) {

char name[1024];
if (ma_strcpy_s(name, sizeof(name), pDeviceInfo->name) == 0) {
char* nameBeg = ma_find_last_character(name, '(');
if (nameBeg != NULL) {
size_t leadingLen = (nameBeg - name);
ma_strncpy_s(nameBeg + 1, sizeof(name) - leadingLen, (const char*)nameFromReg, (size_t)-1);


if (leadingLen + nameFromRegSize < sizeof(name)-1) {
ma_strcat_s(name, sizeof(name), ")");
}

ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), name, (size_t)-1);
}
}
}
}
}
}


result = ma_get_best_info_from_formats_flags__winmm(pCaps->dwFormats, pCaps->wChannels, &bitsPerSample, &sampleRate);
if (result != MA_SUCCESS) {
return result;
}

pDeviceInfo->minChannels = pCaps->wChannels;
pDeviceInfo->maxChannels = pCaps->wChannels;
pDeviceInfo->minSampleRate = sampleRate;
pDeviceInfo->maxSampleRate = sampleRate;
pDeviceInfo->formatCount = 1;
if (bitsPerSample == 8) {
pDeviceInfo->formats[0] = ma_format_u8;
} else if (bitsPerSample == 16) {
pDeviceInfo->formats[0] = ma_format_s16;
} else if (bitsPerSample == 24) {
pDeviceInfo->formats[0] = ma_format_s24;
} else if (bitsPerSample == 32) {
pDeviceInfo->formats[0] = ma_format_s32;
} else {
return MA_FORMAT_NOT_SUPPORTED;
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info_from_WAVEOUTCAPS2(ma_context* pContext, MA_WAVEOUTCAPS2A* pCaps, ma_device_info* pDeviceInfo)
{
MA_WAVECAPSA caps;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pCaps != NULL);
MA_ASSERT(pDeviceInfo != NULL);

MA_COPY_MEMORY(caps.szPname, pCaps->szPname, sizeof(caps.szPname));
caps.dwFormats = pCaps->dwFormats;
caps.wChannels = pCaps->wChannels;
caps.NameGuid = pCaps->NameGuid;
return ma_context_get_device_info_from_WAVECAPS(pContext, &caps, pDeviceInfo);
}

static ma_result ma_context_get_device_info_from_WAVEINCAPS2(ma_context* pContext, MA_WAVEINCAPS2A* pCaps, ma_device_info* pDeviceInfo)
{
MA_WAVECAPSA caps;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pCaps != NULL);
MA_ASSERT(pDeviceInfo != NULL);

MA_COPY_MEMORY(caps.szPname, pCaps->szPname, sizeof(caps.szPname));
caps.dwFormats = pCaps->dwFormats;
caps.wChannels = pCaps->wChannels;
caps.NameGuid = pCaps->NameGuid;
return ma_context_get_device_info_from_WAVECAPS(pContext, &caps, pDeviceInfo);
}


static ma_bool32 ma_context_is_device_id_equal__winmm(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return pID0->winmm == pID1->winmm;
}

static ma_result ma_context_enumerate_devices__winmm(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
UINT playbackDeviceCount;
UINT captureDeviceCount;
UINT iPlaybackDevice;
UINT iCaptureDevice;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);


playbackDeviceCount = ((MA_PFN_waveOutGetNumDevs)pContext->winmm.waveOutGetNumDevs)();
for (iPlaybackDevice = 0; iPlaybackDevice < playbackDeviceCount; ++iPlaybackDevice) {
MMRESULT result;
MA_WAVEOUTCAPS2A caps;

MA_ZERO_OBJECT(&caps);

result = ((MA_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(iPlaybackDevice, (WAVEOUTCAPSA*)&caps, sizeof(caps));
if (result == MMSYSERR_NOERROR) {
ma_device_info deviceInfo;

MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.winmm = iPlaybackDevice;

if (ma_context_get_device_info_from_WAVEOUTCAPS2(pContext, &caps, &deviceInfo) == MA_SUCCESS) {
ma_bool32 cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
if (cbResult == MA_FALSE) {
return MA_SUCCESS; 
}
}
}
}


captureDeviceCount = ((MA_PFN_waveInGetNumDevs)pContext->winmm.waveInGetNumDevs)();
for (iCaptureDevice = 0; iCaptureDevice < captureDeviceCount; ++iCaptureDevice) {
MMRESULT result;
MA_WAVEINCAPS2A caps;

MA_ZERO_OBJECT(&caps);

result = ((MA_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(iCaptureDevice, (WAVEINCAPSA*)&caps, sizeof(caps));
if (result == MMSYSERR_NOERROR) {
ma_device_info deviceInfo;

MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.winmm = iCaptureDevice;

if (ma_context_get_device_info_from_WAVEINCAPS2(pContext, &caps, &deviceInfo) == MA_SUCCESS) {
ma_bool32 cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
if (cbResult == MA_FALSE) {
return MA_SUCCESS; 
}
}
}
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__winmm(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
UINT winMMDeviceID;

MA_ASSERT(pContext != NULL);

if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

winMMDeviceID = 0;
if (pDeviceID != NULL) {
winMMDeviceID = (UINT)pDeviceID->winmm;
}

pDeviceInfo->id.winmm = winMMDeviceID;

if (deviceType == ma_device_type_playback) {
MMRESULT result;
MA_WAVEOUTCAPS2A caps;

MA_ZERO_OBJECT(&caps);

result = ((MA_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(winMMDeviceID, (WAVEOUTCAPSA*)&caps, sizeof(caps));
if (result == MMSYSERR_NOERROR) {
return ma_context_get_device_info_from_WAVEOUTCAPS2(pContext, &caps, pDeviceInfo);
}
} else {
MMRESULT result;
MA_WAVEINCAPS2A caps;

MA_ZERO_OBJECT(&caps);

result = ((MA_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(winMMDeviceID, (WAVEINCAPSA*)&caps, sizeof(caps));
if (result == MMSYSERR_NOERROR) {
return ma_context_get_device_info_from_WAVEINCAPS2(pContext, &caps, pDeviceInfo);
}
}

return MA_NO_DEVICE;
}


static void ma_device_uninit__winmm(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((MA_PFN_waveInClose)pDevice->pContext->winmm.waveInClose)((HWAVEIN)pDevice->winmm.hDeviceCapture);
CloseHandle((HANDLE)pDevice->winmm.hEventCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
((MA_PFN_waveOutReset)pDevice->pContext->winmm.waveOutReset)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
((MA_PFN_waveOutClose)pDevice->pContext->winmm.waveOutClose)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
CloseHandle((HANDLE)pDevice->winmm.hEventPlayback);
}

ma__free_from_callbacks(pDevice->winmm._pHeapData, &pDevice->pContext->allocationCallbacks);

MA_ZERO_OBJECT(&pDevice->winmm); 
}

static ma_result ma_device_init__winmm(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
const char* errorMsg = "";
ma_result errorCode = MA_ERROR;
ma_result result = MA_SUCCESS;
ma_uint32 heapSize;
UINT winMMDeviceIDPlayback = 0;
UINT winMMDeviceIDCapture = 0;
ma_uint32 periodSizeInMilliseconds;

MA_ASSERT(pDevice != NULL);
MA_ZERO_OBJECT(&pDevice->winmm);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

periodSizeInMilliseconds = pConfig->periodSizeInMilliseconds;
if (periodSizeInMilliseconds == 0) {
periodSizeInMilliseconds = ma_calculate_buffer_size_in_milliseconds_from_frames(pConfig->periodSizeInFrames, pConfig->sampleRate);
}


if (pDevice->usingDefaultBufferSize) {
if (pConfig->performanceProfile == ma_performance_profile_low_latency) {
periodSizeInMilliseconds = 40;
} else {
periodSizeInMilliseconds = 400;
}
}


if (pConfig->playback.pDeviceID != NULL) {
winMMDeviceIDPlayback = (UINT)pConfig->playback.pDeviceID->winmm;
}
if (pConfig->capture.pDeviceID != NULL) {
winMMDeviceIDCapture = (UINT)pConfig->capture.pDeviceID->winmm;
}


if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
WAVEINCAPSA caps;
WAVEFORMATEX wf;
MMRESULT resultMM;


pDevice->winmm.hEventCapture = (ma_handle)CreateEvent(NULL, TRUE, TRUE, NULL);
if (pDevice->winmm.hEventCapture == NULL) {
errorMsg = "[WinMM] Failed to create event for fragment enqueing for the capture device.", errorCode = MA_FAILED_TO_CREATE_EVENT;
goto on_error;
}


if (((MA_PFN_waveInGetDevCapsA)pContext->winmm.waveInGetDevCapsA)(winMMDeviceIDCapture, &caps, sizeof(caps)) != MMSYSERR_NOERROR) {
errorMsg = "[WinMM] Failed to retrieve internal device caps.", errorCode = MA_FORMAT_NOT_SUPPORTED;
goto on_error;
}

result = ma_formats_flags_to_WAVEFORMATEX__winmm(caps.dwFormats, caps.wChannels, &wf);
if (result != MA_SUCCESS) {
errorMsg = "[WinMM] Could not find appropriate format for internal device.", errorCode = result;
goto on_error;
}

resultMM = ((MA_PFN_waveInOpen)pDevice->pContext->winmm.waveInOpen)((LPHWAVEIN)&pDevice->winmm.hDeviceCapture, winMMDeviceIDCapture, &wf, (DWORD_PTR)pDevice->winmm.hEventCapture, (DWORD_PTR)pDevice, CALLBACK_EVENT | WAVE_ALLOWSYNC);
if (resultMM != MMSYSERR_NOERROR) {
errorMsg = "[WinMM] Failed to open capture device.", errorCode = MA_FAILED_TO_OPEN_BACKEND_DEVICE;
goto on_error;
}

pDevice->capture.internalFormat = ma_format_from_WAVEFORMATEX(&wf);
pDevice->capture.internalChannels = wf.nChannels;
pDevice->capture.internalSampleRate = wf.nSamplesPerSec;
ma_get_standard_channel_map(ma_standard_channel_map_microsoft, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
pDevice->capture.internalPeriods = pConfig->periods;
pDevice->capture.internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, pDevice->capture.internalSampleRate);
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
WAVEOUTCAPSA caps;
WAVEFORMATEX wf;
MMRESULT resultMM;


pDevice->winmm.hEventPlayback = (ma_handle)CreateEvent(NULL, TRUE, TRUE, NULL);
if (pDevice->winmm.hEventPlayback == NULL) {
errorMsg = "[WinMM] Failed to create event for fragment enqueing for the playback device.", errorCode = MA_FAILED_TO_CREATE_EVENT;
goto on_error;
}


if (((MA_PFN_waveOutGetDevCapsA)pContext->winmm.waveOutGetDevCapsA)(winMMDeviceIDPlayback, &caps, sizeof(caps)) != MMSYSERR_NOERROR) {
errorMsg = "[WinMM] Failed to retrieve internal device caps.", errorCode = MA_FORMAT_NOT_SUPPORTED;
goto on_error;
}

result = ma_formats_flags_to_WAVEFORMATEX__winmm(caps.dwFormats, caps.wChannels, &wf);
if (result != MA_SUCCESS) {
errorMsg = "[WinMM] Could not find appropriate format for internal device.", errorCode = result;
goto on_error;
}

resultMM = ((MA_PFN_waveOutOpen)pContext->winmm.waveOutOpen)((LPHWAVEOUT)&pDevice->winmm.hDevicePlayback, winMMDeviceIDPlayback, &wf, (DWORD_PTR)pDevice->winmm.hEventPlayback, (DWORD_PTR)pDevice, CALLBACK_EVENT | WAVE_ALLOWSYNC);
if (resultMM != MMSYSERR_NOERROR) {
errorMsg = "[WinMM] Failed to open playback device.", errorCode = MA_FAILED_TO_OPEN_BACKEND_DEVICE;
goto on_error;
}

pDevice->playback.internalFormat = ma_format_from_WAVEFORMATEX(&wf);
pDevice->playback.internalChannels = wf.nChannels;
pDevice->playback.internalSampleRate = wf.nSamplesPerSec;
ma_get_standard_channel_map(ma_standard_channel_map_microsoft, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
pDevice->playback.internalPeriods = pConfig->periods;
pDevice->playback.internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, pDevice->playback.internalSampleRate);
}






heapSize = 0;
if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
heapSize += sizeof(WAVEHDR)*pDevice->capture.internalPeriods + (pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
}
if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
heapSize += sizeof(WAVEHDR)*pDevice->playback.internalPeriods + (pDevice->playback.internalPeriodSizeInFrames*pDevice->playback.internalPeriods*ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
}

pDevice->winmm._pHeapData = (ma_uint8*)ma__calloc_from_callbacks(heapSize, &pContext->allocationCallbacks);
if (pDevice->winmm._pHeapData == NULL) {
errorMsg = "[WinMM] Failed to allocate memory for the intermediary buffer.", errorCode = MA_OUT_OF_MEMORY;
goto on_error;
}

MA_ZERO_MEMORY(pDevice->winmm._pHeapData, heapSize);

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 iPeriod;

if (pConfig->deviceType == ma_device_type_capture) {
pDevice->winmm.pWAVEHDRCapture = pDevice->winmm._pHeapData;
pDevice->winmm.pIntermediaryBufferCapture = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods));
} else {
pDevice->winmm.pWAVEHDRCapture = pDevice->winmm._pHeapData;
pDevice->winmm.pIntermediaryBufferCapture = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods + pDevice->playback.internalPeriods));
}


for (iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
ma_uint32 periodSizeInBytes = ma_get_period_size_in_bytes(pDevice->capture.internalPeriodSizeInFrames, pDevice->capture.internalFormat, pDevice->capture.internalChannels);

((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].lpData = (LPSTR)(pDevice->winmm.pIntermediaryBufferCapture + (periodSizeInBytes*iPeriod));
((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwBufferLength = periodSizeInBytes;
((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwFlags = 0L;
((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwLoops = 0L;
((MA_PFN_waveInPrepareHeader)pContext->winmm.waveInPrepareHeader)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));





((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod].dwUser = 0;
}
}
if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 iPeriod;

if (pConfig->deviceType == ma_device_type_playback) {
pDevice->winmm.pWAVEHDRPlayback = pDevice->winmm._pHeapData;
pDevice->winmm.pIntermediaryBufferPlayback = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*pDevice->playback.internalPeriods);
} else {
pDevice->winmm.pWAVEHDRPlayback = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods));
pDevice->winmm.pIntermediaryBufferPlayback = pDevice->winmm._pHeapData + (sizeof(WAVEHDR)*(pDevice->capture.internalPeriods + pDevice->playback.internalPeriods)) + (pDevice->capture.internalPeriodSizeInFrames*pDevice->capture.internalPeriods*ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
}


for (iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
ma_uint32 periodSizeInBytes = ma_get_period_size_in_bytes(pDevice->playback.internalPeriodSizeInFrames, pDevice->playback.internalFormat, pDevice->playback.internalChannels);

((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].lpData = (LPSTR)(pDevice->winmm.pIntermediaryBufferPlayback + (periodSizeInBytes*iPeriod));
((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwBufferLength = periodSizeInBytes;
((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwFlags = 0L;
((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwLoops = 0L;
((MA_PFN_waveOutPrepareHeader)pContext->winmm.waveOutPrepareHeader)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod], sizeof(WAVEHDR));





((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod].dwUser = 0;
}
}

return MA_SUCCESS;

on_error:
if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (pDevice->winmm.pWAVEHDRCapture != NULL) {
ma_uint32 iPeriod;
for (iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
((MA_PFN_waveInUnprepareHeader)pContext->winmm.waveInUnprepareHeader)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((WAVEHDR*)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));
}
}

((MA_PFN_waveInClose)pContext->winmm.waveInClose)((HWAVEIN)pDevice->winmm.hDeviceCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
if (pDevice->winmm.pWAVEHDRCapture != NULL) {
ma_uint32 iPeriod;
for (iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
((MA_PFN_waveOutUnprepareHeader)pContext->winmm.waveOutUnprepareHeader)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &((WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback)[iPeriod], sizeof(WAVEHDR));
}
}

((MA_PFN_waveOutClose)pContext->winmm.waveOutClose)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
}

ma__free_from_callbacks(pDevice->winmm._pHeapData, &pContext->allocationCallbacks);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, errorMsg, errorCode);
}

static ma_result ma_device_stop__winmm(ma_device* pDevice)
{
MMRESULT resultMM;

MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (pDevice->winmm.hDeviceCapture == NULL) {
return MA_INVALID_ARGS;
}

resultMM = ((MA_PFN_waveInReset)pDevice->pContext->winmm.waveInReset)((HWAVEIN)pDevice->winmm.hDeviceCapture);
if (resultMM != MMSYSERR_NOERROR) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] WARNING: Failed to reset capture device.", ma_result_from_MMRESULT(resultMM));
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_uint32 iPeriod;
WAVEHDR* pWAVEHDR;

if (pDevice->winmm.hDevicePlayback == NULL) {
return MA_INVALID_ARGS;
}


pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback;
for (iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; iPeriod += 1) {
if (pWAVEHDR[iPeriod].dwUser == 1) { 
if (WaitForSingleObject((HANDLE)pDevice->winmm.hEventPlayback, INFINITE) != WAIT_OBJECT_0) {
break; 
}

pWAVEHDR[iPeriod].dwUser = 0;
}
}

resultMM = ((MA_PFN_waveOutReset)pDevice->pContext->winmm.waveOutReset)((HWAVEOUT)pDevice->winmm.hDevicePlayback);
if (resultMM != MMSYSERR_NOERROR) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] WARNING: Failed to reset playback device.", ma_result_from_MMRESULT(resultMM));
}
}

return MA_SUCCESS;
}

static ma_result ma_device_write__winmm(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
ma_result result = MA_SUCCESS;
MMRESULT resultMM;
ma_uint32 totalFramesWritten;
WAVEHDR* pWAVEHDR;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pPCMFrames != NULL);

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRPlayback;


totalFramesWritten = 0;
while (totalFramesWritten < frameCount) {

if (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser == 0) { 




ma_uint32 bpf = ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 framesRemainingInHeader = (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwBufferLength/bpf) - pDevice->winmm.headerFramesConsumedPlayback;

ma_uint32 framesToCopy = ma_min(framesRemainingInHeader, (frameCount - totalFramesWritten));
const void* pSrc = ma_offset_ptr(pPCMFrames, totalFramesWritten*bpf);
void* pDst = ma_offset_ptr(pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].lpData, pDevice->winmm.headerFramesConsumedPlayback*bpf);
MA_COPY_MEMORY(pDst, pSrc, framesToCopy*bpf);

pDevice->winmm.headerFramesConsumedPlayback += framesToCopy;
totalFramesWritten += framesToCopy;


if (pDevice->winmm.headerFramesConsumedPlayback == (pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwBufferLength/bpf)) {
pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser = 1; 
pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwFlags &= ~WHDR_DONE; 


ResetEvent((HANDLE)pDevice->winmm.hEventPlayback);


resultMM = ((MA_PFN_waveOutWrite)pDevice->pContext->winmm.waveOutWrite)((HWAVEOUT)pDevice->winmm.hDevicePlayback, &pWAVEHDR[pDevice->winmm.iNextHeaderPlayback], sizeof(WAVEHDR));
if (resultMM != MMSYSERR_NOERROR) {
result = ma_result_from_MMRESULT(resultMM);
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] waveOutWrite() failed.", result);
break;
}


pDevice->winmm.iNextHeaderPlayback = (pDevice->winmm.iNextHeaderPlayback + 1) % pDevice->playback.internalPeriods;
pDevice->winmm.headerFramesConsumedPlayback = 0;
}


MA_ASSERT(totalFramesWritten <= frameCount);
if (totalFramesWritten == frameCount) {
break;
}


continue;
}


if (WaitForSingleObject((HANDLE)pDevice->winmm.hEventPlayback, INFINITE) != WAIT_OBJECT_0) {
result = MA_ERROR;
break;
}


if ((pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwFlags & WHDR_DONE) != 0) {
pWAVEHDR[pDevice->winmm.iNextHeaderPlayback].dwUser = 0; 
pDevice->winmm.headerFramesConsumedPlayback = 0;
}


if (ma_device__get_state(pDevice) != MA_STATE_STARTED) {
break;
}
}

if (pFramesWritten != NULL) {
*pFramesWritten = totalFramesWritten;
}

return result;
}

static ma_result ma_device_read__winmm(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
ma_result result = MA_SUCCESS;
MMRESULT resultMM;
ma_uint32 totalFramesRead;
WAVEHDR* pWAVEHDR;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pPCMFrames != NULL);

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRCapture;


totalFramesRead = 0;
while (totalFramesRead < frameCount) {

if (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser == 0) { 

ma_uint32 bpf = ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 framesRemainingInHeader = (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwBufferLength/bpf) - pDevice->winmm.headerFramesConsumedCapture;

ma_uint32 framesToCopy = ma_min(framesRemainingInHeader, (frameCount - totalFramesRead));
const void* pSrc = ma_offset_ptr(pWAVEHDR[pDevice->winmm.iNextHeaderCapture].lpData, pDevice->winmm.headerFramesConsumedCapture*bpf);
void* pDst = ma_offset_ptr(pPCMFrames, totalFramesRead*bpf);
MA_COPY_MEMORY(pDst, pSrc, framesToCopy*bpf);

pDevice->winmm.headerFramesConsumedCapture += framesToCopy;
totalFramesRead += framesToCopy;


if (pDevice->winmm.headerFramesConsumedCapture == (pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwBufferLength/bpf)) {
pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser = 1; 
pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwFlags &= ~WHDR_DONE; 


ResetEvent((HANDLE)pDevice->winmm.hEventCapture);


resultMM = ((MA_PFN_waveInAddBuffer)pDevice->pContext->winmm.waveInAddBuffer)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((LPWAVEHDR)pDevice->winmm.pWAVEHDRCapture)[pDevice->winmm.iNextHeaderCapture], sizeof(WAVEHDR));
if (resultMM != MMSYSERR_NOERROR) {
result = ma_result_from_MMRESULT(resultMM);
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] waveInAddBuffer() failed.", result);
break;
}


pDevice->winmm.iNextHeaderCapture = (pDevice->winmm.iNextHeaderCapture + 1) % pDevice->capture.internalPeriods;
pDevice->winmm.headerFramesConsumedCapture = 0;
}


MA_ASSERT(totalFramesRead <= frameCount);
if (totalFramesRead == frameCount) {
break;
}


continue;
}


if (WaitForSingleObject((HANDLE)pDevice->winmm.hEventCapture, INFINITE) != WAIT_OBJECT_0) {
result = MA_ERROR;
break;
}


if ((pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwFlags & WHDR_DONE) != 0) {
pWAVEHDR[pDevice->winmm.iNextHeaderCapture].dwUser = 0; 
pDevice->winmm.headerFramesConsumedCapture = 0;
}


if (ma_device__get_state(pDevice) != MA_STATE_STARTED) {
break;
}
}

if (pFramesRead != NULL) {
*pFramesRead = totalFramesRead;
}

return result;
}

static ma_result ma_device_main_loop__winmm(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
MMRESULT resultMM;
WAVEHDR* pWAVEHDR;
ma_uint32 iPeriod;

pWAVEHDR = (WAVEHDR*)pDevice->winmm.pWAVEHDRCapture;


ResetEvent((HANDLE)pDevice->winmm.hEventCapture);


for (iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
resultMM = ((MA_PFN_waveInAddBuffer)pDevice->pContext->winmm.waveInAddBuffer)((HWAVEIN)pDevice->winmm.hDeviceCapture, &((LPWAVEHDR)pDevice->winmm.pWAVEHDRCapture)[iPeriod], sizeof(WAVEHDR));
if (resultMM != MMSYSERR_NOERROR) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] Failed to attach input buffers to capture device in preparation for capture.", ma_result_from_MMRESULT(resultMM));
}


pWAVEHDR[iPeriod].dwUser = 1; 
}


resultMM = ((MA_PFN_waveInStart)pDevice->pContext->winmm.waveInStart)((HWAVEIN)pDevice->winmm.hDeviceCapture);
if (resultMM != MMSYSERR_NOERROR) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[WinMM] Failed to start backend device.", ma_result_from_MMRESULT(resultMM));
}
}


while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__winmm(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__winmm(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{

ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__winmm(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{

ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__winmm(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}



ma_device_stop__winmm(pDevice);

return result;
}

static ma_result ma_context_uninit__winmm(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_winmm);

ma_dlclose(pContext, pContext->winmm.hWinMM);
return MA_SUCCESS;
}

static ma_result ma_context_init__winmm(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

(void)pConfig;

pContext->winmm.hWinMM = ma_dlopen(pContext, "winmm.dll");
if (pContext->winmm.hWinMM == NULL) {
return MA_NO_BACKEND;
}

pContext->winmm.waveOutGetNumDevs = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutGetNumDevs");
pContext->winmm.waveOutGetDevCapsA = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutGetDevCapsA");
pContext->winmm.waveOutOpen = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutOpen");
pContext->winmm.waveOutClose = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutClose");
pContext->winmm.waveOutPrepareHeader = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutPrepareHeader");
pContext->winmm.waveOutUnprepareHeader = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutUnprepareHeader");
pContext->winmm.waveOutWrite = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutWrite");
pContext->winmm.waveOutReset = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveOutReset");
pContext->winmm.waveInGetNumDevs = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInGetNumDevs");
pContext->winmm.waveInGetDevCapsA = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInGetDevCapsA");
pContext->winmm.waveInOpen = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInOpen");
pContext->winmm.waveInClose = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInClose");
pContext->winmm.waveInPrepareHeader = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInPrepareHeader");
pContext->winmm.waveInUnprepareHeader = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInUnprepareHeader");
pContext->winmm.waveInAddBuffer = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInAddBuffer");
pContext->winmm.waveInStart = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInStart");
pContext->winmm.waveInReset = ma_dlsym(pContext, pContext->winmm.hWinMM, "waveInReset");

pContext->onUninit = ma_context_uninit__winmm;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__winmm;
pContext->onEnumDevices = ma_context_enumerate_devices__winmm;
pContext->onGetDeviceInfo = ma_context_get_device_info__winmm;
pContext->onDeviceInit = ma_device_init__winmm;
pContext->onDeviceUninit = ma_device_uninit__winmm;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__winmm;

return MA_SUCCESS;
}
#endif









#if defined(MA_HAS_ALSA)

#if defined(MA_NO_RUNTIME_LINKING)
#include <alsa/asoundlib.h>
typedef snd_pcm_uframes_t ma_snd_pcm_uframes_t;
typedef snd_pcm_sframes_t ma_snd_pcm_sframes_t;
typedef snd_pcm_stream_t ma_snd_pcm_stream_t;
typedef snd_pcm_format_t ma_snd_pcm_format_t;
typedef snd_pcm_access_t ma_snd_pcm_access_t;
typedef snd_pcm_t ma_snd_pcm_t;
typedef snd_pcm_hw_params_t ma_snd_pcm_hw_params_t;
typedef snd_pcm_sw_params_t ma_snd_pcm_sw_params_t;
typedef snd_pcm_format_mask_t ma_snd_pcm_format_mask_t;
typedef snd_pcm_info_t ma_snd_pcm_info_t;
typedef snd_pcm_channel_area_t ma_snd_pcm_channel_area_t;
typedef snd_pcm_chmap_t ma_snd_pcm_chmap_t;


#define MA_SND_PCM_STREAM_PLAYBACK SND_PCM_STREAM_PLAYBACK
#define MA_SND_PCM_STREAM_CAPTURE SND_PCM_STREAM_CAPTURE


#define MA_SND_PCM_FORMAT_UNKNOWN SND_PCM_FORMAT_UNKNOWN
#define MA_SND_PCM_FORMAT_U8 SND_PCM_FORMAT_U8
#define MA_SND_PCM_FORMAT_S16_LE SND_PCM_FORMAT_S16_LE
#define MA_SND_PCM_FORMAT_S16_BE SND_PCM_FORMAT_S16_BE
#define MA_SND_PCM_FORMAT_S24_LE SND_PCM_FORMAT_S24_LE
#define MA_SND_PCM_FORMAT_S24_BE SND_PCM_FORMAT_S24_BE
#define MA_SND_PCM_FORMAT_S32_LE SND_PCM_FORMAT_S32_LE
#define MA_SND_PCM_FORMAT_S32_BE SND_PCM_FORMAT_S32_BE
#define MA_SND_PCM_FORMAT_FLOAT_LE SND_PCM_FORMAT_FLOAT_LE
#define MA_SND_PCM_FORMAT_FLOAT_BE SND_PCM_FORMAT_FLOAT_BE
#define MA_SND_PCM_FORMAT_FLOAT64_LE SND_PCM_FORMAT_FLOAT64_LE
#define MA_SND_PCM_FORMAT_FLOAT64_BE SND_PCM_FORMAT_FLOAT64_BE
#define MA_SND_PCM_FORMAT_MU_LAW SND_PCM_FORMAT_MU_LAW
#define MA_SND_PCM_FORMAT_A_LAW SND_PCM_FORMAT_A_LAW
#define MA_SND_PCM_FORMAT_S24_3LE SND_PCM_FORMAT_S24_3LE
#define MA_SND_PCM_FORMAT_S24_3BE SND_PCM_FORMAT_S24_3BE


#define MA_SND_PCM_ACCESS_MMAP_INTERLEAVED SND_PCM_ACCESS_MMAP_INTERLEAVED
#define MA_SND_PCM_ACCESS_MMAP_NONINTERLEAVED SND_PCM_ACCESS_MMAP_NONINTERLEAVED
#define MA_SND_PCM_ACCESS_MMAP_COMPLEX SND_PCM_ACCESS_MMAP_COMPLEX
#define MA_SND_PCM_ACCESS_RW_INTERLEAVED SND_PCM_ACCESS_RW_INTERLEAVED
#define MA_SND_PCM_ACCESS_RW_NONINTERLEAVED SND_PCM_ACCESS_RW_NONINTERLEAVED


#define MA_SND_CHMAP_UNKNOWN SND_CHMAP_UNKNOWN
#define MA_SND_CHMAP_NA SND_CHMAP_NA
#define MA_SND_CHMAP_MONO SND_CHMAP_MONO
#define MA_SND_CHMAP_FL SND_CHMAP_FL
#define MA_SND_CHMAP_FR SND_CHMAP_FR
#define MA_SND_CHMAP_RL SND_CHMAP_RL
#define MA_SND_CHMAP_RR SND_CHMAP_RR
#define MA_SND_CHMAP_FC SND_CHMAP_FC
#define MA_SND_CHMAP_LFE SND_CHMAP_LFE
#define MA_SND_CHMAP_SL SND_CHMAP_SL
#define MA_SND_CHMAP_SR SND_CHMAP_SR
#define MA_SND_CHMAP_RC SND_CHMAP_RC
#define MA_SND_CHMAP_FLC SND_CHMAP_FLC
#define MA_SND_CHMAP_FRC SND_CHMAP_FRC
#define MA_SND_CHMAP_RLC SND_CHMAP_RLC
#define MA_SND_CHMAP_RRC SND_CHMAP_RRC
#define MA_SND_CHMAP_FLW SND_CHMAP_FLW
#define MA_SND_CHMAP_FRW SND_CHMAP_FRW
#define MA_SND_CHMAP_FLH SND_CHMAP_FLH
#define MA_SND_CHMAP_FCH SND_CHMAP_FCH
#define MA_SND_CHMAP_FRH SND_CHMAP_FRH
#define MA_SND_CHMAP_TC SND_CHMAP_TC
#define MA_SND_CHMAP_TFL SND_CHMAP_TFL
#define MA_SND_CHMAP_TFR SND_CHMAP_TFR
#define MA_SND_CHMAP_TFC SND_CHMAP_TFC
#define MA_SND_CHMAP_TRL SND_CHMAP_TRL
#define MA_SND_CHMAP_TRR SND_CHMAP_TRR
#define MA_SND_CHMAP_TRC SND_CHMAP_TRC
#define MA_SND_CHMAP_TFLC SND_CHMAP_TFLC
#define MA_SND_CHMAP_TFRC SND_CHMAP_TFRC
#define MA_SND_CHMAP_TSL SND_CHMAP_TSL
#define MA_SND_CHMAP_TSR SND_CHMAP_TSR
#define MA_SND_CHMAP_LLFE SND_CHMAP_LLFE
#define MA_SND_CHMAP_RLFE SND_CHMAP_RLFE
#define MA_SND_CHMAP_BC SND_CHMAP_BC
#define MA_SND_CHMAP_BLC SND_CHMAP_BLC
#define MA_SND_CHMAP_BRC SND_CHMAP_BRC


#define MA_SND_PCM_NO_AUTO_RESAMPLE SND_PCM_NO_AUTO_RESAMPLE
#define MA_SND_PCM_NO_AUTO_CHANNELS SND_PCM_NO_AUTO_CHANNELS
#define MA_SND_PCM_NO_AUTO_FORMAT SND_PCM_NO_AUTO_FORMAT
#else
#include <errno.h> 
typedef unsigned long ma_snd_pcm_uframes_t;
typedef long ma_snd_pcm_sframes_t;
typedef int ma_snd_pcm_stream_t;
typedef int ma_snd_pcm_format_t;
typedef int ma_snd_pcm_access_t;
typedef struct ma_snd_pcm_t ma_snd_pcm_t;
typedef struct ma_snd_pcm_hw_params_t ma_snd_pcm_hw_params_t;
typedef struct ma_snd_pcm_sw_params_t ma_snd_pcm_sw_params_t;
typedef struct ma_snd_pcm_format_mask_t ma_snd_pcm_format_mask_t;
typedef struct ma_snd_pcm_info_t ma_snd_pcm_info_t;
typedef struct
{
void* addr;
unsigned int first;
unsigned int step;
} ma_snd_pcm_channel_area_t;
typedef struct
{
unsigned int channels;
unsigned int pos[1];
} ma_snd_pcm_chmap_t;


#define MA_SND_PCM_STATE_OPEN 0
#define MA_SND_PCM_STATE_SETUP 1
#define MA_SND_PCM_STATE_PREPARED 2
#define MA_SND_PCM_STATE_RUNNING 3
#define MA_SND_PCM_STATE_XRUN 4
#define MA_SND_PCM_STATE_DRAINING 5
#define MA_SND_PCM_STATE_PAUSED 6
#define MA_SND_PCM_STATE_SUSPENDED 7
#define MA_SND_PCM_STATE_DISCONNECTED 8


#define MA_SND_PCM_STREAM_PLAYBACK 0
#define MA_SND_PCM_STREAM_CAPTURE 1


#define MA_SND_PCM_FORMAT_UNKNOWN -1
#define MA_SND_PCM_FORMAT_U8 1
#define MA_SND_PCM_FORMAT_S16_LE 2
#define MA_SND_PCM_FORMAT_S16_BE 3
#define MA_SND_PCM_FORMAT_S24_LE 6
#define MA_SND_PCM_FORMAT_S24_BE 7
#define MA_SND_PCM_FORMAT_S32_LE 10
#define MA_SND_PCM_FORMAT_S32_BE 11
#define MA_SND_PCM_FORMAT_FLOAT_LE 14
#define MA_SND_PCM_FORMAT_FLOAT_BE 15
#define MA_SND_PCM_FORMAT_FLOAT64_LE 16
#define MA_SND_PCM_FORMAT_FLOAT64_BE 17
#define MA_SND_PCM_FORMAT_MU_LAW 20
#define MA_SND_PCM_FORMAT_A_LAW 21
#define MA_SND_PCM_FORMAT_S24_3LE 32
#define MA_SND_PCM_FORMAT_S24_3BE 33


#define MA_SND_PCM_ACCESS_MMAP_INTERLEAVED 0
#define MA_SND_PCM_ACCESS_MMAP_NONINTERLEAVED 1
#define MA_SND_PCM_ACCESS_MMAP_COMPLEX 2
#define MA_SND_PCM_ACCESS_RW_INTERLEAVED 3
#define MA_SND_PCM_ACCESS_RW_NONINTERLEAVED 4


#define MA_SND_CHMAP_UNKNOWN 0
#define MA_SND_CHMAP_NA 1
#define MA_SND_CHMAP_MONO 2
#define MA_SND_CHMAP_FL 3
#define MA_SND_CHMAP_FR 4
#define MA_SND_CHMAP_RL 5
#define MA_SND_CHMAP_RR 6
#define MA_SND_CHMAP_FC 7
#define MA_SND_CHMAP_LFE 8
#define MA_SND_CHMAP_SL 9
#define MA_SND_CHMAP_SR 10
#define MA_SND_CHMAP_RC 11
#define MA_SND_CHMAP_FLC 12
#define MA_SND_CHMAP_FRC 13
#define MA_SND_CHMAP_RLC 14
#define MA_SND_CHMAP_RRC 15
#define MA_SND_CHMAP_FLW 16
#define MA_SND_CHMAP_FRW 17
#define MA_SND_CHMAP_FLH 18
#define MA_SND_CHMAP_FCH 19
#define MA_SND_CHMAP_FRH 20
#define MA_SND_CHMAP_TC 21
#define MA_SND_CHMAP_TFL 22
#define MA_SND_CHMAP_TFR 23
#define MA_SND_CHMAP_TFC 24
#define MA_SND_CHMAP_TRL 25
#define MA_SND_CHMAP_TRR 26
#define MA_SND_CHMAP_TRC 27
#define MA_SND_CHMAP_TFLC 28
#define MA_SND_CHMAP_TFRC 29
#define MA_SND_CHMAP_TSL 30
#define MA_SND_CHMAP_TSR 31
#define MA_SND_CHMAP_LLFE 32
#define MA_SND_CHMAP_RLFE 33
#define MA_SND_CHMAP_BC 34
#define MA_SND_CHMAP_BLC 35
#define MA_SND_CHMAP_BRC 36


#define MA_SND_PCM_NO_AUTO_RESAMPLE 0x00010000
#define MA_SND_PCM_NO_AUTO_CHANNELS 0x00020000
#define MA_SND_PCM_NO_AUTO_FORMAT 0x00040000
#endif

typedef int (* ma_snd_pcm_open_proc) (ma_snd_pcm_t **pcm, const char *name, ma_snd_pcm_stream_t stream, int mode);
typedef int (* ma_snd_pcm_close_proc) (ma_snd_pcm_t *pcm);
typedef size_t (* ma_snd_pcm_hw_params_sizeof_proc) (void);
typedef int (* ma_snd_pcm_hw_params_any_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params);
typedef int (* ma_snd_pcm_hw_params_set_format_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, ma_snd_pcm_format_t val);
typedef int (* ma_snd_pcm_hw_params_set_format_first_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, ma_snd_pcm_format_t *format);
typedef void (* ma_snd_pcm_hw_params_get_format_mask_proc) (ma_snd_pcm_hw_params_t *params, ma_snd_pcm_format_mask_t *mask);
typedef int (* ma_snd_pcm_hw_params_set_channels_near_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int (* ma_snd_pcm_hw_params_set_rate_resample_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, unsigned int val);
typedef int (* ma_snd_pcm_hw_params_set_rate_near_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int (* ma_snd_pcm_hw_params_set_buffer_size_near_proc)(ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, ma_snd_pcm_uframes_t *val);
typedef int (* ma_snd_pcm_hw_params_set_periods_near_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int (* ma_snd_pcm_hw_params_set_access_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params, ma_snd_pcm_access_t _access);
typedef int (* ma_snd_pcm_hw_params_get_format_proc) (const ma_snd_pcm_hw_params_t *params, ma_snd_pcm_format_t *format);
typedef int (* ma_snd_pcm_hw_params_get_channels_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int (* ma_snd_pcm_hw_params_get_channels_min_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int (* ma_snd_pcm_hw_params_get_channels_max_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *val);
typedef int (* ma_snd_pcm_hw_params_get_rate_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int (* ma_snd_pcm_hw_params_get_rate_min_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int (* ma_snd_pcm_hw_params_get_rate_max_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *rate, int *dir);
typedef int (* ma_snd_pcm_hw_params_get_buffer_size_proc) (const ma_snd_pcm_hw_params_t *params, ma_snd_pcm_uframes_t *val);
typedef int (* ma_snd_pcm_hw_params_get_periods_proc) (const ma_snd_pcm_hw_params_t *params, unsigned int *val, int *dir);
typedef int (* ma_snd_pcm_hw_params_get_access_proc) (const ma_snd_pcm_hw_params_t *params, ma_snd_pcm_access_t *_access);
typedef int (* ma_snd_pcm_hw_params_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_hw_params_t *params);
typedef size_t (* ma_snd_pcm_sw_params_sizeof_proc) (void);
typedef int (* ma_snd_pcm_sw_params_current_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_sw_params_t *params);
typedef int (* ma_snd_pcm_sw_params_get_boundary_proc) (ma_snd_pcm_sw_params_t *params, ma_snd_pcm_uframes_t* val);
typedef int (* ma_snd_pcm_sw_params_set_avail_min_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_sw_params_t *params, ma_snd_pcm_uframes_t val);
typedef int (* ma_snd_pcm_sw_params_set_start_threshold_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_sw_params_t *params, ma_snd_pcm_uframes_t val);
typedef int (* ma_snd_pcm_sw_params_set_stop_threshold_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_sw_params_t *params, ma_snd_pcm_uframes_t val);
typedef int (* ma_snd_pcm_sw_params_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_sw_params_t *params);
typedef size_t (* ma_snd_pcm_format_mask_sizeof_proc) (void);
typedef int (* ma_snd_pcm_format_mask_test_proc) (const ma_snd_pcm_format_mask_t *mask, ma_snd_pcm_format_t val);
typedef ma_snd_pcm_chmap_t * (* ma_snd_pcm_get_chmap_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_state_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_prepare_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_start_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_drop_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_drain_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_device_name_hint_proc) (int card, const char *iface, void ***hints);
typedef char * (* ma_snd_device_name_get_hint_proc) (const void *hint, const char *id);
typedef int (* ma_snd_card_get_index_proc) (const char *name);
typedef int (* ma_snd_device_name_free_hint_proc) (void **hints);
typedef int (* ma_snd_pcm_mmap_begin_proc) (ma_snd_pcm_t *pcm, const ma_snd_pcm_channel_area_t **areas, ma_snd_pcm_uframes_t *offset, ma_snd_pcm_uframes_t *frames);
typedef ma_snd_pcm_sframes_t (* ma_snd_pcm_mmap_commit_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_uframes_t offset, ma_snd_pcm_uframes_t frames);
typedef int (* ma_snd_pcm_recover_proc) (ma_snd_pcm_t *pcm, int err, int silent);
typedef ma_snd_pcm_sframes_t (* ma_snd_pcm_readi_proc) (ma_snd_pcm_t *pcm, void *buffer, ma_snd_pcm_uframes_t size);
typedef ma_snd_pcm_sframes_t (* ma_snd_pcm_writei_proc) (ma_snd_pcm_t *pcm, const void *buffer, ma_snd_pcm_uframes_t size);
typedef ma_snd_pcm_sframes_t (* ma_snd_pcm_avail_proc) (ma_snd_pcm_t *pcm);
typedef ma_snd_pcm_sframes_t (* ma_snd_pcm_avail_update_proc) (ma_snd_pcm_t *pcm);
typedef int (* ma_snd_pcm_wait_proc) (ma_snd_pcm_t *pcm, int timeout);
typedef int (* ma_snd_pcm_info_proc) (ma_snd_pcm_t *pcm, ma_snd_pcm_info_t* info);
typedef size_t (* ma_snd_pcm_info_sizeof_proc) ();
typedef const char* (* ma_snd_pcm_info_get_name_proc) (const ma_snd_pcm_info_t* info);
typedef int (* ma_snd_config_update_free_global_proc) ();


static const char* g_maCommonDeviceNamesALSA[] = {
"default",
"null",
"pulse",
"jack"
};


static const char* g_maBlacklistedPlaybackDeviceNamesALSA[] = {
""
};


static const char* g_maBlacklistedCaptureDeviceNamesALSA[] = {
""
};






static struct
{
const char* name;
float scale;
} g_maDefaultBufferSizeScalesALSA[] = {
{"bcm2835 IEC958/HDMI", 2.0f},
{"bcm2835 ALSA", 2.0f}
};

static float ma_find_default_buffer_size_scale__alsa(const char* deviceName)
{
size_t i;

if (deviceName == NULL) {
return 1;
}

for (i = 0; i < ma_countof(g_maDefaultBufferSizeScalesALSA); ++i) {
if (strstr(g_maDefaultBufferSizeScalesALSA[i].name, deviceName) != NULL) {
return g_maDefaultBufferSizeScalesALSA[i].scale;
}
}

return 1;
}

static ma_snd_pcm_format_t ma_convert_ma_format_to_alsa_format(ma_format format)
{
ma_snd_pcm_format_t ALSAFormats[] = {
MA_SND_PCM_FORMAT_UNKNOWN, 
MA_SND_PCM_FORMAT_U8, 
MA_SND_PCM_FORMAT_S16_LE, 
MA_SND_PCM_FORMAT_S24_3LE, 
MA_SND_PCM_FORMAT_S32_LE, 
MA_SND_PCM_FORMAT_FLOAT_LE 
};

if (ma_is_big_endian()) {
ALSAFormats[0] = MA_SND_PCM_FORMAT_UNKNOWN;
ALSAFormats[1] = MA_SND_PCM_FORMAT_U8;
ALSAFormats[2] = MA_SND_PCM_FORMAT_S16_BE;
ALSAFormats[3] = MA_SND_PCM_FORMAT_S24_3BE;
ALSAFormats[4] = MA_SND_PCM_FORMAT_S32_BE;
ALSAFormats[5] = MA_SND_PCM_FORMAT_FLOAT_BE;
}

return ALSAFormats[format];
}

static ma_format ma_format_from_alsa(ma_snd_pcm_format_t formatALSA)
{
if (ma_is_little_endian()) {
switch (formatALSA) {
case MA_SND_PCM_FORMAT_S16_LE: return ma_format_s16;
case MA_SND_PCM_FORMAT_S24_3LE: return ma_format_s24;
case MA_SND_PCM_FORMAT_S32_LE: return ma_format_s32;
case MA_SND_PCM_FORMAT_FLOAT_LE: return ma_format_f32;
default: break;
}
} else {
switch (formatALSA) {
case MA_SND_PCM_FORMAT_S16_BE: return ma_format_s16;
case MA_SND_PCM_FORMAT_S24_3BE: return ma_format_s24;
case MA_SND_PCM_FORMAT_S32_BE: return ma_format_s32;
case MA_SND_PCM_FORMAT_FLOAT_BE: return ma_format_f32;
default: break;
}
}


switch (formatALSA) {
case MA_SND_PCM_FORMAT_U8: return ma_format_u8;
default: return ma_format_unknown;
}
}

static ma_channel ma_convert_alsa_channel_position_to_ma_channel(unsigned int alsaChannelPos)
{
switch (alsaChannelPos)
{
case MA_SND_CHMAP_MONO: return MA_CHANNEL_MONO;
case MA_SND_CHMAP_FL: return MA_CHANNEL_FRONT_LEFT;
case MA_SND_CHMAP_FR: return MA_CHANNEL_FRONT_RIGHT;
case MA_SND_CHMAP_RL: return MA_CHANNEL_BACK_LEFT;
case MA_SND_CHMAP_RR: return MA_CHANNEL_BACK_RIGHT;
case MA_SND_CHMAP_FC: return MA_CHANNEL_FRONT_CENTER;
case MA_SND_CHMAP_LFE: return MA_CHANNEL_LFE;
case MA_SND_CHMAP_SL: return MA_CHANNEL_SIDE_LEFT;
case MA_SND_CHMAP_SR: return MA_CHANNEL_SIDE_RIGHT;
case MA_SND_CHMAP_RC: return MA_CHANNEL_BACK_CENTER;
case MA_SND_CHMAP_FLC: return MA_CHANNEL_FRONT_LEFT_CENTER;
case MA_SND_CHMAP_FRC: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case MA_SND_CHMAP_RLC: return 0;
case MA_SND_CHMAP_RRC: return 0;
case MA_SND_CHMAP_FLW: return 0;
case MA_SND_CHMAP_FRW: return 0;
case MA_SND_CHMAP_FLH: return 0;
case MA_SND_CHMAP_FCH: return 0;
case MA_SND_CHMAP_FRH: return 0;
case MA_SND_CHMAP_TC: return MA_CHANNEL_TOP_CENTER;
case MA_SND_CHMAP_TFL: return MA_CHANNEL_TOP_FRONT_LEFT;
case MA_SND_CHMAP_TFR: return MA_CHANNEL_TOP_FRONT_RIGHT;
case MA_SND_CHMAP_TFC: return MA_CHANNEL_TOP_FRONT_CENTER;
case MA_SND_CHMAP_TRL: return MA_CHANNEL_TOP_BACK_LEFT;
case MA_SND_CHMAP_TRR: return MA_CHANNEL_TOP_BACK_RIGHT;
case MA_SND_CHMAP_TRC: return MA_CHANNEL_TOP_BACK_CENTER;
default: break;
}

return 0;
}

static ma_bool32 ma_is_common_device_name__alsa(const char* name)
{
size_t iName;
for (iName = 0; iName < ma_countof(g_maCommonDeviceNamesALSA); ++iName) {
if (ma_strcmp(name, g_maCommonDeviceNamesALSA[iName]) == 0) {
return MA_TRUE;
}
}

return MA_FALSE;
}


static ma_bool32 ma_is_playback_device_blacklisted__alsa(const char* name)
{
size_t iName;
for (iName = 0; iName < ma_countof(g_maBlacklistedPlaybackDeviceNamesALSA); ++iName) {
if (ma_strcmp(name, g_maBlacklistedPlaybackDeviceNamesALSA[iName]) == 0) {
return MA_TRUE;
}
}

return MA_FALSE;
}

static ma_bool32 ma_is_capture_device_blacklisted__alsa(const char* name)
{
size_t iName;
for (iName = 0; iName < ma_countof(g_maBlacklistedCaptureDeviceNamesALSA); ++iName) {
if (ma_strcmp(name, g_maBlacklistedCaptureDeviceNamesALSA[iName]) == 0) {
return MA_TRUE;
}
}

return MA_FALSE;
}

static ma_bool32 ma_is_device_blacklisted__alsa(ma_device_type deviceType, const char* name)
{
if (deviceType == ma_device_type_playback) {
return ma_is_playback_device_blacklisted__alsa(name);
} else {
return ma_is_capture_device_blacklisted__alsa(name);
}
}


static const char* ma_find_char(const char* str, char c, int* index)
{
int i = 0;
for (;;) {
if (str[i] == '\0') {
if (index) *index = -1;
return NULL;
}

if (str[i] == c) {
if (index) *index = i;
return str + i;
}

i += 1;
}


if (index) *index = -1;
return NULL;
}

static ma_bool32 ma_is_device_name_in_hw_format__alsa(const char* hwid)
{


int commaPos;
const char* dev;
int i;

if (hwid == NULL) {
return MA_FALSE;
}

if (hwid[0] != 'h' || hwid[1] != 'w' || hwid[2] != ':') {
return MA_FALSE;
}

hwid += 3;

dev = ma_find_char(hwid, ',', &commaPos);
if (dev == NULL) {
return MA_FALSE;
} else {
dev += 1; 
}


for (i = 0; i < commaPos; ++i) {
if (hwid[i] < '0' || hwid[i] > '9') {
return MA_FALSE;
}
}


i = 0;
while (dev[i] != '\0') {
if (dev[i] < '0' || dev[i] > '9') {
return MA_FALSE;
}
i += 1;
}

return MA_TRUE;
}

static int ma_convert_device_name_to_hw_format__alsa(ma_context* pContext, char* dst, size_t dstSize, const char* src) 
{


int colonPos;
int commaPos;
char card[256];
const char* dev;
int cardIndex;

if (dst == NULL) {
return -1;
}
if (dstSize < 7) {
return -1; 
}

*dst = '\0'; 
if (src == NULL) {
return -1;
}


if (ma_is_device_name_in_hw_format__alsa(src)) {
return ma_strcpy_s(dst, dstSize, src);
}

src = ma_find_char(src, ':', &colonPos);
if (src == NULL) {
return -1; 
}

dev = ma_find_char(src, ',', &commaPos);
if (dev == NULL) {
dev = "0";
ma_strncpy_s(card, sizeof(card), src+6, (size_t)-1); 
} else {
dev = dev + 5; 
ma_strncpy_s(card, sizeof(card), src+6, commaPos-6); 
}

cardIndex = ((ma_snd_card_get_index_proc)pContext->alsa.snd_card_get_index)(card);
if (cardIndex < 0) {
return -2; 
}





dst[0] = 'h'; dst[1] = 'w'; dst[2] = ':';
if (ma_itoa_s(cardIndex, dst+3, dstSize-3, 10) != 0) {
return -3;
}
if (ma_strcat_s(dst, dstSize, ",") != 0) {
return -3;
}
if (ma_strcat_s(dst, dstSize, dev) != 0) {
return -3;
}

return 0;
}

static ma_bool32 ma_does_id_exist_in_list__alsa(ma_device_id* pUniqueIDs, ma_uint32 count, const char* pHWID)
{
ma_uint32 i;

MA_ASSERT(pHWID != NULL);

for (i = 0; i < count; ++i) {
if (ma_strcmp(pUniqueIDs[i].alsa, pHWID) == 0) {
return MA_TRUE;
}
}

return MA_FALSE;
}


static ma_result ma_context_open_pcm__alsa(ma_context* pContext, ma_share_mode shareMode, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_snd_pcm_t** ppPCM)
{
ma_snd_pcm_t* pPCM;
ma_snd_pcm_stream_t stream;
int openMode;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppPCM != NULL);

*ppPCM = NULL;
pPCM = NULL;

stream = (deviceType == ma_device_type_playback) ? MA_SND_PCM_STREAM_PLAYBACK : MA_SND_PCM_STREAM_CAPTURE;
openMode = MA_SND_PCM_NO_AUTO_RESAMPLE | MA_SND_PCM_NO_AUTO_CHANNELS | MA_SND_PCM_NO_AUTO_FORMAT;

if (pDeviceID == NULL) {
ma_bool32 isDeviceOpen;
size_t i;





const char* defaultDeviceNames[] = {
"default",
NULL,
NULL,
NULL,
NULL,
NULL,
NULL
};

if (shareMode == ma_share_mode_exclusive) {
defaultDeviceNames[1] = "hw";
defaultDeviceNames[2] = "hw:0";
defaultDeviceNames[3] = "hw:0,0";
} else {
if (deviceType == ma_device_type_playback) {
defaultDeviceNames[1] = "dmix";
defaultDeviceNames[2] = "dmix:0";
defaultDeviceNames[3] = "dmix:0,0";
} else {
defaultDeviceNames[1] = "dsnoop";
defaultDeviceNames[2] = "dsnoop:0";
defaultDeviceNames[3] = "dsnoop:0,0";
}
defaultDeviceNames[4] = "hw";
defaultDeviceNames[5] = "hw:0";
defaultDeviceNames[6] = "hw:0,0";
}

isDeviceOpen = MA_FALSE;
for (i = 0; i < ma_countof(defaultDeviceNames); ++i) {
if (defaultDeviceNames[i] != NULL && defaultDeviceNames[i][0] != '\0') {
if (((ma_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, defaultDeviceNames[i], stream, openMode) == 0) {
isDeviceOpen = MA_TRUE;
break;
}
}
}

if (!isDeviceOpen) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_open() failed when trying to open an appropriate default device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
} else {









ma_device_id deviceID = *pDeviceID;
ma_bool32 isDeviceOpen = MA_FALSE;

if (deviceID.alsa[0] != ':') {

if (((ma_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, deviceID.alsa, stream, openMode) == 0) {
isDeviceOpen = MA_TRUE;
}
} else {
char hwid[256];


if (deviceID.alsa[1] == '\0') {
deviceID.alsa[0] = '\0'; 
}

if (shareMode == ma_share_mode_shared) {
if (deviceType == ma_device_type_playback) {
ma_strcpy_s(hwid, sizeof(hwid), "dmix");
} else {
ma_strcpy_s(hwid, sizeof(hwid), "dsnoop");
}

if (ma_strcat_s(hwid, sizeof(hwid), deviceID.alsa) == 0) {
if (((ma_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, hwid, stream, openMode) == 0) {
isDeviceOpen = MA_TRUE;
}
}
}


if (!isDeviceOpen) {
ma_strcpy_s(hwid, sizeof(hwid), "hw");
if (ma_strcat_s(hwid, sizeof(hwid), deviceID.alsa) == 0) {
if (((ma_snd_pcm_open_proc)pContext->alsa.snd_pcm_open)(&pPCM, hwid, stream, openMode) == 0) {
isDeviceOpen = MA_TRUE;
}
}
}
}

if (!isDeviceOpen) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_open() failed.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}

*ppPCM = pPCM;
return MA_SUCCESS;
}


static ma_bool32 ma_context_is_device_id_equal__alsa(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->alsa, pID1->alsa) == 0;
}

static ma_result ma_context_enumerate_devices__alsa(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult = MA_TRUE;
char** ppDeviceHints;
ma_device_id* pUniqueIDs = NULL;
ma_uint32 uniqueIDCount = 0;
char** ppNextDeviceHint;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);

ma_mutex_lock(&pContext->alsa.internalDeviceEnumLock);

if (((ma_snd_device_name_hint_proc)pContext->alsa.snd_device_name_hint)(-1, "pcm", (void***)&ppDeviceHints) < 0) {
ma_mutex_unlock(&pContext->alsa.internalDeviceEnumLock);
return MA_NO_BACKEND;
}

ppNextDeviceHint = ppDeviceHints;
while (*ppNextDeviceHint != NULL) {
char* NAME = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "NAME");
char* DESC = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "DESC");
char* IOID = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "IOID");
ma_device_type deviceType = ma_device_type_playback;
ma_bool32 stopEnumeration = MA_FALSE;
char hwid[sizeof(pUniqueIDs->alsa)];
ma_device_info deviceInfo;

if ((IOID == NULL || ma_strcmp(IOID, "Output") == 0)) {
deviceType = ma_device_type_playback;
}
if ((IOID != NULL && ma_strcmp(IOID, "Input" ) == 0)) {
deviceType = ma_device_type_capture;
}

if (NAME != NULL) {
if (pContext->alsa.useVerboseDeviceEnumeration) {

ma_strncpy_s(hwid, sizeof(hwid), NAME, (size_t)-1);
} else {

if (ma_convert_device_name_to_hw_format__alsa(pContext, hwid, sizeof(hwid), NAME) == 0) {






char* dst = hwid;
char* src = hwid+2;
while ((*dst++ = *src++));
} else {

ma_strncpy_s(hwid, sizeof(hwid), NAME, (size_t)-1);
}

if (ma_does_id_exist_in_list__alsa(pUniqueIDs, uniqueIDCount, hwid)) {
goto next_device; 
} else {

size_t oldCapacity = sizeof(*pUniqueIDs) * uniqueIDCount;
size_t newCapacity = sizeof(*pUniqueIDs) * (uniqueIDCount + 1);
ma_device_id* pNewUniqueIDs = (ma_device_id*)ma__realloc_from_callbacks(pUniqueIDs, newCapacity, oldCapacity, &pContext->allocationCallbacks);
if (pNewUniqueIDs == NULL) {
goto next_device; 
}

pUniqueIDs = pNewUniqueIDs;
MA_COPY_MEMORY(pUniqueIDs[uniqueIDCount].alsa, hwid, sizeof(hwid));
uniqueIDCount += 1;
}
}
} else {
MA_ZERO_MEMORY(hwid, sizeof(hwid));
}

MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.id.alsa, sizeof(deviceInfo.id.alsa), hwid, (size_t)-1);












if (DESC != NULL) {
int lfPos;
const char* line2 = ma_find_char(DESC, '\n', &lfPos);
if (line2 != NULL) {
line2 += 1; 

if (pContext->alsa.useVerboseDeviceEnumeration) {

ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, lfPos);
ma_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), " (");
ma_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), line2);
ma_strcat_s (deviceInfo.name, sizeof(deviceInfo.name), ")");
} else {

ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, lfPos);
}
} else {

ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), DESC, (size_t)-1);
}
}

if (!ma_is_device_blacklisted__alsa(deviceType, NAME)) {
cbResult = callback(pContext, deviceType, &deviceInfo, pUserData);
}





if (cbResult) {
if (ma_is_common_device_name__alsa(NAME)) {
if (deviceType == ma_device_type_playback) {
if (!ma_is_capture_device_blacklisted__alsa(NAME)) {
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}
} else {
if (!ma_is_playback_device_blacklisted__alsa(NAME)) {
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}
}
}
}

if (cbResult == MA_FALSE) {
stopEnumeration = MA_TRUE;
}

next_device:
free(NAME);
free(DESC);
free(IOID);
ppNextDeviceHint += 1;


if (stopEnumeration) {
break;
}
}

ma__free_from_callbacks(pUniqueIDs, &pContext->allocationCallbacks);
((ma_snd_device_name_free_hint_proc)pContext->alsa.snd_device_name_free_hint)((void**)ppDeviceHints);

ma_mutex_unlock(&pContext->alsa.internalDeviceEnumLock);

return MA_SUCCESS;
}


typedef struct
{
ma_device_type deviceType;
const ma_device_id* pDeviceID;
ma_share_mode shareMode;
ma_device_info* pDeviceInfo;
ma_bool32 foundDevice;
} ma_context_get_device_info_enum_callback_data__alsa;

static ma_bool32 ma_context_get_device_info_enum_callback__alsa(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pDeviceInfo, void* pUserData)
{
ma_context_get_device_info_enum_callback_data__alsa* pData = (ma_context_get_device_info_enum_callback_data__alsa*)pUserData;
MA_ASSERT(pData != NULL);

if (pData->pDeviceID == NULL && ma_strcmp(pDeviceInfo->id.alsa, "default") == 0) {
ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pDeviceInfo->name, (size_t)-1);
pData->foundDevice = MA_TRUE;
} else {
if (pData->deviceType == deviceType && ma_context_is_device_id_equal__alsa(pContext, pData->pDeviceID, &pDeviceInfo->id)) {
ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pDeviceInfo->name, (size_t)-1);
pData->foundDevice = MA_TRUE;
}
}


return !pData->foundDevice;
}

static ma_result ma_context_get_device_info__alsa(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_context_get_device_info_enum_callback_data__alsa data;
ma_result result;
ma_snd_pcm_t* pPCM;
ma_snd_pcm_hw_params_t* pHWParams;
ma_snd_pcm_format_mask_t* pFormatMask;
int sampleRateDir = 0;

MA_ASSERT(pContext != NULL);


data.deviceType = deviceType;
data.pDeviceID = pDeviceID;
data.shareMode = shareMode;
data.pDeviceInfo = pDeviceInfo;
data.foundDevice = MA_FALSE;
result = ma_context_enumerate_devices__alsa(pContext, ma_context_get_device_info_enum_callback__alsa, &data);
if (result != MA_SUCCESS) {
return result;
}

if (!data.foundDevice) {
return MA_NO_DEVICE;
}


result = ma_context_open_pcm__alsa(pContext, shareMode, deviceType, pDeviceID, &pPCM);
if (result != MA_SUCCESS) {
return result;
}


pHWParams = (ma_snd_pcm_hw_params_t*)ma__calloc_from_callbacks(((ma_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)(), &pContext->allocationCallbacks);
if (pHWParams == NULL) {
return MA_OUT_OF_MEMORY;
}

if (((ma_snd_pcm_hw_params_any_proc)pContext->alsa.snd_pcm_hw_params_any)(pPCM, pHWParams) < 0) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize hardware parameters. snd_pcm_hw_params_any() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}

((ma_snd_pcm_hw_params_get_channels_min_proc)pContext->alsa.snd_pcm_hw_params_get_channels_min)(pHWParams, &pDeviceInfo->minChannels);
((ma_snd_pcm_hw_params_get_channels_max_proc)pContext->alsa.snd_pcm_hw_params_get_channels_max)(pHWParams, &pDeviceInfo->maxChannels);
((ma_snd_pcm_hw_params_get_rate_min_proc)pContext->alsa.snd_pcm_hw_params_get_rate_min)(pHWParams, &pDeviceInfo->minSampleRate, &sampleRateDir);
((ma_snd_pcm_hw_params_get_rate_max_proc)pContext->alsa.snd_pcm_hw_params_get_rate_max)(pHWParams, &pDeviceInfo->maxSampleRate, &sampleRateDir);


pFormatMask = (ma_snd_pcm_format_mask_t*)ma__calloc_from_callbacks(((ma_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)(), &pContext->allocationCallbacks);
if (pFormatMask == NULL) {
return MA_OUT_OF_MEMORY;
}

((ma_snd_pcm_hw_params_get_format_mask_proc)pContext->alsa.snd_pcm_hw_params_get_format_mask)(pHWParams, pFormatMask);

pDeviceInfo->formatCount = 0;
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MA_SND_PCM_FORMAT_U8)) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_u8;
}
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MA_SND_PCM_FORMAT_S16_LE)) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_s16;
}
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MA_SND_PCM_FORMAT_S24_3LE)) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_s24;
}
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MA_SND_PCM_FORMAT_S32_LE)) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_s32;
}
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, MA_SND_PCM_FORMAT_FLOAT_LE)) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_f32;
}

ma__free_from_callbacks(pFormatMask, &pContext->allocationCallbacks);
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);

((ma_snd_pcm_close_proc)pContext->alsa.snd_pcm_close)(pPCM);
return MA_SUCCESS;
}


#if 0






static ma_uint32 ma_device__wait_for_frames__alsa(ma_device* pDevice, ma_bool32* pRequiresRestart)
{
MA_ASSERT(pDevice != NULL);

if (pRequiresRestart) *pRequiresRestart = MA_FALSE;


ma_uint32 periodSizeInFrames = pDevice->bufferSizeInFrames / pDevice->periods;
while (!pDevice->alsa.breakFromMainLoop) {
ma_snd_pcm_sframes_t framesAvailable = ((ma_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((ma_snd_pcm_t*)pDevice->alsa.pPCM);
if (framesAvailable < 0) {
if (framesAvailable == -EPIPE) {
if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, framesAvailable, MA_TRUE) < 0) {
return 0;
}


if (pRequiresRestart) {
*pRequiresRestart = MA_TRUE;
}


framesAvailable = ((ma_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((ma_snd_pcm_t*)pDevice->alsa.pPCM);
if (framesAvailable < 0) {
return 0;
}
}
}

if (framesAvailable >= periodSizeInFrames) {
return periodSizeInFrames;
}

if (framesAvailable < periodSizeInFrames) {

int waitResult = ((ma_snd_pcm_wait_proc)pDevice->pContext->alsa.snd_pcm_wait)((ma_snd_pcm_t*)pDevice->alsa.pPCM, -1);
if (waitResult < 0) {
if (waitResult == -EPIPE) {
if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, waitResult, MA_TRUE) < 0) {
return 0;
}


if (pRequiresRestart) {
*pRequiresRestart = MA_TRUE;
}
}
}
}
}


ma_snd_pcm_sframes_t framesAvailable = ((ma_snd_pcm_avail_update_proc)pDevice->pContext->alsa.snd_pcm_avail_update)((ma_snd_pcm_t*)pDevice->alsa.pPCM);
if (framesAvailable < 0) {
return 0;
}

return framesAvailable;
}

static ma_bool32 ma_device_read_from_client_and_write__alsa(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);
if (!ma_device_is_started(pDevice) && ma_device__get_state(pDevice) != MA_STATE_STARTING) {
return MA_FALSE;
}
if (pDevice->alsa.breakFromMainLoop) {
return MA_FALSE;
}

if (pDevice->alsa.isUsingMMap) {

ma_bool32 requiresRestart;
ma_uint32 framesAvailable = ma_device__wait_for_frames__alsa(pDevice, &requiresRestart);
if (framesAvailable == 0) {
return MA_FALSE;
}


if (pDevice->alsa.breakFromMainLoop) {
return MA_FALSE;
}

const ma_snd_pcm_channel_area_t* pAreas;
ma_snd_pcm_uframes_t mappedOffset;
ma_snd_pcm_uframes_t mappedFrames = framesAvailable;
while (framesAvailable > 0) {
int result = ((ma_snd_pcm_mmap_begin_proc)pDevice->pContext->alsa.snd_pcm_mmap_begin)((ma_snd_pcm_t*)pDevice->alsa.pPCM, &pAreas, &mappedOffset, &mappedFrames);
if (result < 0) {
return MA_FALSE;
}

if (mappedFrames > 0) {
void* pBuffer = (ma_uint8*)pAreas[0].addr + ((pAreas[0].first + (mappedOffset * pAreas[0].step)) / 8);
ma_device__read_frames_from_client(pDevice, mappedFrames, pBuffer);
}

result = ((ma_snd_pcm_mmap_commit_proc)pDevice->pContext->alsa.snd_pcm_mmap_commit)((ma_snd_pcm_t*)pDevice->alsa.pPCM, mappedOffset, mappedFrames);
if (result < 0 || (ma_snd_pcm_uframes_t)result != mappedFrames) {
((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, result, MA_TRUE);
return MA_FALSE;
}

if (requiresRestart) {
if (((ma_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((ma_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
return MA_FALSE;
}
}

if (framesAvailable >= mappedFrames) {
framesAvailable -= mappedFrames;
} else {
framesAvailable = 0;
}
}
} else {

while (!pDevice->alsa.breakFromMainLoop) {
ma_uint32 framesAvailable = ma_device__wait_for_frames__alsa(pDevice, NULL);
if (framesAvailable == 0) {
continue;
}


if (pDevice->alsa.breakFromMainLoop) {
return MA_FALSE;
}

ma_device__read_frames_from_client(pDevice, framesAvailable, pDevice->alsa.pIntermediaryBuffer);

ma_snd_pcm_sframes_t framesWritten = ((ma_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((ma_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
if (framesWritten < 0) {
if (framesWritten == -EAGAIN) {
continue; 
} else if (framesWritten == -EPIPE) {

if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, framesWritten, MA_TRUE) < 0) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after underrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
return MA_FALSE;
}

framesWritten = ((ma_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((ma_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
if (framesWritten < 0) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to write data to the internal device.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
return MA_FALSE;
}

break; 
} else {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_writei() failed when writing initial data.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
return MA_FALSE;
}
} else {
break; 
}
}
}

return MA_TRUE;
}

static ma_bool32 ma_device_read_and_send_to_client__alsa(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);
if (!ma_device_is_started(pDevice)) {
return MA_FALSE;
}
if (pDevice->alsa.breakFromMainLoop) {
return MA_FALSE;
}

ma_uint32 framesToSend = 0;
void* pBuffer = NULL;
if (pDevice->alsa.pIntermediaryBuffer == NULL) {

ma_bool32 requiresRestart;
ma_uint32 framesAvailable = ma_device__wait_for_frames__alsa(pDevice, &requiresRestart);
if (framesAvailable == 0) {
return MA_FALSE;
}

const ma_snd_pcm_channel_area_t* pAreas;
ma_snd_pcm_uframes_t mappedOffset;
ma_snd_pcm_uframes_t mappedFrames = framesAvailable;
while (framesAvailable > 0) {
int result = ((ma_snd_pcm_mmap_begin_proc)pDevice->pContext->alsa.snd_pcm_mmap_begin)((ma_snd_pcm_t*)pDevice->alsa.pPCM, &pAreas, &mappedOffset, &mappedFrames);
if (result < 0) {
return MA_FALSE;
}

if (mappedFrames > 0) {
void* pBuffer = (ma_uint8*)pAreas[0].addr + ((pAreas[0].first + (mappedOffset * pAreas[0].step)) / 8);
ma_device__send_frames_to_client(pDevice, mappedFrames, pBuffer);
}

result = ((ma_snd_pcm_mmap_commit_proc)pDevice->pContext->alsa.snd_pcm_mmap_commit)((ma_snd_pcm_t*)pDevice->alsa.pPCM, mappedOffset, mappedFrames);
if (result < 0 || (ma_snd_pcm_uframes_t)result != mappedFrames) {
((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, result, MA_TRUE);
return MA_FALSE;
}

if (requiresRestart) {
if (((ma_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((ma_snd_pcm_t*)pDevice->alsa.pPCM) < 0) {
return MA_FALSE;
}
}

if (framesAvailable >= mappedFrames) {
framesAvailable -= mappedFrames;
} else {
framesAvailable = 0;
}
}
} else {

ma_snd_pcm_sframes_t framesRead = 0;
while (!pDevice->alsa.breakFromMainLoop) {
ma_uint32 framesAvailable = ma_device__wait_for_frames__alsa(pDevice, NULL);
if (framesAvailable == 0) {
continue;
}

framesRead = ((ma_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((ma_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
if (framesRead < 0) {
if (framesRead == -EAGAIN) {
continue; 
} else if (framesRead == -EPIPE) {

if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCM, framesRead, MA_TRUE) < 0) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after overrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
return MA_FALSE;
}

framesRead = ((ma_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((ma_snd_pcm_t*)pDevice->alsa.pPCM, pDevice->alsa.pIntermediaryBuffer, framesAvailable);
if (framesRead < 0) {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to read data from the internal device.", MA_FAILED_TO_READ_DATA_FROM_DEVICE);
return MA_FALSE;
}

break; 
} else {
return MA_FALSE;
}
} else {
break; 
}
}

framesToSend = framesRead;
pBuffer = pDevice->alsa.pIntermediaryBuffer;
}

if (framesToSend > 0) {
ma_device__send_frames_to_client(pDevice, framesToSend, pBuffer);
}

return MA_TRUE;
}
#endif 

static void ma_device_uninit__alsa(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if ((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture) {
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture);
}

if ((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback) {
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback);
}
}

static ma_result ma_device_init_by_type__alsa(ma_context* pContext, const ma_device_config* pConfig, ma_device_type deviceType, ma_device* pDevice)
{
ma_result result;
ma_snd_pcm_t* pPCM;
ma_bool32 isUsingMMap;
ma_snd_pcm_format_t formatALSA;
ma_share_mode shareMode;
ma_device_id* pDeviceID;
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_channel internalChannelMap[MA_MAX_CHANNELS];
ma_uint32 internalPeriodSizeInFrames;
ma_uint32 internalPeriods;
ma_snd_pcm_hw_params_t* pHWParams;
ma_snd_pcm_sw_params_t* pSWParams;
ma_snd_pcm_uframes_t bufferBoundary;
float bufferSizeScaleFactor;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(deviceType != ma_device_type_duplex); 
MA_ASSERT(pDevice != NULL);

formatALSA = ma_convert_ma_format_to_alsa_format((deviceType == ma_device_type_capture) ? pConfig->capture.format : pConfig->playback.format);
shareMode = (deviceType == ma_device_type_capture) ? pConfig->capture.shareMode : pConfig->playback.shareMode;
pDeviceID = (deviceType == ma_device_type_capture) ? pConfig->capture.pDeviceID : pConfig->playback.pDeviceID;

result = ma_context_open_pcm__alsa(pContext, shareMode, deviceType, pDeviceID, &pPCM);
if (result != MA_SUCCESS) {
return result;
}


bufferSizeScaleFactor = 1;
if (pDevice->usingDefaultBufferSize) {
ma_snd_pcm_info_t* pInfo = (ma_snd_pcm_info_t*)ma__calloc_from_callbacks(((ma_snd_pcm_info_sizeof_proc)pContext->alsa.snd_pcm_info_sizeof)(), &pContext->allocationCallbacks);
if (pInfo == NULL) {
return MA_OUT_OF_MEMORY;
}


if (((ma_snd_pcm_info_proc)pContext->alsa.snd_pcm_info)(pPCM, pInfo) == 0) {
const char* deviceName = ((ma_snd_pcm_info_get_name_proc)pContext->alsa.snd_pcm_info_get_name)(pInfo);
if (deviceName != NULL) {
if (ma_strcmp(deviceName, "default") == 0) {
char** ppDeviceHints;
char** ppNextDeviceHint;


if (((ma_snd_device_name_hint_proc)pContext->alsa.snd_device_name_hint)(-1, "pcm", (void***)&ppDeviceHints) < 0) {
ma__free_from_callbacks(pInfo, &pContext->allocationCallbacks);
return MA_NO_BACKEND;
}

ppNextDeviceHint = ppDeviceHints;
while (*ppNextDeviceHint != NULL) {
char* NAME = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "NAME");
char* DESC = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "DESC");
char* IOID = ((ma_snd_device_name_get_hint_proc)pContext->alsa.snd_device_name_get_hint)(*ppNextDeviceHint, "IOID");

ma_bool32 foundDevice = MA_FALSE;
if ((deviceType == ma_device_type_playback && (IOID == NULL || ma_strcmp(IOID, "Output") == 0)) ||
(deviceType == ma_device_type_capture && (IOID != NULL && ma_strcmp(IOID, "Input" ) == 0))) {
if (ma_strcmp(NAME, deviceName) == 0) {
bufferSizeScaleFactor = ma_find_default_buffer_size_scale__alsa(DESC);
foundDevice = MA_TRUE;
}
}

free(NAME);
free(DESC);
free(IOID);
ppNextDeviceHint += 1;

if (foundDevice) {
break;
}
}

((ma_snd_device_name_free_hint_proc)pContext->alsa.snd_device_name_free_hint)((void**)ppDeviceHints);
} else {
bufferSizeScaleFactor = ma_find_default_buffer_size_scale__alsa(deviceName);
}
}
}

ma__free_from_callbacks(pInfo, &pContext->allocationCallbacks);
}



pHWParams = (ma_snd_pcm_hw_params_t*)ma__calloc_from_callbacks(((ma_snd_pcm_hw_params_sizeof_proc)pContext->alsa.snd_pcm_hw_params_sizeof)(), &pContext->allocationCallbacks);
if (pHWParams == NULL) {
return MA_OUT_OF_MEMORY;
}

if (((ma_snd_pcm_hw_params_any_proc)pContext->alsa.snd_pcm_hw_params_any)(pPCM, pHWParams) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize hardware parameters. snd_pcm_hw_params_any() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}


isUsingMMap = MA_FALSE;
#if 0 
if (deviceType != ma_device_type_capture) { 
if (!pConfig->alsa.noMMap && ma_device__is_async(pDevice)) {
if (((ma_snd_pcm_hw_params_set_access_proc)pContext->alsa.snd_pcm_hw_params_set_access)(pPCM, pHWParams, MA_SND_PCM_ACCESS_MMAP_INTERLEAVED) == 0) {
pDevice->alsa.isUsingMMap = MA_TRUE;
}
}
}
#endif

if (!isUsingMMap) {
if (((ma_snd_pcm_hw_params_set_access_proc)pContext->alsa.snd_pcm_hw_params_set_access)(pPCM, pHWParams, MA_SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set access mode to neither SND_PCM_ACCESS_MMAP_INTERLEAVED nor SND_PCM_ACCESS_RW_INTERLEAVED. snd_pcm_hw_params_set_access() failed.", MA_FORMAT_NOT_SUPPORTED);
}
}







{
ma_snd_pcm_format_mask_t* pFormatMask;


pFormatMask = (ma_snd_pcm_format_mask_t*)ma__calloc_from_callbacks(((ma_snd_pcm_format_mask_sizeof_proc)pContext->alsa.snd_pcm_format_mask_sizeof)(), &pContext->allocationCallbacks);
if (pFormatMask == NULL) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return MA_OUT_OF_MEMORY;
}

((ma_snd_pcm_hw_params_get_format_mask_proc)pContext->alsa.snd_pcm_hw_params_get_format_mask)(pHWParams, pFormatMask);





if (!((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, formatALSA)) {
size_t i;


ma_snd_pcm_format_t preferredFormatsALSA[] = {
MA_SND_PCM_FORMAT_S16_LE, 
MA_SND_PCM_FORMAT_FLOAT_LE, 
MA_SND_PCM_FORMAT_S32_LE, 
MA_SND_PCM_FORMAT_S24_3LE, 
MA_SND_PCM_FORMAT_U8 
};

if (ma_is_big_endian()) {
preferredFormatsALSA[0] = MA_SND_PCM_FORMAT_S16_BE;
preferredFormatsALSA[1] = MA_SND_PCM_FORMAT_FLOAT_BE;
preferredFormatsALSA[2] = MA_SND_PCM_FORMAT_S32_BE;
preferredFormatsALSA[3] = MA_SND_PCM_FORMAT_S24_3BE;
preferredFormatsALSA[4] = MA_SND_PCM_FORMAT_U8;
}

formatALSA = MA_SND_PCM_FORMAT_UNKNOWN;
for (i = 0; i < (sizeof(preferredFormatsALSA) / sizeof(preferredFormatsALSA[0])); ++i) {
if (((ma_snd_pcm_format_mask_test_proc)pContext->alsa.snd_pcm_format_mask_test)(pFormatMask, preferredFormatsALSA[i])) {
formatALSA = preferredFormatsALSA[i];
break;
}
}

if (formatALSA == MA_SND_PCM_FORMAT_UNKNOWN) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Format not supported. The device does not support any miniaudio formats.", MA_FORMAT_NOT_SUPPORTED);
}
}

ma__free_from_callbacks(pFormatMask, &pContext->allocationCallbacks);
pFormatMask = NULL;

if (((ma_snd_pcm_hw_params_set_format_proc)pContext->alsa.snd_pcm_hw_params_set_format)(pPCM, pHWParams, formatALSA) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Format not supported. snd_pcm_hw_params_set_format() failed.", MA_FORMAT_NOT_SUPPORTED);
}

internalFormat = ma_format_from_alsa(formatALSA);
if (internalFormat == ma_format_unknown) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] The chosen format is not supported by miniaudio.", MA_FORMAT_NOT_SUPPORTED);
}
}


{
unsigned int channels = (deviceType == ma_device_type_capture) ? pConfig->capture.channels : pConfig->playback.channels;
if (((ma_snd_pcm_hw_params_set_channels_near_proc)pContext->alsa.snd_pcm_hw_params_set_channels_near)(pPCM, pHWParams, &channels) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set channel count. snd_pcm_hw_params_set_channels_near() failed.", MA_FORMAT_NOT_SUPPORTED);
}
internalChannels = (ma_uint32)channels;
}


{
unsigned int sampleRate;


















((ma_snd_pcm_hw_params_set_rate_resample_proc)pContext->alsa.snd_pcm_hw_params_set_rate_resample)(pPCM, pHWParams, 0);

sampleRate = pConfig->sampleRate;
if (((ma_snd_pcm_hw_params_set_rate_near_proc)pContext->alsa.snd_pcm_hw_params_set_rate_near)(pPCM, pHWParams, &sampleRate, 0) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Sample rate not supported. snd_pcm_hw_params_set_rate_near() failed.", MA_FORMAT_NOT_SUPPORTED);
}
internalSampleRate = (ma_uint32)sampleRate;
}


{
ma_uint32 periods = pConfig->periods;
if (((ma_snd_pcm_hw_params_set_periods_near_proc)pContext->alsa.snd_pcm_hw_params_set_periods_near)(pPCM, pHWParams, &periods, NULL) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set period count. snd_pcm_hw_params_set_periods_near() failed.", MA_FORMAT_NOT_SUPPORTED);
}
internalPeriods = periods;
}


{
ma_snd_pcm_uframes_t actualBufferSizeInFrames = pConfig->periodSizeInFrames * internalPeriods;
if (actualBufferSizeInFrames == 0) {
actualBufferSizeInFrames = ma_scale_buffer_size(ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, internalSampleRate), bufferSizeScaleFactor) * internalPeriods;
}

if (((ma_snd_pcm_hw_params_set_buffer_size_near_proc)pContext->alsa.snd_pcm_hw_params_set_buffer_size_near)(pPCM, pHWParams, &actualBufferSizeInFrames) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set buffer size for device. snd_pcm_hw_params_set_buffer_size() failed.", MA_FORMAT_NOT_SUPPORTED);
}
internalPeriodSizeInFrames = actualBufferSizeInFrames / internalPeriods;
}


if (((ma_snd_pcm_hw_params_proc)pContext->alsa.snd_pcm_hw_params)(pPCM, pHWParams) < 0) {
ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set hardware parameters. snd_pcm_hw_params() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}

ma__free_from_callbacks(pHWParams, &pContext->allocationCallbacks);
pHWParams = NULL;



pSWParams = (ma_snd_pcm_sw_params_t*)ma__calloc_from_callbacks(((ma_snd_pcm_sw_params_sizeof_proc)pContext->alsa.snd_pcm_sw_params_sizeof)(), &pContext->allocationCallbacks);
if (pSWParams == NULL) {
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return MA_OUT_OF_MEMORY;
}

if (((ma_snd_pcm_sw_params_current_proc)pContext->alsa.snd_pcm_sw_params_current)(pPCM, pSWParams) != 0) {
ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to initialize software parameters. snd_pcm_sw_params_current() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}

if (((ma_snd_pcm_sw_params_set_avail_min_proc)pContext->alsa.snd_pcm_sw_params_set_avail_min)(pPCM, pSWParams, ma_prev_power_of_2(internalPeriodSizeInFrames)) != 0) {
ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] snd_pcm_sw_params_set_avail_min() failed.", MA_FORMAT_NOT_SUPPORTED);
}

if (((ma_snd_pcm_sw_params_get_boundary_proc)pContext->alsa.snd_pcm_sw_params_get_boundary)(pSWParams, &bufferBoundary) < 0) {
bufferBoundary = internalPeriodSizeInFrames * internalPeriods;
}



if (deviceType == ma_device_type_playback && !isUsingMMap) { 




if (((ma_snd_pcm_sw_params_set_start_threshold_proc)pContext->alsa.snd_pcm_sw_params_set_start_threshold)(pPCM, pSWParams, internalPeriodSizeInFrames*2) != 0) {
ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set start threshold for playback device. snd_pcm_sw_params_set_start_threshold() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}
if (((ma_snd_pcm_sw_params_set_stop_threshold_proc)pContext->alsa.snd_pcm_sw_params_set_stop_threshold)(pPCM, pSWParams, bufferBoundary) != 0) { 
ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set stop threshold for playback device. snd_pcm_sw_params_set_stop_threshold() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}
}

if (((ma_snd_pcm_sw_params_proc)pContext->alsa.snd_pcm_sw_params)(pPCM, pSWParams) != 0) {
ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to set software parameters. snd_pcm_sw_params() failed.", MA_FAILED_TO_CONFIGURE_BACKEND_DEVICE);
}

ma__free_from_callbacks(pSWParams, &pContext->allocationCallbacks);
pSWParams = NULL;



{
ma_snd_pcm_chmap_t* pChmap = ((ma_snd_pcm_get_chmap_proc)pContext->alsa.snd_pcm_get_chmap)(pPCM);
if (pChmap != NULL) {
ma_uint32 iChannel;


if (pChmap->channels >= internalChannels) {

for (iChannel = 0; iChannel < internalChannels; ++iChannel) {
internalChannelMap[iChannel] = ma_convert_alsa_channel_position_to_ma_channel(pChmap->pos[iChannel]);
}
} else {
ma_uint32 i;





ma_bool32 isValid = MA_TRUE;


ma_get_standard_channel_map(ma_standard_channel_map_alsa, internalChannels, internalChannelMap);


for (iChannel = 0; iChannel < pChmap->channels; ++iChannel) {
internalChannelMap[iChannel] = ma_convert_alsa_channel_position_to_ma_channel(pChmap->pos[iChannel]);
}


for (i = 0; i < internalChannels && isValid; ++i) {
ma_uint32 j;
for (j = i+1; j < internalChannels; ++j) {
if (internalChannelMap[i] == internalChannelMap[j]) {
isValid = MA_FALSE;
break;
}
}
}


if (!isValid) {
ma_get_standard_channel_map(ma_standard_channel_map_alsa, internalChannels, internalChannelMap);
}
}

free(pChmap);
pChmap = NULL;
} else {

ma_get_standard_channel_map(ma_standard_channel_map_alsa, internalChannels, internalChannelMap);
}
}



if (((ma_snd_pcm_prepare_proc)pDevice->pContext->alsa.snd_pcm_prepare)(pPCM) < 0) {
((ma_snd_pcm_close_proc)pDevice->pContext->alsa.snd_pcm_close)(pPCM);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to prepare device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}


if (deviceType == ma_device_type_capture) {
pDevice->alsa.pPCMCapture = (ma_ptr)pPCM;
pDevice->alsa.isUsingMMapCapture = isUsingMMap;
pDevice->capture.internalFormat = internalFormat;
pDevice->capture.internalChannels = internalChannels;
pDevice->capture.internalSampleRate = internalSampleRate;
ma_channel_map_copy(pDevice->capture.internalChannelMap, internalChannelMap, internalChannels);
pDevice->capture.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->capture.internalPeriods = internalPeriods;
} else {
pDevice->alsa.pPCMPlayback = (ma_ptr)pPCM;
pDevice->alsa.isUsingMMapPlayback = isUsingMMap;
pDevice->playback.internalFormat = internalFormat;
pDevice->playback.internalChannels = internalChannels;
pDevice->playback.internalSampleRate = internalSampleRate;
ma_channel_map_copy(pDevice->playback.internalChannelMap, internalChannelMap, internalChannels);
pDevice->playback.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->playback.internalPeriods = internalPeriods;
}

return MA_SUCCESS;
}

static ma_result ma_device_init__alsa(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->alsa);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_by_type__alsa(pContext, pConfig, ma_device_type_capture, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_by_type__alsa(pContext, pConfig, ma_device_type_playback, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_read__alsa(ma_device* pDevice, void* pFramesOut, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
ma_snd_pcm_sframes_t resultALSA;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pFramesOut != NULL);

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

for (;;) {
resultALSA = ((ma_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture, pFramesOut, frameCount);
if (resultALSA >= 0) {
break; 
} else {
if (resultALSA == -EAGAIN) {

continue; 
} else if (resultALSA == -EPIPE) {
#if defined(MA_DEBUG_OUTPUT)
printf("TRACE: EPIPE (read)\n");
#endif


if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture, resultALSA, MA_TRUE) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after overrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
}

if (((ma_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to start device after underrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
}

resultALSA = ((ma_snd_pcm_readi_proc)pDevice->pContext->alsa.snd_pcm_readi)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture, pFramesOut, frameCount);
if (resultALSA < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to read data from the internal device.", MA_FAILED_TO_READ_DATA_FROM_DEVICE);
}
}
}
}

if (pFramesRead != NULL) {
*pFramesRead = resultALSA;
}

return MA_SUCCESS;
}

static ma_result ma_device_write__alsa(ma_device* pDevice, const void* pFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
ma_snd_pcm_sframes_t resultALSA;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pFrames != NULL);

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

for (;;) {
resultALSA = ((ma_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback, pFrames, frameCount);
if (resultALSA >= 0) {
break; 
} else {
if (resultALSA == -EAGAIN) {

continue; 
} else if (resultALSA == -EPIPE) {
#if defined(MA_DEBUG_OUTPUT)
printf("TRACE: EPIPE (write)\n");
#endif


if (((ma_snd_pcm_recover_proc)pDevice->pContext->alsa.snd_pcm_recover)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback, resultALSA, MA_TRUE) < 0) { 
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to recover device after underrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
}








if (((ma_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to start device after underrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
}

resultALSA = ((ma_snd_pcm_writei_proc)pDevice->pContext->alsa.snd_pcm_writei)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback, pFrames, frameCount);
if (resultALSA < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to write data to device after underrun.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}
}
}

if (pFramesWritten != NULL) {
*pFramesWritten = resultALSA;
}

return MA_SUCCESS;
}

static ma_result ma_device_main_loop__alsa(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (((ma_snd_pcm_start_proc)pDevice->pContext->alsa.snd_pcm_start)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[ALSA] Failed to start device in preparation for reading.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}

while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{
if (pDevice->alsa.isUsingMMapCapture || pDevice->alsa.isUsingMMapPlayback) {

return MA_INVALID_OPERATION; 
} else {



ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__alsa(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__alsa(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
}
} break;

case ma_device_type_capture:
{
if (pDevice->alsa.isUsingMMapCapture) {

return MA_INVALID_OPERATION; 
} else {



ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__alsa(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
}
} break;

case ma_device_type_playback:
{
if (pDevice->alsa.isUsingMMapPlayback) {

return MA_INVALID_OPERATION; 
} else {



ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__alsa(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
}
} break;


case ma_device_type_loopback:
default: break;
} 
}


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_snd_pcm_drain_proc)pDevice->pContext->alsa.snd_pcm_drain)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture);


if (((ma_snd_pcm_prepare_proc)pDevice->pContext->alsa.snd_pcm_prepare)((ma_snd_pcm_t*)pDevice->alsa.pPCMCapture) < 0) {
#if defined(MA_DEBUG_OUTPUT)
printf("[ALSA] Failed to prepare capture device after stopping.\n");
#endif
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
((ma_snd_pcm_drain_proc)pDevice->pContext->alsa.snd_pcm_drain)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback);


if (((ma_snd_pcm_prepare_proc)pDevice->pContext->alsa.snd_pcm_prepare)((ma_snd_pcm_t*)pDevice->alsa.pPCMPlayback) < 0) {
#if defined(MA_DEBUG_OUTPUT)
printf("[ALSA] Failed to prepare playback device after stopping.\n");
#endif
}
}

return result;
}

static ma_result ma_context_uninit__alsa(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_alsa);


((ma_snd_config_update_free_global_proc)pContext->alsa.snd_config_update_free_global)();

#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->alsa.asoundSO);
#endif

ma_mutex_uninit(&pContext->alsa.internalDeviceEnumLock);

return MA_SUCCESS;
}

static ma_result ma_context_init__alsa(const ma_context_config* pConfig, ma_context* pContext)
{
#if !defined(MA_NO_RUNTIME_LINKING)
const char* libasoundNames[] = {
"libasound.so.2",
"libasound.so"
};
size_t i;

for (i = 0; i < ma_countof(libasoundNames); ++i) {
pContext->alsa.asoundSO = ma_dlopen(pContext, libasoundNames[i]);
if (pContext->alsa.asoundSO != NULL) {
break;
}
}

if (pContext->alsa.asoundSO == NULL) {
#if defined(MA_DEBUG_OUTPUT)
printf("[ALSA] Failed to open shared object.\n");
#endif
return MA_NO_BACKEND;
}

pContext->alsa.snd_pcm_open = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_open");
pContext->alsa.snd_pcm_close = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_close");
pContext->alsa.snd_pcm_hw_params_sizeof = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_sizeof");
pContext->alsa.snd_pcm_hw_params_any = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_any");
pContext->alsa.snd_pcm_hw_params_set_format = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_format");
pContext->alsa.snd_pcm_hw_params_set_format_first = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_format_first");
pContext->alsa.snd_pcm_hw_params_get_format_mask = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_format_mask");
pContext->alsa.snd_pcm_hw_params_set_channels_near = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_channels_near");
pContext->alsa.snd_pcm_hw_params_set_rate_resample = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_rate_resample");
pContext->alsa.snd_pcm_hw_params_set_rate_near = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_rate_near");
pContext->alsa.snd_pcm_hw_params_set_buffer_size_near = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_buffer_size_near");
pContext->alsa.snd_pcm_hw_params_set_periods_near = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_periods_near");
pContext->alsa.snd_pcm_hw_params_set_access = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_set_access");
pContext->alsa.snd_pcm_hw_params_get_format = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_format");
pContext->alsa.snd_pcm_hw_params_get_channels = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels");
pContext->alsa.snd_pcm_hw_params_get_channels_min = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels_min");
pContext->alsa.snd_pcm_hw_params_get_channels_max = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_channels_max");
pContext->alsa.snd_pcm_hw_params_get_rate = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate");
pContext->alsa.snd_pcm_hw_params_get_rate_min = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate_min");
pContext->alsa.snd_pcm_hw_params_get_rate_max = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_rate_max");
pContext->alsa.snd_pcm_hw_params_get_buffer_size = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_buffer_size");
pContext->alsa.snd_pcm_hw_params_get_periods = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_periods");
pContext->alsa.snd_pcm_hw_params_get_access = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params_get_access");
pContext->alsa.snd_pcm_hw_params = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_hw_params");
pContext->alsa.snd_pcm_sw_params_sizeof = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_sizeof");
pContext->alsa.snd_pcm_sw_params_current = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_current");
pContext->alsa.snd_pcm_sw_params_get_boundary = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_get_boundary");
pContext->alsa.snd_pcm_sw_params_set_avail_min = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_set_avail_min");
pContext->alsa.snd_pcm_sw_params_set_start_threshold = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_set_start_threshold");
pContext->alsa.snd_pcm_sw_params_set_stop_threshold = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params_set_stop_threshold");
pContext->alsa.snd_pcm_sw_params = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_sw_params");
pContext->alsa.snd_pcm_format_mask_sizeof = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_format_mask_sizeof");
pContext->alsa.snd_pcm_format_mask_test = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_format_mask_test");
pContext->alsa.snd_pcm_get_chmap = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_get_chmap");
pContext->alsa.snd_pcm_state = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_state");
pContext->alsa.snd_pcm_prepare = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_prepare");
pContext->alsa.snd_pcm_start = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_start");
pContext->alsa.snd_pcm_drop = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_drop");
pContext->alsa.snd_pcm_drain = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_drain");
pContext->alsa.snd_device_name_hint = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_device_name_hint");
pContext->alsa.snd_device_name_get_hint = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_device_name_get_hint");
pContext->alsa.snd_card_get_index = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_card_get_index");
pContext->alsa.snd_device_name_free_hint = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_device_name_free_hint");
pContext->alsa.snd_pcm_mmap_begin = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_mmap_begin");
pContext->alsa.snd_pcm_mmap_commit = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_mmap_commit");
pContext->alsa.snd_pcm_recover = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_recover");
pContext->alsa.snd_pcm_readi = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_readi");
pContext->alsa.snd_pcm_writei = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_writei");
pContext->alsa.snd_pcm_avail = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_avail");
pContext->alsa.snd_pcm_avail_update = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_avail_update");
pContext->alsa.snd_pcm_wait = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_wait");
pContext->alsa.snd_pcm_info = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_info");
pContext->alsa.snd_pcm_info_sizeof = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_info_sizeof");
pContext->alsa.snd_pcm_info_get_name = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_pcm_info_get_name");
pContext->alsa.snd_config_update_free_global = (ma_proc)ma_dlsym(pContext, pContext->alsa.asoundSO, "snd_config_update_free_global");
#else

ma_snd_pcm_open_proc _snd_pcm_open = snd_pcm_open;
ma_snd_pcm_close_proc _snd_pcm_close = snd_pcm_close;
ma_snd_pcm_hw_params_sizeof_proc _snd_pcm_hw_params_sizeof = snd_pcm_hw_params_sizeof;
ma_snd_pcm_hw_params_any_proc _snd_pcm_hw_params_any = snd_pcm_hw_params_any;
ma_snd_pcm_hw_params_set_format_proc _snd_pcm_hw_params_set_format = snd_pcm_hw_params_set_format;
ma_snd_pcm_hw_params_set_format_first_proc _snd_pcm_hw_params_set_format_first = snd_pcm_hw_params_set_format_first;
ma_snd_pcm_hw_params_get_format_mask_proc _snd_pcm_hw_params_get_format_mask = snd_pcm_hw_params_get_format_mask;
ma_snd_pcm_hw_params_set_channels_near_proc _snd_pcm_hw_params_set_channels_near = snd_pcm_hw_params_set_channels_near;
ma_snd_pcm_hw_params_set_rate_resample_proc _snd_pcm_hw_params_set_rate_resample = snd_pcm_hw_params_set_rate_resample;
ma_snd_pcm_hw_params_set_rate_near_proc _snd_pcm_hw_params_set_rate_near = snd_pcm_hw_params_set_rate_near;
ma_snd_pcm_hw_params_set_buffer_size_near_proc _snd_pcm_hw_params_set_buffer_size_near = snd_pcm_hw_params_set_buffer_size_near;
ma_snd_pcm_hw_params_set_periods_near_proc _snd_pcm_hw_params_set_periods_near = snd_pcm_hw_params_set_periods_near;
ma_snd_pcm_hw_params_set_access_proc _snd_pcm_hw_params_set_access = snd_pcm_hw_params_set_access;
ma_snd_pcm_hw_params_get_format_proc _snd_pcm_hw_params_get_format = snd_pcm_hw_params_get_format;
ma_snd_pcm_hw_params_get_channels_proc _snd_pcm_hw_params_get_channels = snd_pcm_hw_params_get_channels;
ma_snd_pcm_hw_params_get_channels_min_proc _snd_pcm_hw_params_get_channels_min = snd_pcm_hw_params_get_channels_min;
ma_snd_pcm_hw_params_get_channels_max_proc _snd_pcm_hw_params_get_channels_max = snd_pcm_hw_params_get_channels_max;
ma_snd_pcm_hw_params_get_rate_proc _snd_pcm_hw_params_get_rate = snd_pcm_hw_params_get_rate;
ma_snd_pcm_hw_params_get_rate_min_proc _snd_pcm_hw_params_get_rate_min = snd_pcm_hw_params_get_rate_min;
ma_snd_pcm_hw_params_get_rate_max_proc _snd_pcm_hw_params_get_rate_max = snd_pcm_hw_params_get_rate_max;
ma_snd_pcm_hw_params_get_buffer_size_proc _snd_pcm_hw_params_get_buffer_size = snd_pcm_hw_params_get_buffer_size;
ma_snd_pcm_hw_params_get_periods_proc _snd_pcm_hw_params_get_periods = snd_pcm_hw_params_get_periods;
ma_snd_pcm_hw_params_get_access_proc _snd_pcm_hw_params_get_access = snd_pcm_hw_params_get_access;
ma_snd_pcm_hw_params_proc _snd_pcm_hw_params = snd_pcm_hw_params;
ma_snd_pcm_sw_params_sizeof_proc _snd_pcm_sw_params_sizeof = snd_pcm_sw_params_sizeof;
ma_snd_pcm_sw_params_current_proc _snd_pcm_sw_params_current = snd_pcm_sw_params_current;
ma_snd_pcm_sw_params_get_boundary_proc _snd_pcm_sw_params_get_boundary = snd_pcm_sw_params_get_boundary;
ma_snd_pcm_sw_params_set_avail_min_proc _snd_pcm_sw_params_set_avail_min = snd_pcm_sw_params_set_avail_min;
ma_snd_pcm_sw_params_set_start_threshold_proc _snd_pcm_sw_params_set_start_threshold = snd_pcm_sw_params_set_start_threshold;
ma_snd_pcm_sw_params_set_stop_threshold_proc _snd_pcm_sw_params_set_stop_threshold = snd_pcm_sw_params_set_stop_threshold;
ma_snd_pcm_sw_params_proc _snd_pcm_sw_params = snd_pcm_sw_params;
ma_snd_pcm_format_mask_sizeof_proc _snd_pcm_format_mask_sizeof = snd_pcm_format_mask_sizeof;
ma_snd_pcm_format_mask_test_proc _snd_pcm_format_mask_test = snd_pcm_format_mask_test;
ma_snd_pcm_get_chmap_proc _snd_pcm_get_chmap = snd_pcm_get_chmap;
ma_snd_pcm_state_proc _snd_pcm_state = snd_pcm_state;
ma_snd_pcm_prepare_proc _snd_pcm_prepare = snd_pcm_prepare;
ma_snd_pcm_start_proc _snd_pcm_start = snd_pcm_start;
ma_snd_pcm_drop_proc _snd_pcm_drop = snd_pcm_drop;
ma_snd_pcm_drain_proc _snd_pcm_drain = snd_pcm_drain;
ma_snd_device_name_hint_proc _snd_device_name_hint = snd_device_name_hint;
ma_snd_device_name_get_hint_proc _snd_device_name_get_hint = snd_device_name_get_hint;
ma_snd_card_get_index_proc _snd_card_get_index = snd_card_get_index;
ma_snd_device_name_free_hint_proc _snd_device_name_free_hint = snd_device_name_free_hint;
ma_snd_pcm_mmap_begin_proc _snd_pcm_mmap_begin = snd_pcm_mmap_begin;
ma_snd_pcm_mmap_commit_proc _snd_pcm_mmap_commit = snd_pcm_mmap_commit;
ma_snd_pcm_recover_proc _snd_pcm_recover = snd_pcm_recover;
ma_snd_pcm_readi_proc _snd_pcm_readi = snd_pcm_readi;
ma_snd_pcm_writei_proc _snd_pcm_writei = snd_pcm_writei;
ma_snd_pcm_avail_proc _snd_pcm_avail = snd_pcm_avail;
ma_snd_pcm_avail_update_proc _snd_pcm_avail_update = snd_pcm_avail_update;
ma_snd_pcm_wait_proc _snd_pcm_wait = snd_pcm_wait;
ma_snd_pcm_info_proc _snd_pcm_info = snd_pcm_info;
ma_snd_pcm_info_sizeof_proc _snd_pcm_info_sizeof = snd_pcm_info_sizeof;
ma_snd_pcm_info_get_name_proc _snd_pcm_info_get_name = snd_pcm_info_get_name;
ma_snd_config_update_free_global_proc _snd_config_update_free_global = snd_config_update_free_global;

pContext->alsa.snd_pcm_open = (ma_proc)_snd_pcm_open;
pContext->alsa.snd_pcm_close = (ma_proc)_snd_pcm_close;
pContext->alsa.snd_pcm_hw_params_sizeof = (ma_proc)_snd_pcm_hw_params_sizeof;
pContext->alsa.snd_pcm_hw_params_any = (ma_proc)_snd_pcm_hw_params_any;
pContext->alsa.snd_pcm_hw_params_set_format = (ma_proc)_snd_pcm_hw_params_set_format;
pContext->alsa.snd_pcm_hw_params_set_format_first = (ma_proc)_snd_pcm_hw_params_set_format_first;
pContext->alsa.snd_pcm_hw_params_get_format_mask = (ma_proc)_snd_pcm_hw_params_get_format_mask;
pContext->alsa.snd_pcm_hw_params_set_channels_near = (ma_proc)_snd_pcm_hw_params_set_channels_near;
pContext->alsa.snd_pcm_hw_params_set_rate_resample = (ma_proc)_snd_pcm_hw_params_set_rate_resample;
pContext->alsa.snd_pcm_hw_params_set_rate_near = (ma_proc)_snd_pcm_hw_params_set_rate_near;
pContext->alsa.snd_pcm_hw_params_set_buffer_size_near = (ma_proc)_snd_pcm_hw_params_set_buffer_size_near;
pContext->alsa.snd_pcm_hw_params_set_periods_near = (ma_proc)_snd_pcm_hw_params_set_periods_near;
pContext->alsa.snd_pcm_hw_params_set_access = (ma_proc)_snd_pcm_hw_params_set_access;
pContext->alsa.snd_pcm_hw_params_get_format = (ma_proc)_snd_pcm_hw_params_get_format;
pContext->alsa.snd_pcm_hw_params_get_channels = (ma_proc)_snd_pcm_hw_params_get_channels;
pContext->alsa.snd_pcm_hw_params_get_channels_min = (ma_proc)_snd_pcm_hw_params_get_channels_min;
pContext->alsa.snd_pcm_hw_params_get_channels_max = (ma_proc)_snd_pcm_hw_params_get_channels_max;
pContext->alsa.snd_pcm_hw_params_get_rate = (ma_proc)_snd_pcm_hw_params_get_rate;
pContext->alsa.snd_pcm_hw_params_get_buffer_size = (ma_proc)_snd_pcm_hw_params_get_buffer_size;
pContext->alsa.snd_pcm_hw_params_get_periods = (ma_proc)_snd_pcm_hw_params_get_periods;
pContext->alsa.snd_pcm_hw_params_get_access = (ma_proc)_snd_pcm_hw_params_get_access;
pContext->alsa.snd_pcm_hw_params = (ma_proc)_snd_pcm_hw_params;
pContext->alsa.snd_pcm_sw_params_sizeof = (ma_proc)_snd_pcm_sw_params_sizeof;
pContext->alsa.snd_pcm_sw_params_current = (ma_proc)_snd_pcm_sw_params_current;
pContext->alsa.snd_pcm_sw_params_get_boundary = (ma_proc)_snd_pcm_sw_params_get_boundary;
pContext->alsa.snd_pcm_sw_params_set_avail_min = (ma_proc)_snd_pcm_sw_params_set_avail_min;
pContext->alsa.snd_pcm_sw_params_set_start_threshold = (ma_proc)_snd_pcm_sw_params_set_start_threshold;
pContext->alsa.snd_pcm_sw_params_set_stop_threshold = (ma_proc)_snd_pcm_sw_params_set_stop_threshold;
pContext->alsa.snd_pcm_sw_params = (ma_proc)_snd_pcm_sw_params;
pContext->alsa.snd_pcm_format_mask_sizeof = (ma_proc)_snd_pcm_format_mask_sizeof;
pContext->alsa.snd_pcm_format_mask_test = (ma_proc)_snd_pcm_format_mask_test;
pContext->alsa.snd_pcm_get_chmap = (ma_proc)_snd_pcm_get_chmap;
pContext->alsa.snd_pcm_state = (ma_proc)_snd_pcm_state;
pContext->alsa.snd_pcm_prepare = (ma_proc)_snd_pcm_prepare;
pContext->alsa.snd_pcm_start = (ma_proc)_snd_pcm_start;
pContext->alsa.snd_pcm_drop = (ma_proc)_snd_pcm_drop;
pContext->alsa.snd_pcm_drain = (ma_proc)_snd_pcm_drain;
pContext->alsa.snd_device_name_hint = (ma_proc)_snd_device_name_hint;
pContext->alsa.snd_device_name_get_hint = (ma_proc)_snd_device_name_get_hint;
pContext->alsa.snd_card_get_index = (ma_proc)_snd_card_get_index;
pContext->alsa.snd_device_name_free_hint = (ma_proc)_snd_device_name_free_hint;
pContext->alsa.snd_pcm_mmap_begin = (ma_proc)_snd_pcm_mmap_begin;
pContext->alsa.snd_pcm_mmap_commit = (ma_proc)_snd_pcm_mmap_commit;
pContext->alsa.snd_pcm_recover = (ma_proc)_snd_pcm_recover;
pContext->alsa.snd_pcm_readi = (ma_proc)_snd_pcm_readi;
pContext->alsa.snd_pcm_writei = (ma_proc)_snd_pcm_writei;
pContext->alsa.snd_pcm_avail = (ma_proc)_snd_pcm_avail;
pContext->alsa.snd_pcm_avail_update = (ma_proc)_snd_pcm_avail_update;
pContext->alsa.snd_pcm_wait = (ma_proc)_snd_pcm_wait;
pContext->alsa.snd_pcm_info = (ma_proc)_snd_pcm_info;
pContext->alsa.snd_pcm_info_sizeof = (ma_proc)_snd_pcm_info_sizeof;
pContext->alsa.snd_pcm_info_get_name = (ma_proc)_snd_pcm_info_get_name;
pContext->alsa.snd_config_update_free_global = (ma_proc)_snd_config_update_free_global;
#endif

pContext->alsa.useVerboseDeviceEnumeration = pConfig->alsa.useVerboseDeviceEnumeration;

if (ma_mutex_init(pContext, &pContext->alsa.internalDeviceEnumLock) != MA_SUCCESS) {
ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[ALSA] WARNING: Failed to initialize mutex for internal device enumeration.", MA_ERROR);
}

pContext->onUninit = ma_context_uninit__alsa;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__alsa;
pContext->onEnumDevices = ma_context_enumerate_devices__alsa;
pContext->onGetDeviceInfo = ma_context_get_device_info__alsa;
pContext->onDeviceInit = ma_device_init__alsa;
pContext->onDeviceUninit = ma_device_uninit__alsa;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__alsa;

return MA_SUCCESS;
}
#endif 








#if defined(MA_HAS_PULSEAUDIO)







#if defined(MA_NO_RUNTIME_LINKING)
#include <pulse/pulseaudio.h>

#define MA_PA_OK PA_OK
#define MA_PA_ERR_ACCESS PA_ERR_ACCESS
#define MA_PA_ERR_INVALID PA_ERR_INVALID
#define MA_PA_ERR_NOENTITY PA_ERR_NOENTITY

#define MA_PA_CHANNELS_MAX PA_CHANNELS_MAX
#define MA_PA_RATE_MAX PA_RATE_MAX

typedef pa_context_flags_t ma_pa_context_flags_t;
#define MA_PA_CONTEXT_NOFLAGS PA_CONTEXT_NOFLAGS
#define MA_PA_CONTEXT_NOAUTOSPAWN PA_CONTEXT_NOAUTOSPAWN
#define MA_PA_CONTEXT_NOFAIL PA_CONTEXT_NOFAIL

typedef pa_stream_flags_t ma_pa_stream_flags_t;
#define MA_PA_STREAM_NOFLAGS PA_STREAM_NOFLAGS
#define MA_PA_STREAM_START_CORKED PA_STREAM_START_CORKED
#define MA_PA_STREAM_INTERPOLATE_TIMING PA_STREAM_INTERPOLATE_TIMING
#define MA_PA_STREAM_NOT_MONOTONIC PA_STREAM_NOT_MONOTONIC
#define MA_PA_STREAM_AUTO_TIMING_UPDATE PA_STREAM_AUTO_TIMING_UPDATE
#define MA_PA_STREAM_NO_REMAP_CHANNELS PA_STREAM_NO_REMAP_CHANNELS
#define MA_PA_STREAM_NO_REMIX_CHANNELS PA_STREAM_NO_REMIX_CHANNELS
#define MA_PA_STREAM_FIX_FORMAT PA_STREAM_FIX_FORMAT
#define MA_PA_STREAM_FIX_RATE PA_STREAM_FIX_RATE
#define MA_PA_STREAM_FIX_CHANNELS PA_STREAM_FIX_CHANNELS
#define MA_PA_STREAM_DONT_MOVE PA_STREAM_DONT_MOVE
#define MA_PA_STREAM_VARIABLE_RATE PA_STREAM_VARIABLE_RATE
#define MA_PA_STREAM_PEAK_DETECT PA_STREAM_PEAK_DETECT
#define MA_PA_STREAM_START_MUTED PA_STREAM_START_MUTED
#define MA_PA_STREAM_ADJUST_LATENCY PA_STREAM_ADJUST_LATENCY
#define MA_PA_STREAM_EARLY_REQUESTS PA_STREAM_EARLY_REQUESTS
#define MA_PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND
#define MA_PA_STREAM_START_UNMUTED PA_STREAM_START_UNMUTED
#define MA_PA_STREAM_FAIL_ON_SUSPEND PA_STREAM_FAIL_ON_SUSPEND
#define MA_PA_STREAM_RELATIVE_VOLUME PA_STREAM_RELATIVE_VOLUME
#define MA_PA_STREAM_PASSTHROUGH PA_STREAM_PASSTHROUGH

typedef pa_sink_flags_t ma_pa_sink_flags_t;
#define MA_PA_SINK_NOFLAGS PA_SINK_NOFLAGS
#define MA_PA_SINK_HW_VOLUME_CTRL PA_SINK_HW_VOLUME_CTRL
#define MA_PA_SINK_LATENCY PA_SINK_LATENCY
#define MA_PA_SINK_HARDWARE PA_SINK_HARDWARE
#define MA_PA_SINK_NETWORK PA_SINK_NETWORK
#define MA_PA_SINK_HW_MUTE_CTRL PA_SINK_HW_MUTE_CTRL
#define MA_PA_SINK_DECIBEL_VOLUME PA_SINK_DECIBEL_VOLUME
#define MA_PA_SINK_FLAT_VOLUME PA_SINK_FLAT_VOLUME
#define MA_PA_SINK_DYNAMIC_LATENCY PA_SINK_DYNAMIC_LATENCY
#define MA_PA_SINK_SET_FORMATS PA_SINK_SET_FORMATS

typedef pa_source_flags_t ma_pa_source_flags_t;
#define MA_PA_SOURCE_NOFLAGS PA_SOURCE_NOFLAGS
#define MA_PA_SOURCE_HW_VOLUME_CTRL PA_SOURCE_HW_VOLUME_CTRL
#define MA_PA_SOURCE_LATENCY PA_SOURCE_LATENCY
#define MA_PA_SOURCE_HARDWARE PA_SOURCE_HARDWARE
#define MA_PA_SOURCE_NETWORK PA_SOURCE_NETWORK
#define MA_PA_SOURCE_HW_MUTE_CTRL PA_SOURCE_HW_MUTE_CTRL
#define MA_PA_SOURCE_DECIBEL_VOLUME PA_SOURCE_DECIBEL_VOLUME
#define MA_PA_SOURCE_DYNAMIC_LATENCY PA_SOURCE_DYNAMIC_LATENCY
#define MA_PA_SOURCE_FLAT_VOLUME PA_SOURCE_FLAT_VOLUME

typedef pa_context_state_t ma_pa_context_state_t;
#define MA_PA_CONTEXT_UNCONNECTED PA_CONTEXT_UNCONNECTED
#define MA_PA_CONTEXT_CONNECTING PA_CONTEXT_CONNECTING
#define MA_PA_CONTEXT_AUTHORIZING PA_CONTEXT_AUTHORIZING
#define MA_PA_CONTEXT_SETTING_NAME PA_CONTEXT_SETTING_NAME
#define MA_PA_CONTEXT_READY PA_CONTEXT_READY
#define MA_PA_CONTEXT_FAILED PA_CONTEXT_FAILED
#define MA_PA_CONTEXT_TERMINATED PA_CONTEXT_TERMINATED

typedef pa_stream_state_t ma_pa_stream_state_t;
#define MA_PA_STREAM_UNCONNECTED PA_STREAM_UNCONNECTED
#define MA_PA_STREAM_CREATING PA_STREAM_CREATING
#define MA_PA_STREAM_READY PA_STREAM_READY
#define MA_PA_STREAM_FAILED PA_STREAM_FAILED
#define MA_PA_STREAM_TERMINATED PA_STREAM_TERMINATED

typedef pa_operation_state_t ma_pa_operation_state_t;
#define MA_PA_OPERATION_RUNNING PA_OPERATION_RUNNING
#define MA_PA_OPERATION_DONE PA_OPERATION_DONE
#define MA_PA_OPERATION_CANCELLED PA_OPERATION_CANCELLED

typedef pa_sink_state_t ma_pa_sink_state_t;
#define MA_PA_SINK_INVALID_STATE PA_SINK_INVALID_STATE
#define MA_PA_SINK_RUNNING PA_SINK_RUNNING
#define MA_PA_SINK_IDLE PA_SINK_IDLE
#define MA_PA_SINK_SUSPENDED PA_SINK_SUSPENDED

typedef pa_source_state_t ma_pa_source_state_t;
#define MA_PA_SOURCE_INVALID_STATE PA_SOURCE_INVALID_STATE
#define MA_PA_SOURCE_RUNNING PA_SOURCE_RUNNING
#define MA_PA_SOURCE_IDLE PA_SOURCE_IDLE
#define MA_PA_SOURCE_SUSPENDED PA_SOURCE_SUSPENDED

typedef pa_seek_mode_t ma_pa_seek_mode_t;
#define MA_PA_SEEK_RELATIVE PA_SEEK_RELATIVE
#define MA_PA_SEEK_ABSOLUTE PA_SEEK_ABSOLUTE
#define MA_PA_SEEK_RELATIVE_ON_READ PA_SEEK_RELATIVE_ON_READ
#define MA_PA_SEEK_RELATIVE_END PA_SEEK_RELATIVE_END

typedef pa_channel_position_t ma_pa_channel_position_t;
#define MA_PA_CHANNEL_POSITION_INVALID PA_CHANNEL_POSITION_INVALID
#define MA_PA_CHANNEL_POSITION_MONO PA_CHANNEL_POSITION_MONO
#define MA_PA_CHANNEL_POSITION_FRONT_LEFT PA_CHANNEL_POSITION_FRONT_LEFT
#define MA_PA_CHANNEL_POSITION_FRONT_RIGHT PA_CHANNEL_POSITION_FRONT_RIGHT
#define MA_PA_CHANNEL_POSITION_FRONT_CENTER PA_CHANNEL_POSITION_FRONT_CENTER
#define MA_PA_CHANNEL_POSITION_REAR_CENTER PA_CHANNEL_POSITION_REAR_CENTER
#define MA_PA_CHANNEL_POSITION_REAR_LEFT PA_CHANNEL_POSITION_REAR_LEFT
#define MA_PA_CHANNEL_POSITION_REAR_RIGHT PA_CHANNEL_POSITION_REAR_RIGHT
#define MA_PA_CHANNEL_POSITION_LFE PA_CHANNEL_POSITION_LFE
#define MA_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER
#define MA_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER
#define MA_PA_CHANNEL_POSITION_SIDE_LEFT PA_CHANNEL_POSITION_SIDE_LEFT
#define MA_PA_CHANNEL_POSITION_SIDE_RIGHT PA_CHANNEL_POSITION_SIDE_RIGHT
#define MA_PA_CHANNEL_POSITION_AUX0 PA_CHANNEL_POSITION_AUX0
#define MA_PA_CHANNEL_POSITION_AUX1 PA_CHANNEL_POSITION_AUX1
#define MA_PA_CHANNEL_POSITION_AUX2 PA_CHANNEL_POSITION_AUX2
#define MA_PA_CHANNEL_POSITION_AUX3 PA_CHANNEL_POSITION_AUX3
#define MA_PA_CHANNEL_POSITION_AUX4 PA_CHANNEL_POSITION_AUX4
#define MA_PA_CHANNEL_POSITION_AUX5 PA_CHANNEL_POSITION_AUX5
#define MA_PA_CHANNEL_POSITION_AUX6 PA_CHANNEL_POSITION_AUX6
#define MA_PA_CHANNEL_POSITION_AUX7 PA_CHANNEL_POSITION_AUX7
#define MA_PA_CHANNEL_POSITION_AUX8 PA_CHANNEL_POSITION_AUX8
#define MA_PA_CHANNEL_POSITION_AUX9 PA_CHANNEL_POSITION_AUX9
#define MA_PA_CHANNEL_POSITION_AUX10 PA_CHANNEL_POSITION_AUX10
#define MA_PA_CHANNEL_POSITION_AUX11 PA_CHANNEL_POSITION_AUX11
#define MA_PA_CHANNEL_POSITION_AUX12 PA_CHANNEL_POSITION_AUX12
#define MA_PA_CHANNEL_POSITION_AUX13 PA_CHANNEL_POSITION_AUX13
#define MA_PA_CHANNEL_POSITION_AUX14 PA_CHANNEL_POSITION_AUX14
#define MA_PA_CHANNEL_POSITION_AUX15 PA_CHANNEL_POSITION_AUX15
#define MA_PA_CHANNEL_POSITION_AUX16 PA_CHANNEL_POSITION_AUX16
#define MA_PA_CHANNEL_POSITION_AUX17 PA_CHANNEL_POSITION_AUX17
#define MA_PA_CHANNEL_POSITION_AUX18 PA_CHANNEL_POSITION_AUX18
#define MA_PA_CHANNEL_POSITION_AUX19 PA_CHANNEL_POSITION_AUX19
#define MA_PA_CHANNEL_POSITION_AUX20 PA_CHANNEL_POSITION_AUX20
#define MA_PA_CHANNEL_POSITION_AUX21 PA_CHANNEL_POSITION_AUX21
#define MA_PA_CHANNEL_POSITION_AUX22 PA_CHANNEL_POSITION_AUX22
#define MA_PA_CHANNEL_POSITION_AUX23 PA_CHANNEL_POSITION_AUX23
#define MA_PA_CHANNEL_POSITION_AUX24 PA_CHANNEL_POSITION_AUX24
#define MA_PA_CHANNEL_POSITION_AUX25 PA_CHANNEL_POSITION_AUX25
#define MA_PA_CHANNEL_POSITION_AUX26 PA_CHANNEL_POSITION_AUX26
#define MA_PA_CHANNEL_POSITION_AUX27 PA_CHANNEL_POSITION_AUX27
#define MA_PA_CHANNEL_POSITION_AUX28 PA_CHANNEL_POSITION_AUX28
#define MA_PA_CHANNEL_POSITION_AUX29 PA_CHANNEL_POSITION_AUX29
#define MA_PA_CHANNEL_POSITION_AUX30 PA_CHANNEL_POSITION_AUX30
#define MA_PA_CHANNEL_POSITION_AUX31 PA_CHANNEL_POSITION_AUX31
#define MA_PA_CHANNEL_POSITION_TOP_CENTER PA_CHANNEL_POSITION_TOP_CENTER
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_LEFT PA_CHANNEL_POSITION_TOP_FRONT_LEFT
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT PA_CHANNEL_POSITION_TOP_FRONT_RIGHT
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_CENTER PA_CHANNEL_POSITION_TOP_FRONT_CENTER
#define MA_PA_CHANNEL_POSITION_TOP_REAR_LEFT PA_CHANNEL_POSITION_TOP_REAR_LEFT
#define MA_PA_CHANNEL_POSITION_TOP_REAR_RIGHT PA_CHANNEL_POSITION_TOP_REAR_RIGHT
#define MA_PA_CHANNEL_POSITION_TOP_REAR_CENTER PA_CHANNEL_POSITION_TOP_REAR_CENTER
#define MA_PA_CHANNEL_POSITION_LEFT PA_CHANNEL_POSITION_LEFT
#define MA_PA_CHANNEL_POSITION_RIGHT PA_CHANNEL_POSITION_RIGHT
#define MA_PA_CHANNEL_POSITION_CENTER PA_CHANNEL_POSITION_CENTER
#define MA_PA_CHANNEL_POSITION_SUBWOOFER PA_CHANNEL_POSITION_SUBWOOFER

typedef pa_channel_map_def_t ma_pa_channel_map_def_t;
#define MA_PA_CHANNEL_MAP_AIFF PA_CHANNEL_MAP_AIFF
#define MA_PA_CHANNEL_MAP_ALSA PA_CHANNEL_MAP_ALSA
#define MA_PA_CHANNEL_MAP_AUX PA_CHANNEL_MAP_AUX
#define MA_PA_CHANNEL_MAP_WAVEEX PA_CHANNEL_MAP_WAVEEX
#define MA_PA_CHANNEL_MAP_OSS PA_CHANNEL_MAP_OSS
#define MA_PA_CHANNEL_MAP_DEFAULT PA_CHANNEL_MAP_DEFAULT

typedef pa_sample_format_t ma_pa_sample_format_t;
#define MA_PA_SAMPLE_INVALID PA_SAMPLE_INVALID
#define MA_PA_SAMPLE_U8 PA_SAMPLE_U8
#define MA_PA_SAMPLE_ALAW PA_SAMPLE_ALAW
#define MA_PA_SAMPLE_ULAW PA_SAMPLE_ULAW
#define MA_PA_SAMPLE_S16LE PA_SAMPLE_S16LE
#define MA_PA_SAMPLE_S16BE PA_SAMPLE_S16BE
#define MA_PA_SAMPLE_FLOAT32LE PA_SAMPLE_FLOAT32LE
#define MA_PA_SAMPLE_FLOAT32BE PA_SAMPLE_FLOAT32BE
#define MA_PA_SAMPLE_S32LE PA_SAMPLE_S32LE
#define MA_PA_SAMPLE_S32BE PA_SAMPLE_S32BE
#define MA_PA_SAMPLE_S24LE PA_SAMPLE_S24LE
#define MA_PA_SAMPLE_S24BE PA_SAMPLE_S24BE
#define MA_PA_SAMPLE_S24_32LE PA_SAMPLE_S24_32LE
#define MA_PA_SAMPLE_S24_32BE PA_SAMPLE_S24_32BE

typedef pa_mainloop ma_pa_mainloop;
typedef pa_mainloop_api ma_pa_mainloop_api;
typedef pa_context ma_pa_context;
typedef pa_operation ma_pa_operation;
typedef pa_stream ma_pa_stream;
typedef pa_spawn_api ma_pa_spawn_api;
typedef pa_buffer_attr ma_pa_buffer_attr;
typedef pa_channel_map ma_pa_channel_map;
typedef pa_cvolume ma_pa_cvolume;
typedef pa_sample_spec ma_pa_sample_spec;
typedef pa_sink_info ma_pa_sink_info;
typedef pa_source_info ma_pa_source_info;

typedef pa_context_notify_cb_t ma_pa_context_notify_cb_t;
typedef pa_sink_info_cb_t ma_pa_sink_info_cb_t;
typedef pa_source_info_cb_t ma_pa_source_info_cb_t;
typedef pa_stream_success_cb_t ma_pa_stream_success_cb_t;
typedef pa_stream_request_cb_t ma_pa_stream_request_cb_t;
typedef pa_free_cb_t ma_pa_free_cb_t;
#else
#define MA_PA_OK 0
#define MA_PA_ERR_ACCESS 1
#define MA_PA_ERR_INVALID 2
#define MA_PA_ERR_NOENTITY 5

#define MA_PA_CHANNELS_MAX 32
#define MA_PA_RATE_MAX 384000

typedef int ma_pa_context_flags_t;
#define MA_PA_CONTEXT_NOFLAGS 0x00000000
#define MA_PA_CONTEXT_NOAUTOSPAWN 0x00000001
#define MA_PA_CONTEXT_NOFAIL 0x00000002

typedef int ma_pa_stream_flags_t;
#define MA_PA_STREAM_NOFLAGS 0x00000000
#define MA_PA_STREAM_START_CORKED 0x00000001
#define MA_PA_STREAM_INTERPOLATE_TIMING 0x00000002
#define MA_PA_STREAM_NOT_MONOTONIC 0x00000004
#define MA_PA_STREAM_AUTO_TIMING_UPDATE 0x00000008
#define MA_PA_STREAM_NO_REMAP_CHANNELS 0x00000010
#define MA_PA_STREAM_NO_REMIX_CHANNELS 0x00000020
#define MA_PA_STREAM_FIX_FORMAT 0x00000040
#define MA_PA_STREAM_FIX_RATE 0x00000080
#define MA_PA_STREAM_FIX_CHANNELS 0x00000100
#define MA_PA_STREAM_DONT_MOVE 0x00000200
#define MA_PA_STREAM_VARIABLE_RATE 0x00000400
#define MA_PA_STREAM_PEAK_DETECT 0x00000800
#define MA_PA_STREAM_START_MUTED 0x00001000
#define MA_PA_STREAM_ADJUST_LATENCY 0x00002000
#define MA_PA_STREAM_EARLY_REQUESTS 0x00004000
#define MA_PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND 0x00008000
#define MA_PA_STREAM_START_UNMUTED 0x00010000
#define MA_PA_STREAM_FAIL_ON_SUSPEND 0x00020000
#define MA_PA_STREAM_RELATIVE_VOLUME 0x00040000
#define MA_PA_STREAM_PASSTHROUGH 0x00080000

typedef int ma_pa_sink_flags_t;
#define MA_PA_SINK_NOFLAGS 0x00000000
#define MA_PA_SINK_HW_VOLUME_CTRL 0x00000001
#define MA_PA_SINK_LATENCY 0x00000002
#define MA_PA_SINK_HARDWARE 0x00000004
#define MA_PA_SINK_NETWORK 0x00000008
#define MA_PA_SINK_HW_MUTE_CTRL 0x00000010
#define MA_PA_SINK_DECIBEL_VOLUME 0x00000020
#define MA_PA_SINK_FLAT_VOLUME 0x00000040
#define MA_PA_SINK_DYNAMIC_LATENCY 0x00000080
#define MA_PA_SINK_SET_FORMATS 0x00000100

typedef int ma_pa_source_flags_t;
#define MA_PA_SOURCE_NOFLAGS 0x00000000
#define MA_PA_SOURCE_HW_VOLUME_CTRL 0x00000001
#define MA_PA_SOURCE_LATENCY 0x00000002
#define MA_PA_SOURCE_HARDWARE 0x00000004
#define MA_PA_SOURCE_NETWORK 0x00000008
#define MA_PA_SOURCE_HW_MUTE_CTRL 0x00000010
#define MA_PA_SOURCE_DECIBEL_VOLUME 0x00000020
#define MA_PA_SOURCE_DYNAMIC_LATENCY 0x00000040
#define MA_PA_SOURCE_FLAT_VOLUME 0x00000080

typedef int ma_pa_context_state_t;
#define MA_PA_CONTEXT_UNCONNECTED 0
#define MA_PA_CONTEXT_CONNECTING 1
#define MA_PA_CONTEXT_AUTHORIZING 2
#define MA_PA_CONTEXT_SETTING_NAME 3
#define MA_PA_CONTEXT_READY 4
#define MA_PA_CONTEXT_FAILED 5
#define MA_PA_CONTEXT_TERMINATED 6

typedef int ma_pa_stream_state_t;
#define MA_PA_STREAM_UNCONNECTED 0
#define MA_PA_STREAM_CREATING 1
#define MA_PA_STREAM_READY 2
#define MA_PA_STREAM_FAILED 3
#define MA_PA_STREAM_TERMINATED 4

typedef int ma_pa_operation_state_t;
#define MA_PA_OPERATION_RUNNING 0
#define MA_PA_OPERATION_DONE 1
#define MA_PA_OPERATION_CANCELLED 2

typedef int ma_pa_sink_state_t;
#define MA_PA_SINK_INVALID_STATE -1
#define MA_PA_SINK_RUNNING 0
#define MA_PA_SINK_IDLE 1
#define MA_PA_SINK_SUSPENDED 2

typedef int ma_pa_source_state_t;
#define MA_PA_SOURCE_INVALID_STATE -1
#define MA_PA_SOURCE_RUNNING 0
#define MA_PA_SOURCE_IDLE 1
#define MA_PA_SOURCE_SUSPENDED 2

typedef int ma_pa_seek_mode_t;
#define MA_PA_SEEK_RELATIVE 0
#define MA_PA_SEEK_ABSOLUTE 1
#define MA_PA_SEEK_RELATIVE_ON_READ 2
#define MA_PA_SEEK_RELATIVE_END 3

typedef int ma_pa_channel_position_t;
#define MA_PA_CHANNEL_POSITION_INVALID -1
#define MA_PA_CHANNEL_POSITION_MONO 0
#define MA_PA_CHANNEL_POSITION_FRONT_LEFT 1
#define MA_PA_CHANNEL_POSITION_FRONT_RIGHT 2
#define MA_PA_CHANNEL_POSITION_FRONT_CENTER 3
#define MA_PA_CHANNEL_POSITION_REAR_CENTER 4
#define MA_PA_CHANNEL_POSITION_REAR_LEFT 5
#define MA_PA_CHANNEL_POSITION_REAR_RIGHT 6
#define MA_PA_CHANNEL_POSITION_LFE 7
#define MA_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER 8
#define MA_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER 9
#define MA_PA_CHANNEL_POSITION_SIDE_LEFT 10
#define MA_PA_CHANNEL_POSITION_SIDE_RIGHT 11
#define MA_PA_CHANNEL_POSITION_AUX0 12
#define MA_PA_CHANNEL_POSITION_AUX1 13
#define MA_PA_CHANNEL_POSITION_AUX2 14
#define MA_PA_CHANNEL_POSITION_AUX3 15
#define MA_PA_CHANNEL_POSITION_AUX4 16
#define MA_PA_CHANNEL_POSITION_AUX5 17
#define MA_PA_CHANNEL_POSITION_AUX6 18
#define MA_PA_CHANNEL_POSITION_AUX7 19
#define MA_PA_CHANNEL_POSITION_AUX8 20
#define MA_PA_CHANNEL_POSITION_AUX9 21
#define MA_PA_CHANNEL_POSITION_AUX10 22
#define MA_PA_CHANNEL_POSITION_AUX11 23
#define MA_PA_CHANNEL_POSITION_AUX12 24
#define MA_PA_CHANNEL_POSITION_AUX13 25
#define MA_PA_CHANNEL_POSITION_AUX14 26
#define MA_PA_CHANNEL_POSITION_AUX15 27
#define MA_PA_CHANNEL_POSITION_AUX16 28
#define MA_PA_CHANNEL_POSITION_AUX17 29
#define MA_PA_CHANNEL_POSITION_AUX18 30
#define MA_PA_CHANNEL_POSITION_AUX19 31
#define MA_PA_CHANNEL_POSITION_AUX20 32
#define MA_PA_CHANNEL_POSITION_AUX21 33
#define MA_PA_CHANNEL_POSITION_AUX22 34
#define MA_PA_CHANNEL_POSITION_AUX23 35
#define MA_PA_CHANNEL_POSITION_AUX24 36
#define MA_PA_CHANNEL_POSITION_AUX25 37
#define MA_PA_CHANNEL_POSITION_AUX26 38
#define MA_PA_CHANNEL_POSITION_AUX27 39
#define MA_PA_CHANNEL_POSITION_AUX28 40
#define MA_PA_CHANNEL_POSITION_AUX29 41
#define MA_PA_CHANNEL_POSITION_AUX30 42
#define MA_PA_CHANNEL_POSITION_AUX31 43
#define MA_PA_CHANNEL_POSITION_TOP_CENTER 44
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_LEFT 45
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT 46
#define MA_PA_CHANNEL_POSITION_TOP_FRONT_CENTER 47
#define MA_PA_CHANNEL_POSITION_TOP_REAR_LEFT 48
#define MA_PA_CHANNEL_POSITION_TOP_REAR_RIGHT 49
#define MA_PA_CHANNEL_POSITION_TOP_REAR_CENTER 50
#define MA_PA_CHANNEL_POSITION_LEFT MA_PA_CHANNEL_POSITION_FRONT_LEFT
#define MA_PA_CHANNEL_POSITION_RIGHT MA_PA_CHANNEL_POSITION_FRONT_RIGHT
#define MA_PA_CHANNEL_POSITION_CENTER MA_PA_CHANNEL_POSITION_FRONT_CENTER
#define MA_PA_CHANNEL_POSITION_SUBWOOFER MA_PA_CHANNEL_POSITION_LFE

typedef int ma_pa_channel_map_def_t;
#define MA_PA_CHANNEL_MAP_AIFF 0
#define MA_PA_CHANNEL_MAP_ALSA 1
#define MA_PA_CHANNEL_MAP_AUX 2
#define MA_PA_CHANNEL_MAP_WAVEEX 3
#define MA_PA_CHANNEL_MAP_OSS 4
#define MA_PA_CHANNEL_MAP_DEFAULT MA_PA_CHANNEL_MAP_AIFF

typedef int ma_pa_sample_format_t;
#define MA_PA_SAMPLE_INVALID -1
#define MA_PA_SAMPLE_U8 0
#define MA_PA_SAMPLE_ALAW 1
#define MA_PA_SAMPLE_ULAW 2
#define MA_PA_SAMPLE_S16LE 3
#define MA_PA_SAMPLE_S16BE 4
#define MA_PA_SAMPLE_FLOAT32LE 5
#define MA_PA_SAMPLE_FLOAT32BE 6
#define MA_PA_SAMPLE_S32LE 7
#define MA_PA_SAMPLE_S32BE 8
#define MA_PA_SAMPLE_S24LE 9
#define MA_PA_SAMPLE_S24BE 10
#define MA_PA_SAMPLE_S24_32LE 11
#define MA_PA_SAMPLE_S24_32BE 12

typedef struct ma_pa_mainloop ma_pa_mainloop;
typedef struct ma_pa_mainloop_api ma_pa_mainloop_api;
typedef struct ma_pa_context ma_pa_context;
typedef struct ma_pa_operation ma_pa_operation;
typedef struct ma_pa_stream ma_pa_stream;
typedef struct ma_pa_spawn_api ma_pa_spawn_api;

typedef struct
{
ma_uint32 maxlength;
ma_uint32 tlength;
ma_uint32 prebuf;
ma_uint32 minreq;
ma_uint32 fragsize;
} ma_pa_buffer_attr;

typedef struct
{
ma_uint8 channels;
ma_pa_channel_position_t map[MA_PA_CHANNELS_MAX];
} ma_pa_channel_map;

typedef struct
{
ma_uint8 channels;
ma_uint32 values[MA_PA_CHANNELS_MAX];
} ma_pa_cvolume;

typedef struct
{
ma_pa_sample_format_t format;
ma_uint32 rate;
ma_uint8 channels;
} ma_pa_sample_spec;

typedef struct
{
const char* name;
ma_uint32 index;
const char* description;
ma_pa_sample_spec sample_spec;
ma_pa_channel_map channel_map;
ma_uint32 owner_module;
ma_pa_cvolume volume;
int mute;
ma_uint32 monitor_source;
const char* monitor_source_name;
ma_uint64 latency;
const char* driver;
ma_pa_sink_flags_t flags;
void* proplist;
ma_uint64 configured_latency;
ma_uint32 base_volume;
ma_pa_sink_state_t state;
ma_uint32 n_volume_steps;
ma_uint32 card;
ma_uint32 n_ports;
void** ports;
void* active_port;
ma_uint8 n_formats;
void** formats;
} ma_pa_sink_info;

typedef struct
{
const char *name;
ma_uint32 index;
const char *description;
ma_pa_sample_spec sample_spec;
ma_pa_channel_map channel_map;
ma_uint32 owner_module;
ma_pa_cvolume volume;
int mute;
ma_uint32 monitor_of_sink;
const char *monitor_of_sink_name;
ma_uint64 latency;
const char *driver;
ma_pa_source_flags_t flags;
void* proplist;
ma_uint64 configured_latency;
ma_uint32 base_volume;
ma_pa_source_state_t state;
ma_uint32 n_volume_steps;
ma_uint32 card;
ma_uint32 n_ports;
void** ports;
void* active_port;
ma_uint8 n_formats;
void** formats;
} ma_pa_source_info;

typedef void (* ma_pa_context_notify_cb_t)(ma_pa_context* c, void* userdata);
typedef void (* ma_pa_sink_info_cb_t) (ma_pa_context* c, const ma_pa_sink_info* i, int eol, void* userdata);
typedef void (* ma_pa_source_info_cb_t) (ma_pa_context* c, const ma_pa_source_info* i, int eol, void* userdata);
typedef void (* ma_pa_stream_success_cb_t)(ma_pa_stream* s, int success, void* userdata);
typedef void (* ma_pa_stream_request_cb_t)(ma_pa_stream* s, size_t nbytes, void* userdata);
typedef void (* ma_pa_free_cb_t) (void* p);
#endif


typedef ma_pa_mainloop* (* ma_pa_mainloop_new_proc) ();
typedef void (* ma_pa_mainloop_free_proc) (ma_pa_mainloop* m);
typedef ma_pa_mainloop_api* (* ma_pa_mainloop_get_api_proc) (ma_pa_mainloop* m);
typedef int (* ma_pa_mainloop_iterate_proc) (ma_pa_mainloop* m, int block, int* retval);
typedef void (* ma_pa_mainloop_wakeup_proc) (ma_pa_mainloop* m);
typedef ma_pa_context* (* ma_pa_context_new_proc) (ma_pa_mainloop_api* mainloop, const char* name);
typedef void (* ma_pa_context_unref_proc) (ma_pa_context* c);
typedef int (* ma_pa_context_connect_proc) (ma_pa_context* c, const char* server, ma_pa_context_flags_t flags, const ma_pa_spawn_api* api);
typedef void (* ma_pa_context_disconnect_proc) (ma_pa_context* c);
typedef void (* ma_pa_context_set_state_callback_proc) (ma_pa_context* c, ma_pa_context_notify_cb_t cb, void* userdata);
typedef ma_pa_context_state_t (* ma_pa_context_get_state_proc) (ma_pa_context* c);
typedef ma_pa_operation* (* ma_pa_context_get_sink_info_list_proc) (ma_pa_context* c, ma_pa_sink_info_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_context_get_source_info_list_proc) (ma_pa_context* c, ma_pa_source_info_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_context_get_sink_info_by_name_proc) (ma_pa_context* c, const char* name, ma_pa_sink_info_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_context_get_source_info_by_name_proc)(ma_pa_context* c, const char* name, ma_pa_source_info_cb_t cb, void* userdata);
typedef void (* ma_pa_operation_unref_proc) (ma_pa_operation* o);
typedef ma_pa_operation_state_t (* ma_pa_operation_get_state_proc) (ma_pa_operation* o);
typedef ma_pa_channel_map* (* ma_pa_channel_map_init_extend_proc) (ma_pa_channel_map* m, unsigned channels, ma_pa_channel_map_def_t def);
typedef int (* ma_pa_channel_map_valid_proc) (const ma_pa_channel_map* m);
typedef int (* ma_pa_channel_map_compatible_proc) (const ma_pa_channel_map* m, const ma_pa_sample_spec* ss);
typedef ma_pa_stream* (* ma_pa_stream_new_proc) (ma_pa_context* c, const char* name, const ma_pa_sample_spec* ss, const ma_pa_channel_map* map);
typedef void (* ma_pa_stream_unref_proc) (ma_pa_stream* s);
typedef int (* ma_pa_stream_connect_playback_proc) (ma_pa_stream* s, const char* dev, const ma_pa_buffer_attr* attr, ma_pa_stream_flags_t flags, const ma_pa_cvolume* volume, ma_pa_stream* sync_stream);
typedef int (* ma_pa_stream_connect_record_proc) (ma_pa_stream* s, const char* dev, const ma_pa_buffer_attr* attr, ma_pa_stream_flags_t flags);
typedef int (* ma_pa_stream_disconnect_proc) (ma_pa_stream* s);
typedef ma_pa_stream_state_t (* ma_pa_stream_get_state_proc) (ma_pa_stream* s);
typedef const ma_pa_sample_spec* (* ma_pa_stream_get_sample_spec_proc) (ma_pa_stream* s);
typedef const ma_pa_channel_map* (* ma_pa_stream_get_channel_map_proc) (ma_pa_stream* s);
typedef const ma_pa_buffer_attr* (* ma_pa_stream_get_buffer_attr_proc) (ma_pa_stream* s);
typedef ma_pa_operation* (* ma_pa_stream_set_buffer_attr_proc) (ma_pa_stream* s, const ma_pa_buffer_attr* attr, ma_pa_stream_success_cb_t cb, void* userdata);
typedef const char* (* ma_pa_stream_get_device_name_proc) (ma_pa_stream* s);
typedef void (* ma_pa_stream_set_write_callback_proc) (ma_pa_stream* s, ma_pa_stream_request_cb_t cb, void* userdata);
typedef void (* ma_pa_stream_set_read_callback_proc) (ma_pa_stream* s, ma_pa_stream_request_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_stream_flush_proc) (ma_pa_stream* s, ma_pa_stream_success_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_stream_drain_proc) (ma_pa_stream* s, ma_pa_stream_success_cb_t cb, void* userdata);
typedef int (* ma_pa_stream_is_corked_proc) (ma_pa_stream* s);
typedef ma_pa_operation* (* ma_pa_stream_cork_proc) (ma_pa_stream* s, int b, ma_pa_stream_success_cb_t cb, void* userdata);
typedef ma_pa_operation* (* ma_pa_stream_trigger_proc) (ma_pa_stream* s, ma_pa_stream_success_cb_t cb, void* userdata);
typedef int (* ma_pa_stream_begin_write_proc) (ma_pa_stream* s, void** data, size_t* nbytes);
typedef int (* ma_pa_stream_write_proc) (ma_pa_stream* s, const void* data, size_t nbytes, ma_pa_free_cb_t free_cb, int64_t offset, ma_pa_seek_mode_t seek);
typedef int (* ma_pa_stream_peek_proc) (ma_pa_stream* s, const void** data, size_t* nbytes);
typedef int (* ma_pa_stream_drop_proc) (ma_pa_stream* s);
typedef size_t (* ma_pa_stream_writable_size_proc) (ma_pa_stream* s);
typedef size_t (* ma_pa_stream_readable_size_proc) (ma_pa_stream* s);

typedef struct
{
ma_uint32 count;
ma_uint32 capacity;
ma_device_info* pInfo;
} ma_pulse_device_enum_data;

static ma_result ma_result_from_pulse(int result)
{
switch (result) {
case MA_PA_OK: return MA_SUCCESS;
case MA_PA_ERR_ACCESS: return MA_ACCESS_DENIED;
case MA_PA_ERR_INVALID: return MA_INVALID_ARGS;
case MA_PA_ERR_NOENTITY: return MA_NO_DEVICE;
default: return MA_ERROR;
}
}

#if 0
static ma_pa_sample_format_t ma_format_to_pulse(ma_format format)
{
if (ma_is_little_endian()) {
switch (format) {
case ma_format_s16: return MA_PA_SAMPLE_S16LE;
case ma_format_s24: return MA_PA_SAMPLE_S24LE;
case ma_format_s32: return MA_PA_SAMPLE_S32LE;
case ma_format_f32: return MA_PA_SAMPLE_FLOAT32LE;
default: break;
}
} else {
switch (format) {
case ma_format_s16: return MA_PA_SAMPLE_S16BE;
case ma_format_s24: return MA_PA_SAMPLE_S24BE;
case ma_format_s32: return MA_PA_SAMPLE_S32BE;
case ma_format_f32: return MA_PA_SAMPLE_FLOAT32BE;
default: break;
}
}


switch (format) {
case ma_format_u8: return MA_PA_SAMPLE_U8;
default: return MA_PA_SAMPLE_INVALID;
}
}
#endif

static ma_format ma_format_from_pulse(ma_pa_sample_format_t format)
{
if (ma_is_little_endian()) {
switch (format) {
case MA_PA_SAMPLE_S16LE: return ma_format_s16;
case MA_PA_SAMPLE_S24LE: return ma_format_s24;
case MA_PA_SAMPLE_S32LE: return ma_format_s32;
case MA_PA_SAMPLE_FLOAT32LE: return ma_format_f32;
default: break;
}
} else {
switch (format) {
case MA_PA_SAMPLE_S16BE: return ma_format_s16;
case MA_PA_SAMPLE_S24BE: return ma_format_s24;
case MA_PA_SAMPLE_S32BE: return ma_format_s32;
case MA_PA_SAMPLE_FLOAT32BE: return ma_format_f32;
default: break;
}
}


switch (format) {
case MA_PA_SAMPLE_U8: return ma_format_u8;
default: return ma_format_unknown;
}
}

static ma_channel ma_channel_position_from_pulse(ma_pa_channel_position_t position)
{
switch (position)
{
case MA_PA_CHANNEL_POSITION_INVALID: return MA_CHANNEL_NONE;
case MA_PA_CHANNEL_POSITION_MONO: return MA_CHANNEL_MONO;
case MA_PA_CHANNEL_POSITION_FRONT_LEFT: return MA_CHANNEL_FRONT_LEFT;
case MA_PA_CHANNEL_POSITION_FRONT_RIGHT: return MA_CHANNEL_FRONT_RIGHT;
case MA_PA_CHANNEL_POSITION_FRONT_CENTER: return MA_CHANNEL_FRONT_CENTER;
case MA_PA_CHANNEL_POSITION_REAR_CENTER: return MA_CHANNEL_BACK_CENTER;
case MA_PA_CHANNEL_POSITION_REAR_LEFT: return MA_CHANNEL_BACK_LEFT;
case MA_PA_CHANNEL_POSITION_REAR_RIGHT: return MA_CHANNEL_BACK_RIGHT;
case MA_PA_CHANNEL_POSITION_LFE: return MA_CHANNEL_LFE;
case MA_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: return MA_CHANNEL_FRONT_LEFT_CENTER;
case MA_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case MA_PA_CHANNEL_POSITION_SIDE_LEFT: return MA_CHANNEL_SIDE_LEFT;
case MA_PA_CHANNEL_POSITION_SIDE_RIGHT: return MA_CHANNEL_SIDE_RIGHT;
case MA_PA_CHANNEL_POSITION_AUX0: return MA_CHANNEL_AUX_0;
case MA_PA_CHANNEL_POSITION_AUX1: return MA_CHANNEL_AUX_1;
case MA_PA_CHANNEL_POSITION_AUX2: return MA_CHANNEL_AUX_2;
case MA_PA_CHANNEL_POSITION_AUX3: return MA_CHANNEL_AUX_3;
case MA_PA_CHANNEL_POSITION_AUX4: return MA_CHANNEL_AUX_4;
case MA_PA_CHANNEL_POSITION_AUX5: return MA_CHANNEL_AUX_5;
case MA_PA_CHANNEL_POSITION_AUX6: return MA_CHANNEL_AUX_6;
case MA_PA_CHANNEL_POSITION_AUX7: return MA_CHANNEL_AUX_7;
case MA_PA_CHANNEL_POSITION_AUX8: return MA_CHANNEL_AUX_8;
case MA_PA_CHANNEL_POSITION_AUX9: return MA_CHANNEL_AUX_9;
case MA_PA_CHANNEL_POSITION_AUX10: return MA_CHANNEL_AUX_10;
case MA_PA_CHANNEL_POSITION_AUX11: return MA_CHANNEL_AUX_11;
case MA_PA_CHANNEL_POSITION_AUX12: return MA_CHANNEL_AUX_12;
case MA_PA_CHANNEL_POSITION_AUX13: return MA_CHANNEL_AUX_13;
case MA_PA_CHANNEL_POSITION_AUX14: return MA_CHANNEL_AUX_14;
case MA_PA_CHANNEL_POSITION_AUX15: return MA_CHANNEL_AUX_15;
case MA_PA_CHANNEL_POSITION_AUX16: return MA_CHANNEL_AUX_16;
case MA_PA_CHANNEL_POSITION_AUX17: return MA_CHANNEL_AUX_17;
case MA_PA_CHANNEL_POSITION_AUX18: return MA_CHANNEL_AUX_18;
case MA_PA_CHANNEL_POSITION_AUX19: return MA_CHANNEL_AUX_19;
case MA_PA_CHANNEL_POSITION_AUX20: return MA_CHANNEL_AUX_20;
case MA_PA_CHANNEL_POSITION_AUX21: return MA_CHANNEL_AUX_21;
case MA_PA_CHANNEL_POSITION_AUX22: return MA_CHANNEL_AUX_22;
case MA_PA_CHANNEL_POSITION_AUX23: return MA_CHANNEL_AUX_23;
case MA_PA_CHANNEL_POSITION_AUX24: return MA_CHANNEL_AUX_24;
case MA_PA_CHANNEL_POSITION_AUX25: return MA_CHANNEL_AUX_25;
case MA_PA_CHANNEL_POSITION_AUX26: return MA_CHANNEL_AUX_26;
case MA_PA_CHANNEL_POSITION_AUX27: return MA_CHANNEL_AUX_27;
case MA_PA_CHANNEL_POSITION_AUX28: return MA_CHANNEL_AUX_28;
case MA_PA_CHANNEL_POSITION_AUX29: return MA_CHANNEL_AUX_29;
case MA_PA_CHANNEL_POSITION_AUX30: return MA_CHANNEL_AUX_30;
case MA_PA_CHANNEL_POSITION_AUX31: return MA_CHANNEL_AUX_31;
case MA_PA_CHANNEL_POSITION_TOP_CENTER: return MA_CHANNEL_TOP_CENTER;
case MA_PA_CHANNEL_POSITION_TOP_FRONT_LEFT: return MA_CHANNEL_TOP_FRONT_LEFT;
case MA_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: return MA_CHANNEL_TOP_FRONT_RIGHT;
case MA_PA_CHANNEL_POSITION_TOP_FRONT_CENTER: return MA_CHANNEL_TOP_FRONT_CENTER;
case MA_PA_CHANNEL_POSITION_TOP_REAR_LEFT: return MA_CHANNEL_TOP_BACK_LEFT;
case MA_PA_CHANNEL_POSITION_TOP_REAR_RIGHT: return MA_CHANNEL_TOP_BACK_RIGHT;
case MA_PA_CHANNEL_POSITION_TOP_REAR_CENTER: return MA_CHANNEL_TOP_BACK_CENTER;
default: return MA_CHANNEL_NONE;
}
}

#if 0
static ma_pa_channel_position_t ma_channel_position_to_pulse(ma_channel position)
{
switch (position)
{
case MA_CHANNEL_NONE: return MA_PA_CHANNEL_POSITION_INVALID;
case MA_CHANNEL_FRONT_LEFT: return MA_PA_CHANNEL_POSITION_FRONT_LEFT;
case MA_CHANNEL_FRONT_RIGHT: return MA_PA_CHANNEL_POSITION_FRONT_RIGHT;
case MA_CHANNEL_FRONT_CENTER: return MA_PA_CHANNEL_POSITION_FRONT_CENTER;
case MA_CHANNEL_LFE: return MA_PA_CHANNEL_POSITION_LFE;
case MA_CHANNEL_BACK_LEFT: return MA_PA_CHANNEL_POSITION_REAR_LEFT;
case MA_CHANNEL_BACK_RIGHT: return MA_PA_CHANNEL_POSITION_REAR_RIGHT;
case MA_CHANNEL_FRONT_LEFT_CENTER: return MA_PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER;
case MA_CHANNEL_FRONT_RIGHT_CENTER: return MA_PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER;
case MA_CHANNEL_BACK_CENTER: return MA_PA_CHANNEL_POSITION_REAR_CENTER;
case MA_CHANNEL_SIDE_LEFT: return MA_PA_CHANNEL_POSITION_SIDE_LEFT;
case MA_CHANNEL_SIDE_RIGHT: return MA_PA_CHANNEL_POSITION_SIDE_RIGHT;
case MA_CHANNEL_TOP_CENTER: return MA_PA_CHANNEL_POSITION_TOP_CENTER;
case MA_CHANNEL_TOP_FRONT_LEFT: return MA_PA_CHANNEL_POSITION_TOP_FRONT_LEFT;
case MA_CHANNEL_TOP_FRONT_CENTER: return MA_PA_CHANNEL_POSITION_TOP_FRONT_CENTER;
case MA_CHANNEL_TOP_FRONT_RIGHT: return MA_PA_CHANNEL_POSITION_TOP_FRONT_RIGHT;
case MA_CHANNEL_TOP_BACK_LEFT: return MA_PA_CHANNEL_POSITION_TOP_REAR_LEFT;
case MA_CHANNEL_TOP_BACK_CENTER: return MA_PA_CHANNEL_POSITION_TOP_REAR_CENTER;
case MA_CHANNEL_TOP_BACK_RIGHT: return MA_PA_CHANNEL_POSITION_TOP_REAR_RIGHT;
case MA_CHANNEL_19: return MA_PA_CHANNEL_POSITION_AUX18;
case MA_CHANNEL_20: return MA_PA_CHANNEL_POSITION_AUX19;
case MA_CHANNEL_21: return MA_PA_CHANNEL_POSITION_AUX20;
case MA_CHANNEL_22: return MA_PA_CHANNEL_POSITION_AUX21;
case MA_CHANNEL_23: return MA_PA_CHANNEL_POSITION_AUX22;
case MA_CHANNEL_24: return MA_PA_CHANNEL_POSITION_AUX23;
case MA_CHANNEL_25: return MA_PA_CHANNEL_POSITION_AUX24;
case MA_CHANNEL_26: return MA_PA_CHANNEL_POSITION_AUX25;
case MA_CHANNEL_27: return MA_PA_CHANNEL_POSITION_AUX26;
case MA_CHANNEL_28: return MA_PA_CHANNEL_POSITION_AUX27;
case MA_CHANNEL_29: return MA_PA_CHANNEL_POSITION_AUX28;
case MA_CHANNEL_30: return MA_PA_CHANNEL_POSITION_AUX29;
case MA_CHANNEL_31: return MA_PA_CHANNEL_POSITION_AUX30;
case MA_CHANNEL_32: return MA_PA_CHANNEL_POSITION_AUX31;
default: return (ma_pa_channel_position_t)position;
}
}
#endif

static ma_result ma_wait_for_operation__pulse(ma_context* pContext, ma_pa_mainloop* pMainLoop, ma_pa_operation* pOP)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pMainLoop != NULL);
MA_ASSERT(pOP != NULL);

while (((ma_pa_operation_get_state_proc)pContext->pulse.pa_operation_get_state)(pOP) == MA_PA_OPERATION_RUNNING) {
int error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
if (error < 0) {
return ma_result_from_pulse(error);
}
}

return MA_SUCCESS;
}

static ma_result ma_device__wait_for_operation__pulse(ma_device* pDevice, ma_pa_operation* pOP)
{
MA_ASSERT(pDevice != NULL);
MA_ASSERT(pOP != NULL);

return ma_wait_for_operation__pulse(pDevice->pContext, (ma_pa_mainloop*)pDevice->pulse.pMainLoop, pOP);
}


static ma_bool32 ma_context_is_device_id_equal__pulse(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->pulse, pID1->pulse) == 0;
}


typedef struct
{
ma_context* pContext;
ma_enum_devices_callback_proc callback;
void* pUserData;
ma_bool32 isTerminated;
} ma_context_enumerate_devices_callback_data__pulse;

static void ma_context_enumerate_devices_sink_callback__pulse(ma_pa_context* pPulseContext, const ma_pa_sink_info* pSinkInfo, int endOfList, void* pUserData)
{
ma_context_enumerate_devices_callback_data__pulse* pData = (ma_context_enumerate_devices_callback_data__pulse*)pUserData;
ma_device_info deviceInfo;

MA_ASSERT(pData != NULL);

if (endOfList || pData->isTerminated) {
return;
}

MA_ZERO_OBJECT(&deviceInfo);


if (pSinkInfo->name != NULL) {
ma_strncpy_s(deviceInfo.id.pulse, sizeof(deviceInfo.id.pulse), pSinkInfo->name, (size_t)-1);
}


if (pSinkInfo->description != NULL) {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), pSinkInfo->description, (size_t)-1);
}

pData->isTerminated = !pData->callback(pData->pContext, ma_device_type_playback, &deviceInfo, pData->pUserData);

(void)pPulseContext; 
}

static void ma_context_enumerate_devices_source_callback__pulse(ma_pa_context* pPulseContext, const ma_pa_source_info* pSinkInfo, int endOfList, void* pUserData)
{
ma_context_enumerate_devices_callback_data__pulse* pData = (ma_context_enumerate_devices_callback_data__pulse*)pUserData;
ma_device_info deviceInfo;

MA_ASSERT(pData != NULL);

if (endOfList || pData->isTerminated) {
return;
}

MA_ZERO_OBJECT(&deviceInfo);


if (pSinkInfo->name != NULL) {
ma_strncpy_s(deviceInfo.id.pulse, sizeof(deviceInfo.id.pulse), pSinkInfo->name, (size_t)-1);
}


if (pSinkInfo->description != NULL) {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), pSinkInfo->description, (size_t)-1);
}

pData->isTerminated = !pData->callback(pData->pContext, ma_device_type_capture, &deviceInfo, pData->pUserData);

(void)pPulseContext; 
}

static ma_result ma_context_enumerate_devices__pulse(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_result result = MA_SUCCESS;
ma_context_enumerate_devices_callback_data__pulse callbackData;
ma_pa_operation* pOP = NULL;
ma_pa_mainloop* pMainLoop;
ma_pa_mainloop_api* pAPI;
ma_pa_context* pPulseContext;
int error;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);

callbackData.pContext = pContext;
callbackData.callback = callback;
callbackData.pUserData = pUserData;
callbackData.isTerminated = MA_FALSE;

pMainLoop = ((ma_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
if (pMainLoop == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pAPI = ((ma_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
if (pAPI == NULL) {
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return MA_FAILED_TO_INIT_BACKEND;
}

pPulseContext = ((ma_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->pulse.pApplicationName);
if (pPulseContext == NULL) {
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return MA_FAILED_TO_INIT_BACKEND;
}

error = ((ma_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->pulse.pServerName, (pContext->pulse.tryAutoSpawn) ? 0 : MA_PA_CONTEXT_NOAUTOSPAWN, NULL);
if (error != MA_PA_OK) {
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return ma_result_from_pulse(error);
}

for (;;) {
ma_pa_context_state_t state = ((ma_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext);
if (state == MA_PA_CONTEXT_READY) {
break; 
}
if (state == MA_PA_CONTEXT_CONNECTING || state == MA_PA_CONTEXT_AUTHORIZING || state == MA_PA_CONTEXT_SETTING_NAME) {
error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
if (error < 0) {
result = ma_result_from_pulse(error);
goto done;
}

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] pa_context_get_state() returned %d. Waiting.\n", state);
#endif
continue; 
}
if (state == MA_PA_CONTEXT_UNCONNECTED || state == MA_PA_CONTEXT_FAILED || state == MA_PA_CONTEXT_TERMINATED) {
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] pa_context_get_state() returned %d. Failed.\n", state);
#endif
goto done; 
}
}



if (!callbackData.isTerminated) {
pOP = ((ma_pa_context_get_sink_info_list_proc)pContext->pulse.pa_context_get_sink_info_list)(pPulseContext, ma_context_enumerate_devices_sink_callback__pulse, &callbackData);
if (pOP == NULL) {
result = MA_ERROR;
goto done;
}

result = ma_wait_for_operation__pulse(pContext, pMainLoop, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
if (result != MA_SUCCESS) {
goto done;
}
}



if (!callbackData.isTerminated) {
pOP = ((ma_pa_context_get_source_info_list_proc)pContext->pulse.pa_context_get_source_info_list)(pPulseContext, ma_context_enumerate_devices_source_callback__pulse, &callbackData);
if (pOP == NULL) {
result = MA_ERROR;
goto done;
}

result = ma_wait_for_operation__pulse(pContext, pMainLoop, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
if (result != MA_SUCCESS) {
goto done;
}
}

done:
((ma_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return result;
}


typedef struct
{
ma_device_info* pDeviceInfo;
ma_bool32 foundDevice;
} ma_context_get_device_info_callback_data__pulse;

static void ma_context_get_device_info_sink_callback__pulse(ma_pa_context* pPulseContext, const ma_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
ma_context_get_device_info_callback_data__pulse* pData = (ma_context_get_device_info_callback_data__pulse*)pUserData;

if (endOfList > 0) {
return;
}

MA_ASSERT(pData != NULL);
pData->foundDevice = MA_TRUE;

if (pInfo->name != NULL) {
ma_strncpy_s(pData->pDeviceInfo->id.pulse, sizeof(pData->pDeviceInfo->id.pulse), pInfo->name, (size_t)-1);
}

if (pInfo->description != NULL) {
ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pInfo->description, (size_t)-1);
}

pData->pDeviceInfo->minChannels = pInfo->sample_spec.channels;
pData->pDeviceInfo->maxChannels = pInfo->sample_spec.channels;
pData->pDeviceInfo->minSampleRate = pInfo->sample_spec.rate;
pData->pDeviceInfo->maxSampleRate = pInfo->sample_spec.rate;
pData->pDeviceInfo->formatCount = 1;
pData->pDeviceInfo->formats[0] = ma_format_from_pulse(pInfo->sample_spec.format);

(void)pPulseContext; 
}

static void ma_context_get_device_info_source_callback__pulse(ma_pa_context* pPulseContext, const ma_pa_source_info* pInfo, int endOfList, void* pUserData)
{
ma_context_get_device_info_callback_data__pulse* pData = (ma_context_get_device_info_callback_data__pulse*)pUserData;

if (endOfList > 0) {
return;
}

MA_ASSERT(pData != NULL);
pData->foundDevice = MA_TRUE;

if (pInfo->name != NULL) {
ma_strncpy_s(pData->pDeviceInfo->id.pulse, sizeof(pData->pDeviceInfo->id.pulse), pInfo->name, (size_t)-1);
}

if (pInfo->description != NULL) {
ma_strncpy_s(pData->pDeviceInfo->name, sizeof(pData->pDeviceInfo->name), pInfo->description, (size_t)-1);
}

pData->pDeviceInfo->minChannels = pInfo->sample_spec.channels;
pData->pDeviceInfo->maxChannels = pInfo->sample_spec.channels;
pData->pDeviceInfo->minSampleRate = pInfo->sample_spec.rate;
pData->pDeviceInfo->maxSampleRate = pInfo->sample_spec.rate;
pData->pDeviceInfo->formatCount = 1;
pData->pDeviceInfo->formats[0] = ma_format_from_pulse(pInfo->sample_spec.format);

(void)pPulseContext; 
}

static ma_result ma_context_get_device_info__pulse(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_result result = MA_SUCCESS;
ma_context_get_device_info_callback_data__pulse callbackData;
ma_pa_operation* pOP = NULL;
ma_pa_mainloop* pMainLoop;
ma_pa_mainloop_api* pAPI;
ma_pa_context* pPulseContext;
int error;

MA_ASSERT(pContext != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

callbackData.pDeviceInfo = pDeviceInfo;
callbackData.foundDevice = MA_FALSE;

pMainLoop = ((ma_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
if (pMainLoop == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pAPI = ((ma_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
if (pAPI == NULL) {
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return MA_FAILED_TO_INIT_BACKEND;
}

pPulseContext = ((ma_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->pulse.pApplicationName);
if (pPulseContext == NULL) {
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return MA_FAILED_TO_INIT_BACKEND;
}

error = ((ma_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->pulse.pServerName, 0, NULL);
if (error != MA_PA_OK) {
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return ma_result_from_pulse(error);
}

for (;;) {
ma_pa_context_state_t state = ((ma_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext);
if (state == MA_PA_CONTEXT_READY) {
break; 
}
if (state == MA_PA_CONTEXT_CONNECTING || state == MA_PA_CONTEXT_AUTHORIZING || state == MA_PA_CONTEXT_SETTING_NAME) {
error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)(pMainLoop, 1, NULL);
if (error < 0) {
result = ma_result_from_pulse(error);
goto done;
}

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] pa_context_get_state() returned %d. Waiting.\n", state);
#endif
continue; 
}
if (state == MA_PA_CONTEXT_UNCONNECTED || state == MA_PA_CONTEXT_FAILED || state == MA_PA_CONTEXT_TERMINATED) {
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] pa_context_get_state() returned %d. Failed.\n", state);
#endif
goto done; 
}
}

if (deviceType == ma_device_type_playback) {
pOP = ((ma_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)(pPulseContext, pDeviceID->pulse, ma_context_get_device_info_sink_callback__pulse, &callbackData);
} else {
pOP = ((ma_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)(pPulseContext, pDeviceID->pulse, ma_context_get_device_info_source_callback__pulse, &callbackData);
}

if (pOP != NULL) {
ma_wait_for_operation__pulse(pContext, pMainLoop, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
} else {
result = MA_ERROR;
goto done;
}

if (!callbackData.foundDevice) {
result = MA_NO_DEVICE;
goto done;
}


done:
((ma_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
return result;
}


static void ma_pulse_device_state_callback(ma_pa_context* pPulseContext, void* pUserData)
{
ma_device* pDevice;
ma_context* pContext;

pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

pContext = pDevice->pContext;
MA_ASSERT(pContext != NULL);

pDevice->pulse.pulseContextState = ((ma_pa_context_get_state_proc)pContext->pulse.pa_context_get_state)(pPulseContext);
}

void ma_device_sink_info_callback(ma_pa_context* pPulseContext, const ma_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
ma_pa_sink_info* pInfoOut;

if (endOfList > 0) {
return;
}

pInfoOut = (ma_pa_sink_info*)pUserData;
MA_ASSERT(pInfoOut != NULL);

*pInfoOut = *pInfo;

(void)pPulseContext; 
}

static void ma_device_source_info_callback(ma_pa_context* pPulseContext, const ma_pa_source_info* pInfo, int endOfList, void* pUserData)
{
ma_pa_source_info* pInfoOut;

if (endOfList > 0) {
return;
}

pInfoOut = (ma_pa_source_info*)pUserData;
MA_ASSERT(pInfoOut != NULL);

*pInfoOut = *pInfo;

(void)pPulseContext; 
}

static void ma_device_sink_name_callback(ma_pa_context* pPulseContext, const ma_pa_sink_info* pInfo, int endOfList, void* pUserData)
{
ma_device* pDevice;

if (endOfList > 0) {
return;
}

pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

ma_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), pInfo->description, (size_t)-1);

(void)pPulseContext; 
}

static void ma_device_source_name_callback(ma_pa_context* pPulseContext, const ma_pa_source_info* pInfo, int endOfList, void* pUserData)
{
ma_device* pDevice;

if (endOfList > 0) {
return;
}

pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

ma_strncpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), pInfo->description, (size_t)-1);

(void)pPulseContext; 
}

static void ma_device_uninit__pulse(ma_device* pDevice)
{
ma_context* pContext;

MA_ASSERT(pDevice != NULL);

pContext = pDevice->pContext;
MA_ASSERT(pContext != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
((ma_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
((ma_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
((ma_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
}

((ma_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)((ma_pa_context*)pDevice->pulse.pPulseContext);
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)((ma_pa_context*)pDevice->pulse.pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)((ma_pa_mainloop*)pDevice->pulse.pMainLoop);
}

static ma_pa_buffer_attr ma_device__pa_buffer_attr_new(ma_uint32 periodSizeInFrames, ma_uint32 periods, const ma_pa_sample_spec* ss)
{
ma_pa_buffer_attr attr;
attr.maxlength = periodSizeInFrames * periods * ma_get_bytes_per_frame(ma_format_from_pulse(ss->format), ss->channels);
attr.tlength = attr.maxlength / periods;
attr.prebuf = (ma_uint32)-1;
attr.minreq = (ma_uint32)-1;
attr.fragsize = attr.maxlength / periods;

return attr;
}

static ma_pa_stream* ma_device__pa_stream_new__pulse(ma_device* pDevice, const char* pStreamName, const ma_pa_sample_spec* ss, const ma_pa_channel_map* cmap)
{
static int g_StreamCounter = 0;
char actualStreamName[256];

if (pStreamName != NULL) {
ma_strncpy_s(actualStreamName, sizeof(actualStreamName), pStreamName, (size_t)-1);
} else {
ma_strcpy_s(actualStreamName, sizeof(actualStreamName), "miniaudio:");
ma_itoa_s(g_StreamCounter, actualStreamName + 8, sizeof(actualStreamName)-8, 10); 
}
g_StreamCounter += 1;

return ((ma_pa_stream_new_proc)pDevice->pContext->pulse.pa_stream_new)((ma_pa_context*)pDevice->pulse.pPulseContext, actualStreamName, ss, cmap);
}

static ma_result ma_device_init__pulse(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
int error = 0;
const char* devPlayback = NULL;
const char* devCapture = NULL;
ma_uint32 periodSizeInMilliseconds;
ma_pa_sink_info sinkInfo;
ma_pa_source_info sourceInfo;
ma_pa_operation* pOP = NULL;
ma_pa_sample_spec ss;
ma_pa_channel_map cmap;
ma_pa_buffer_attr attr;
const ma_pa_sample_spec* pActualSS = NULL;
const ma_pa_channel_map* pActualCMap = NULL;
const ma_pa_buffer_attr* pActualAttr = NULL;
ma_uint32 iChannel;
ma_pa_stream_flags_t streamFlags;

MA_ASSERT(pDevice != NULL);
MA_ZERO_OBJECT(&pDevice->pulse);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

if ((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.pDeviceID != NULL) {
devPlayback = pConfig->playback.pDeviceID->pulse;
}
if ((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.pDeviceID != NULL) {
devCapture = pConfig->capture.pDeviceID->pulse;
}

periodSizeInMilliseconds = pConfig->periodSizeInMilliseconds;
if (periodSizeInMilliseconds == 0) {
periodSizeInMilliseconds = ma_calculate_buffer_size_in_milliseconds_from_frames(pConfig->periodSizeInFrames, pConfig->sampleRate);
}

pDevice->pulse.pMainLoop = ((ma_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
if (pDevice->pulse.pMainLoop == NULL) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create main loop for device.", MA_FAILED_TO_INIT_BACKEND);
goto on_error0;
}

pDevice->pulse.pAPI = ((ma_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)((ma_pa_mainloop*)pDevice->pulse.pMainLoop);
if (pDevice->pulse.pAPI == NULL) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve PulseAudio main loop.", MA_FAILED_TO_INIT_BACKEND);
goto on_error1;
}

pDevice->pulse.pPulseContext = ((ma_pa_context_new_proc)pContext->pulse.pa_context_new)((ma_pa_mainloop_api*)pDevice->pulse.pAPI, pContext->pulse.pApplicationName);
if (pDevice->pulse.pPulseContext == NULL) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio context for device.", MA_FAILED_TO_INIT_BACKEND);
goto on_error1;
}

error = ((ma_pa_context_connect_proc)pContext->pulse.pa_context_connect)((ma_pa_context*)pDevice->pulse.pPulseContext, pContext->pulse.pServerName, (pContext->pulse.tryAutoSpawn) ? 0 : MA_PA_CONTEXT_NOAUTOSPAWN, NULL);
if (error != MA_PA_OK) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio context.", ma_result_from_pulse(error));
goto on_error2;
}


pDevice->pulse.pulseContextState = MA_PA_CONTEXT_UNCONNECTED;
((ma_pa_context_set_state_callback_proc)pContext->pulse.pa_context_set_state_callback)((ma_pa_context*)pDevice->pulse.pPulseContext, ma_pulse_device_state_callback, pDevice);


for (;;) {
if (pDevice->pulse.pulseContextState == MA_PA_CONTEXT_READY) {
break;
}


if (pDevice->pulse.pulseContextState == MA_PA_CONTEXT_FAILED || pDevice->pulse.pulseContextState == MA_PA_CONTEXT_TERMINATED) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] An error occurred while connecting the PulseAudio context.", MA_ERROR);
goto on_error3;
}

error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((ma_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
if (error < 0) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio context.", ma_result_from_pulse(error));
goto on_error3;
}
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
pOP = ((ma_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)((ma_pa_context*)pDevice->pulse.pPulseContext, devCapture, ma_device_source_info_callback, &sourceInfo);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
} else {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve source info for capture device.", ma_result_from_pulse(error));
goto on_error3;
}

ss = sourceInfo.sample_spec;
cmap = sourceInfo.channel_map;

pDevice->capture.internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, ss.rate);
pDevice->capture.internalPeriods = pConfig->periods;

attr = ma_device__pa_buffer_attr_new(pDevice->capture.internalPeriodSizeInFrames, pConfig->periods, &ss);
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] Capture attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalPeriodSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->capture.internalPeriodSizeInFrames);
#endif

pDevice->pulse.pStreamCapture = ma_device__pa_stream_new__pulse(pDevice, pConfig->pulse.pStreamNameCapture, &ss, &cmap);
if (pDevice->pulse.pStreamCapture == NULL) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio capture stream.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
goto on_error3;
}

streamFlags = MA_PA_STREAM_START_CORKED | MA_PA_STREAM_FIX_FORMAT | MA_PA_STREAM_FIX_RATE | MA_PA_STREAM_FIX_CHANNELS;
if (devCapture != NULL) {
streamFlags |= MA_PA_STREAM_DONT_MOVE;
}

error = ((ma_pa_stream_connect_record_proc)pContext->pulse.pa_stream_connect_record)((ma_pa_stream*)pDevice->pulse.pStreamCapture, devCapture, &attr, streamFlags);
if (error != MA_PA_OK) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio capture stream.", ma_result_from_pulse(error));
goto on_error4;
}

while (((ma_pa_stream_get_state_proc)pContext->pulse.pa_stream_get_state)((ma_pa_stream*)pDevice->pulse.pStreamCapture) != MA_PA_STREAM_READY) {
error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((ma_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
if (error < 0) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio capture stream.", ma_result_from_pulse(error));
goto on_error5;
}
}


pActualSS = ((ma_pa_stream_get_sample_spec_proc)pContext->pulse.pa_stream_get_sample_spec)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
if (pActualSS != NULL) {

if (ss.format != pActualSS->format || ss.channels != pActualSS->channels || ss.rate != pActualSS->rate) {
attr = ma_device__pa_buffer_attr_new(pDevice->capture.internalPeriodSizeInFrames, pConfig->periods, pActualSS);

pOP = ((ma_pa_stream_set_buffer_attr_proc)pContext->pulse.pa_stream_set_buffer_attr)((ma_pa_stream*)pDevice->pulse.pStreamCapture, &attr, NULL, NULL);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
}
}

ss = *pActualSS;
}

pDevice->capture.internalFormat = ma_format_from_pulse(ss.format);
pDevice->capture.internalChannels = ss.channels;
pDevice->capture.internalSampleRate = ss.rate;


pActualCMap = ((ma_pa_stream_get_channel_map_proc)pContext->pulse.pa_stream_get_channel_map)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
if (pActualCMap != NULL) {
cmap = *pActualCMap;
}
for (iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
pDevice->capture.internalChannelMap[iChannel] = ma_channel_position_from_pulse(cmap.map[iChannel]);
}


pActualAttr = ((ma_pa_stream_get_buffer_attr_proc)pContext->pulse.pa_stream_get_buffer_attr)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
if (pActualAttr != NULL) {
attr = *pActualAttr;
}
pDevice->capture.internalPeriods = attr.maxlength / attr.fragsize;
pDevice->capture.internalPeriodSizeInFrames = attr.maxlength / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels) / pDevice->capture.internalPeriods;
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] Capture actual attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalPeriodSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->capture.internalPeriodSizeInFrames);
#endif


devCapture = ((ma_pa_stream_get_device_name_proc)pContext->pulse.pa_stream_get_device_name)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
if (devCapture != NULL) {
ma_pa_operation* pOP = ((ma_pa_context_get_source_info_by_name_proc)pContext->pulse.pa_context_get_source_info_by_name)((ma_pa_context*)pDevice->pulse.pPulseContext, devCapture, ma_device_source_name_callback, pDevice);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
}
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
pOP = ((ma_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)((ma_pa_context*)pDevice->pulse.pPulseContext, devPlayback, ma_device_sink_info_callback, &sinkInfo);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
} else {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to retrieve sink info for playback device.", ma_result_from_pulse(error));
goto on_error3;
}

ss = sinkInfo.sample_spec;
cmap = sinkInfo.channel_map;

pDevice->playback.internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(periodSizeInMilliseconds, ss.rate);
pDevice->playback.internalPeriods = pConfig->periods;

attr = ma_device__pa_buffer_attr_new(pDevice->playback.internalPeriodSizeInFrames, pConfig->periods, &ss);
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] Playback attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalPeriodSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->playback.internalPeriodSizeInFrames);
#endif

pDevice->pulse.pStreamPlayback = ma_device__pa_stream_new__pulse(pDevice, pConfig->pulse.pStreamNamePlayback, &ss, &cmap);
if (pDevice->pulse.pStreamPlayback == NULL) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to create PulseAudio playback stream.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
goto on_error3;
}

streamFlags = MA_PA_STREAM_START_CORKED | MA_PA_STREAM_FIX_FORMAT | MA_PA_STREAM_FIX_RATE | MA_PA_STREAM_FIX_CHANNELS;
if (devPlayback != NULL) {
streamFlags |= MA_PA_STREAM_DONT_MOVE;
}

error = ((ma_pa_stream_connect_playback_proc)pContext->pulse.pa_stream_connect_playback)((ma_pa_stream*)pDevice->pulse.pStreamPlayback, devPlayback, &attr, streamFlags, NULL, NULL);
if (error != MA_PA_OK) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to connect PulseAudio playback stream.", ma_result_from_pulse(error));
goto on_error6;
}

while (((ma_pa_stream_get_state_proc)pContext->pulse.pa_stream_get_state)((ma_pa_stream*)pDevice->pulse.pStreamPlayback) != MA_PA_STREAM_READY) {
error = ((ma_pa_mainloop_iterate_proc)pContext->pulse.pa_mainloop_iterate)((ma_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
if (error < 0) {
result = ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] The PulseAudio main loop returned an error while connecting the PulseAudio playback stream.", ma_result_from_pulse(error));
goto on_error7;
}
}


pActualSS = ((ma_pa_stream_get_sample_spec_proc)pContext->pulse.pa_stream_get_sample_spec)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
if (pActualSS != NULL) {

if (ss.format != pActualSS->format || ss.channels != pActualSS->channels || ss.rate != pActualSS->rate) {
attr = ma_device__pa_buffer_attr_new(pDevice->playback.internalPeriodSizeInFrames, pConfig->periods, pActualSS);

pOP = ((ma_pa_stream_set_buffer_attr_proc)pContext->pulse.pa_stream_set_buffer_attr)((ma_pa_stream*)pDevice->pulse.pStreamPlayback, &attr, NULL, NULL);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
}
}

ss = *pActualSS;
}

pDevice->playback.internalFormat = ma_format_from_pulse(ss.format);
pDevice->playback.internalChannels = ss.channels;
pDevice->playback.internalSampleRate = ss.rate;


pActualCMap = ((ma_pa_stream_get_channel_map_proc)pContext->pulse.pa_stream_get_channel_map)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
if (pActualCMap != NULL) {
cmap = *pActualCMap;
}
for (iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
pDevice->playback.internalChannelMap[iChannel] = ma_channel_position_from_pulse(cmap.map[iChannel]);
}


pActualAttr = ((ma_pa_stream_get_buffer_attr_proc)pContext->pulse.pa_stream_get_buffer_attr)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
if (pActualAttr != NULL) {
attr = *pActualAttr;
}
pDevice->playback.internalPeriods = attr.maxlength / attr.tlength;
pDevice->playback.internalPeriodSizeInFrames = attr.maxlength / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels) / pDevice->playback.internalPeriods;
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] Playback actual attr: maxlength=%d, tlength=%d, prebuf=%d, minreq=%d, fragsize=%d; internalPeriodSizeInFrames=%d\n", attr.maxlength, attr.tlength, attr.prebuf, attr.minreq, attr.fragsize, pDevice->playback.internalPeriodSizeInFrames);
#endif


devPlayback = ((ma_pa_stream_get_device_name_proc)pContext->pulse.pa_stream_get_device_name)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
if (devPlayback != NULL) {
ma_pa_operation* pOP = ((ma_pa_context_get_sink_info_by_name_proc)pContext->pulse.pa_context_get_sink_info_by_name)((ma_pa_context*)pDevice->pulse.pPulseContext, devPlayback, ma_device_sink_name_callback, pDevice);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);
}
}
}

return MA_SUCCESS;


on_error7:
if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
((ma_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
}
on_error6:
if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
((ma_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
}
on_error5:
if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
((ma_pa_stream_disconnect_proc)pContext->pulse.pa_stream_disconnect)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
}
on_error4:
if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
((ma_pa_stream_unref_proc)pContext->pulse.pa_stream_unref)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
}
on_error3: ((ma_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)((ma_pa_context*)pDevice->pulse.pPulseContext);
on_error2: ((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)((ma_pa_context*)pDevice->pulse.pPulseContext);
on_error1: ((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)((ma_pa_mainloop*)pDevice->pulse.pMainLoop);
on_error0:
return result;
}


static void ma_pulse_operation_complete_callback(ma_pa_stream* pStream, int success, void* pUserData)
{
ma_bool32* pIsSuccessful = (ma_bool32*)pUserData;
MA_ASSERT(pIsSuccessful != NULL);

*pIsSuccessful = (ma_bool32)success;

(void)pStream; 
}

static ma_result ma_device__cork_stream__pulse(ma_device* pDevice, ma_device_type deviceType, int cork)
{
ma_context* pContext = pDevice->pContext;
ma_bool32 wasSuccessful;
ma_pa_stream* pStream;
ma_pa_operation* pOP;
ma_result result;


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

wasSuccessful = MA_FALSE;

pStream = (ma_pa_stream*)((deviceType == ma_device_type_capture) ? pDevice->pulse.pStreamCapture : pDevice->pulse.pStreamPlayback);
MA_ASSERT(pStream != NULL);

pOP = ((ma_pa_stream_cork_proc)pContext->pulse.pa_stream_cork)(pStream, cork, ma_pulse_operation_complete_callback, &wasSuccessful);
if (pOP == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to cork PulseAudio stream.", (cork == 0) ? MA_FAILED_TO_START_BACKEND_DEVICE : MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

result = ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pContext->pulse.pa_operation_unref)(pOP);

if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] An error occurred while waiting for the PulseAudio stream to cork.", result);
}

if (!wasSuccessful) {
if (cork) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to stop PulseAudio stream.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
} else {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to start PulseAudio stream.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__pulse(ma_device* pDevice)
{
ma_result result;
ma_bool32 wasSuccessful;
ma_pa_operation* pOP;

MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
result = ma_device__cork_stream__pulse(pDevice, ma_device_type_capture, 1);
if (result != MA_SUCCESS) {
return result;
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {

pOP = ((ma_pa_stream_drain_proc)pDevice->pContext->pulse.pa_stream_drain)((ma_pa_stream*)pDevice->pulse.pStreamPlayback, ma_pulse_operation_complete_callback, &wasSuccessful);
if (pOP != NULL) {
ma_device__wait_for_operation__pulse(pDevice, pOP);
((ma_pa_operation_unref_proc)pDevice->pContext->pulse.pa_operation_unref)(pOP);
}

result = ma_device__cork_stream__pulse(pDevice, ma_device_type_playback, 1);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_write__pulse(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
ma_uint32 totalFramesWritten;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pPCMFrames != NULL);
MA_ASSERT(frameCount > 0);

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

totalFramesWritten = 0;
while (totalFramesWritten < frameCount) {
if (ma_device__get_state(pDevice) != MA_STATE_STARTED) {
return MA_DEVICE_NOT_STARTED;
}


if (pDevice->pulse.pMappedBufferPlayback != NULL && pDevice->pulse.mappedBufferFramesRemainingPlayback > 0) {
ma_uint32 bpf = ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 mappedBufferFramesConsumed = pDevice->pulse.mappedBufferFramesCapacityPlayback - pDevice->pulse.mappedBufferFramesRemainingPlayback;

void* pDst = (ma_uint8*)pDevice->pulse.pMappedBufferPlayback + (mappedBufferFramesConsumed * bpf);
const void* pSrc = (const ma_uint8*)pPCMFrames + (totalFramesWritten * bpf);
ma_uint32 framesToCopy = ma_min(pDevice->pulse.mappedBufferFramesRemainingPlayback, (frameCount - totalFramesWritten));
MA_COPY_MEMORY(pDst, pSrc, framesToCopy * bpf);

pDevice->pulse.mappedBufferFramesRemainingPlayback -= framesToCopy;
totalFramesWritten += framesToCopy;
}





if (pDevice->pulse.mappedBufferFramesCapacityPlayback > 0 && pDevice->pulse.mappedBufferFramesRemainingPlayback == 0) {
size_t nbytes = pDevice->pulse.mappedBufferFramesCapacityPlayback * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);

int error = ((ma_pa_stream_write_proc)pDevice->pContext->pulse.pa_stream_write)((ma_pa_stream*)pDevice->pulse.pStreamPlayback, pDevice->pulse.pMappedBufferPlayback, nbytes, NULL, 0, MA_PA_SEEK_RELATIVE);
if (error < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to write data to the PulseAudio stream.", ma_result_from_pulse(error));
}

pDevice->pulse.pMappedBufferPlayback = NULL;
pDevice->pulse.mappedBufferFramesRemainingPlayback = 0;
pDevice->pulse.mappedBufferFramesCapacityPlayback = 0;
}

MA_ASSERT(totalFramesWritten <= frameCount);
if (totalFramesWritten == frameCount) {
break;
}


for (;;) {
size_t writableSizeInBytes;


if (((ma_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)((ma_pa_stream*)pDevice->pulse.pStreamPlayback)) {
break;
}

writableSizeInBytes = ((ma_pa_stream_writable_size_proc)pDevice->pContext->pulse.pa_stream_writable_size)((ma_pa_stream*)pDevice->pulse.pStreamPlayback);
if (writableSizeInBytes != (size_t)-1) {
if (writableSizeInBytes > 0) {

size_t bytesToMap = writableSizeInBytes;
int error = ((ma_pa_stream_begin_write_proc)pDevice->pContext->pulse.pa_stream_begin_write)((ma_pa_stream*)pDevice->pulse.pStreamPlayback, &pDevice->pulse.pMappedBufferPlayback, &bytesToMap);
if (error < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to map write buffer.", ma_result_from_pulse(error));
}

pDevice->pulse.mappedBufferFramesCapacityPlayback = bytesToMap / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
pDevice->pulse.mappedBufferFramesRemainingPlayback = pDevice->pulse.mappedBufferFramesCapacityPlayback;

break;
} else {

int error = ((ma_pa_mainloop_iterate_proc)pDevice->pContext->pulse.pa_mainloop_iterate)((ma_pa_mainloop*)pDevice->pulse.pMainLoop, 1, NULL);
if (error < 0) {
return ma_result_from_pulse(error);
}

continue;
}
} else {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to query the stream's writable size.", MA_ERROR);
}
}
}

if (pFramesWritten != NULL) {
*pFramesWritten = totalFramesWritten;
}

return MA_SUCCESS;
}

static ma_result ma_device_read__pulse(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
ma_uint32 totalFramesRead;

MA_ASSERT(pDevice != NULL);
MA_ASSERT(pPCMFrames != NULL);
MA_ASSERT(frameCount > 0);

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

totalFramesRead = 0;
while (totalFramesRead < frameCount) {
if (ma_device__get_state(pDevice) != MA_STATE_STARTED) {
return MA_DEVICE_NOT_STARTED;
}





if (pDevice->pulse.mappedBufferFramesRemainingCapture > 0) {
ma_uint32 bpf = ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 mappedBufferFramesConsumed = pDevice->pulse.mappedBufferFramesCapacityCapture - pDevice->pulse.mappedBufferFramesRemainingCapture;

ma_uint32 framesToCopy = ma_min(pDevice->pulse.mappedBufferFramesRemainingCapture, (frameCount - totalFramesRead));
void* pDst = (ma_uint8*)pPCMFrames + (totalFramesRead * bpf);





if (pDevice->pulse.pMappedBufferCapture != NULL) {
const void* pSrc = (const ma_uint8*)pDevice->pulse.pMappedBufferCapture + (mappedBufferFramesConsumed * bpf);
MA_COPY_MEMORY(pDst, pSrc, framesToCopy * bpf);
} else {
MA_ZERO_MEMORY(pDst, framesToCopy * bpf);
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: Filling hole with silence.\n");
#endif
}

pDevice->pulse.mappedBufferFramesRemainingCapture -= framesToCopy;
totalFramesRead += framesToCopy;
}





if (pDevice->pulse.mappedBufferFramesCapacityCapture > 0 && pDevice->pulse.mappedBufferFramesRemainingCapture == 0) {
int error;

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: Call pa_stream_drop()\n");
#endif

error = ((ma_pa_stream_drop_proc)pDevice->pContext->pulse.pa_stream_drop)((ma_pa_stream*)pDevice->pulse.pStreamCapture);
if (error != 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to drop fragment.", ma_result_from_pulse(error));
}

pDevice->pulse.pMappedBufferCapture = NULL;
pDevice->pulse.mappedBufferFramesRemainingCapture = 0;
pDevice->pulse.mappedBufferFramesCapacityCapture = 0;
}

MA_ASSERT(totalFramesRead <= frameCount);
if (totalFramesRead == frameCount) {
break;
}


for (;;) {
int error;
size_t bytesMapped;

if (ma_device__get_state(pDevice) != MA_STATE_STARTED) {
break;
}


if (((ma_pa_stream_is_corked_proc)pDevice->pContext->pulse.pa_stream_is_corked)((ma_pa_stream*)pDevice->pulse.pStreamCapture)) {
#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: Corked.\n");
#endif
break;
}

MA_ASSERT(pDevice->pulse.pMappedBufferCapture == NULL); 

error = ((ma_pa_stream_peek_proc)pDevice->pContext->pulse.pa_stream_peek)((ma_pa_stream*)pDevice->pulse.pStreamCapture, &pDevice->pulse.pMappedBufferCapture, &bytesMapped);
if (error < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[PulseAudio] Failed to peek capture buffer.", ma_result_from_pulse(error));
}

if (bytesMapped > 0) {
pDevice->pulse.mappedBufferFramesCapacityCapture = bytesMapped / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
pDevice->pulse.mappedBufferFramesRemainingCapture = pDevice->pulse.mappedBufferFramesCapacityCapture;

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: Mapped. mappedBufferFramesCapacityCapture=%d, mappedBufferFramesRemainingCapture=%d\n", pDevice->pulse.mappedBufferFramesCapacityCapture, pDevice->pulse.mappedBufferFramesRemainingCapture);
#endif

if (pDevice->pulse.pMappedBufferCapture == NULL) {

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: Call pa_stream_peek(). Hole.\n");
#endif
}

break;
} else {
if (pDevice->pulse.pMappedBufferCapture == NULL) {







error = ((ma_pa_mainloop_iterate_proc)pDevice->pContext->pulse.pa_mainloop_iterate)((ma_pa_mainloop*)pDevice->pulse.pMainLoop, 0, NULL);
if (error < 0) {
return ma_result_from_pulse(error);
}


if (error == 0) {
ma_sleep(1);
}

#if defined(MA_DEBUG_OUTPUT)
printf("[PulseAudio] ma_device_read__pulse: No data available. Waiting. mappedBufferFramesCapacityCapture=%d, mappedBufferFramesRemainingCapture=%d\n", pDevice->pulse.mappedBufferFramesCapacityCapture, pDevice->pulse.mappedBufferFramesRemainingCapture);
#endif
} else {

MA_ASSERT(MA_FALSE);
}
}
}
}

if (pFramesRead != NULL) {
*pFramesRead = totalFramesRead;
}

return MA_SUCCESS;
}

static ma_result ma_device_main_loop__pulse(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;

MA_ASSERT(pDevice != NULL);


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
result = ma_device__cork_stream__pulse(pDevice, ma_device_type_capture, 0);
if (result != MA_SUCCESS) {
return result;
}
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
result = ma_device__cork_stream__pulse(pDevice, ma_device_type_playback, 0);
if (result != MA_SUCCESS) {
return result;
}
}


while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__pulse(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__pulse(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{
ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__pulse(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{
ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__pulse(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}


ma_device_stop__pulse(pDevice);

return result;
}


static ma_result ma_context_uninit__pulse(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_pulseaudio);

ma_free(pContext->pulse.pServerName, &pContext->allocationCallbacks);
pContext->pulse.pServerName = NULL;

ma_free(pContext->pulse.pApplicationName, &pContext->allocationCallbacks);
pContext->pulse.pApplicationName = NULL;

#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->pulse.pulseSO);
#endif

return MA_SUCCESS;
}

static ma_result ma_context_init__pulse(const ma_context_config* pConfig, ma_context* pContext)
{
#if !defined(MA_NO_RUNTIME_LINKING)
const char* libpulseNames[] = {
"libpulse.so",
"libpulse.so.0"
};
size_t i;

for (i = 0; i < ma_countof(libpulseNames); ++i) {
pContext->pulse.pulseSO = ma_dlopen(pContext, libpulseNames[i]);
if (pContext->pulse.pulseSO != NULL) {
break;
}
}

if (pContext->pulse.pulseSO == NULL) {
return MA_NO_BACKEND;
}

pContext->pulse.pa_mainloop_new = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_mainloop_new");
pContext->pulse.pa_mainloop_free = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_mainloop_free");
pContext->pulse.pa_mainloop_get_api = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_mainloop_get_api");
pContext->pulse.pa_mainloop_iterate = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_mainloop_iterate");
pContext->pulse.pa_mainloop_wakeup = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_mainloop_wakeup");
pContext->pulse.pa_context_new = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_new");
pContext->pulse.pa_context_unref = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_unref");
pContext->pulse.pa_context_connect = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_connect");
pContext->pulse.pa_context_disconnect = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_disconnect");
pContext->pulse.pa_context_set_state_callback = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_set_state_callback");
pContext->pulse.pa_context_get_state = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_get_state");
pContext->pulse.pa_context_get_sink_info_list = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_get_sink_info_list");
pContext->pulse.pa_context_get_source_info_list = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_get_source_info_list");
pContext->pulse.pa_context_get_sink_info_by_name = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_get_sink_info_by_name");
pContext->pulse.pa_context_get_source_info_by_name = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_context_get_source_info_by_name");
pContext->pulse.pa_operation_unref = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_operation_unref");
pContext->pulse.pa_operation_get_state = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_operation_get_state");
pContext->pulse.pa_channel_map_init_extend = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_channel_map_init_extend");
pContext->pulse.pa_channel_map_valid = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_channel_map_valid");
pContext->pulse.pa_channel_map_compatible = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_channel_map_compatible");
pContext->pulse.pa_stream_new = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_new");
pContext->pulse.pa_stream_unref = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_unref");
pContext->pulse.pa_stream_connect_playback = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_connect_playback");
pContext->pulse.pa_stream_connect_record = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_connect_record");
pContext->pulse.pa_stream_disconnect = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_disconnect");
pContext->pulse.pa_stream_get_state = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_get_state");
pContext->pulse.pa_stream_get_sample_spec = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_get_sample_spec");
pContext->pulse.pa_stream_get_channel_map = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_get_channel_map");
pContext->pulse.pa_stream_get_buffer_attr = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_get_buffer_attr");
pContext->pulse.pa_stream_set_buffer_attr = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_set_buffer_attr");
pContext->pulse.pa_stream_get_device_name = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_get_device_name");
pContext->pulse.pa_stream_set_write_callback = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_set_write_callback");
pContext->pulse.pa_stream_set_read_callback = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_set_read_callback");
pContext->pulse.pa_stream_flush = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_flush");
pContext->pulse.pa_stream_drain = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_drain");
pContext->pulse.pa_stream_is_corked = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_is_corked");
pContext->pulse.pa_stream_cork = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_cork");
pContext->pulse.pa_stream_trigger = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_trigger");
pContext->pulse.pa_stream_begin_write = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_begin_write");
pContext->pulse.pa_stream_write = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_write");
pContext->pulse.pa_stream_peek = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_peek");
pContext->pulse.pa_stream_drop = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_drop");
pContext->pulse.pa_stream_writable_size = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_writable_size");
pContext->pulse.pa_stream_readable_size = (ma_proc)ma_dlsym(pContext, pContext->pulse.pulseSO, "pa_stream_readable_size");
#else

ma_pa_mainloop_new_proc _pa_mainloop_new = pa_mainloop_new;
ma_pa_mainloop_free_proc _pa_mainloop_free = pa_mainloop_free;
ma_pa_mainloop_get_api_proc _pa_mainloop_get_api = pa_mainloop_get_api;
ma_pa_mainloop_iterate_proc _pa_mainloop_iterate = pa_mainloop_iterate;
ma_pa_mainloop_wakeup_proc _pa_mainloop_wakeup = pa_mainloop_wakeup;
ma_pa_context_new_proc _pa_context_new = pa_context_new;
ma_pa_context_unref_proc _pa_context_unref = pa_context_unref;
ma_pa_context_connect_proc _pa_context_connect = pa_context_connect;
ma_pa_context_disconnect_proc _pa_context_disconnect = pa_context_disconnect;
ma_pa_context_set_state_callback_proc _pa_context_set_state_callback = pa_context_set_state_callback;
ma_pa_context_get_state_proc _pa_context_get_state = pa_context_get_state;
ma_pa_context_get_sink_info_list_proc _pa_context_get_sink_info_list = pa_context_get_sink_info_list;
ma_pa_context_get_source_info_list_proc _pa_context_get_source_info_list = pa_context_get_source_info_list;
ma_pa_context_get_sink_info_by_name_proc _pa_context_get_sink_info_by_name = pa_context_get_sink_info_by_name;
ma_pa_context_get_source_info_by_name_proc _pa_context_get_source_info_by_name= pa_context_get_source_info_by_name;
ma_pa_operation_unref_proc _pa_operation_unref = pa_operation_unref;
ma_pa_operation_get_state_proc _pa_operation_get_state = pa_operation_get_state;
ma_pa_channel_map_init_extend_proc _pa_channel_map_init_extend = pa_channel_map_init_extend;
ma_pa_channel_map_valid_proc _pa_channel_map_valid = pa_channel_map_valid;
ma_pa_channel_map_compatible_proc _pa_channel_map_compatible = pa_channel_map_compatible;
ma_pa_stream_new_proc _pa_stream_new = pa_stream_new;
ma_pa_stream_unref_proc _pa_stream_unref = pa_stream_unref;
ma_pa_stream_connect_playback_proc _pa_stream_connect_playback = pa_stream_connect_playback;
ma_pa_stream_connect_record_proc _pa_stream_connect_record = pa_stream_connect_record;
ma_pa_stream_disconnect_proc _pa_stream_disconnect = pa_stream_disconnect;
ma_pa_stream_get_state_proc _pa_stream_get_state = pa_stream_get_state;
ma_pa_stream_get_sample_spec_proc _pa_stream_get_sample_spec = pa_stream_get_sample_spec;
ma_pa_stream_get_channel_map_proc _pa_stream_get_channel_map = pa_stream_get_channel_map;
ma_pa_stream_get_buffer_attr_proc _pa_stream_get_buffer_attr = pa_stream_get_buffer_attr;
ma_pa_stream_set_buffer_attr_proc _pa_stream_set_buffer_attr = pa_stream_set_buffer_attr;
ma_pa_stream_get_device_name_proc _pa_stream_get_device_name = pa_stream_get_device_name;
ma_pa_stream_set_write_callback_proc _pa_stream_set_write_callback = pa_stream_set_write_callback;
ma_pa_stream_set_read_callback_proc _pa_stream_set_read_callback = pa_stream_set_read_callback;
ma_pa_stream_flush_proc _pa_stream_flush = pa_stream_flush;
ma_pa_stream_drain_proc _pa_stream_drain = pa_stream_drain;
ma_pa_stream_is_corked_proc _pa_stream_is_corked = pa_stream_is_corked;
ma_pa_stream_cork_proc _pa_stream_cork = pa_stream_cork;
ma_pa_stream_trigger_proc _pa_stream_trigger = pa_stream_trigger;
ma_pa_stream_begin_write_proc _pa_stream_begin_write = pa_stream_begin_write;
ma_pa_stream_write_proc _pa_stream_write = pa_stream_write;
ma_pa_stream_peek_proc _pa_stream_peek = pa_stream_peek;
ma_pa_stream_drop_proc _pa_stream_drop = pa_stream_drop;
ma_pa_stream_writable_size_proc _pa_stream_writable_size = pa_stream_writable_size;
ma_pa_stream_readable_size_proc _pa_stream_readable_size = pa_stream_readable_size;

pContext->pulse.pa_mainloop_new = (ma_proc)_pa_mainloop_new;
pContext->pulse.pa_mainloop_free = (ma_proc)_pa_mainloop_free;
pContext->pulse.pa_mainloop_get_api = (ma_proc)_pa_mainloop_get_api;
pContext->pulse.pa_mainloop_iterate = (ma_proc)_pa_mainloop_iterate;
pContext->pulse.pa_mainloop_wakeup = (ma_proc)_pa_mainloop_wakeup;
pContext->pulse.pa_context_new = (ma_proc)_pa_context_new;
pContext->pulse.pa_context_unref = (ma_proc)_pa_context_unref;
pContext->pulse.pa_context_connect = (ma_proc)_pa_context_connect;
pContext->pulse.pa_context_disconnect = (ma_proc)_pa_context_disconnect;
pContext->pulse.pa_context_set_state_callback = (ma_proc)_pa_context_set_state_callback;
pContext->pulse.pa_context_get_state = (ma_proc)_pa_context_get_state;
pContext->pulse.pa_context_get_sink_info_list = (ma_proc)_pa_context_get_sink_info_list;
pContext->pulse.pa_context_get_source_info_list = (ma_proc)_pa_context_get_source_info_list;
pContext->pulse.pa_context_get_sink_info_by_name = (ma_proc)_pa_context_get_sink_info_by_name;
pContext->pulse.pa_context_get_source_info_by_name = (ma_proc)_pa_context_get_source_info_by_name;
pContext->pulse.pa_operation_unref = (ma_proc)_pa_operation_unref;
pContext->pulse.pa_operation_get_state = (ma_proc)_pa_operation_get_state;
pContext->pulse.pa_channel_map_init_extend = (ma_proc)_pa_channel_map_init_extend;
pContext->pulse.pa_channel_map_valid = (ma_proc)_pa_channel_map_valid;
pContext->pulse.pa_channel_map_compatible = (ma_proc)_pa_channel_map_compatible;
pContext->pulse.pa_stream_new = (ma_proc)_pa_stream_new;
pContext->pulse.pa_stream_unref = (ma_proc)_pa_stream_unref;
pContext->pulse.pa_stream_connect_playback = (ma_proc)_pa_stream_connect_playback;
pContext->pulse.pa_stream_connect_record = (ma_proc)_pa_stream_connect_record;
pContext->pulse.pa_stream_disconnect = (ma_proc)_pa_stream_disconnect;
pContext->pulse.pa_stream_get_state = (ma_proc)_pa_stream_get_state;
pContext->pulse.pa_stream_get_sample_spec = (ma_proc)_pa_stream_get_sample_spec;
pContext->pulse.pa_stream_get_channel_map = (ma_proc)_pa_stream_get_channel_map;
pContext->pulse.pa_stream_get_buffer_attr = (ma_proc)_pa_stream_get_buffer_attr;
pContext->pulse.pa_stream_set_buffer_attr = (ma_proc)_pa_stream_set_buffer_attr;
pContext->pulse.pa_stream_get_device_name = (ma_proc)_pa_stream_get_device_name;
pContext->pulse.pa_stream_set_write_callback = (ma_proc)_pa_stream_set_write_callback;
pContext->pulse.pa_stream_set_read_callback = (ma_proc)_pa_stream_set_read_callback;
pContext->pulse.pa_stream_flush = (ma_proc)_pa_stream_flush;
pContext->pulse.pa_stream_drain = (ma_proc)_pa_stream_drain;
pContext->pulse.pa_stream_is_corked = (ma_proc)_pa_stream_is_corked;
pContext->pulse.pa_stream_cork = (ma_proc)_pa_stream_cork;
pContext->pulse.pa_stream_trigger = (ma_proc)_pa_stream_trigger;
pContext->pulse.pa_stream_begin_write = (ma_proc)_pa_stream_begin_write;
pContext->pulse.pa_stream_write = (ma_proc)_pa_stream_write;
pContext->pulse.pa_stream_peek = (ma_proc)_pa_stream_peek;
pContext->pulse.pa_stream_drop = (ma_proc)_pa_stream_drop;
pContext->pulse.pa_stream_writable_size = (ma_proc)_pa_stream_writable_size;
pContext->pulse.pa_stream_readable_size = (ma_proc)_pa_stream_readable_size;
#endif

pContext->onUninit = ma_context_uninit__pulse;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__pulse;
pContext->onEnumDevices = ma_context_enumerate_devices__pulse;
pContext->onGetDeviceInfo = ma_context_get_device_info__pulse;
pContext->onDeviceInit = ma_device_init__pulse;
pContext->onDeviceUninit = ma_device_uninit__pulse;
pContext->onDeviceStart = NULL;
pContext->onDeviceStop = NULL;
pContext->onDeviceMainLoop = ma_device_main_loop__pulse;

if (pConfig->pulse.pApplicationName) {
pContext->pulse.pApplicationName = ma_copy_string(pConfig->pulse.pApplicationName, &pContext->allocationCallbacks);
}
if (pConfig->pulse.pServerName) {
pContext->pulse.pServerName = ma_copy_string(pConfig->pulse.pServerName, &pContext->allocationCallbacks);
}
pContext->pulse.tryAutoSpawn = pConfig->pulse.tryAutoSpawn;





{
ma_pa_mainloop* pMainLoop;
ma_pa_mainloop_api* pAPI;
ma_pa_context* pPulseContext;
int error;

pMainLoop = ((ma_pa_mainloop_new_proc)pContext->pulse.pa_mainloop_new)();
if (pMainLoop == NULL) {
ma_free(pContext->pulse.pServerName, &pContext->allocationCallbacks);
ma_free(pContext->pulse.pApplicationName, &pContext->allocationCallbacks);
#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->pulse.pulseSO);
#endif
return MA_NO_BACKEND;
}

pAPI = ((ma_pa_mainloop_get_api_proc)pContext->pulse.pa_mainloop_get_api)(pMainLoop);
if (pAPI == NULL) {
ma_free(pContext->pulse.pServerName, &pContext->allocationCallbacks);
ma_free(pContext->pulse.pApplicationName, &pContext->allocationCallbacks);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->pulse.pulseSO);
#endif
return MA_NO_BACKEND;
}

pPulseContext = ((ma_pa_context_new_proc)pContext->pulse.pa_context_new)(pAPI, pContext->pulse.pApplicationName);
if (pPulseContext == NULL) {
ma_free(pContext->pulse.pServerName, &pContext->allocationCallbacks);
ma_free(pContext->pulse.pApplicationName, &pContext->allocationCallbacks);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->pulse.pulseSO);
#endif
return MA_NO_BACKEND;
}

error = ((ma_pa_context_connect_proc)pContext->pulse.pa_context_connect)(pPulseContext, pContext->pulse.pServerName, 0, NULL);
if (error != MA_PA_OK) {
ma_free(pContext->pulse.pServerName, &pContext->allocationCallbacks);
ma_free(pContext->pulse.pApplicationName, &pContext->allocationCallbacks);
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->pulse.pulseSO);
#endif
return MA_NO_BACKEND;
}

((ma_pa_context_disconnect_proc)pContext->pulse.pa_context_disconnect)(pPulseContext);
((ma_pa_context_unref_proc)pContext->pulse.pa_context_unref)(pPulseContext);
((ma_pa_mainloop_free_proc)pContext->pulse.pa_mainloop_free)(pMainLoop);
}

return MA_SUCCESS;
}
#endif







#if defined(MA_HAS_JACK)


#if defined(MA_NO_RUNTIME_LINKING)
#include <jack/jack.h>

typedef jack_nframes_t ma_jack_nframes_t;
typedef jack_options_t ma_jack_options_t;
typedef jack_status_t ma_jack_status_t;
typedef jack_client_t ma_jack_client_t;
typedef jack_port_t ma_jack_port_t;
typedef JackProcessCallback ma_JackProcessCallback;
typedef JackBufferSizeCallback ma_JackBufferSizeCallback;
typedef JackShutdownCallback ma_JackShutdownCallback;
#define MA_JACK_DEFAULT_AUDIO_TYPE JACK_DEFAULT_AUDIO_TYPE
#define ma_JackNoStartServer JackNoStartServer
#define ma_JackPortIsInput JackPortIsInput
#define ma_JackPortIsOutput JackPortIsOutput
#define ma_JackPortIsPhysical JackPortIsPhysical
#else
typedef ma_uint32 ma_jack_nframes_t;
typedef int ma_jack_options_t;
typedef int ma_jack_status_t;
typedef struct ma_jack_client_t ma_jack_client_t;
typedef struct ma_jack_port_t ma_jack_port_t;
typedef int (* ma_JackProcessCallback) (ma_jack_nframes_t nframes, void* arg);
typedef int (* ma_JackBufferSizeCallback)(ma_jack_nframes_t nframes, void* arg);
typedef void (* ma_JackShutdownCallback) (void* arg);
#define MA_JACK_DEFAULT_AUDIO_TYPE "32 bit float mono audio"
#define ma_JackNoStartServer 1
#define ma_JackPortIsInput 1
#define ma_JackPortIsOutput 2
#define ma_JackPortIsPhysical 4
#endif

typedef ma_jack_client_t* (* ma_jack_client_open_proc) (const char* client_name, ma_jack_options_t options, ma_jack_status_t* status, ...);
typedef int (* ma_jack_client_close_proc) (ma_jack_client_t* client);
typedef int (* ma_jack_client_name_size_proc) ();
typedef int (* ma_jack_set_process_callback_proc) (ma_jack_client_t* client, ma_JackProcessCallback process_callback, void* arg);
typedef int (* ma_jack_set_buffer_size_callback_proc)(ma_jack_client_t* client, ma_JackBufferSizeCallback bufsize_callback, void* arg);
typedef void (* ma_jack_on_shutdown_proc) (ma_jack_client_t* client, ma_JackShutdownCallback function, void* arg);
typedef ma_jack_nframes_t (* ma_jack_get_sample_rate_proc) (ma_jack_client_t* client);
typedef ma_jack_nframes_t (* ma_jack_get_buffer_size_proc) (ma_jack_client_t* client);
typedef const char** (* ma_jack_get_ports_proc) (ma_jack_client_t* client, const char* port_name_pattern, const char* type_name_pattern, unsigned long flags);
typedef int (* ma_jack_activate_proc) (ma_jack_client_t* client);
typedef int (* ma_jack_deactivate_proc) (ma_jack_client_t* client);
typedef int (* ma_jack_connect_proc) (ma_jack_client_t* client, const char* source_port, const char* destination_port);
typedef ma_jack_port_t* (* ma_jack_port_register_proc) (ma_jack_client_t* client, const char* port_name, const char* port_type, unsigned long flags, unsigned long buffer_size);
typedef const char* (* ma_jack_port_name_proc) (const ma_jack_port_t* port);
typedef void* (* ma_jack_port_get_buffer_proc) (ma_jack_port_t* port, ma_jack_nframes_t nframes);
typedef void (* ma_jack_free_proc) (void* ptr);

static ma_result ma_context_open_client__jack(ma_context* pContext, ma_jack_client_t** ppClient)
{
size_t maxClientNameSize;
char clientName[256];
ma_jack_status_t status;
ma_jack_client_t* pClient;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppClient != NULL);

if (ppClient) {
*ppClient = NULL;
}

maxClientNameSize = ((ma_jack_client_name_size_proc)pContext->jack.jack_client_name_size)(); 
ma_strncpy_s(clientName, ma_min(sizeof(clientName), maxClientNameSize), (pContext->jack.pClientName != NULL) ? pContext->jack.pClientName : "miniaudio", (size_t)-1);

pClient = ((ma_jack_client_open_proc)pContext->jack.jack_client_open)(clientName, (pContext->jack.tryStartServer) ? 0 : ma_JackNoStartServer, &status, NULL);
if (pClient == NULL) {
return MA_FAILED_TO_OPEN_BACKEND_DEVICE;
}

if (ppClient) {
*ppClient = pClient;
}

return MA_SUCCESS;
}

static ma_bool32 ma_context_is_device_id_equal__jack(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return pID0->jack == pID1->jack;
}

static ma_result ma_context_enumerate_devices__jack(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult = MA_TRUE;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__jack(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_jack_client_t* pClient;
ma_result result;
const char** ppPorts;

MA_ASSERT(pContext != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

if (pDeviceID != NULL && pDeviceID->jack != 0) {
return MA_NO_DEVICE; 
}


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}


pDeviceInfo->formatCount = 1;
pDeviceInfo->formats[0] = ma_format_f32;


result = ma_context_open_client__jack(pContext, &pClient);
if (result != MA_SUCCESS) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[JACK] Failed to open client.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

pDeviceInfo->minSampleRate = ((ma_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((ma_jack_client_t*)pClient);
pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;

pDeviceInfo->minChannels = 0;
pDeviceInfo->maxChannels = 0;

ppPorts = ((ma_jack_get_ports_proc)pContext->jack.jack_get_ports)((ma_jack_client_t*)pClient, NULL, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsPhysical | ((deviceType == ma_device_type_playback) ? ma_JackPortIsInput : ma_JackPortIsOutput));
if (ppPorts == NULL) {
((ma_jack_client_close_proc)pContext->jack.jack_client_close)((ma_jack_client_t*)pClient);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

while (ppPorts[pDeviceInfo->minChannels] != NULL) {
pDeviceInfo->minChannels += 1;
pDeviceInfo->maxChannels += 1;
}

((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
((ma_jack_client_close_proc)pContext->jack.jack_client_close)((ma_jack_client_t*)pClient);

(void)pContext;
return MA_SUCCESS;
}


static void ma_device_uninit__jack(ma_device* pDevice)
{
ma_context* pContext;

MA_ASSERT(pDevice != NULL);

pContext = pDevice->pContext;
MA_ASSERT(pContext != NULL);

if (pDevice->jack.pClient != NULL) {
((ma_jack_client_close_proc)pContext->jack.jack_client_close)((ma_jack_client_t*)pDevice->jack.pClient);
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma__free_from_callbacks(pDevice->jack.pIntermediaryBufferCapture, &pDevice->pContext->allocationCallbacks);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma__free_from_callbacks(pDevice->jack.pIntermediaryBufferPlayback, &pDevice->pContext->allocationCallbacks);
}

if (pDevice->type == ma_device_type_duplex) {
ma_pcm_rb_uninit(&pDevice->jack.duplexRB);
}
}

static void ma_device__jack_shutdown_callback(void* pUserData)
{

ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

ma_device_stop(pDevice);
}

static int ma_device__jack_buffer_size_callback(ma_jack_nframes_t frameCount, void* pUserData)
{
ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
size_t newBufferSize = frameCount * (pDevice->capture.internalChannels * ma_get_bytes_per_sample(pDevice->capture.internalFormat));
float* pNewBuffer = (float*)ma__calloc_from_callbacks(newBufferSize, &pDevice->pContext->allocationCallbacks);
if (pNewBuffer == NULL) {
return MA_OUT_OF_MEMORY;
}

ma__free_from_callbacks(pDevice->jack.pIntermediaryBufferCapture, &pDevice->pContext->allocationCallbacks);

pDevice->jack.pIntermediaryBufferCapture = pNewBuffer;
pDevice->playback.internalPeriodSizeInFrames = frameCount;
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
size_t newBufferSize = frameCount * (pDevice->playback.internalChannels * ma_get_bytes_per_sample(pDevice->playback.internalFormat));
float* pNewBuffer = (float*)ma__calloc_from_callbacks(newBufferSize, &pDevice->pContext->allocationCallbacks);
if (pNewBuffer == NULL) {
return MA_OUT_OF_MEMORY;
}

ma__free_from_callbacks(pDevice->jack.pIntermediaryBufferPlayback, &pDevice->pContext->allocationCallbacks);

pDevice->jack.pIntermediaryBufferPlayback = pNewBuffer;
pDevice->playback.internalPeriodSizeInFrames = frameCount;
}

return 0;
}

static int ma_device__jack_process_callback(ma_jack_nframes_t frameCount, void* pUserData)
{
ma_device* pDevice;
ma_context* pContext;
ma_uint32 iChannel;

pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

pContext = pDevice->pContext;
MA_ASSERT(pContext != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {

for (iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
const float* pSrc = (const float*)((ma_jack_port_get_buffer_proc)pContext->jack.jack_port_get_buffer)((ma_jack_port_t*)pDevice->jack.pPortsCapture[iChannel], frameCount);
if (pSrc != NULL) {
float* pDst = pDevice->jack.pIntermediaryBufferCapture + iChannel;
ma_jack_nframes_t iFrame;
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
*pDst = *pSrc;

pDst += pDevice->capture.internalChannels;
pSrc += 1;
}
}
}

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, frameCount, pDevice->jack.pIntermediaryBufferCapture, &pDevice->jack.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, frameCount, pDevice->jack.pIntermediaryBufferCapture);
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, frameCount, pDevice->jack.pIntermediaryBufferPlayback, &pDevice->jack.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, frameCount, pDevice->jack.pIntermediaryBufferPlayback);
}


for (iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
float* pDst = (float*)((ma_jack_port_get_buffer_proc)pContext->jack.jack_port_get_buffer)((ma_jack_port_t*)pDevice->jack.pPortsPlayback[iChannel], frameCount);
if (pDst != NULL) {
const float* pSrc = pDevice->jack.pIntermediaryBufferPlayback + iChannel;
ma_jack_nframes_t iFrame;
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
*pDst = *pSrc;

pDst += 1;
pSrc += pDevice->playback.internalChannels;
}
}
}
}

return 0;
}

static ma_result ma_device_init__jack(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;
ma_uint32 periods;
ma_uint32 periodSizeInFrames;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDevice != NULL);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.pDeviceID != NULL && pConfig->playback.pDeviceID->jack != 0) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.pDeviceID != NULL && pConfig->capture.pDeviceID->jack != 0)) {
return MA_NO_DEVICE;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}


result = ma_context_open_client__jack(pContext, (ma_jack_client_t**)&pDevice->jack.pClient);
if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to open client.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


if (((ma_jack_set_process_callback_proc)pContext->jack.jack_set_process_callback)((ma_jack_client_t*)pDevice->jack.pClient, ma_device__jack_process_callback, pDevice) != 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to set process callback.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
if (((ma_jack_set_buffer_size_callback_proc)pContext->jack.jack_set_buffer_size_callback)((ma_jack_client_t*)pDevice->jack.pClient, ma_device__jack_buffer_size_callback, pDevice) != 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to set buffer size callback.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

((ma_jack_on_shutdown_proc)pContext->jack.jack_on_shutdown)((ma_jack_client_t*)pDevice->jack.pClient, ma_device__jack_shutdown_callback, pDevice);



periods = pConfig->periods;
periodSizeInFrames = ((ma_jack_get_buffer_size_proc)pContext->jack.jack_get_buffer_size)((ma_jack_client_t*)pDevice->jack.pClient);

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
const char** ppPorts;

pDevice->capture.internalFormat = ma_format_f32;
pDevice->capture.internalChannels = 0;
pDevice->capture.internalSampleRate = ((ma_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((ma_jack_client_t*)pDevice->jack.pClient);
ma_get_standard_channel_map(ma_standard_channel_map_alsa, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);

ppPorts = ((ma_jack_get_ports_proc)pContext->jack.jack_get_ports)((ma_jack_client_t*)pDevice->jack.pClient, NULL, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsPhysical | ma_JackPortIsOutput);
if (ppPorts == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

while (ppPorts[pDevice->capture.internalChannels] != NULL) {
char name[64];
ma_strcpy_s(name, sizeof(name), "capture");
ma_itoa_s((int)pDevice->capture.internalChannels, name+7, sizeof(name)-7, 10); 

pDevice->jack.pPortsCapture[pDevice->capture.internalChannels] = ((ma_jack_port_register_proc)pContext->jack.jack_port_register)((ma_jack_client_t*)pDevice->jack.pClient, name, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsInput, 0);
if (pDevice->jack.pPortsCapture[pDevice->capture.internalChannels] == NULL) {
((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
ma_device_uninit__jack(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to register ports.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

pDevice->capture.internalChannels += 1;
}

((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);

pDevice->capture.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->capture.internalPeriods = periods;

pDevice->jack.pIntermediaryBufferCapture = (float*)ma__calloc_from_callbacks(pDevice->capture.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels), &pContext->allocationCallbacks);
if (pDevice->jack.pIntermediaryBufferCapture == NULL) {
ma_device_uninit__jack(pDevice);
return MA_OUT_OF_MEMORY;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
const char** ppPorts;

pDevice->playback.internalFormat = ma_format_f32;
pDevice->playback.internalChannels = 0;
pDevice->playback.internalSampleRate = ((ma_jack_get_sample_rate_proc)pContext->jack.jack_get_sample_rate)((ma_jack_client_t*)pDevice->jack.pClient);
ma_get_standard_channel_map(ma_standard_channel_map_alsa, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);

ppPorts = ((ma_jack_get_ports_proc)pContext->jack.jack_get_ports)((ma_jack_client_t*)pDevice->jack.pClient, NULL, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsPhysical | ma_JackPortIsInput);
if (ppPorts == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to query physical ports.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

while (ppPorts[pDevice->playback.internalChannels] != NULL) {
char name[64];
ma_strcpy_s(name, sizeof(name), "playback");
ma_itoa_s((int)pDevice->playback.internalChannels, name+8, sizeof(name)-8, 10); 

pDevice->jack.pPortsPlayback[pDevice->playback.internalChannels] = ((ma_jack_port_register_proc)pContext->jack.jack_port_register)((ma_jack_client_t*)pDevice->jack.pClient, name, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsOutput, 0);
if (pDevice->jack.pPortsPlayback[pDevice->playback.internalChannels] == NULL) {
((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);
ma_device_uninit__jack(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to register ports.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

pDevice->playback.internalChannels += 1;
}

((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppPorts);

pDevice->playback.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->playback.internalPeriods = periods;

pDevice->jack.pIntermediaryBufferPlayback = (float*)ma__calloc_from_callbacks(pDevice->playback.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels), &pContext->allocationCallbacks);
if (pDevice->jack.pIntermediaryBufferPlayback == NULL) {
ma_device_uninit__jack(pDevice);
return MA_OUT_OF_MEMORY;
}
}

if (pDevice->type == ma_device_type_duplex) {
ma_uint32 rbSizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalPeriodSizeInFrames * pDevice->capture.internalPeriods);
result = ma_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->pContext->allocationCallbacks, &pDevice->jack.duplexRB);
if (result != MA_SUCCESS) {
ma_device_uninit__jack(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to initialize ring buffer.", result);
}


{
ma_uint32 marginSizeInFrames = rbSizeInFrames / pDevice->capture.internalPeriods;
void* pMarginData;
ma_pcm_rb_acquire_write(&pDevice->jack.duplexRB, &marginSizeInFrames, &pMarginData);
{
MA_ZERO_MEMORY(pMarginData, marginSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels));
}
ma_pcm_rb_commit_write(&pDevice->jack.duplexRB, marginSizeInFrames, pMarginData);
}
}

return MA_SUCCESS;
}


static ma_result ma_device_start__jack(ma_device* pDevice)
{
ma_context* pContext = pDevice->pContext;
int resultJACK;
size_t i;

resultJACK = ((ma_jack_activate_proc)pContext->jack.jack_activate)((ma_jack_client_t*)pDevice->jack.pClient);
if (resultJACK != 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to activate the JACK client.", MA_FAILED_TO_START_BACKEND_DEVICE);
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
const char** ppServerPorts = ((ma_jack_get_ports_proc)pContext->jack.jack_get_ports)((ma_jack_client_t*)pDevice->jack.pClient, NULL, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsPhysical | ma_JackPortIsOutput);
if (ppServerPorts == NULL) {
((ma_jack_deactivate_proc)pContext->jack.jack_deactivate)((ma_jack_client_t*)pDevice->jack.pClient);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to retrieve physical ports.", MA_ERROR);
}

for (i = 0; ppServerPorts[i] != NULL; ++i) {
const char* pServerPort = ppServerPorts[i];
const char* pClientPort = ((ma_jack_port_name_proc)pContext->jack.jack_port_name)((ma_jack_port_t*)pDevice->jack.pPortsCapture[i]);

resultJACK = ((ma_jack_connect_proc)pContext->jack.jack_connect)((ma_jack_client_t*)pDevice->jack.pClient, pServerPort, pClientPort);
if (resultJACK != 0) {
((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
((ma_jack_deactivate_proc)pContext->jack.jack_deactivate)((ma_jack_client_t*)pDevice->jack.pClient);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to connect ports.", MA_ERROR);
}
}

((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
const char** ppServerPorts = ((ma_jack_get_ports_proc)pContext->jack.jack_get_ports)((ma_jack_client_t*)pDevice->jack.pClient, NULL, MA_JACK_DEFAULT_AUDIO_TYPE, ma_JackPortIsPhysical | ma_JackPortIsInput);
if (ppServerPorts == NULL) {
((ma_jack_deactivate_proc)pContext->jack.jack_deactivate)((ma_jack_client_t*)pDevice->jack.pClient);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to retrieve physical ports.", MA_ERROR);
}

for (i = 0; ppServerPorts[i] != NULL; ++i) {
const char* pServerPort = ppServerPorts[i];
const char* pClientPort = ((ma_jack_port_name_proc)pContext->jack.jack_port_name)((ma_jack_port_t*)pDevice->jack.pPortsPlayback[i]);

resultJACK = ((ma_jack_connect_proc)pContext->jack.jack_connect)((ma_jack_client_t*)pDevice->jack.pClient, pClientPort, pServerPort);
if (resultJACK != 0) {
((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
((ma_jack_deactivate_proc)pContext->jack.jack_deactivate)((ma_jack_client_t*)pDevice->jack.pClient);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] Failed to connect ports.", MA_ERROR);
}
}

((ma_jack_free_proc)pContext->jack.jack_free)((void*)ppServerPorts);
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__jack(ma_device* pDevice)
{
ma_context* pContext = pDevice->pContext;
ma_stop_proc onStop;

if (((ma_jack_deactivate_proc)pContext->jack.jack_deactivate)((ma_jack_client_t*)pDevice->jack.pClient) != 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[JACK] An error occurred when deactivating the JACK client.", MA_ERROR);
}

onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}

return MA_SUCCESS;
}


static ma_result ma_context_uninit__jack(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_jack);

ma_free(pContext->jack.pClientName, &pContext->allocationCallbacks);
pContext->jack.pClientName = NULL;

#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->jack.jackSO);
#endif

return MA_SUCCESS;
}

static ma_result ma_context_init__jack(const ma_context_config* pConfig, ma_context* pContext)
{
#if !defined(MA_NO_RUNTIME_LINKING)
const char* libjackNames[] = {
#if defined(MA_WIN32)
"libjack.dll"
#else
"libjack.so",
"libjack.so.0"
#endif
};
size_t i;

for (i = 0; i < ma_countof(libjackNames); ++i) {
pContext->jack.jackSO = ma_dlopen(pContext, libjackNames[i]);
if (pContext->jack.jackSO != NULL) {
break;
}
}

if (pContext->jack.jackSO == NULL) {
return MA_NO_BACKEND;
}

pContext->jack.jack_client_open = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_client_open");
pContext->jack.jack_client_close = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_client_close");
pContext->jack.jack_client_name_size = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_client_name_size");
pContext->jack.jack_set_process_callback = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_set_process_callback");
pContext->jack.jack_set_buffer_size_callback = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_set_buffer_size_callback");
pContext->jack.jack_on_shutdown = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_on_shutdown");
pContext->jack.jack_get_sample_rate = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_get_sample_rate");
pContext->jack.jack_get_buffer_size = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_get_buffer_size");
pContext->jack.jack_get_ports = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_get_ports");
pContext->jack.jack_activate = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_activate");
pContext->jack.jack_deactivate = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_deactivate");
pContext->jack.jack_connect = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_connect");
pContext->jack.jack_port_register = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_port_register");
pContext->jack.jack_port_name = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_port_name");
pContext->jack.jack_port_get_buffer = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_port_get_buffer");
pContext->jack.jack_free = (ma_proc)ma_dlsym(pContext, pContext->jack.jackSO, "jack_free");
#else




ma_jack_client_open_proc _jack_client_open = jack_client_open;
ma_jack_client_close_proc _jack_client_close = jack_client_close;
ma_jack_client_name_size_proc _jack_client_name_size = jack_client_name_size;
ma_jack_set_process_callback_proc _jack_set_process_callback = jack_set_process_callback;
ma_jack_set_buffer_size_callback_proc _jack_set_buffer_size_callback = jack_set_buffer_size_callback;
ma_jack_on_shutdown_proc _jack_on_shutdown = jack_on_shutdown;
ma_jack_get_sample_rate_proc _jack_get_sample_rate = jack_get_sample_rate;
ma_jack_get_buffer_size_proc _jack_get_buffer_size = jack_get_buffer_size;
ma_jack_get_ports_proc _jack_get_ports = jack_get_ports;
ma_jack_activate_proc _jack_activate = jack_activate;
ma_jack_deactivate_proc _jack_deactivate = jack_deactivate;
ma_jack_connect_proc _jack_connect = jack_connect;
ma_jack_port_register_proc _jack_port_register = jack_port_register;
ma_jack_port_name_proc _jack_port_name = jack_port_name;
ma_jack_port_get_buffer_proc _jack_port_get_buffer = jack_port_get_buffer;
ma_jack_free_proc _jack_free = jack_free;

pContext->jack.jack_client_open = (ma_proc)_jack_client_open;
pContext->jack.jack_client_close = (ma_proc)_jack_client_close;
pContext->jack.jack_client_name_size = (ma_proc)_jack_client_name_size;
pContext->jack.jack_set_process_callback = (ma_proc)_jack_set_process_callback;
pContext->jack.jack_set_buffer_size_callback = (ma_proc)_jack_set_buffer_size_callback;
pContext->jack.jack_on_shutdown = (ma_proc)_jack_on_shutdown;
pContext->jack.jack_get_sample_rate = (ma_proc)_jack_get_sample_rate;
pContext->jack.jack_get_buffer_size = (ma_proc)_jack_get_buffer_size;
pContext->jack.jack_get_ports = (ma_proc)_jack_get_ports;
pContext->jack.jack_activate = (ma_proc)_jack_activate;
pContext->jack.jack_deactivate = (ma_proc)_jack_deactivate;
pContext->jack.jack_connect = (ma_proc)_jack_connect;
pContext->jack.jack_port_register = (ma_proc)_jack_port_register;
pContext->jack.jack_port_name = (ma_proc)_jack_port_name;
pContext->jack.jack_port_get_buffer = (ma_proc)_jack_port_get_buffer;
pContext->jack.jack_free = (ma_proc)_jack_free;
#endif

pContext->isBackendAsynchronous = MA_TRUE;

pContext->onUninit = ma_context_uninit__jack;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__jack;
pContext->onEnumDevices = ma_context_enumerate_devices__jack;
pContext->onGetDeviceInfo = ma_context_get_device_info__jack;
pContext->onDeviceInit = ma_device_init__jack;
pContext->onDeviceUninit = ma_device_uninit__jack;
pContext->onDeviceStart = ma_device_start__jack;
pContext->onDeviceStop = ma_device_stop__jack;

if (pConfig->jack.pClientName != NULL) {
pContext->jack.pClientName = ma_copy_string(pConfig->jack.pClientName, &pContext->allocationCallbacks);
}
pContext->jack.tryStartServer = pConfig->jack.tryStartServer;





{
ma_jack_client_t* pDummyClient;
ma_result result = ma_context_open_client__jack(pContext, &pDummyClient);
if (result != MA_SUCCESS) {
ma_free(pContext->jack.pClientName, &pContext->allocationCallbacks);
#if !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->jack.jackSO);
#endif
return MA_NO_BACKEND;
}

((ma_jack_client_close_proc)pContext->jack.jack_client_close)((ma_jack_client_t*)pDummyClient);
}

return MA_SUCCESS;
}
#endif 








#if defined(MA_HAS_COREAUDIO)
#include <TargetConditionals.h>

#if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1
#define MA_APPLE_MOBILE
#if defined(TARGET_OS_TV) && TARGET_OS_TV == 1
#define MA_APPLE_TV
#endif
#if defined(TARGET_OS_WATCH) && TARGET_OS_WATCH == 1
#define MA_APPLE_WATCH
#endif
#else
#define MA_APPLE_DESKTOP
#endif

#if defined(MA_APPLE_DESKTOP)
#include <CoreAudio/CoreAudio.h>
#else
#include <AVFoundation/AVFoundation.h>
#endif

#include <AudioToolbox/AudioToolbox.h>


typedef Boolean (* ma_CFStringGetCString_proc)(CFStringRef theString, char* buffer, CFIndex bufferSize, CFStringEncoding encoding);
typedef void (* ma_CFRelease_proc)(CFTypeRef cf);


#if defined(MA_APPLE_DESKTOP)
typedef OSStatus (* ma_AudioObjectGetPropertyData_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32* ioDataSize, void* outData);
typedef OSStatus (* ma_AudioObjectGetPropertyDataSize_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32* outDataSize);
typedef OSStatus (* ma_AudioObjectSetPropertyData_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, UInt32 inQualifierDataSize, const void* inQualifierData, UInt32 inDataSize, const void* inData);
typedef OSStatus (* ma_AudioObjectAddPropertyListener_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, AudioObjectPropertyListenerProc inListener, void* inClientData);
typedef OSStatus (* ma_AudioObjectRemovePropertyListener_proc)(AudioObjectID inObjectID, const AudioObjectPropertyAddress* inAddress, AudioObjectPropertyListenerProc inListener, void* inClientData);
#endif


typedef AudioComponent (* ma_AudioComponentFindNext_proc)(AudioComponent inComponent, const AudioComponentDescription* inDesc);
typedef OSStatus (* ma_AudioComponentInstanceDispose_proc)(AudioComponentInstance inInstance);
typedef OSStatus (* ma_AudioComponentInstanceNew_proc)(AudioComponent inComponent, AudioComponentInstance* outInstance);
typedef OSStatus (* ma_AudioOutputUnitStart_proc)(AudioUnit inUnit);
typedef OSStatus (* ma_AudioOutputUnitStop_proc)(AudioUnit inUnit);
typedef OSStatus (* ma_AudioUnitAddPropertyListener_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitPropertyListenerProc inProc, void* inProcUserData);
typedef OSStatus (* ma_AudioUnitGetPropertyInfo_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, UInt32* outDataSize, Boolean* outWriteable);
typedef OSStatus (* ma_AudioUnitGetProperty_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void* outData, UInt32* ioDataSize);
typedef OSStatus (* ma_AudioUnitSetProperty_proc)(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void* inData, UInt32 inDataSize);
typedef OSStatus (* ma_AudioUnitInitialize_proc)(AudioUnit inUnit);
typedef OSStatus (* ma_AudioUnitRender_proc)(AudioUnit inUnit, AudioUnitRenderActionFlags* ioActionFlags, const AudioTimeStamp* inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList* ioData);


#define MA_COREAUDIO_OUTPUT_BUS 0
#define MA_COREAUDIO_INPUT_BUS 1

static ma_result ma_device_reinit_internal__coreaudio(ma_device* pDevice, ma_device_type deviceType, ma_bool32 disposePreviousAudioUnit);


































static ma_result ma_result_from_OSStatus(OSStatus status)
{
switch (status)
{
case noErr: return MA_SUCCESS;
#if defined(MA_APPLE_DESKTOP)
case kAudioHardwareNotRunningError: return MA_DEVICE_NOT_STARTED;
case kAudioHardwareUnspecifiedError: return MA_ERROR;
case kAudioHardwareUnknownPropertyError: return MA_INVALID_ARGS;
case kAudioHardwareBadPropertySizeError: return MA_INVALID_OPERATION;
case kAudioHardwareIllegalOperationError: return MA_INVALID_OPERATION;
case kAudioHardwareBadObjectError: return MA_INVALID_ARGS;
case kAudioHardwareBadDeviceError: return MA_INVALID_ARGS;
case kAudioHardwareBadStreamError: return MA_INVALID_ARGS;
case kAudioHardwareUnsupportedOperationError: return MA_INVALID_OPERATION;
case kAudioDeviceUnsupportedFormatError: return MA_FORMAT_NOT_SUPPORTED;
case kAudioDevicePermissionsError: return MA_ACCESS_DENIED;
#endif
default: return MA_ERROR;
}
}

#if 0
static ma_channel ma_channel_from_AudioChannelBitmap(AudioChannelBitmap bit)
{
switch (bit)
{
case kAudioChannelBit_Left: return MA_CHANNEL_LEFT;
case kAudioChannelBit_Right: return MA_CHANNEL_RIGHT;
case kAudioChannelBit_Center: return MA_CHANNEL_FRONT_CENTER;
case kAudioChannelBit_LFEScreen: return MA_CHANNEL_LFE;
case kAudioChannelBit_LeftSurround: return MA_CHANNEL_BACK_LEFT;
case kAudioChannelBit_RightSurround: return MA_CHANNEL_BACK_RIGHT;
case kAudioChannelBit_LeftCenter: return MA_CHANNEL_FRONT_LEFT_CENTER;
case kAudioChannelBit_RightCenter: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case kAudioChannelBit_CenterSurround: return MA_CHANNEL_BACK_CENTER;
case kAudioChannelBit_LeftSurroundDirect: return MA_CHANNEL_SIDE_LEFT;
case kAudioChannelBit_RightSurroundDirect: return MA_CHANNEL_SIDE_RIGHT;
case kAudioChannelBit_TopCenterSurround: return MA_CHANNEL_TOP_CENTER;
case kAudioChannelBit_VerticalHeightLeft: return MA_CHANNEL_TOP_FRONT_LEFT;
case kAudioChannelBit_VerticalHeightCenter: return MA_CHANNEL_TOP_FRONT_CENTER;
case kAudioChannelBit_VerticalHeightRight: return MA_CHANNEL_TOP_FRONT_RIGHT;
case kAudioChannelBit_TopBackLeft: return MA_CHANNEL_TOP_BACK_LEFT;
case kAudioChannelBit_TopBackCenter: return MA_CHANNEL_TOP_BACK_CENTER;
case kAudioChannelBit_TopBackRight: return MA_CHANNEL_TOP_BACK_RIGHT;
default: return MA_CHANNEL_NONE;
}
}
#endif

static ma_channel ma_channel_from_AudioChannelLabel(AudioChannelLabel label)
{
switch (label)
{
case kAudioChannelLabel_Unknown: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Unused: return MA_CHANNEL_NONE;
case kAudioChannelLabel_UseCoordinates: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Left: return MA_CHANNEL_LEFT;
case kAudioChannelLabel_Right: return MA_CHANNEL_RIGHT;
case kAudioChannelLabel_Center: return MA_CHANNEL_FRONT_CENTER;
case kAudioChannelLabel_LFEScreen: return MA_CHANNEL_LFE;
case kAudioChannelLabel_LeftSurround: return MA_CHANNEL_BACK_LEFT;
case kAudioChannelLabel_RightSurround: return MA_CHANNEL_BACK_RIGHT;
case kAudioChannelLabel_LeftCenter: return MA_CHANNEL_FRONT_LEFT_CENTER;
case kAudioChannelLabel_RightCenter: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case kAudioChannelLabel_CenterSurround: return MA_CHANNEL_BACK_CENTER;
case kAudioChannelLabel_LeftSurroundDirect: return MA_CHANNEL_SIDE_LEFT;
case kAudioChannelLabel_RightSurroundDirect: return MA_CHANNEL_SIDE_RIGHT;
case kAudioChannelLabel_TopCenterSurround: return MA_CHANNEL_TOP_CENTER;
case kAudioChannelLabel_VerticalHeightLeft: return MA_CHANNEL_TOP_FRONT_LEFT;
case kAudioChannelLabel_VerticalHeightCenter: return MA_CHANNEL_TOP_FRONT_CENTER;
case kAudioChannelLabel_VerticalHeightRight: return MA_CHANNEL_TOP_FRONT_RIGHT;
case kAudioChannelLabel_TopBackLeft: return MA_CHANNEL_TOP_BACK_LEFT;
case kAudioChannelLabel_TopBackCenter: return MA_CHANNEL_TOP_BACK_CENTER;
case kAudioChannelLabel_TopBackRight: return MA_CHANNEL_TOP_BACK_RIGHT;
case kAudioChannelLabel_RearSurroundLeft: return MA_CHANNEL_BACK_LEFT;
case kAudioChannelLabel_RearSurroundRight: return MA_CHANNEL_BACK_RIGHT;
case kAudioChannelLabel_LeftWide: return MA_CHANNEL_SIDE_LEFT;
case kAudioChannelLabel_RightWide: return MA_CHANNEL_SIDE_RIGHT;
case kAudioChannelLabel_LFE2: return MA_CHANNEL_LFE;
case kAudioChannelLabel_LeftTotal: return MA_CHANNEL_LEFT;
case kAudioChannelLabel_RightTotal: return MA_CHANNEL_RIGHT;
case kAudioChannelLabel_HearingImpaired: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Narration: return MA_CHANNEL_MONO;
case kAudioChannelLabel_Mono: return MA_CHANNEL_MONO;
case kAudioChannelLabel_DialogCentricMix: return MA_CHANNEL_MONO;
case kAudioChannelLabel_CenterSurroundDirect: return MA_CHANNEL_BACK_CENTER;
case kAudioChannelLabel_Haptic: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Ambisonic_W: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Ambisonic_X: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Ambisonic_Y: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Ambisonic_Z: return MA_CHANNEL_NONE;
case kAudioChannelLabel_MS_Mid: return MA_CHANNEL_LEFT;
case kAudioChannelLabel_MS_Side: return MA_CHANNEL_RIGHT;
case kAudioChannelLabel_XY_X: return MA_CHANNEL_LEFT;
case kAudioChannelLabel_XY_Y: return MA_CHANNEL_RIGHT;
case kAudioChannelLabel_HeadphonesLeft: return MA_CHANNEL_LEFT;
case kAudioChannelLabel_HeadphonesRight: return MA_CHANNEL_RIGHT;
case kAudioChannelLabel_ClickTrack: return MA_CHANNEL_NONE;
case kAudioChannelLabel_ForeignLanguage: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Discrete: return MA_CHANNEL_NONE;
case kAudioChannelLabel_Discrete_0: return MA_CHANNEL_AUX_0;
case kAudioChannelLabel_Discrete_1: return MA_CHANNEL_AUX_1;
case kAudioChannelLabel_Discrete_2: return MA_CHANNEL_AUX_2;
case kAudioChannelLabel_Discrete_3: return MA_CHANNEL_AUX_3;
case kAudioChannelLabel_Discrete_4: return MA_CHANNEL_AUX_4;
case kAudioChannelLabel_Discrete_5: return MA_CHANNEL_AUX_5;
case kAudioChannelLabel_Discrete_6: return MA_CHANNEL_AUX_6;
case kAudioChannelLabel_Discrete_7: return MA_CHANNEL_AUX_7;
case kAudioChannelLabel_Discrete_8: return MA_CHANNEL_AUX_8;
case kAudioChannelLabel_Discrete_9: return MA_CHANNEL_AUX_9;
case kAudioChannelLabel_Discrete_10: return MA_CHANNEL_AUX_10;
case kAudioChannelLabel_Discrete_11: return MA_CHANNEL_AUX_11;
case kAudioChannelLabel_Discrete_12: return MA_CHANNEL_AUX_12;
case kAudioChannelLabel_Discrete_13: return MA_CHANNEL_AUX_13;
case kAudioChannelLabel_Discrete_14: return MA_CHANNEL_AUX_14;
case kAudioChannelLabel_Discrete_15: return MA_CHANNEL_AUX_15;
case kAudioChannelLabel_Discrete_65535: return MA_CHANNEL_NONE;

#if 0 
case kAudioChannelLabel_HOA_ACN: return MA_CHANNEL_NONE;
case kAudioChannelLabel_HOA_ACN_0: return MA_CHANNEL_AUX_0;
case kAudioChannelLabel_HOA_ACN_1: return MA_CHANNEL_AUX_1;
case kAudioChannelLabel_HOA_ACN_2: return MA_CHANNEL_AUX_2;
case kAudioChannelLabel_HOA_ACN_3: return MA_CHANNEL_AUX_3;
case kAudioChannelLabel_HOA_ACN_4: return MA_CHANNEL_AUX_4;
case kAudioChannelLabel_HOA_ACN_5: return MA_CHANNEL_AUX_5;
case kAudioChannelLabel_HOA_ACN_6: return MA_CHANNEL_AUX_6;
case kAudioChannelLabel_HOA_ACN_7: return MA_CHANNEL_AUX_7;
case kAudioChannelLabel_HOA_ACN_8: return MA_CHANNEL_AUX_8;
case kAudioChannelLabel_HOA_ACN_9: return MA_CHANNEL_AUX_9;
case kAudioChannelLabel_HOA_ACN_10: return MA_CHANNEL_AUX_10;
case kAudioChannelLabel_HOA_ACN_11: return MA_CHANNEL_AUX_11;
case kAudioChannelLabel_HOA_ACN_12: return MA_CHANNEL_AUX_12;
case kAudioChannelLabel_HOA_ACN_13: return MA_CHANNEL_AUX_13;
case kAudioChannelLabel_HOA_ACN_14: return MA_CHANNEL_AUX_14;
case kAudioChannelLabel_HOA_ACN_15: return MA_CHANNEL_AUX_15;
case kAudioChannelLabel_HOA_ACN_65024: return MA_CHANNEL_NONE;
#endif

default: return MA_CHANNEL_NONE;
}
}

static ma_result ma_format_from_AudioStreamBasicDescription(const AudioStreamBasicDescription* pDescription, ma_format* pFormatOut)
{
MA_ASSERT(pDescription != NULL);
MA_ASSERT(pFormatOut != NULL);

*pFormatOut = ma_format_unknown; 


if (pDescription->mFormatID != kAudioFormatLinearPCM) {
return MA_FORMAT_NOT_SUPPORTED;
}


if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsAlignedHigh) != 0) {
return MA_FORMAT_NOT_SUPPORTED;
}


if ((ma_is_little_endian() && (pDescription->mFormatFlags & kAudioFormatFlagIsBigEndian) != 0) || (ma_is_big_endian() && (pDescription->mFormatFlags & kAudioFormatFlagIsBigEndian) == 0)) {
return MA_FORMAT_NOT_SUPPORTED;
}






if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsFloat) != 0) {
if (pDescription->mBitsPerChannel == 32) {
*pFormatOut = ma_format_f32;
return MA_SUCCESS;
}
} else {
if ((pDescription->mFormatFlags & kLinearPCMFormatFlagIsSignedInteger) != 0) {
if (pDescription->mBitsPerChannel == 16) {
*pFormatOut = ma_format_s16;
return MA_SUCCESS;
} else if (pDescription->mBitsPerChannel == 24) {
if (pDescription->mBytesPerFrame == (pDescription->mBitsPerChannel/8 * pDescription->mChannelsPerFrame)) {
*pFormatOut = ma_format_s24;
return MA_SUCCESS;
} else {
if (pDescription->mBytesPerFrame/pDescription->mChannelsPerFrame == sizeof(ma_int32)) {



return MA_FORMAT_NOT_SUPPORTED;
}
}
} else if (pDescription->mBitsPerChannel == 32) {
*pFormatOut = ma_format_s32;
return MA_SUCCESS;
}
} else {
if (pDescription->mBitsPerChannel == 8) {
*pFormatOut = ma_format_u8;
return MA_SUCCESS;
}
}
}


return MA_FORMAT_NOT_SUPPORTED;
}

static ma_result ma_get_channel_map_from_AudioChannelLayout(AudioChannelLayout* pChannelLayout, ma_channel channelMap[MA_MAX_CHANNELS])
{
MA_ASSERT(pChannelLayout != NULL);

if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelDescriptions) {
UInt32 iChannel;
for (iChannel = 0; iChannel < pChannelLayout->mNumberChannelDescriptions; ++iChannel) {
channelMap[iChannel] = ma_channel_from_AudioChannelLabel(pChannelLayout->mChannelDescriptions[iChannel].mChannelLabel);
}
} else
#if 0
if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap) {

UInt32 iChannel = 0;
UInt32 iBit;
AudioChannelBitmap bitmap = pChannelLayout->mChannelBitmap;
for (iBit = 0; iBit < 32; ++iBit) {
AudioChannelBitmap bit = bitmap & (1 << iBit);
if (bit != 0) {
channelMap[iChannel++] = ma_channel_from_AudioChannelBit(bit);
}
}
} else
#endif
{




UInt32 channelCount = AudioChannelLayoutTag_GetNumberOfChannels(pChannelLayout->mChannelLayoutTag);
switch (pChannelLayout->mChannelLayoutTag)
{
case kAudioChannelLayoutTag_Mono:
case kAudioChannelLayoutTag_Stereo:
case kAudioChannelLayoutTag_StereoHeadphones:
case kAudioChannelLayoutTag_MatrixStereo:
case kAudioChannelLayoutTag_MidSide:
case kAudioChannelLayoutTag_XY:
case kAudioChannelLayoutTag_Binaural:
case kAudioChannelLayoutTag_Ambisonic_B_Format:
{
ma_get_standard_channel_map(ma_standard_channel_map_default, channelCount, channelMap);
} break;

case kAudioChannelLayoutTag_Octagonal:
{
channelMap[7] = MA_CHANNEL_SIDE_RIGHT;
channelMap[6] = MA_CHANNEL_SIDE_LEFT;
} 
case kAudioChannelLayoutTag_Hexagonal:
{
channelMap[5] = MA_CHANNEL_BACK_CENTER;
} 
case kAudioChannelLayoutTag_Pentagonal:
{
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
} 
case kAudioChannelLayoutTag_Quadraphonic:
{
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
channelMap[0] = MA_CHANNEL_LEFT;
} break;



default:
{
ma_get_standard_channel_map(ma_standard_channel_map_default, channelCount, channelMap);
} break;
}
}

return MA_SUCCESS;
}


#if defined(MA_APPLE_DESKTOP)
static ma_result ma_get_device_object_ids__coreaudio(ma_context* pContext, UInt32* pDeviceCount, AudioObjectID** ppDeviceObjectIDs) 
{
AudioObjectPropertyAddress propAddressDevices;
UInt32 deviceObjectsDataSize;
OSStatus status;
AudioObjectID* pDeviceObjectIDs;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pDeviceCount != NULL);
MA_ASSERT(ppDeviceObjectIDs != NULL);


*pDeviceCount = 0;
*ppDeviceObjectIDs = NULL;

propAddressDevices.mSelector = kAudioHardwarePropertyDevices;
propAddressDevices.mScope = kAudioObjectPropertyScopeGlobal;
propAddressDevices.mElement = kAudioObjectPropertyElementMaster;

status = ((ma_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(kAudioObjectSystemObject, &propAddressDevices, 0, NULL, &deviceObjectsDataSize);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

pDeviceObjectIDs = (AudioObjectID*)ma_malloc(deviceObjectsDataSize, &pContext->allocationCallbacks);
if (pDeviceObjectIDs == NULL) {
return MA_OUT_OF_MEMORY;
}

status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(kAudioObjectSystemObject, &propAddressDevices, 0, NULL, &deviceObjectsDataSize, pDeviceObjectIDs);
if (status != noErr) {
ma_free(pDeviceObjectIDs, &pContext->allocationCallbacks);
return ma_result_from_OSStatus(status);
}

*pDeviceCount = deviceObjectsDataSize / sizeof(AudioObjectID);
*ppDeviceObjectIDs = pDeviceObjectIDs;

return MA_SUCCESS;
}

static ma_result ma_get_AudioObject_uid_as_CFStringRef(ma_context* pContext, AudioObjectID objectID, CFStringRef* pUID)
{
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;

MA_ASSERT(pContext != NULL);

propAddress.mSelector = kAudioDevicePropertyDeviceUID;
propAddress.mScope = kAudioObjectPropertyScopeGlobal;
propAddress.mElement = kAudioObjectPropertyElementMaster;

dataSize = sizeof(*pUID);
status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(objectID, &propAddress, 0, NULL, &dataSize, pUID);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

return MA_SUCCESS;
}

static ma_result ma_get_AudioObject_uid(ma_context* pContext, AudioObjectID objectID, size_t bufferSize, char* bufferOut)
{
CFStringRef uid;
ma_result result;

MA_ASSERT(pContext != NULL);

result = ma_get_AudioObject_uid_as_CFStringRef(pContext, objectID, &uid);
if (result != MA_SUCCESS) {
return result;
}

if (!((ma_CFStringGetCString_proc)pContext->coreaudio.CFStringGetCString)(uid, bufferOut, bufferSize, kCFStringEncodingUTF8)) {
return MA_ERROR;
}

((ma_CFRelease_proc)pContext->coreaudio.CFRelease)(uid);
return MA_SUCCESS;
}

static ma_result ma_get_AudioObject_name(ma_context* pContext, AudioObjectID objectID, size_t bufferSize, char* bufferOut)
{
AudioObjectPropertyAddress propAddress;
CFStringRef deviceName = NULL;
UInt32 dataSize;
OSStatus status;

MA_ASSERT(pContext != NULL);

propAddress.mSelector = kAudioDevicePropertyDeviceNameCFString;
propAddress.mScope = kAudioObjectPropertyScopeGlobal;
propAddress.mElement = kAudioObjectPropertyElementMaster;

dataSize = sizeof(deviceName);
status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(objectID, &propAddress, 0, NULL, &dataSize, &deviceName);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

if (!((ma_CFStringGetCString_proc)pContext->coreaudio.CFStringGetCString)(deviceName, bufferOut, bufferSize, kCFStringEncodingUTF8)) {
return MA_ERROR;
}

((ma_CFRelease_proc)pContext->coreaudio.CFRelease)(deviceName);
return MA_SUCCESS;
}

static ma_bool32 ma_does_AudioObject_support_scope(ma_context* pContext, AudioObjectID deviceObjectID, AudioObjectPropertyScope scope)
{
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;
AudioBufferList* pBufferList;
ma_bool32 isSupported;

MA_ASSERT(pContext != NULL);


propAddress.mSelector = kAudioDevicePropertyStreamConfiguration;
propAddress.mScope = scope;
propAddress.mElement = kAudioObjectPropertyElementMaster;

status = ((ma_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
if (status != noErr) {
return MA_FALSE;
}

pBufferList = (AudioBufferList*)ma__malloc_from_callbacks(dataSize, &pContext->allocationCallbacks);
if (pBufferList == NULL) {
return MA_FALSE; 
}

status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pBufferList);
if (status != noErr) {
ma__free_from_callbacks(pBufferList, &pContext->allocationCallbacks);
return MA_FALSE;
}

isSupported = MA_FALSE;
if (pBufferList->mNumberBuffers > 0) {
isSupported = MA_TRUE;
}

ma__free_from_callbacks(pBufferList, &pContext->allocationCallbacks);
return isSupported;
}

static ma_bool32 ma_does_AudioObject_support_playback(ma_context* pContext, AudioObjectID deviceObjectID)
{
return ma_does_AudioObject_support_scope(pContext, deviceObjectID, kAudioObjectPropertyScopeOutput);
}

static ma_bool32 ma_does_AudioObject_support_capture(ma_context* pContext, AudioObjectID deviceObjectID)
{
return ma_does_AudioObject_support_scope(pContext, deviceObjectID, kAudioObjectPropertyScopeInput);
}


static ma_result ma_get_AudioObject_stream_descriptions(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, UInt32* pDescriptionCount, AudioStreamRangedDescription** ppDescriptions) 
{
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;
AudioStreamRangedDescription* pDescriptions;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pDescriptionCount != NULL);
MA_ASSERT(ppDescriptions != NULL);





propAddress.mSelector = kAudioStreamPropertyAvailableVirtualFormats; 
propAddress.mScope = (deviceType == ma_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
propAddress.mElement = kAudioObjectPropertyElementMaster;

status = ((ma_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

pDescriptions = (AudioStreamRangedDescription*)ma_malloc(dataSize, &pContext->allocationCallbacks);
if (pDescriptions == NULL) {
return MA_OUT_OF_MEMORY;
}

status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pDescriptions);
if (status != noErr) {
ma_free(pDescriptions, &pContext->allocationCallbacks);
return ma_result_from_OSStatus(status);
}

*pDescriptionCount = dataSize / sizeof(*pDescriptions);
*ppDescriptions = pDescriptions;
return MA_SUCCESS;
}


static ma_result ma_get_AudioObject_channel_layout(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, AudioChannelLayout** ppChannelLayout) 
{
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;
AudioChannelLayout* pChannelLayout;

MA_ASSERT(pContext != NULL);
MA_ASSERT(ppChannelLayout != NULL);

*ppChannelLayout = NULL; 

propAddress.mSelector = kAudioDevicePropertyPreferredChannelLayout;
propAddress.mScope = (deviceType == ma_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
propAddress.mElement = kAudioObjectPropertyElementMaster;

status = ((ma_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

pChannelLayout = (AudioChannelLayout*)ma_malloc(dataSize, &pContext->allocationCallbacks);
if (pChannelLayout == NULL) {
return MA_OUT_OF_MEMORY;
}

status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pChannelLayout);
if (status != noErr) {
ma_free(pChannelLayout, &pContext->allocationCallbacks);
return ma_result_from_OSStatus(status);
}

*ppChannelLayout = pChannelLayout;
return MA_SUCCESS;
}

static ma_result ma_get_AudioObject_channel_count(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_uint32* pChannelCount)
{
AudioChannelLayout* pChannelLayout;
ma_result result;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pChannelCount != NULL);

*pChannelCount = 0; 

result = ma_get_AudioObject_channel_layout(pContext, deviceObjectID, deviceType, &pChannelLayout);
if (result != MA_SUCCESS) {
return result;
}

if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelDescriptions) {
*pChannelCount = pChannelLayout->mNumberChannelDescriptions;
} else if (pChannelLayout->mChannelLayoutTag == kAudioChannelLayoutTag_UseChannelBitmap) {
*pChannelCount = ma_count_set_bits(pChannelLayout->mChannelBitmap);
} else {
*pChannelCount = AudioChannelLayoutTag_GetNumberOfChannels(pChannelLayout->mChannelLayoutTag);
}

ma_free(pChannelLayout, &pContext->allocationCallbacks);
return MA_SUCCESS;
}

#if 0
static ma_result ma_get_AudioObject_channel_map(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_channel channelMap[MA_MAX_CHANNELS])
{
AudioChannelLayout* pChannelLayout;
ma_result result;

MA_ASSERT(pContext != NULL);

result = ma_get_AudioObject_channel_layout(pContext, deviceObjectID, deviceType, &pChannelLayout);
if (result != MA_SUCCESS) {
return result; 
}

result = ma_get_channel_map_from_AudioChannelLayout(pChannelLayout, channelMap);
if (result != MA_SUCCESS) {
ma_free(pChannelLayout, &pContext->allocationCallbacks);
return result;
}

ma_free(pChannelLayout, &pContext->allocationCallbacks);
return result;
}
#endif

static ma_result ma_get_AudioObject_sample_rates(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, UInt32* pSampleRateRangesCount, AudioValueRange** ppSampleRateRanges) 
{
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;
AudioValueRange* pSampleRateRanges;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pSampleRateRangesCount != NULL);
MA_ASSERT(ppSampleRateRanges != NULL);


*pSampleRateRangesCount = 0;
*ppSampleRateRanges = NULL;

propAddress.mSelector = kAudioDevicePropertyAvailableNominalSampleRates;
propAddress.mScope = (deviceType == ma_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
propAddress.mElement = kAudioObjectPropertyElementMaster;

status = ((ma_AudioObjectGetPropertyDataSize_proc)pContext->coreaudio.AudioObjectGetPropertyDataSize)(deviceObjectID, &propAddress, 0, NULL, &dataSize);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

pSampleRateRanges = (AudioValueRange*)ma_malloc(dataSize, &pContext->allocationCallbacks);
if (pSampleRateRanges == NULL) {
return MA_OUT_OF_MEMORY;
}

status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, pSampleRateRanges);
if (status != noErr) {
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return ma_result_from_OSStatus(status);
}

*pSampleRateRangesCount = dataSize / sizeof(*pSampleRateRanges);
*ppSampleRateRanges = pSampleRateRanges;
return MA_SUCCESS;
}

#if 0
static ma_result ma_get_AudioObject_get_closest_sample_rate(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_uint32 sampleRateIn, ma_uint32* pSampleRateOut)
{
UInt32 sampleRateRangeCount;
AudioValueRange* pSampleRateRanges;
ma_result result;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pSampleRateOut != NULL);

*pSampleRateOut = 0; 

result = ma_get_AudioObject_sample_rates(pContext, deviceObjectID, deviceType, &sampleRateRangeCount, &pSampleRateRanges);
if (result != MA_SUCCESS) {
return result;
}

if (sampleRateRangeCount == 0) {
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return MA_ERROR; 
}

if (sampleRateIn == 0) {

UInt32 iMALSampleRate;
for (iMALSampleRate = 0; iMALSampleRate < ma_countof(g_maStandardSampleRatePriorities); ++iMALSampleRate) {
ma_uint32 malSampleRate = g_maStandardSampleRatePriorities[iMALSampleRate];
UInt32 iCASampleRate;
for (iCASampleRate = 0; iCASampleRate < sampleRateRangeCount; ++iCASampleRate) {
AudioValueRange caSampleRate = pSampleRateRanges[iCASampleRate];
if (caSampleRate.mMinimum <= malSampleRate && caSampleRate.mMaximum >= malSampleRate) {
*pSampleRateOut = malSampleRate;
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return MA_SUCCESS;
}
}
}





MA_ASSERT(sampleRateRangeCount > 0);

*pSampleRateOut = pSampleRateRanges[0].mMinimum;
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return MA_SUCCESS;
} else {

UInt32 currentAbsoluteDifference = INT32_MAX;
UInt32 iCurrentClosestRange = (UInt32)-1;
UInt32 iRange;
for (iRange = 0; iRange < sampleRateRangeCount; ++iRange) {
if (pSampleRateRanges[iRange].mMinimum <= sampleRateIn && pSampleRateRanges[iRange].mMaximum >= sampleRateIn) {
*pSampleRateOut = sampleRateIn;
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return MA_SUCCESS;
} else {
UInt32 absoluteDifference;
if (pSampleRateRanges[iRange].mMinimum > sampleRateIn) {
absoluteDifference = pSampleRateRanges[iRange].mMinimum - sampleRateIn;
} else {
absoluteDifference = sampleRateIn - pSampleRateRanges[iRange].mMaximum;
}

if (currentAbsoluteDifference > absoluteDifference) {
currentAbsoluteDifference = absoluteDifference;
iCurrentClosestRange = iRange;
}
}
}

MA_ASSERT(iCurrentClosestRange != (UInt32)-1);

*pSampleRateOut = pSampleRateRanges[iCurrentClosestRange].mMinimum;
ma_free(pSampleRateRanges, &pContext->allocationCallbacks);
return MA_SUCCESS;
}




}
#endif

static ma_result ma_get_AudioObject_closest_buffer_size_in_frames(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_uint32 bufferSizeInFramesIn, ma_uint32* pBufferSizeInFramesOut)
{
AudioObjectPropertyAddress propAddress;
AudioValueRange bufferSizeRange;
UInt32 dataSize;
OSStatus status;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pBufferSizeInFramesOut != NULL);

*pBufferSizeInFramesOut = 0; 

propAddress.mSelector = kAudioDevicePropertyBufferFrameSizeRange;
propAddress.mScope = (deviceType == ma_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
propAddress.mElement = kAudioObjectPropertyElementMaster;

dataSize = sizeof(bufferSizeRange);
status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, &bufferSizeRange);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}


if (bufferSizeInFramesIn < bufferSizeRange.mMinimum) {
*pBufferSizeInFramesOut = (ma_uint32)bufferSizeRange.mMinimum;
} else if (bufferSizeInFramesIn > bufferSizeRange.mMaximum) {
*pBufferSizeInFramesOut = (ma_uint32)bufferSizeRange.mMaximum;
} else {
*pBufferSizeInFramesOut = bufferSizeInFramesIn;
}

return MA_SUCCESS;
}

static ma_result ma_set_AudioObject_buffer_size_in_frames(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_uint32* pPeriodSizeInOut)
{
ma_result result;
ma_uint32 chosenBufferSizeInFrames;
AudioObjectPropertyAddress propAddress;
UInt32 dataSize;
OSStatus status;

MA_ASSERT(pContext != NULL);

result = ma_get_AudioObject_closest_buffer_size_in_frames(pContext, deviceObjectID, deviceType, *pPeriodSizeInOut, &chosenBufferSizeInFrames);
if (result != MA_SUCCESS) {
return result;
}


propAddress.mSelector = kAudioDevicePropertyBufferFrameSize;
propAddress.mScope = (deviceType == ma_device_type_playback) ? kAudioObjectPropertyScopeOutput : kAudioObjectPropertyScopeInput;
propAddress.mElement = kAudioObjectPropertyElementMaster;

((ma_AudioObjectSetPropertyData_proc)pContext->coreaudio.AudioObjectSetPropertyData)(deviceObjectID, &propAddress, 0, NULL, sizeof(chosenBufferSizeInFrames), &chosenBufferSizeInFrames);


dataSize = sizeof(*pPeriodSizeInOut);
status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(deviceObjectID, &propAddress, 0, NULL, &dataSize, &chosenBufferSizeInFrames);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

*pPeriodSizeInOut = chosenBufferSizeInFrames;
return MA_SUCCESS;
}


static ma_result ma_find_AudioObjectID(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, AudioObjectID* pDeviceObjectID)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pDeviceObjectID != NULL);


*pDeviceObjectID = 0;

if (pDeviceID == NULL) {

AudioObjectPropertyAddress propAddressDefaultDevice;
UInt32 defaultDeviceObjectIDSize = sizeof(AudioObjectID);
AudioObjectID defaultDeviceObjectID;
OSStatus status;

propAddressDefaultDevice.mScope = kAudioObjectPropertyScopeGlobal;
propAddressDefaultDevice.mElement = kAudioObjectPropertyElementMaster;
if (deviceType == ma_device_type_playback) {
propAddressDefaultDevice.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
} else {
propAddressDefaultDevice.mSelector = kAudioHardwarePropertyDefaultInputDevice;
}

defaultDeviceObjectIDSize = sizeof(AudioObjectID);
status = ((ma_AudioObjectGetPropertyData_proc)pContext->coreaudio.AudioObjectGetPropertyData)(kAudioObjectSystemObject, &propAddressDefaultDevice, 0, NULL, &defaultDeviceObjectIDSize, &defaultDeviceObjectID);
if (status == noErr) {
*pDeviceObjectID = defaultDeviceObjectID;
return MA_SUCCESS;
}
} else {

UInt32 deviceCount;
AudioObjectID* pDeviceObjectIDs;
ma_result result;
UInt32 iDevice;

result = ma_get_device_object_ids__coreaudio(pContext, &deviceCount, &pDeviceObjectIDs);
if (result != MA_SUCCESS) {
return result;
}

for (iDevice = 0; iDevice < deviceCount; ++iDevice) {
AudioObjectID deviceObjectID = pDeviceObjectIDs[iDevice];

char uid[256];
if (ma_get_AudioObject_uid(pContext, deviceObjectID, sizeof(uid), uid) != MA_SUCCESS) {
continue;
}

if (deviceType == ma_device_type_playback) {
if (ma_does_AudioObject_support_playback(pContext, deviceObjectID)) {
if (strcmp(uid, pDeviceID->coreaudio) == 0) {
*pDeviceObjectID = deviceObjectID;
ma_free(pDeviceObjectIDs, &pContext->allocationCallbacks);
return MA_SUCCESS;
}
}
} else {
if (ma_does_AudioObject_support_capture(pContext, deviceObjectID)) {
if (strcmp(uid, pDeviceID->coreaudio) == 0) {
*pDeviceObjectID = deviceObjectID;
ma_free(pDeviceObjectIDs, &pContext->allocationCallbacks);
return MA_SUCCESS;
}
}
}
}

ma_free(pDeviceObjectIDs, &pContext->allocationCallbacks);
}


return MA_NO_DEVICE;
}


static ma_result ma_find_best_format__coreaudio(ma_context* pContext, AudioObjectID deviceObjectID, ma_device_type deviceType, ma_format format, ma_uint32 channels, ma_uint32 sampleRate, ma_bool32 usingDefaultFormat, ma_bool32 usingDefaultChannels, ma_bool32 usingDefaultSampleRate, AudioStreamBasicDescription* pFormat)
{
UInt32 deviceFormatDescriptionCount;
AudioStreamRangedDescription* pDeviceFormatDescriptions;
ma_result result;
ma_uint32 desiredSampleRate;
ma_uint32 desiredChannelCount;
ma_format desiredFormat;
AudioStreamBasicDescription bestDeviceFormatSoFar;
ma_bool32 hasSupportedFormat;
UInt32 iFormat;

result = ma_get_AudioObject_stream_descriptions(pContext, deviceObjectID, deviceType, &deviceFormatDescriptionCount, &pDeviceFormatDescriptions);
if (result != MA_SUCCESS) {
return result;
}

desiredSampleRate = sampleRate;
if (usingDefaultSampleRate) {




ma_uint32 iStandardRate;
for (iStandardRate = 0; iStandardRate < ma_countof(g_maStandardSampleRatePriorities); ++iStandardRate) {
ma_uint32 standardRate = g_maStandardSampleRatePriorities[iStandardRate];
ma_bool32 foundRate = MA_FALSE;
UInt32 iDeviceRate;

for (iDeviceRate = 0; iDeviceRate < deviceFormatDescriptionCount; ++iDeviceRate) {
ma_uint32 deviceRate = (ma_uint32)pDeviceFormatDescriptions[iDeviceRate].mFormat.mSampleRate;

if (deviceRate == standardRate) {
desiredSampleRate = standardRate;
foundRate = MA_TRUE;
break;
}
}

if (foundRate) {
break;
}
}
}

desiredChannelCount = channels;
if (usingDefaultChannels) {
ma_get_AudioObject_channel_count(pContext, deviceObjectID, deviceType, &desiredChannelCount); 
}

desiredFormat = format;
if (usingDefaultFormat) {
desiredFormat = g_maFormatPriorities[0];
}





MA_ZERO_OBJECT(&bestDeviceFormatSoFar);

hasSupportedFormat = MA_FALSE;
for (iFormat = 0; iFormat < deviceFormatDescriptionCount; ++iFormat) {
ma_format format;
ma_result formatResult = ma_format_from_AudioStreamBasicDescription(&pDeviceFormatDescriptions[iFormat].mFormat, &format);
if (formatResult == MA_SUCCESS && format != ma_format_unknown) {
hasSupportedFormat = MA_TRUE;
bestDeviceFormatSoFar = pDeviceFormatDescriptions[iFormat].mFormat;
break;
}
}

if (!hasSupportedFormat) {
ma_free(pDeviceFormatDescriptions, &pContext->allocationCallbacks);
return MA_FORMAT_NOT_SUPPORTED;
}


for (iFormat = 0; iFormat < deviceFormatDescriptionCount; ++iFormat) {
AudioStreamBasicDescription thisDeviceFormat = pDeviceFormatDescriptions[iFormat].mFormat;
ma_format thisSampleFormat;
ma_result formatResult;
ma_format bestSampleFormatSoFar;


formatResult = ma_format_from_AudioStreamBasicDescription(&pDeviceFormatDescriptions[iFormat].mFormat, &thisSampleFormat);
if (formatResult != MA_SUCCESS || thisSampleFormat == ma_format_unknown) {
continue; 
}

ma_format_from_AudioStreamBasicDescription(&bestDeviceFormatSoFar, &bestSampleFormatSoFar);


if (thisDeviceFormat.mSampleRate != desiredSampleRate) {




if (bestDeviceFormatSoFar.mSampleRate == desiredSampleRate) {
continue; 
} else {

if (thisDeviceFormat.mChannelsPerFrame != desiredChannelCount) {

if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {
continue; 
} else {




if (ma_get_format_priority_index(thisSampleFormat) < ma_get_format_priority_index(bestSampleFormatSoFar)) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {
continue; 
}
}
} else {

if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {

if (ma_get_format_priority_index(thisSampleFormat) < ma_get_format_priority_index(bestSampleFormatSoFar)) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {
continue; 
}
} else {

bestDeviceFormatSoFar = thisDeviceFormat;
continue;
}
}
}
} else {




if (bestDeviceFormatSoFar.mSampleRate != desiredSampleRate) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {

if (thisDeviceFormat.mChannelsPerFrame == desiredChannelCount) {




if (bestDeviceFormatSoFar.mChannelsPerFrame != desiredChannelCount) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {

if (thisSampleFormat == desiredFormat) {
bestDeviceFormatSoFar = thisDeviceFormat;
break; 
} else {

if (ma_get_format_priority_index(thisSampleFormat) < ma_get_format_priority_index(bestSampleFormatSoFar)) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {
continue; 
}
}
}
} else {




if (bestDeviceFormatSoFar.mChannelsPerFrame == desiredChannelCount) {
continue;
} else {




if (thisSampleFormat == bestSampleFormatSoFar) {
if (ma_get_format_priority_index(thisSampleFormat) < ma_get_format_priority_index(bestSampleFormatSoFar)) {
bestDeviceFormatSoFar = thisDeviceFormat;
continue;
} else {
continue; 
}
}
}
}
}
}
}

*pFormat = bestDeviceFormatSoFar;

ma_free(pDeviceFormatDescriptions, &pContext->allocationCallbacks);
return MA_SUCCESS;
}
#endif

static ma_result ma_get_AudioUnit_channel_map(ma_context* pContext, AudioUnit audioUnit, ma_device_type deviceType, ma_channel channelMap[MA_MAX_CHANNELS])
{
AudioUnitScope deviceScope;
AudioUnitElement deviceBus;
UInt32 channelLayoutSize;
OSStatus status;
AudioChannelLayout* pChannelLayout;
ma_result result;

MA_ASSERT(pContext != NULL);

if (deviceType == ma_device_type_playback) {
deviceScope = kAudioUnitScope_Output;
deviceBus = MA_COREAUDIO_OUTPUT_BUS;
} else {
deviceScope = kAudioUnitScope_Input;
deviceBus = MA_COREAUDIO_INPUT_BUS;
}

status = ((ma_AudioUnitGetPropertyInfo_proc)pContext->coreaudio.AudioUnitGetPropertyInfo)(audioUnit, kAudioUnitProperty_AudioChannelLayout, deviceScope, deviceBus, &channelLayoutSize, NULL);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

pChannelLayout = (AudioChannelLayout*)ma__malloc_from_callbacks(channelLayoutSize, &pContext->allocationCallbacks);
if (pChannelLayout == NULL) {
return MA_OUT_OF_MEMORY;
}

status = ((ma_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioUnitProperty_AudioChannelLayout, deviceScope, deviceBus, pChannelLayout, &channelLayoutSize);
if (status != noErr) {
ma__free_from_callbacks(pChannelLayout, &pContext->allocationCallbacks);
return ma_result_from_OSStatus(status);
}

result = ma_get_channel_map_from_AudioChannelLayout(pChannelLayout, channelMap);
if (result != MA_SUCCESS) {
ma__free_from_callbacks(pChannelLayout, &pContext->allocationCallbacks);
return result;
}

ma__free_from_callbacks(pChannelLayout, &pContext->allocationCallbacks);
return MA_SUCCESS;
}

static ma_bool32 ma_context_is_device_id_equal__coreaudio(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return strcmp(pID0->coreaudio, pID1->coreaudio) == 0;
}

static ma_result ma_context_enumerate_devices__coreaudio(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
#if defined(MA_APPLE_DESKTOP)
UInt32 deviceCount;
AudioObjectID* pDeviceObjectIDs;
ma_result result;
UInt32 iDevice;

result = ma_get_device_object_ids__coreaudio(pContext, &deviceCount, &pDeviceObjectIDs);
if (result != MA_SUCCESS) {
return result;
}

for (iDevice = 0; iDevice < deviceCount; ++iDevice) {
AudioObjectID deviceObjectID = pDeviceObjectIDs[iDevice];
ma_device_info info;

MA_ZERO_OBJECT(&info);
if (ma_get_AudioObject_uid(pContext, deviceObjectID, sizeof(info.id.coreaudio), info.id.coreaudio) != MA_SUCCESS) {
continue;
}
if (ma_get_AudioObject_name(pContext, deviceObjectID, sizeof(info.name), info.name) != MA_SUCCESS) {
continue;
}

if (ma_does_AudioObject_support_playback(pContext, deviceObjectID)) {
if (!callback(pContext, ma_device_type_playback, &info, pUserData)) {
break;
}
}
if (ma_does_AudioObject_support_capture(pContext, deviceObjectID)) {
if (!callback(pContext, ma_device_type_capture, &info, pUserData)) {
break;
}
}
}

ma_free(pDeviceObjectIDs, &pContext->allocationCallbacks);
#else

ma_device_info info;

MA_ZERO_OBJECT(&info);
ma_strncpy_s(info.name, sizeof(info.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
if (!callback(pContext, ma_device_type_playback, &info, pUserData)) {
return MA_SUCCESS;
}

MA_ZERO_OBJECT(&info);
ma_strncpy_s(info.name, sizeof(info.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
if (!callback(pContext, ma_device_type_capture, &info, pUserData)) {
return MA_SUCCESS;
}
#endif

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__coreaudio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_result result;

MA_ASSERT(pContext != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

#if defined(MA_APPLE_DESKTOP)

{
AudioObjectID deviceObjectID;
UInt32 streamDescriptionCount;
AudioStreamRangedDescription* pStreamDescriptions;
UInt32 iStreamDescription;
UInt32 sampleRateRangeCount;
AudioValueRange* pSampleRateRanges;

result = ma_find_AudioObjectID(pContext, deviceType, pDeviceID, &deviceObjectID);
if (result != MA_SUCCESS) {
return result;
}

result = ma_get_AudioObject_uid(pContext, deviceObjectID, sizeof(pDeviceInfo->id.coreaudio), pDeviceInfo->id.coreaudio);
if (result != MA_SUCCESS) {
return result;
}

result = ma_get_AudioObject_name(pContext, deviceObjectID, sizeof(pDeviceInfo->name), pDeviceInfo->name);
if (result != MA_SUCCESS) {
return result;
}


result = ma_get_AudioObject_stream_descriptions(pContext, deviceObjectID, deviceType, &streamDescriptionCount, &pStreamDescriptions);
if (result != MA_SUCCESS) {
return result;
}

for (iStreamDescription = 0; iStreamDescription < streamDescriptionCount; ++iStreamDescription) {
ma_format format;
ma_bool32 formatExists = MA_FALSE;
ma_uint32 iOutputFormat;

result = ma_format_from_AudioStreamBasicDescription(&pStreamDescriptions[iStreamDescription].mFormat, &format);
if (result != MA_SUCCESS) {
continue;
}

MA_ASSERT(format != ma_format_unknown);


for (iOutputFormat = 0; iOutputFormat < pDeviceInfo->formatCount; ++iOutputFormat) {
if (pDeviceInfo->formats[iOutputFormat] == format) {
formatExists = MA_TRUE;
break;
}
}

if (!formatExists) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = format;
}
}

ma_free(pStreamDescriptions, &pContext->allocationCallbacks);



result = ma_get_AudioObject_channel_count(pContext, deviceObjectID, deviceType, &pDeviceInfo->minChannels);
if (result != MA_SUCCESS) {
return result;
}
pDeviceInfo->maxChannels = pDeviceInfo->minChannels;



result = ma_get_AudioObject_sample_rates(pContext, deviceObjectID, deviceType, &sampleRateRangeCount, &pSampleRateRanges);
if (result != MA_SUCCESS) {
return result;
}

if (sampleRateRangeCount > 0) {
UInt32 iSampleRate;
pDeviceInfo->minSampleRate = UINT32_MAX;
pDeviceInfo->maxSampleRate = 0;
for (iSampleRate = 0; iSampleRate < sampleRateRangeCount; ++iSampleRate) {
if (pDeviceInfo->minSampleRate > pSampleRateRanges[iSampleRate].mMinimum) {
pDeviceInfo->minSampleRate = pSampleRateRanges[iSampleRate].mMinimum;
}
if (pDeviceInfo->maxSampleRate < pSampleRateRanges[iSampleRate].mMaximum) {
pDeviceInfo->maxSampleRate = pSampleRateRanges[iSampleRate].mMaximum;
}
}
}
}
#else

{
AudioComponentDescription desc;
AudioComponent component;
AudioUnit audioUnit;
OSStatus status;
AudioUnitScope formatScope;
AudioUnitElement formatElement;
AudioStreamBasicDescription bestFormat;
UInt32 propSize;

if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}






desc.componentType = kAudioUnitType_Output;
desc.componentSubType = kAudioUnitSubType_RemoteIO;
desc.componentManufacturer = kAudioUnitManufacturer_Apple;
desc.componentFlags = 0;
desc.componentFlagsMask = 0;

component = ((ma_AudioComponentFindNext_proc)pContext->coreaudio.AudioComponentFindNext)(NULL, &desc);
if (component == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

status = ((ma_AudioComponentInstanceNew_proc)pContext->coreaudio.AudioComponentInstanceNew)(component, &audioUnit);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}

formatScope = (deviceType == ma_device_type_playback) ? kAudioUnitScope_Input : kAudioUnitScope_Output;
formatElement = (deviceType == ma_device_type_playback) ? MA_COREAUDIO_OUTPUT_BUS : MA_COREAUDIO_INPUT_BUS;

propSize = sizeof(bestFormat);
status = ((ma_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, &propSize);
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(audioUnit);
return ma_result_from_OSStatus(status);
}

((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(audioUnit);
audioUnit = NULL;


pDeviceInfo->minChannels = bestFormat.mChannelsPerFrame;
pDeviceInfo->maxChannels = bestFormat.mChannelsPerFrame;

pDeviceInfo->formatCount = 1;
result = ma_format_from_AudioStreamBasicDescription(&bestFormat, &pDeviceInfo->formats[0]);
if (result != MA_SUCCESS) {
return result;
}





@autoreleasepool {
AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
MA_ASSERT(pAudioSession != NULL);

pDeviceInfo->minSampleRate = (ma_uint32)pAudioSession.sampleRate;
pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;
}
}
#endif

(void)pDeviceInfo; 
return MA_SUCCESS;
}


static OSStatus ma_on_output__coreaudio(void* pUserData, AudioUnitRenderActionFlags* pActionFlags, const AudioTimeStamp* pTimeStamp, UInt32 busNumber, UInt32 frameCount, AudioBufferList* pBufferList)
{
ma_device* pDevice = (ma_device*)pUserData;
ma_stream_layout layout;

MA_ASSERT(pDevice != NULL);

#if defined(MA_DEBUG_OUTPUT)
printf("INFO: Output Callback: busNumber=%d, frameCount=%d, mNumberBuffers=%d\n", busNumber, frameCount, pBufferList->mNumberBuffers);
#endif


layout = ma_stream_layout_interleaved;
if (pBufferList->mBuffers[0].mNumberChannels != pDevice->playback.internalChannels) {
layout = ma_stream_layout_deinterleaved;
}

if (layout == ma_stream_layout_interleaved) {

UInt32 iBuffer;
for (iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; ++iBuffer) {
if (pBufferList->mBuffers[iBuffer].mNumberChannels == pDevice->playback.internalChannels) {
ma_uint32 frameCountForThisBuffer = pBufferList->mBuffers[iBuffer].mDataByteSize / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
if (frameCountForThisBuffer > 0) {
if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, frameCountForThisBuffer, pBufferList->mBuffers[iBuffer].mData, &pDevice->coreaudio.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, frameCountForThisBuffer, pBufferList->mBuffers[iBuffer].mData);
}
}

#if defined(MA_DEBUG_OUTPUT)
printf(" frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pBufferList->mBuffers[iBuffer].mNumberChannels, pBufferList->mBuffers[iBuffer].mDataByteSize);
#endif
} else {





MA_ZERO_MEMORY(pBufferList->mBuffers[iBuffer].mData, pBufferList->mBuffers[iBuffer].mDataByteSize);

#if defined(MA_DEBUG_OUTPUT)
printf(" WARNING: Outputting silence. frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pBufferList->mBuffers[iBuffer].mNumberChannels, pBufferList->mBuffers[iBuffer].mDataByteSize);
#endif
}
}
} else {






if ((pBufferList->mNumberBuffers % pDevice->playback.internalChannels) == 0) {
ma_uint8 tempBuffer[4096];
UInt32 iBuffer;

for (iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; iBuffer += pDevice->playback.internalChannels) {
ma_uint32 frameCountPerBuffer = pBufferList->mBuffers[iBuffer].mDataByteSize / ma_get_bytes_per_sample(pDevice->playback.internalFormat);
ma_uint32 framesRemaining = frameCountPerBuffer;

while (framesRemaining > 0) {
void* ppDeinterleavedBuffers[MA_MAX_CHANNELS];
ma_uint32 iChannel;
ma_uint32 framesToRead = sizeof(tempBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
if (framesToRead > framesRemaining) {
framesToRead = framesRemaining;
}

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, framesToRead, tempBuffer, &pDevice->coreaudio.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, framesToRead, tempBuffer);
}

for (iChannel = 0; iChannel < pDevice->playback.internalChannels; ++iChannel) {
ppDeinterleavedBuffers[iChannel] = (void*)ma_offset_ptr(pBufferList->mBuffers[iBuffer+iChannel].mData, (frameCountPerBuffer - framesRemaining) * ma_get_bytes_per_sample(pDevice->playback.internalFormat));
}

ma_deinterleave_pcm_frames(pDevice->playback.internalFormat, pDevice->playback.internalChannels, framesToRead, tempBuffer, ppDeinterleavedBuffers);

framesRemaining -= framesToRead;
}
}
}
}

(void)pActionFlags;
(void)pTimeStamp;
(void)busNumber;

return noErr;
}

static OSStatus ma_on_input__coreaudio(void* pUserData, AudioUnitRenderActionFlags* pActionFlags, const AudioTimeStamp* pTimeStamp, UInt32 busNumber, UInt32 frameCount, AudioBufferList* pUnusedBufferList)
{
ma_device* pDevice = (ma_device*)pUserData;
AudioBufferList* pRenderedBufferList;
ma_stream_layout layout;
OSStatus status;

MA_ASSERT(pDevice != NULL);

pRenderedBufferList = (AudioBufferList*)pDevice->coreaudio.pAudioBufferList;
MA_ASSERT(pRenderedBufferList);


layout = ma_stream_layout_interleaved;
if (pRenderedBufferList->mBuffers[0].mNumberChannels != pDevice->capture.internalChannels) {
layout = ma_stream_layout_deinterleaved;
}

#if defined(MA_DEBUG_OUTPUT)
printf("INFO: Input Callback: busNumber=%d, frameCount=%d, mNumberBuffers=%d\n", busNumber, frameCount, pRenderedBufferList->mNumberBuffers);
#endif

status = ((ma_AudioUnitRender_proc)pDevice->pContext->coreaudio.AudioUnitRender)((AudioUnit)pDevice->coreaudio.audioUnitCapture, pActionFlags, pTimeStamp, busNumber, frameCount, pRenderedBufferList);
if (status != noErr) {
#if defined(MA_DEBUG_OUTPUT)
printf(" ERROR: AudioUnitRender() failed with %d\n", status);
#endif
return status;
}

if (layout == ma_stream_layout_interleaved) {
UInt32 iBuffer;
for (iBuffer = 0; iBuffer < pRenderedBufferList->mNumberBuffers; ++iBuffer) {
if (pRenderedBufferList->mBuffers[iBuffer].mNumberChannels == pDevice->capture.internalChannels) {
if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, frameCount, pRenderedBufferList->mBuffers[iBuffer].mData, &pDevice->coreaudio.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, frameCount, pRenderedBufferList->mBuffers[iBuffer].mData);
}
#if defined(MA_DEBUG_OUTPUT)
printf(" mDataByteSize=%d\n", pRenderedBufferList->mBuffers[iBuffer].mDataByteSize);
#endif
} else {




ma_uint8 silentBuffer[4096];
ma_uint32 framesRemaining;

MA_ZERO_MEMORY(silentBuffer, sizeof(silentBuffer));

framesRemaining = frameCount;
while (framesRemaining > 0) {
ma_uint32 framesToSend = sizeof(silentBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
if (framesToSend > framesRemaining) {
framesToSend = framesRemaining;
}

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, framesToSend, silentBuffer, &pDevice->coreaudio.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, framesToSend, silentBuffer);
}

framesRemaining -= framesToSend;
}

#if defined(MA_DEBUG_OUTPUT)
printf(" WARNING: Outputting silence. frameCount=%d, mNumberChannels=%d, mDataByteSize=%d\n", frameCount, pRenderedBufferList->mBuffers[iBuffer].mNumberChannels, pRenderedBufferList->mBuffers[iBuffer].mDataByteSize);
#endif
}
}
} else {






if ((pRenderedBufferList->mNumberBuffers % pDevice->capture.internalChannels) == 0) {
ma_uint8 tempBuffer[4096];
UInt32 iBuffer;
for (iBuffer = 0; iBuffer < pRenderedBufferList->mNumberBuffers; iBuffer += pDevice->capture.internalChannels) {
ma_uint32 framesRemaining = frameCount;
while (framesRemaining > 0) {
void* ppDeinterleavedBuffers[MA_MAX_CHANNELS];
ma_uint32 iChannel;
ma_uint32 framesToSend = sizeof(tempBuffer) / ma_get_bytes_per_sample(pDevice->capture.internalFormat);
if (framesToSend > framesRemaining) {
framesToSend = framesRemaining;
}

for (iChannel = 0; iChannel < pDevice->capture.internalChannels; ++iChannel) {
ppDeinterleavedBuffers[iChannel] = (void*)ma_offset_ptr(pRenderedBufferList->mBuffers[iBuffer+iChannel].mData, (frameCount - framesRemaining) * ma_get_bytes_per_sample(pDevice->capture.internalFormat));
}

ma_interleave_pcm_frames(pDevice->capture.internalFormat, pDevice->capture.internalChannels, framesToSend, (const void**)ppDeinterleavedBuffers, tempBuffer);

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, framesToSend, tempBuffer, &pDevice->coreaudio.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, framesToSend, tempBuffer);
}

framesRemaining -= framesToSend;
}
}
}
}

(void)pActionFlags;
(void)pTimeStamp;
(void)busNumber;
(void)frameCount;
(void)pUnusedBufferList;

return noErr;
}

static void on_start_stop__coreaudio(void* pUserData, AudioUnit audioUnit, AudioUnitPropertyID propertyID, AudioUnitScope scope, AudioUnitElement element)
{
ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);







if (ma_device__get_state(pDevice) == MA_STATE_UNINITIALIZED || ma_device__get_state(pDevice) == MA_STATE_STOPPING || ma_device__get_state(pDevice) == MA_STATE_STOPPED) {
ma_stop_proc onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}

ma_event_signal(&pDevice->coreaudio.stopEvent);
} else {
UInt32 isRunning;
UInt32 isRunningSize = sizeof(isRunning);
OSStatus status = ((ma_AudioUnitGetProperty_proc)pDevice->pContext->coreaudio.AudioUnitGetProperty)(audioUnit, kAudioOutputUnitProperty_IsRunning, scope, element, &isRunning, &isRunningSize);
if (status != noErr) {
return; 
}

if (!isRunning) {
ma_stop_proc onStop;









if (((audioUnit == pDevice->coreaudio.audioUnitPlayback) && pDevice->coreaudio.isDefaultPlaybackDevice) ||
((audioUnit == pDevice->coreaudio.audioUnitCapture) && pDevice->coreaudio.isDefaultCaptureDevice)) {






if (((audioUnit == pDevice->coreaudio.audioUnitPlayback) && pDevice->coreaudio.isSwitchingPlaybackDevice) ||
((audioUnit == pDevice->coreaudio.audioUnitCapture) && pDevice->coreaudio.isSwitchingCaptureDevice)) {
return;
}








return;
}


onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}
}
}

(void)propertyID; 
}

#if defined(MA_APPLE_DESKTOP)
static ma_uint32 g_DeviceTrackingInitCounter_CoreAudio = 0;
static ma_mutex g_DeviceTrackingMutex_CoreAudio;
static ma_device** g_ppTrackedDevices_CoreAudio = NULL;
static ma_uint32 g_TrackedDeviceCap_CoreAudio = 0;
static ma_uint32 g_TrackedDeviceCount_CoreAudio = 0;

static OSStatus ma_default_device_changed__coreaudio(AudioObjectID objectID, UInt32 addressCount, const AudioObjectPropertyAddress* pAddresses, void* pUserData)
{
ma_device_type deviceType;


if (addressCount == 0) {
return noErr;
}

if (pAddresses[0].mSelector == kAudioHardwarePropertyDefaultOutputDevice) {
deviceType = ma_device_type_playback;
} else if (pAddresses[0].mSelector == kAudioHardwarePropertyDefaultInputDevice) {
deviceType = ma_device_type_capture;
} else {
return noErr; 
}

ma_mutex_lock(&g_DeviceTrackingMutex_CoreAudio);
{
ma_uint32 iDevice;
for (iDevice = 0; iDevice < g_TrackedDeviceCount_CoreAudio; iDevice += 1) {
ma_result reinitResult;
ma_device* pDevice;

pDevice = g_ppTrackedDevices_CoreAudio[iDevice];
if (pDevice->type == deviceType || pDevice->type == ma_device_type_duplex) {
if (deviceType == ma_device_type_playback) {
pDevice->coreaudio.isSwitchingPlaybackDevice = MA_TRUE;
reinitResult = ma_device_reinit_internal__coreaudio(pDevice, deviceType, MA_TRUE);
pDevice->coreaudio.isSwitchingPlaybackDevice = MA_FALSE;
} else {
pDevice->coreaudio.isSwitchingCaptureDevice = MA_TRUE;
reinitResult = ma_device_reinit_internal__coreaudio(pDevice, deviceType, MA_TRUE);
pDevice->coreaudio.isSwitchingCaptureDevice = MA_FALSE;
}

if (reinitResult == MA_SUCCESS) {
ma_device__post_init_setup(pDevice, deviceType);


if (ma_device__get_state(pDevice) == MA_STATE_STARTED) {
OSStatus status;
if (deviceType == ma_device_type_playback) {
status = ((ma_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
if (status != noErr) {
if (pDevice->type == ma_device_type_duplex) {
((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
}
ma_device__set_state(pDevice, MA_STATE_STOPPED);
}
} else if (deviceType == ma_device_type_capture) {
status = ((ma_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
if (status != noErr) {
if (pDevice->type == ma_device_type_duplex) {
((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
}
ma_device__set_state(pDevice, MA_STATE_STOPPED);
}
}
}
}
}
}
}
ma_mutex_unlock(&g_DeviceTrackingMutex_CoreAudio);

(void)objectID; 
return noErr;
}

static ma_result ma_context__init_device_tracking__coreaudio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

if (ma_atomic_increment_32(&g_DeviceTrackingInitCounter_CoreAudio) == 1) {
AudioObjectPropertyAddress propAddress;
propAddress.mScope = kAudioObjectPropertyScopeGlobal;
propAddress.mElement = kAudioObjectPropertyElementMaster;

ma_mutex_init(pContext, &g_DeviceTrackingMutex_CoreAudio);

propAddress.mSelector = kAudioHardwarePropertyDefaultInputDevice;
((ma_AudioObjectAddPropertyListener_proc)pContext->coreaudio.AudioObjectAddPropertyListener)(kAudioObjectSystemObject, &propAddress, &ma_default_device_changed__coreaudio, NULL);

propAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
((ma_AudioObjectAddPropertyListener_proc)pContext->coreaudio.AudioObjectAddPropertyListener)(kAudioObjectSystemObject, &propAddress, &ma_default_device_changed__coreaudio, NULL);
}

return MA_SUCCESS;
}

static ma_result ma_context__uninit_device_tracking__coreaudio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

if (ma_atomic_decrement_32(&g_DeviceTrackingInitCounter_CoreAudio) == 0) {
AudioObjectPropertyAddress propAddress;
propAddress.mScope = kAudioObjectPropertyScopeGlobal;
propAddress.mElement = kAudioObjectPropertyElementMaster;

propAddress.mSelector = kAudioHardwarePropertyDefaultInputDevice;
((ma_AudioObjectRemovePropertyListener_proc)pContext->coreaudio.AudioObjectRemovePropertyListener)(kAudioObjectSystemObject, &propAddress, &ma_default_device_changed__coreaudio, NULL);

propAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
((ma_AudioObjectRemovePropertyListener_proc)pContext->coreaudio.AudioObjectRemovePropertyListener)(kAudioObjectSystemObject, &propAddress, &ma_default_device_changed__coreaudio, NULL);


MA_ASSERT(g_ppTrackedDevices_CoreAudio == NULL);
MA_ASSERT(g_TrackedDeviceCount_CoreAudio == 0);

ma_mutex_uninit(&g_DeviceTrackingMutex_CoreAudio);
}

return MA_SUCCESS;
}

static ma_result ma_device__track__coreaudio(ma_device* pDevice)
{
ma_result result;

MA_ASSERT(pDevice != NULL);

result = ma_context__init_device_tracking__coreaudio(pDevice->pContext);
if (result != MA_SUCCESS) {
return result;
}

ma_mutex_lock(&g_DeviceTrackingMutex_CoreAudio);
{

if (g_TrackedDeviceCap_CoreAudio <= g_TrackedDeviceCount_CoreAudio) {
ma_uint32 oldCap;
ma_uint32 newCap;
ma_device** ppNewDevices;

oldCap = g_TrackedDeviceCap_CoreAudio;
newCap = g_TrackedDeviceCap_CoreAudio * 2;
if (newCap == 0) {
newCap = 1;
}

ppNewDevices = (ma_device**)ma__realloc_from_callbacks(g_ppTrackedDevices_CoreAudio, sizeof(*g_ppTrackedDevices_CoreAudio)*newCap, sizeof(*g_ppTrackedDevices_CoreAudio)*oldCap, &pDevice->pContext->allocationCallbacks);
if (ppNewDevices == NULL) {
ma_mutex_unlock(&g_DeviceTrackingMutex_CoreAudio);
return MA_OUT_OF_MEMORY;
}

g_ppTrackedDevices_CoreAudio = ppNewDevices;
g_TrackedDeviceCap_CoreAudio = newCap;
}

g_ppTrackedDevices_CoreAudio[g_TrackedDeviceCount_CoreAudio] = pDevice;
g_TrackedDeviceCount_CoreAudio += 1;
}
ma_mutex_unlock(&g_DeviceTrackingMutex_CoreAudio);

return MA_SUCCESS;
}

static ma_result ma_device__untrack__coreaudio(ma_device* pDevice)
{
ma_result result;

MA_ASSERT(pDevice != NULL);

ma_mutex_lock(&g_DeviceTrackingMutex_CoreAudio);
{
ma_uint32 iDevice;
for (iDevice = 0; iDevice < g_TrackedDeviceCount_CoreAudio; iDevice += 1) {
if (g_ppTrackedDevices_CoreAudio[iDevice] == pDevice) {

ma_uint32 jDevice;
for (jDevice = iDevice; jDevice < g_TrackedDeviceCount_CoreAudio-1; jDevice += 1) {
g_ppTrackedDevices_CoreAudio[jDevice] = g_ppTrackedDevices_CoreAudio[jDevice+1];
}

g_TrackedDeviceCount_CoreAudio -= 1;


if (g_TrackedDeviceCount_CoreAudio == 0) {
ma__free_from_callbacks(g_ppTrackedDevices_CoreAudio, &pDevice->pContext->allocationCallbacks);
g_ppTrackedDevices_CoreAudio = NULL;
g_TrackedDeviceCap_CoreAudio = 0;
}

break;
}
}
}
ma_mutex_unlock(&g_DeviceTrackingMutex_CoreAudio);

result = ma_context__uninit_device_tracking__coreaudio(pDevice->pContext);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}
#endif

#if defined(MA_APPLE_MOBILE)
@interface ma_router_change_handler:NSObject {
ma_device* m_pDevice;
}
@end

@implementation ma_router_change_handler
-(id)init:(ma_device*)pDevice
{
self = [super init];
m_pDevice = pDevice;

[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handle_route_change:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];

return self;
}

-(void)dealloc
{
[self remove_handler];
}

-(void)remove_handler
{
[[NSNotificationCenter defaultCenter] removeObserver:self name:@"AVAudioSessionRouteChangeNotification" object:nil];
}

-(void)handle_route_change:(NSNotification*)pNotification
{
AVAudioSession* pSession = [AVAudioSession sharedInstance];

NSInteger reason = [[[pNotification userInfo] objectForKey:AVAudioSessionRouteChangeReasonKey] integerValue];
switch (reason)
{
case AVAudioSessionRouteChangeReasonOldDeviceUnavailable:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonOldDeviceUnavailable\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonNewDeviceAvailable:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonNewDeviceAvailable\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonWakeFromSleep:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonWakeFromSleep\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonOverride:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonOverride\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonCategoryChange:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonCategoryChange\n");
#endif
} break;

case AVAudioSessionRouteChangeReasonUnknown:
default:
{
#if defined(MA_DEBUG_OUTPUT)
printf("[Core Audio] Route Changed: AVAudioSessionRouteChangeReasonUnknown\n");
#endif
} break;
}

m_pDevice->sampleRate = (ma_uint32)pSession.sampleRate;

if (m_pDevice->type == ma_device_type_capture || m_pDevice->type == ma_device_type_duplex) {
m_pDevice->capture.channels = (ma_uint32)pSession.inputNumberOfChannels;
ma_device__post_init_setup(m_pDevice, ma_device_type_capture);
}
if (m_pDevice->type == ma_device_type_playback || m_pDevice->type == ma_device_type_duplex) {
m_pDevice->playback.channels = (ma_uint32)pSession.outputNumberOfChannels;
ma_device__post_init_setup(m_pDevice, ma_device_type_playback);
}
}
@end
#endif

static void ma_device_uninit__coreaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);
MA_ASSERT(ma_device__get_state(pDevice) == MA_STATE_UNINITIALIZED);

#if defined(MA_APPLE_DESKTOP)




ma_device__untrack__coreaudio(pDevice);
#endif
#if defined(MA_APPLE_MOBILE)
if (pDevice->coreaudio.pRouteChangeHandler != NULL) {
ma_router_change_handler* pRouteChangeHandler = (__bridge_transfer ma_router_change_handler*)pDevice->coreaudio.pRouteChangeHandler;
[pRouteChangeHandler remove_handler];
}
#endif

if (pDevice->coreaudio.audioUnitCapture != NULL) {
((ma_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
}
if (pDevice->coreaudio.audioUnitPlayback != NULL) {
((ma_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
}

if (pDevice->coreaudio.pAudioBufferList) {
ma__free_from_callbacks(pDevice->coreaudio.pAudioBufferList, &pDevice->pContext->allocationCallbacks);
}

if (pDevice->type == ma_device_type_duplex) {
ma_pcm_rb_uninit(&pDevice->coreaudio.duplexRB);
}
}

typedef struct
{

ma_format formatIn;
ma_uint32 channelsIn;
ma_uint32 sampleRateIn;
ma_channel channelMapIn[MA_MAX_CHANNELS];
ma_uint32 periodSizeInFramesIn;
ma_uint32 periodSizeInMillisecondsIn;
ma_uint32 periodsIn;
ma_bool32 usingDefaultFormat;
ma_bool32 usingDefaultChannels;
ma_bool32 usingDefaultSampleRate;
ma_bool32 usingDefaultChannelMap;
ma_share_mode shareMode;
ma_bool32 registerStopEvent;


#if defined(MA_APPLE_DESKTOP)
AudioObjectID deviceObjectID;
#endif
AudioComponent component;
AudioUnit audioUnit;
AudioBufferList* pAudioBufferList; 
ma_format formatOut;
ma_uint32 channelsOut;
ma_uint32 sampleRateOut;
ma_channel channelMapOut[MA_MAX_CHANNELS];
ma_uint32 periodSizeInFramesOut;
ma_uint32 periodsOut;
char deviceName[256];
} ma_device_init_internal_data__coreaudio;

static ma_result ma_device_init_internal__coreaudio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_device_init_internal_data__coreaudio* pData, void* pDevice_DoNotReference) 
{
ma_result result;
OSStatus status;
UInt32 enableIOFlag;
AudioStreamBasicDescription bestFormat;
ma_uint32 actualPeriodSizeInFrames;
AURenderCallbackStruct callbackInfo;
#if defined(MA_APPLE_DESKTOP)
AudioObjectID deviceObjectID;
#endif


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

MA_ASSERT(pContext != NULL);
MA_ASSERT(deviceType == ma_device_type_playback || deviceType == ma_device_type_capture);

#if defined(MA_APPLE_DESKTOP)
pData->deviceObjectID = 0;
#endif
pData->component = NULL;
pData->audioUnit = NULL;
pData->pAudioBufferList = NULL;

#if defined(MA_APPLE_DESKTOP)
result = ma_find_AudioObjectID(pContext, deviceType, pDeviceID, &deviceObjectID);
if (result != MA_SUCCESS) {
return result;
}

pData->deviceObjectID = deviceObjectID;
#endif


pData->periodsOut = pData->periodsIn;
if (pData->periodsOut == 0) {
pData->periodsOut = MA_DEFAULT_PERIODS;
}
if (pData->periodsOut > 16) {
pData->periodsOut = 16;
}



status = ((ma_AudioComponentInstanceNew_proc)pContext->coreaudio.AudioComponentInstanceNew)((AudioComponent)pContext->coreaudio.component, (AudioUnit*)&pData->audioUnit);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}



enableIOFlag = 1;
if (deviceType == ma_device_type_capture) {
enableIOFlag = 0;
}

status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, MA_COREAUDIO_OUTPUT_BUS, &enableIOFlag, sizeof(enableIOFlag));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}

enableIOFlag = (enableIOFlag == 0) ? 1 : 0;
status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, MA_COREAUDIO_INPUT_BUS, &enableIOFlag, sizeof(enableIOFlag));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}



#if defined(MA_APPLE_DESKTOP)
status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, (deviceType == ma_device_type_playback) ? MA_COREAUDIO_OUTPUT_BUS : MA_COREAUDIO_INPUT_BUS, &deviceObjectID, sizeof(AudioDeviceID));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(result);
}
#endif













{
AudioUnitScope formatScope = (deviceType == ma_device_type_playback) ? kAudioUnitScope_Input : kAudioUnitScope_Output;
AudioUnitElement formatElement = (deviceType == ma_device_type_playback) ? MA_COREAUDIO_OUTPUT_BUS : MA_COREAUDIO_INPUT_BUS;

#if defined(MA_APPLE_DESKTOP)
AudioStreamBasicDescription origFormat;
UInt32 origFormatSize;

result = ma_find_best_format__coreaudio(pContext, deviceObjectID, deviceType, pData->formatIn, pData->channelsIn, pData->sampleRateIn, pData->usingDefaultFormat, pData->usingDefaultChannels, pData->usingDefaultSampleRate, &bestFormat);
if (result != MA_SUCCESS) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return result;
}


origFormatSize = sizeof(origFormat);
if (deviceType == ma_device_type_playback) {
status = ((ma_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, MA_COREAUDIO_OUTPUT_BUS, &origFormat, &origFormatSize);
} else {
status = ((ma_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, MA_COREAUDIO_INPUT_BUS, &origFormat, &origFormatSize);
}

if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return result;
}

bestFormat.mSampleRate = origFormat.mSampleRate;

status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, sizeof(bestFormat));
if (status != noErr) {

bestFormat = origFormat;
}
#else
UInt32 propSize = sizeof(bestFormat);
status = ((ma_AudioUnitGetProperty_proc)pContext->coreaudio.AudioUnitGetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, &propSize);
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}







@autoreleasepool {
AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
MA_ASSERT(pAudioSession != NULL);

[pAudioSession setPreferredSampleRate:(double)pData->sampleRateIn error:nil];
bestFormat.mSampleRate = pAudioSession.sampleRate;





if (deviceType == ma_device_type_playback) {
bestFormat.mChannelsPerFrame = (UInt32)pAudioSession.outputNumberOfChannels;
}
if (deviceType == ma_device_type_capture) {
bestFormat.mChannelsPerFrame = (UInt32)pAudioSession.inputNumberOfChannels;
}
}

status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_StreamFormat, formatScope, formatElement, &bestFormat, sizeof(bestFormat));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}
#endif

result = ma_format_from_AudioStreamBasicDescription(&bestFormat, &pData->formatOut);
if (result != MA_SUCCESS) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return result;
}

if (pData->formatOut == ma_format_unknown) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return MA_FORMAT_NOT_SUPPORTED;
}

pData->channelsOut = bestFormat.mChannelsPerFrame;
pData->sampleRateOut = bestFormat.mSampleRate;
}








#if defined(MA_APPLE_DESKTOP)
result = ma_get_AudioUnit_channel_map(pContext, pData->audioUnit, deviceType, pData->channelMapOut);
if (result != MA_SUCCESS) {
#if 0

result = ma_get_AudioObject_channel_map(pContext, deviceObjectID, deviceType, pData->channelMapOut);
if (result != MA_SUCCESS) {
return result;
}
#else

ma_get_standard_channel_map(ma_standard_channel_map_default, pData->channelsOut, pData->channelMapOut);
#endif
}
#else

ma_get_standard_channel_map(ma_standard_channel_map_default, pData->channelsOut, pData->channelMapOut);
#endif



actualPeriodSizeInFrames = pData->periodSizeInFramesIn;

#if defined(MA_APPLE_DESKTOP)
if (actualPeriodSizeInFrames == 0) {
actualPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pData->periodSizeInMillisecondsIn, pData->sampleRateOut);
}

result = ma_set_AudioObject_buffer_size_in_frames(pContext, deviceObjectID, deviceType, &actualPeriodSizeInFrames);
if (result != MA_SUCCESS) {
return result;
}

pData->periodSizeInFramesOut = actualPeriodSizeInFrames;
#else
actualPeriodSizeInFrames = 2048;
pData->periodSizeInFramesOut = actualPeriodSizeInFrames;
#endif










{









status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &actualPeriodSizeInFrames, sizeof(actualPeriodSizeInFrames));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}
}


if (deviceType == ma_device_type_capture) {
ma_bool32 isInterleaved = (bestFormat.mFormatFlags & kAudioFormatFlagIsNonInterleaved) == 0;
size_t allocationSize;
AudioBufferList* pBufferList;

allocationSize = sizeof(AudioBufferList) - sizeof(AudioBuffer); 
if (isInterleaved) {

allocationSize += sizeof(AudioBuffer) * 1;
allocationSize += actualPeriodSizeInFrames * ma_get_bytes_per_frame(pData->formatOut, pData->channelsOut);
} else {

allocationSize += sizeof(AudioBuffer) * pData->channelsOut;
allocationSize += actualPeriodSizeInFrames * ma_get_bytes_per_sample(pData->formatOut) * pData->channelsOut;
}

pBufferList = (AudioBufferList*)ma__malloc_from_callbacks(allocationSize, &pContext->allocationCallbacks);
if (pBufferList == NULL) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return MA_OUT_OF_MEMORY;
}

if (isInterleaved) {
pBufferList->mNumberBuffers = 1;
pBufferList->mBuffers[0].mNumberChannels = pData->channelsOut;
pBufferList->mBuffers[0].mDataByteSize = actualPeriodSizeInFrames * ma_get_bytes_per_frame(pData->formatOut, pData->channelsOut);
pBufferList->mBuffers[0].mData = (ma_uint8*)pBufferList + sizeof(AudioBufferList);
} else {
ma_uint32 iBuffer;
pBufferList->mNumberBuffers = pData->channelsOut;
for (iBuffer = 0; iBuffer < pBufferList->mNumberBuffers; ++iBuffer) {
pBufferList->mBuffers[iBuffer].mNumberChannels = 1;
pBufferList->mBuffers[iBuffer].mDataByteSize = actualPeriodSizeInFrames * ma_get_bytes_per_sample(pData->formatOut);
pBufferList->mBuffers[iBuffer].mData = (ma_uint8*)pBufferList + ((sizeof(AudioBufferList) - sizeof(AudioBuffer)) + (sizeof(AudioBuffer) * pData->channelsOut)) + (actualPeriodSizeInFrames * ma_get_bytes_per_sample(pData->formatOut) * iBuffer);
}
}

pData->pAudioBufferList = pBufferList;
}


callbackInfo.inputProcRefCon = pDevice_DoNotReference;
if (deviceType == ma_device_type_playback) {
callbackInfo.inputProc = ma_on_output__coreaudio;
status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Global, MA_COREAUDIO_OUTPUT_BUS, &callbackInfo, sizeof(callbackInfo));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}
} else {
callbackInfo.inputProc = ma_on_input__coreaudio;
status = ((ma_AudioUnitSetProperty_proc)pContext->coreaudio.AudioUnitSetProperty)(pData->audioUnit, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Global, MA_COREAUDIO_INPUT_BUS, &callbackInfo, sizeof(callbackInfo));
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}
}


if (pData->registerStopEvent) {
status = ((ma_AudioUnitAddPropertyListener_proc)pContext->coreaudio.AudioUnitAddPropertyListener)(pData->audioUnit, kAudioOutputUnitProperty_IsRunning, on_start_stop__coreaudio, pDevice_DoNotReference);
if (status != noErr) {
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}
}


status = ((ma_AudioUnitInitialize_proc)pContext->coreaudio.AudioUnitInitialize)(pData->audioUnit);
if (status != noErr) {
ma__free_from_callbacks(pData->pAudioBufferList, &pContext->allocationCallbacks);
pData->pAudioBufferList = NULL;
((ma_AudioComponentInstanceDispose_proc)pContext->coreaudio.AudioComponentInstanceDispose)(pData->audioUnit);
return ma_result_from_OSStatus(status);
}


#if defined(MA_APPLE_DESKTOP)
ma_get_AudioObject_name(pContext, deviceObjectID, sizeof(pData->deviceName), pData->deviceName);
#else
if (deviceType == ma_device_type_playback) {
ma_strcpy_s(pData->deviceName, sizeof(pData->deviceName), MA_DEFAULT_PLAYBACK_DEVICE_NAME);
} else {
ma_strcpy_s(pData->deviceName, sizeof(pData->deviceName), MA_DEFAULT_CAPTURE_DEVICE_NAME);
}
#endif

return result;
}

static ma_result ma_device_reinit_internal__coreaudio(ma_device* pDevice, ma_device_type deviceType, ma_bool32 disposePreviousAudioUnit)
{
ma_device_init_internal_data__coreaudio data;
ma_result result;


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

if (deviceType == ma_device_type_capture) {
data.formatIn = pDevice->capture.format;
data.channelsIn = pDevice->capture.channels;
data.sampleRateIn = pDevice->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pDevice->capture.channelMap, sizeof(pDevice->capture.channelMap));
data.usingDefaultFormat = pDevice->capture.usingDefaultFormat;
data.usingDefaultChannels = pDevice->capture.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
data.shareMode = pDevice->capture.shareMode;
data.registerStopEvent = MA_TRUE;

if (disposePreviousAudioUnit) {
((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
((ma_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
}
if (pDevice->coreaudio.pAudioBufferList) {
ma__free_from_callbacks(pDevice->coreaudio.pAudioBufferList, &pDevice->pContext->allocationCallbacks);
}
} else if (deviceType == ma_device_type_playback) {
data.formatIn = pDevice->playback.format;
data.channelsIn = pDevice->playback.channels;
data.sampleRateIn = pDevice->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pDevice->playback.channelMap, sizeof(pDevice->playback.channelMap));
data.usingDefaultFormat = pDevice->playback.usingDefaultFormat;
data.usingDefaultChannels = pDevice->playback.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
data.shareMode = pDevice->playback.shareMode;
data.registerStopEvent = (pDevice->type != ma_device_type_duplex);

if (disposePreviousAudioUnit) {
((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
((ma_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
}
}
data.periodSizeInFramesIn = pDevice->coreaudio.originalPeriodSizeInFrames;
data.periodSizeInMillisecondsIn = pDevice->coreaudio.originalPeriodSizeInMilliseconds;
data.periodsIn = pDevice->coreaudio.originalPeriods;


if (data.periodsIn < 3 && pDevice->type == ma_device_type_duplex) {
data.periodsIn = 3;
}

result = ma_device_init_internal__coreaudio(pDevice->pContext, deviceType, NULL, &data, (void*)pDevice);
if (result != MA_SUCCESS) {
return result;
}

if (deviceType == ma_device_type_capture) {
#if defined(MA_APPLE_DESKTOP)
pDevice->coreaudio.deviceObjectIDCapture = (ma_uint32)data.deviceObjectID;
#endif
pDevice->coreaudio.audioUnitCapture = (ma_ptr)data.audioUnit;
pDevice->coreaudio.pAudioBufferList = (ma_ptr)data.pAudioBufferList;

pDevice->capture.internalFormat = data.formatOut;
pDevice->capture.internalChannels = data.channelsOut;
pDevice->capture.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->capture.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->capture.internalPeriods = data.periodsOut;
} else if (deviceType == ma_device_type_playback) {
#if defined(MA_APPLE_DESKTOP)
pDevice->coreaudio.deviceObjectIDPlayback = (ma_uint32)data.deviceObjectID;
#endif
pDevice->coreaudio.audioUnitPlayback = (ma_ptr)data.audioUnit;

pDevice->playback.internalFormat = data.formatOut;
pDevice->playback.internalChannels = data.channelsOut;
pDevice->playback.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->playback.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->playback.internalPeriods = data.periodsOut;
}

return MA_SUCCESS;
}


static ma_result ma_device_init__coreaudio(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDevice != NULL);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}


if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_device_init_internal_data__coreaudio data;
data.formatIn = pConfig->capture.format;
data.channelsIn = pConfig->capture.channels;
data.sampleRateIn = pConfig->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pConfig->capture.channelMap, sizeof(pConfig->capture.channelMap));
data.usingDefaultFormat = pDevice->capture.usingDefaultFormat;
data.usingDefaultChannels = pDevice->capture.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->capture.usingDefaultChannelMap;
data.shareMode = pConfig->capture.shareMode;
data.periodSizeInFramesIn = pConfig->periodSizeInFrames;
data.periodSizeInMillisecondsIn = pConfig->periodSizeInMilliseconds;
data.periodsIn = pConfig->periods;
data.registerStopEvent = MA_TRUE;


if (data.periodsIn < 3 && pConfig->deviceType == ma_device_type_duplex) {
data.periodsIn = 3;
}

result = ma_device_init_internal__coreaudio(pDevice->pContext, ma_device_type_capture, pConfig->capture.pDeviceID, &data, (void*)pDevice);
if (result != MA_SUCCESS) {
return result;
}

pDevice->coreaudio.isDefaultCaptureDevice = (pConfig->capture.pDeviceID == NULL);
#if defined(MA_APPLE_DESKTOP)
pDevice->coreaudio.deviceObjectIDCapture = (ma_uint32)data.deviceObjectID;
#endif
pDevice->coreaudio.audioUnitCapture = (ma_ptr)data.audioUnit;
pDevice->coreaudio.pAudioBufferList = (ma_ptr)data.pAudioBufferList;

pDevice->capture.internalFormat = data.formatOut;
pDevice->capture.internalChannels = data.channelsOut;
pDevice->capture.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->capture.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->capture.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->capture.internalPeriods = data.periodsOut;

#if defined(MA_APPLE_DESKTOP)




if (pConfig->capture.pDeviceID == NULL) {
ma_device__track__coreaudio(pDevice);
}
#endif
}


if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_device_init_internal_data__coreaudio data;
data.formatIn = pConfig->playback.format;
data.channelsIn = pConfig->playback.channels;
data.sampleRateIn = pConfig->sampleRate;
MA_COPY_MEMORY(data.channelMapIn, pConfig->playback.channelMap, sizeof(pConfig->playback.channelMap));
data.usingDefaultFormat = pDevice->playback.usingDefaultFormat;
data.usingDefaultChannels = pDevice->playback.usingDefaultChannels;
data.usingDefaultSampleRate = pDevice->usingDefaultSampleRate;
data.usingDefaultChannelMap = pDevice->playback.usingDefaultChannelMap;
data.shareMode = pConfig->playback.shareMode;


if (pConfig->deviceType == ma_device_type_duplex) {
data.periodSizeInFramesIn = pDevice->capture.internalPeriodSizeInFrames;
data.periodsIn = pDevice->capture.internalPeriods;
data.registerStopEvent = MA_FALSE;
} else {
data.periodSizeInFramesIn = pConfig->periodSizeInFrames;
data.periodSizeInMillisecondsIn = pConfig->periodSizeInMilliseconds;
data.periodsIn = pConfig->periods;
data.registerStopEvent = MA_TRUE;
}

result = ma_device_init_internal__coreaudio(pDevice->pContext, ma_device_type_playback, pConfig->playback.pDeviceID, &data, (void*)pDevice);
if (result != MA_SUCCESS) {
if (pConfig->deviceType == ma_device_type_duplex) {
((ma_AudioComponentInstanceDispose_proc)pDevice->pContext->coreaudio.AudioComponentInstanceDispose)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
if (pDevice->coreaudio.pAudioBufferList) {
ma__free_from_callbacks(pDevice->coreaudio.pAudioBufferList, &pDevice->pContext->allocationCallbacks);
}
}
return result;
}

pDevice->coreaudio.isDefaultPlaybackDevice = (pConfig->playback.pDeviceID == NULL);
#if defined(MA_APPLE_DESKTOP)
pDevice->coreaudio.deviceObjectIDPlayback = (ma_uint32)data.deviceObjectID;
#endif
pDevice->coreaudio.audioUnitPlayback = (ma_ptr)data.audioUnit;

pDevice->playback.internalFormat = data.formatOut;
pDevice->playback.internalChannels = data.channelsOut;
pDevice->playback.internalSampleRate = data.sampleRateOut;
MA_COPY_MEMORY(pDevice->playback.internalChannelMap, data.channelMapOut, sizeof(data.channelMapOut));
pDevice->playback.internalPeriodSizeInFrames = data.periodSizeInFramesOut;
pDevice->playback.internalPeriods = data.periodsOut;

#if defined(MA_APPLE_DESKTOP)




if (pConfig->playback.pDeviceID == NULL && (pConfig->deviceType != ma_device_type_duplex || pConfig->capture.pDeviceID != NULL)) {
ma_device__track__coreaudio(pDevice);
}
#endif
}

pDevice->coreaudio.originalPeriodSizeInFrames = pConfig->periodSizeInFrames;
pDevice->coreaudio.originalPeriodSizeInMilliseconds = pConfig->periodSizeInMilliseconds;
pDevice->coreaudio.originalPeriods = pConfig->periods;





ma_event_init(pContext, &pDevice->coreaudio.stopEvent);


if (pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 rbSizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalPeriodSizeInFrames * pDevice->capture.internalPeriods);
ma_result result = ma_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->pContext->allocationCallbacks, &pDevice->coreaudio.duplexRB);
if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[Core Audio] Failed to initialize ring buffer.", result);
}


{
ma_uint32 bufferSizeInFrames = rbSizeInFrames / pDevice->capture.internalPeriods;
void* pBufferData;
ma_pcm_rb_acquire_write(&pDevice->coreaudio.duplexRB, &bufferSizeInFrames, &pBufferData);
{
MA_ZERO_MEMORY(pBufferData, bufferSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels));
}
ma_pcm_rb_commit_write(&pDevice->coreaudio.duplexRB, bufferSizeInFrames, pBufferData);
}
}





#if defined(MA_APPLE_MOBILE)
pDevice->coreaudio.pRouteChangeHandler = (__bridge_retained void*)[[ma_router_change_handler alloc] init:pDevice];
#endif

return MA_SUCCESS;
}


static ma_result ma_device_start__coreaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
OSStatus status = ((ma_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
OSStatus status = ((ma_AudioOutputUnitStart_proc)pDevice->pContext->coreaudio.AudioOutputUnitStart)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
if (status != noErr) {
if (pDevice->type == ma_device_type_duplex) {
((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
}
return ma_result_from_OSStatus(status);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__coreaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);



if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
OSStatus status = ((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitCapture);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
OSStatus status = ((ma_AudioOutputUnitStop_proc)pDevice->pContext->coreaudio.AudioOutputUnitStop)((AudioUnit)pDevice->coreaudio.audioUnitPlayback);
if (status != noErr) {
return ma_result_from_OSStatus(status);
}
}


ma_event_wait(&pDevice->coreaudio.stopEvent);
return MA_SUCCESS;
}


static ma_result ma_context_uninit__coreaudio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_coreaudio);

#if !defined(MA_NO_RUNTIME_LINKING) && !defined(MA_APPLE_MOBILE)
ma_dlclose(pContext, pContext->coreaudio.hAudioUnit);
ma_dlclose(pContext, pContext->coreaudio.hCoreAudio);
ma_dlclose(pContext, pContext->coreaudio.hCoreFoundation);
#endif

(void)pContext;
return MA_SUCCESS;
}

#if defined(MA_APPLE_MOBILE)
static AVAudioSessionCategory ma_to_AVAudioSessionCategory(ma_ios_session_category category)
{

MA_ASSERT(category != ma_ios_session_category_default);
MA_ASSERT(category != ma_ios_session_category_none);

switch (category) {
case ma_ios_session_category_ambient: return AVAudioSessionCategoryAmbient;
case ma_ios_session_category_solo_ambient: return AVAudioSessionCategorySoloAmbient;
case ma_ios_session_category_playback: return AVAudioSessionCategoryPlayback;
case ma_ios_session_category_record: return AVAudioSessionCategoryRecord;
case ma_ios_session_category_play_and_record: return AVAudioSessionCategoryPlayAndRecord;
case ma_ios_session_category_multi_route: return AVAudioSessionCategoryMultiRoute;
case ma_ios_session_category_none: return AVAudioSessionCategoryAmbient;
case ma_ios_session_category_default: return AVAudioSessionCategoryAmbient;
default: return AVAudioSessionCategoryAmbient;
}
}
#endif

static ma_result ma_context_init__coreaudio(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pConfig != NULL);
MA_ASSERT(pContext != NULL);

#if defined(MA_APPLE_MOBILE)
@autoreleasepool {
AVAudioSession* pAudioSession = [AVAudioSession sharedInstance];
AVAudioSessionCategoryOptions options = pConfig->coreaudio.sessionCategoryOptions;

MA_ASSERT(pAudioSession != NULL);

if (pConfig->coreaudio.sessionCategory == ma_ios_session_category_default) {




#if !defined(MA_APPLE_TV) && !defined(MA_APPLE_WATCH)
options |= AVAudioSessionCategoryOptionDefaultToSpeaker;
#endif

if ([pAudioSession setCategory: AVAudioSessionCategoryPlayAndRecord withOptions:options error:nil]) {

} else if ([pAudioSession setCategory: AVAudioSessionCategoryPlayback withOptions:options error:nil]) {

} else if ([pAudioSession setCategory: AVAudioSessionCategoryRecord withOptions:options error:nil]) {

} else {

}
} else {
if (pConfig->coreaudio.sessionCategory != ma_ios_session_category_none) {
if (![pAudioSession setCategory: ma_to_AVAudioSessionCategory(pConfig->coreaudio.sessionCategory) withOptions:options error:nil]) {
return MA_INVALID_OPERATION; 
}
}
}
}
#endif

#if !defined(MA_NO_RUNTIME_LINKING) && !defined(MA_APPLE_MOBILE)
pContext->coreaudio.hCoreFoundation = ma_dlopen(pContext, "CoreFoundation.framework/CoreFoundation");
if (pContext->coreaudio.hCoreFoundation == NULL) {
return MA_API_NOT_FOUND;
}

pContext->coreaudio.CFStringGetCString = ma_dlsym(pContext, pContext->coreaudio.hCoreFoundation, "CFStringGetCString");
pContext->coreaudio.CFRelease = ma_dlsym(pContext, pContext->coreaudio.hCoreFoundation, "CFRelease");


pContext->coreaudio.hCoreAudio = ma_dlopen(pContext, "CoreAudio.framework/CoreAudio");
if (pContext->coreaudio.hCoreAudio == NULL) {
ma_dlclose(pContext, pContext->coreaudio.hCoreFoundation);
return MA_API_NOT_FOUND;
}

pContext->coreaudio.AudioObjectGetPropertyData = ma_dlsym(pContext, pContext->coreaudio.hCoreAudio, "AudioObjectGetPropertyData");
pContext->coreaudio.AudioObjectGetPropertyDataSize = ma_dlsym(pContext, pContext->coreaudio.hCoreAudio, "AudioObjectGetPropertyDataSize");
pContext->coreaudio.AudioObjectSetPropertyData = ma_dlsym(pContext, pContext->coreaudio.hCoreAudio, "AudioObjectSetPropertyData");
pContext->coreaudio.AudioObjectAddPropertyListener = ma_dlsym(pContext, pContext->coreaudio.hCoreAudio, "AudioObjectAddPropertyListener");
pContext->coreaudio.AudioObjectRemovePropertyListener = ma_dlsym(pContext, pContext->coreaudio.hCoreAudio, "AudioObjectRemovePropertyListener");







pContext->coreaudio.hAudioUnit = ma_dlopen(pContext, "AudioUnit.framework/AudioUnit");
if (pContext->coreaudio.hAudioUnit == NULL) {
ma_dlclose(pContext, pContext->coreaudio.hCoreAudio);
ma_dlclose(pContext, pContext->coreaudio.hCoreFoundation);
return MA_API_NOT_FOUND;
}

if (ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioComponentFindNext") == NULL) {

ma_dlclose(pContext, pContext->coreaudio.hAudioUnit);
pContext->coreaudio.hAudioUnit = ma_dlopen(pContext, "AudioToolbox.framework/AudioToolbox");
if (pContext->coreaudio.hAudioUnit == NULL) {
ma_dlclose(pContext, pContext->coreaudio.hCoreAudio);
ma_dlclose(pContext, pContext->coreaudio.hCoreFoundation);
return MA_API_NOT_FOUND;
}
}

pContext->coreaudio.AudioComponentFindNext = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioComponentFindNext");
pContext->coreaudio.AudioComponentInstanceDispose = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioComponentInstanceDispose");
pContext->coreaudio.AudioComponentInstanceNew = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioComponentInstanceNew");
pContext->coreaudio.AudioOutputUnitStart = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioOutputUnitStart");
pContext->coreaudio.AudioOutputUnitStop = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioOutputUnitStop");
pContext->coreaudio.AudioUnitAddPropertyListener = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitAddPropertyListener");
pContext->coreaudio.AudioUnitGetPropertyInfo = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitGetPropertyInfo");
pContext->coreaudio.AudioUnitGetProperty = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitGetProperty");
pContext->coreaudio.AudioUnitSetProperty = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitSetProperty");
pContext->coreaudio.AudioUnitInitialize = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitInitialize");
pContext->coreaudio.AudioUnitRender = ma_dlsym(pContext, pContext->coreaudio.hAudioUnit, "AudioUnitRender");
#else
pContext->coreaudio.CFStringGetCString = (ma_proc)CFStringGetCString;
pContext->coreaudio.CFRelease = (ma_proc)CFRelease;

#if defined(MA_APPLE_DESKTOP)
pContext->coreaudio.AudioObjectGetPropertyData = (ma_proc)AudioObjectGetPropertyData;
pContext->coreaudio.AudioObjectGetPropertyDataSize = (ma_proc)AudioObjectGetPropertyDataSize;
pContext->coreaudio.AudioObjectSetPropertyData = (ma_proc)AudioObjectSetPropertyData;
pContext->coreaudio.AudioObjectAddPropertyListener = (ma_proc)AudioObjectAddPropertyListener;
pContext->coreaudio.AudioObjectRemovePropertyListener = (ma_proc)AudioObjectRemovePropertyListener;
#endif

pContext->coreaudio.AudioComponentFindNext = (ma_proc)AudioComponentFindNext;
pContext->coreaudio.AudioComponentInstanceDispose = (ma_proc)AudioComponentInstanceDispose;
pContext->coreaudio.AudioComponentInstanceNew = (ma_proc)AudioComponentInstanceNew;
pContext->coreaudio.AudioOutputUnitStart = (ma_proc)AudioOutputUnitStart;
pContext->coreaudio.AudioOutputUnitStop = (ma_proc)AudioOutputUnitStop;
pContext->coreaudio.AudioUnitAddPropertyListener = (ma_proc)AudioUnitAddPropertyListener;
pContext->coreaudio.AudioUnitGetPropertyInfo = (ma_proc)AudioUnitGetPropertyInfo;
pContext->coreaudio.AudioUnitGetProperty = (ma_proc)AudioUnitGetProperty;
pContext->coreaudio.AudioUnitSetProperty = (ma_proc)AudioUnitSetProperty;
pContext->coreaudio.AudioUnitInitialize = (ma_proc)AudioUnitInitialize;
pContext->coreaudio.AudioUnitRender = (ma_proc)AudioUnitRender;
#endif

pContext->isBackendAsynchronous = MA_TRUE;

pContext->onUninit = ma_context_uninit__coreaudio;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__coreaudio;
pContext->onEnumDevices = ma_context_enumerate_devices__coreaudio;
pContext->onGetDeviceInfo = ma_context_get_device_info__coreaudio;
pContext->onDeviceInit = ma_device_init__coreaudio;
pContext->onDeviceUninit = ma_device_uninit__coreaudio;
pContext->onDeviceStart = ma_device_start__coreaudio;
pContext->onDeviceStop = ma_device_stop__coreaudio;


{
AudioComponentDescription desc;
desc.componentType = kAudioUnitType_Output;
#if defined(MA_APPLE_DESKTOP)
desc.componentSubType = kAudioUnitSubType_HALOutput;
#else
desc.componentSubType = kAudioUnitSubType_RemoteIO;
#endif
desc.componentManufacturer = kAudioUnitManufacturer_Apple;
desc.componentFlags = 0;
desc.componentFlagsMask = 0;

pContext->coreaudio.component = ((ma_AudioComponentFindNext_proc)pContext->coreaudio.AudioComponentFindNext)(NULL, &desc);
if (pContext->coreaudio.component == NULL) {
#if !defined(MA_NO_RUNTIME_LINKING) && !defined(MA_APPLE_MOBILE)
ma_dlclose(pContext, pContext->coreaudio.hAudioUnit);
ma_dlclose(pContext, pContext->coreaudio.hCoreAudio);
ma_dlclose(pContext, pContext->coreaudio.hCoreFoundation);
#endif
return MA_FAILED_TO_INIT_BACKEND;
}
}

return MA_SUCCESS;
}
#endif 








#if defined(MA_HAS_SNDIO)
#include <fcntl.h>
#include <sys/stat.h>







#if 0
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/audioio.h>
#endif
#if defined(__FreeBSD__) || defined(__DragonFly__)
#include <sys/soundcard.h>
#endif
#endif

#define MA_SIO_DEVANY "default"
#define MA_SIO_PLAY 1
#define MA_SIO_REC 2
#define MA_SIO_NENC 8
#define MA_SIO_NCHAN 8
#define MA_SIO_NRATE 16
#define MA_SIO_NCONF 4

struct ma_sio_hdl; 

struct ma_sio_par
{
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
unsigned int rchan;
unsigned int pchan;
unsigned int rate;
unsigned int bufsz;
unsigned int xrun;
unsigned int round;
unsigned int appbufsz;
int __pad[3];
unsigned int __magic;
};

struct ma_sio_enc
{
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
};

struct ma_sio_conf
{
unsigned int enc;
unsigned int rchan;
unsigned int pchan;
unsigned int rate;
};

struct ma_sio_cap
{
struct ma_sio_enc enc[MA_SIO_NENC];
unsigned int rchan[MA_SIO_NCHAN];
unsigned int pchan[MA_SIO_NCHAN];
unsigned int rate[MA_SIO_NRATE];
int __pad[7];
unsigned int nconf;
struct ma_sio_conf confs[MA_SIO_NCONF];
};

typedef struct ma_sio_hdl* (* ma_sio_open_proc) (const char*, unsigned int, int);
typedef void (* ma_sio_close_proc) (struct ma_sio_hdl*);
typedef int (* ma_sio_setpar_proc) (struct ma_sio_hdl*, struct ma_sio_par*);
typedef int (* ma_sio_getpar_proc) (struct ma_sio_hdl*, struct ma_sio_par*);
typedef int (* ma_sio_getcap_proc) (struct ma_sio_hdl*, struct ma_sio_cap*);
typedef size_t (* ma_sio_write_proc) (struct ma_sio_hdl*, const void*, size_t);
typedef size_t (* ma_sio_read_proc) (struct ma_sio_hdl*, void*, size_t);
typedef int (* ma_sio_start_proc) (struct ma_sio_hdl*);
typedef int (* ma_sio_stop_proc) (struct ma_sio_hdl*);
typedef int (* ma_sio_initpar_proc)(struct ma_sio_par*);

static ma_uint32 ma_get_standard_sample_rate_priority_index__sndio(ma_uint32 sampleRate) 
{
ma_uint32 i;
for (i = 0; i < ma_countof(g_maStandardSampleRatePriorities); ++i) {
if (g_maStandardSampleRatePriorities[i] == sampleRate) {
return i;
}
}

return (ma_uint32)-1;
}

static ma_format ma_format_from_sio_enc__sndio(unsigned int bits, unsigned int bps, unsigned int sig, unsigned int le, unsigned int msb)
{

if ((ma_is_little_endian() && le == 0) || (ma_is_big_endian() && le == 1)) {
return ma_format_unknown;
}

if (bits == 8 && bps == 1 && sig == 0) {
return ma_format_u8;
}
if (bits == 16 && bps == 2 && sig == 1) {
return ma_format_s16;
}
if (bits == 24 && bps == 3 && sig == 1) {
return ma_format_s24;
}
if (bits == 24 && bps == 4 && sig == 1 && msb == 0) {

}
if (bits == 32 && bps == 4 && sig == 1) {
return ma_format_s32;
}

return ma_format_unknown;
}

static ma_format ma_find_best_format_from_sio_cap__sndio(struct ma_sio_cap* caps)
{
ma_format bestFormat;
unsigned int iConfig;

MA_ASSERT(caps != NULL);

bestFormat = ma_format_unknown;
for (iConfig = 0; iConfig < caps->nconf; iConfig += 1) {
unsigned int iEncoding;
for (iEncoding = 0; iEncoding < MA_SIO_NENC; iEncoding += 1) {
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
ma_format format;

if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
continue;
}

bits = caps->enc[iEncoding].bits;
bps = caps->enc[iEncoding].bps;
sig = caps->enc[iEncoding].sig;
le = caps->enc[iEncoding].le;
msb = caps->enc[iEncoding].msb;
format = ma_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
if (format == ma_format_unknown) {
continue; 
}

if (bestFormat == ma_format_unknown) {
bestFormat = format;
} else {
if (ma_get_format_priority_index(bestFormat) > ma_get_format_priority_index(format)) { 
bestFormat = format;
}
}
}
}

return ma_format_unknown;
}

static ma_uint32 ma_find_best_channels_from_sio_cap__sndio(struct ma_sio_cap* caps, ma_device_type deviceType, ma_format requiredFormat)
{
ma_uint32 maxChannels;
unsigned int iConfig;

MA_ASSERT(caps != NULL);
MA_ASSERT(requiredFormat != ma_format_unknown);


maxChannels = 0;
for (iConfig = 0; iConfig < caps->nconf; iConfig += 1) {

unsigned int iEncoding;
for (iEncoding = 0; iEncoding < MA_SIO_NENC; iEncoding += 1) {
unsigned int iChannel;
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
ma_format format;

if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
continue;
}

bits = caps->enc[iEncoding].bits;
bps = caps->enc[iEncoding].bps;
sig = caps->enc[iEncoding].sig;
le = caps->enc[iEncoding].le;
msb = caps->enc[iEncoding].msb;
format = ma_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
if (format != requiredFormat) {
continue;
}


for (iChannel = 0; iChannel < MA_SIO_NCHAN; iChannel += 1) {
unsigned int chan = 0;
unsigned int channels;

if (deviceType == ma_device_type_playback) {
chan = caps->confs[iConfig].pchan;
} else {
chan = caps->confs[iConfig].rchan;
}

if ((chan & (1UL << iChannel)) == 0) {
continue;
}

if (deviceType == ma_device_type_playback) {
channels = caps->pchan[iChannel];
} else {
channels = caps->rchan[iChannel];
}

if (maxChannels < channels) {
maxChannels = channels;
}
}
}
}

return maxChannels;
}

static ma_uint32 ma_find_best_sample_rate_from_sio_cap__sndio(struct ma_sio_cap* caps, ma_device_type deviceType, ma_format requiredFormat, ma_uint32 requiredChannels)
{
ma_uint32 firstSampleRate;
ma_uint32 bestSampleRate;
unsigned int iConfig;

MA_ASSERT(caps != NULL);
MA_ASSERT(requiredFormat != ma_format_unknown);
MA_ASSERT(requiredChannels > 0);
MA_ASSERT(requiredChannels <= MA_MAX_CHANNELS);

firstSampleRate = 0; 
bestSampleRate = 0;

for (iConfig = 0; iConfig < caps->nconf; iConfig += 1) {

unsigned int iEncoding;
for (iEncoding = 0; iEncoding < MA_SIO_NENC; iEncoding += 1) {
unsigned int iChannel;
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
ma_format format;

if ((caps->confs[iConfig].enc & (1UL << iEncoding)) == 0) {
continue;
}

bits = caps->enc[iEncoding].bits;
bps = caps->enc[iEncoding].bps;
sig = caps->enc[iEncoding].sig;
le = caps->enc[iEncoding].le;
msb = caps->enc[iEncoding].msb;
format = ma_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
if (format != requiredFormat) {
continue;
}


for (iChannel = 0; iChannel < MA_SIO_NCHAN; iChannel += 1) {
unsigned int chan = 0;
unsigned int channels;
unsigned int iRate;

if (deviceType == ma_device_type_playback) {
chan = caps->confs[iConfig].pchan;
} else {
chan = caps->confs[iConfig].rchan;
}

if ((chan & (1UL << iChannel)) == 0) {
continue;
}

if (deviceType == ma_device_type_playback) {
channels = caps->pchan[iChannel];
} else {
channels = caps->rchan[iChannel];
}

if (channels != requiredChannels) {
continue;
}


for (iRate = 0; iRate < MA_SIO_NRATE; iRate += 1) {
ma_uint32 rate = (ma_uint32)caps->rate[iRate];
ma_uint32 ratePriority;

if (firstSampleRate == 0) {
firstSampleRate = rate;
}


ratePriority = ma_get_standard_sample_rate_priority_index__sndio(rate);
if (ratePriority == (ma_uint32)-1) {
continue;
}

if (ma_get_standard_sample_rate_priority_index__sndio(bestSampleRate) > ratePriority) { 
bestSampleRate = rate;
}
}
}
}
}


if (bestSampleRate == 0) {
bestSampleRate = firstSampleRate;
}

return bestSampleRate;
}


static ma_bool32 ma_context_is_device_id_equal__sndio(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->sndio, pID1->sndio) == 0;
}

static ma_result ma_context_enumerate_devices__sndio(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 isTerminating = MA_FALSE;
struct ma_sio_hdl* handle;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);




if (!isTerminating) {
handle = ((ma_sio_open_proc)pContext->sndio.sio_open)(MA_SIO_DEVANY, MA_SIO_PLAY, 0);
if (handle != NULL) {

ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strcpy_s(deviceInfo.id.sndio, sizeof(deviceInfo.id.sndio), MA_SIO_DEVANY);
ma_strcpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME);

isTerminating = !callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);

((ma_sio_close_proc)pContext->sndio.sio_close)(handle);
}
}


if (!isTerminating) {
handle = ((ma_sio_open_proc)pContext->sndio.sio_open)(MA_SIO_DEVANY, MA_SIO_REC, 0);
if (handle != NULL) {

ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strcpy_s(deviceInfo.id.sndio, sizeof(deviceInfo.id.sndio), "default");
ma_strcpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME);

isTerminating = !callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);

((ma_sio_close_proc)pContext->sndio.sio_close)(handle);
}
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__sndio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
char devid[256];
struct ma_sio_hdl* handle;
struct ma_sio_cap caps;
unsigned int iConfig;

MA_ASSERT(pContext != NULL);
(void)shareMode;


if (pDeviceID == NULL) {
ma_strcpy_s(devid, sizeof(devid), MA_SIO_DEVANY);
ma_strcpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (deviceType == ma_device_type_playback) ? MA_DEFAULT_PLAYBACK_DEVICE_NAME : MA_DEFAULT_CAPTURE_DEVICE_NAME);
} else {
ma_strcpy_s(devid, sizeof(devid), pDeviceID->sndio);
ma_strcpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), devid);
}

handle = ((ma_sio_open_proc)pContext->sndio.sio_open)(devid, (deviceType == ma_device_type_playback) ? MA_SIO_PLAY : MA_SIO_REC, 0);
if (handle == NULL) {
return MA_NO_DEVICE;
}

if (((ma_sio_getcap_proc)pContext->sndio.sio_getcap)(handle, &caps) == 0) {
return MA_ERROR;
}

for (iConfig = 0; iConfig < caps.nconf; iConfig += 1) {




unsigned int iEncoding;
unsigned int iChannel;
unsigned int iRate;

for (iEncoding = 0; iEncoding < MA_SIO_NENC; iEncoding += 1) {
unsigned int bits;
unsigned int bps;
unsigned int sig;
unsigned int le;
unsigned int msb;
ma_format format;
ma_bool32 formatExists = MA_FALSE;
ma_uint32 iExistingFormat;

if ((caps.confs[iConfig].enc & (1UL << iEncoding)) == 0) {
continue;
}

bits = caps.enc[iEncoding].bits;
bps = caps.enc[iEncoding].bps;
sig = caps.enc[iEncoding].sig;
le = caps.enc[iEncoding].le;
msb = caps.enc[iEncoding].msb;
format = ma_format_from_sio_enc__sndio(bits, bps, sig, le, msb);
if (format == ma_format_unknown) {
continue; 
}


for (iExistingFormat = 0; iExistingFormat < pDeviceInfo->formatCount; iExistingFormat += 1) {
if (pDeviceInfo->formats[iExistingFormat] == format) {
formatExists = MA_TRUE;
break;
}
}

if (!formatExists) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = format;
}
}


for (iChannel = 0; iChannel < MA_SIO_NCHAN; iChannel += 1) {
unsigned int chan = 0;
unsigned int channels;

if (deviceType == ma_device_type_playback) {
chan = caps.confs[iConfig].pchan;
} else {
chan = caps.confs[iConfig].rchan;
}

if ((chan & (1UL << iChannel)) == 0) {
continue;
}

if (deviceType == ma_device_type_playback) {
channels = caps.pchan[iChannel];
} else {
channels = caps.rchan[iChannel];
}

if (pDeviceInfo->minChannels > channels) {
pDeviceInfo->minChannels = channels;
}
if (pDeviceInfo->maxChannels < channels) {
pDeviceInfo->maxChannels = channels;
}
}


for (iRate = 0; iRate < MA_SIO_NRATE; iRate += 1) {
if ((caps.confs[iConfig].rate & (1UL << iRate)) != 0) {
unsigned int rate = caps.rate[iRate];
if (pDeviceInfo->minSampleRate > rate) {
pDeviceInfo->minSampleRate = rate;
}
if (pDeviceInfo->maxSampleRate < rate) {
pDeviceInfo->maxSampleRate = rate;
}
}
}
}

((ma_sio_close_proc)pContext->sndio.sio_close)(handle);
return MA_SUCCESS;
}

static void ma_device_uninit__sndio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_sio_close_proc)pDevice->pContext->sndio.sio_close)((struct ma_sio_hdl*)pDevice->sndio.handleCapture);
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_sio_close_proc)pDevice->pContext->sndio.sio_close)((struct ma_sio_hdl*)pDevice->sndio.handlePlayback);
}
}

static ma_result ma_device_init_handle__sndio(ma_context* pContext, const ma_device_config* pConfig, ma_device_type deviceType, ma_device* pDevice)
{
const char* pDeviceName;
ma_ptr handle;
int openFlags = 0;
struct ma_sio_cap caps;
struct ma_sio_par par;
ma_device_id* pDeviceID;
ma_format format;
ma_uint32 channels;
ma_uint32 sampleRate;
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_uint32 internalPeriodSizeInFrames;
ma_uint32 internalPeriods;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(deviceType != ma_device_type_duplex);
MA_ASSERT(pDevice != NULL);

if (deviceType == ma_device_type_capture) {
openFlags = MA_SIO_REC;
pDeviceID = pConfig->capture.pDeviceID;
format = pConfig->capture.format;
channels = pConfig->capture.channels;
sampleRate = pConfig->sampleRate;
} else {
openFlags = MA_SIO_PLAY;
pDeviceID = pConfig->playback.pDeviceID;
format = pConfig->playback.format;
channels = pConfig->playback.channels;
sampleRate = pConfig->sampleRate;
}

pDeviceName = MA_SIO_DEVANY;
if (pDeviceID != NULL) {
pDeviceName = pDeviceID->sndio;
}

handle = (ma_ptr)((ma_sio_open_proc)pContext->sndio.sio_open)(pDeviceName, openFlags, 0);
if (handle == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to open device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


if (((ma_sio_getcap_proc)pContext->sndio.sio_getcap)((struct ma_sio_hdl*)handle, &caps) == 0) {
((ma_sio_close_proc)pContext->sndio.sio_close)((struct ma_sio_hdl*)handle);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to retrieve device caps.", MA_ERROR);
}









if (deviceType == ma_device_type_capture) {
if (pDevice->capture.usingDefaultFormat) {
format = ma_find_best_format_from_sio_cap__sndio(&caps);
}
if (pDevice->capture.usingDefaultChannels) {
if (strlen(pDeviceName) > strlen("rsnd/") && strncmp(pDeviceName, "rsnd/", strlen("rsnd/")) == 0) {
channels = ma_find_best_channels_from_sio_cap__sndio(&caps, deviceType, format);
}
}
} else {
if (pDevice->playback.usingDefaultFormat) {
format = ma_find_best_format_from_sio_cap__sndio(&caps);
}
if (pDevice->playback.usingDefaultChannels) {
if (strlen(pDeviceName) > strlen("rsnd/") && strncmp(pDeviceName, "rsnd/", strlen("rsnd/")) == 0) {
channels = ma_find_best_channels_from_sio_cap__sndio(&caps, deviceType, format);
}
}
}

if (pDevice->usingDefaultSampleRate) {
sampleRate = ma_find_best_sample_rate_from_sio_cap__sndio(&caps, pConfig->deviceType, format, channels);
}


((ma_sio_initpar_proc)pDevice->pContext->sndio.sio_initpar)(&par);
par.msb = 0;
par.le = ma_is_little_endian();

switch (format) {
case ma_format_u8:
{
par.bits = 8;
par.bps = 1;
par.sig = 0;
} break;

case ma_format_s24:
{
par.bits = 24;
par.bps = 3;
par.sig = 1;
} break;

case ma_format_s32:
{
par.bits = 32;
par.bps = 4;
par.sig = 1;
} break;

case ma_format_s16:
case ma_format_f32:
default:
{
par.bits = 16;
par.bps = 2;
par.sig = 1;
} break;
}

if (deviceType == ma_device_type_capture) {
par.rchan = channels;
} else {
par.pchan = channels;
}

par.rate = sampleRate;

internalPeriodSizeInFrames = pConfig->periodSizeInFrames;
if (internalPeriodSizeInFrames == 0) {
internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, par.rate);
}

par.round = internalPeriodSizeInFrames;
par.appbufsz = par.round * pConfig->periods;

if (((ma_sio_setpar_proc)pContext->sndio.sio_setpar)((struct ma_sio_hdl*)handle, &par) == 0) {
((ma_sio_close_proc)pContext->sndio.sio_close)((struct ma_sio_hdl*)handle);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to set buffer size.", MA_FORMAT_NOT_SUPPORTED);
}
if (((ma_sio_getpar_proc)pContext->sndio.sio_getpar)((struct ma_sio_hdl*)handle, &par) == 0) {
((ma_sio_close_proc)pContext->sndio.sio_close)((struct ma_sio_hdl*)handle);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to retrieve buffer size.", MA_FORMAT_NOT_SUPPORTED);
}

internalFormat = ma_format_from_sio_enc__sndio(par.bits, par.bps, par.sig, par.le, par.msb);
internalChannels = (deviceType == ma_device_type_capture) ? par.rchan : par.pchan;
internalSampleRate = par.rate;
internalPeriods = par.appbufsz / par.round;
internalPeriodSizeInFrames = par.round;

if (deviceType == ma_device_type_capture) {
pDevice->sndio.handleCapture = handle;
pDevice->capture.internalFormat = internalFormat;
pDevice->capture.internalChannels = internalChannels;
pDevice->capture.internalSampleRate = internalSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sndio, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
pDevice->capture.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->capture.internalPeriods = internalPeriods;
} else {
pDevice->sndio.handlePlayback = handle;
pDevice->playback.internalFormat = internalFormat;
pDevice->playback.internalChannels = internalChannels;
pDevice->playback.internalSampleRate = internalSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sndio, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
pDevice->playback.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->playback.internalPeriods = internalPeriods;
}

#if defined(MA_DEBUG_OUTPUT)
printf("DEVICE INFO\n");
printf(" Format: %s\n", ma_get_format_name(internalFormat));
printf(" Channels: %d\n", internalChannels);
printf(" Sample Rate: %d\n", internalSampleRate);
printf(" Period Size: %d\n", internalPeriodSizeInFrames);
printf(" Periods: %d\n", internalPeriods);
printf(" appbufsz: %d\n", par.appbufsz);
printf(" round: %d\n", par.round);
#endif

return MA_SUCCESS;
}

static ma_result ma_device_init__sndio(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->sndio);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_handle__sndio(pContext, pConfig, ma_device_type_capture, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_handle__sndio(pContext, pConfig, ma_device_type_playback, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__sndio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);











if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_sio_stop_proc)pDevice->pContext->sndio.sio_stop)((struct ma_sio_hdl*)pDevice->sndio.handleCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
((ma_sio_stop_proc)pDevice->pContext->sndio.sio_stop)((struct ma_sio_hdl*)pDevice->sndio.handlePlayback);
}

return MA_SUCCESS;
}

static ma_result ma_device_write__sndio(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
int result;

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

result = ((ma_sio_write_proc)pDevice->pContext->sndio.sio_write)((struct ma_sio_hdl*)pDevice->sndio.handlePlayback, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
if (result == 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to send data from the client to the device.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
}

if (pFramesWritten != NULL) {
*pFramesWritten = frameCount;
}

return MA_SUCCESS;
}

static ma_result ma_device_read__sndio(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
int result;

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

result = ((ma_sio_read_proc)pDevice->pContext->sndio.sio_read)((struct ma_sio_hdl*)pDevice->sndio.handleCapture, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
if (result == 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[sndio] Failed to read data from the device to be sent to the device.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
}

if (pFramesRead != NULL) {
*pFramesRead = frameCount;
}

return MA_SUCCESS;
}

static ma_result ma_device_main_loop__sndio(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;


if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
((ma_sio_start_proc)pDevice->pContext->sndio.sio_start)((struct ma_sio_hdl*)pDevice->sndio.handleCapture);
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
((ma_sio_start_proc)pDevice->pContext->sndio.sio_start)((struct ma_sio_hdl*)pDevice->sndio.handlePlayback); 
}

while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__sndio(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__sndio(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__sndio(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__sndio(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}



ma_device_stop__sndio(pDevice);

return result;
}

static ma_result ma_context_uninit__sndio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_sndio);

(void)pContext;
return MA_SUCCESS;
}

static ma_result ma_context_init__sndio(const ma_context_config* pConfig, ma_context* pContext)
{
#if !defined(MA_NO_RUNTIME_LINKING)
const char* libsndioNames[] = {
"libsndio.so"
};
size_t i;

for (i = 0; i < ma_countof(libsndioNames); ++i) {
pContext->sndio.sndioSO = ma_dlopen(pContext, libsndioNames[i]);
if (pContext->sndio.sndioSO != NULL) {
break;
}
}

if (pContext->sndio.sndioSO == NULL) {
return MA_NO_BACKEND;
}

pContext->sndio.sio_open = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_open");
pContext->sndio.sio_close = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_close");
pContext->sndio.sio_setpar = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_setpar");
pContext->sndio.sio_getpar = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_getpar");
pContext->sndio.sio_getcap = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_getcap");
pContext->sndio.sio_write = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_write");
pContext->sndio.sio_read = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_read");
pContext->sndio.sio_start = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_start");
pContext->sndio.sio_stop = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_stop");
pContext->sndio.sio_initpar = (ma_proc)ma_dlsym(pContext, pContext->sndio.sndioSO, "sio_initpar");
#else
pContext->sndio.sio_open = sio_open;
pContext->sndio.sio_close = sio_close;
pContext->sndio.sio_setpar = sio_setpar;
pContext->sndio.sio_getpar = sio_getpar;
pContext->sndio.sio_getcap = sio_getcap;
pContext->sndio.sio_write = sio_write;
pContext->sndio.sio_read = sio_read;
pContext->sndio.sio_start = sio_start;
pContext->sndio.sio_stop = sio_stop;
pContext->sndio.sio_initpar = sio_initpar;
#endif

pContext->onUninit = ma_context_uninit__sndio;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__sndio;
pContext->onEnumDevices = ma_context_enumerate_devices__sndio;
pContext->onGetDeviceInfo = ma_context_get_device_info__sndio;
pContext->onDeviceInit = ma_device_init__sndio;
pContext->onDeviceUninit = ma_device_uninit__sndio;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__sndio;

(void)pConfig;
return MA_SUCCESS;
}
#endif 








#if defined(MA_HAS_AUDIO4)
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>

#if defined(__OpenBSD__)
#include <sys/param.h>
#if defined(OpenBSD) && OpenBSD >= 201709
#define MA_AUDIO4_USE_NEW_API
#endif
#endif

static void ma_construct_device_id__audio4(char* id, size_t idSize, const char* base, int deviceIndex)
{
size_t baseLen;

MA_ASSERT(id != NULL);
MA_ASSERT(idSize > 0);
MA_ASSERT(deviceIndex >= 0);

baseLen = strlen(base);
MA_ASSERT(idSize > baseLen);

ma_strcpy_s(id, idSize, base);
ma_itoa_s(deviceIndex, id+baseLen, idSize-baseLen, 10);
}

static ma_result ma_extract_device_index_from_id__audio4(const char* id, const char* base, int* pIndexOut)
{
size_t idLen;
size_t baseLen;
const char* deviceIndexStr;

MA_ASSERT(id != NULL);
MA_ASSERT(base != NULL);
MA_ASSERT(pIndexOut != NULL);

idLen = strlen(id);
baseLen = strlen(base);
if (idLen <= baseLen) {
return MA_ERROR; 
}

if (strncmp(id, base, baseLen) != 0) {
return MA_ERROR; 
}

deviceIndexStr = id + baseLen;
if (deviceIndexStr[0] == '\0') {
return MA_ERROR; 
}

if (pIndexOut) {
*pIndexOut = atoi(deviceIndexStr);
}

return MA_SUCCESS;
}

static ma_bool32 ma_context_is_device_id_equal__audio4(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->audio4, pID1->audio4) == 0;
}

#if !defined(MA_AUDIO4_USE_NEW_API) 
static ma_format ma_format_from_encoding__audio4(unsigned int encoding, unsigned int precision)
{
if (precision == 8 && (encoding == AUDIO_ENCODING_ULINEAR || encoding == AUDIO_ENCODING_ULINEAR || encoding == AUDIO_ENCODING_ULINEAR_LE || encoding == AUDIO_ENCODING_ULINEAR_BE)) {
return ma_format_u8;
} else {
if (ma_is_little_endian() && encoding == AUDIO_ENCODING_SLINEAR_LE) {
if (precision == 16) {
return ma_format_s16;
} else if (precision == 24) {
return ma_format_s24;
} else if (precision == 32) {
return ma_format_s32;
}
} else if (ma_is_big_endian() && encoding == AUDIO_ENCODING_SLINEAR_BE) {
if (precision == 16) {
return ma_format_s16;
} else if (precision == 24) {
return ma_format_s24;
} else if (precision == 32) {
return ma_format_s32;
}
}
}

return ma_format_unknown; 
}

static void ma_encoding_from_format__audio4(ma_format format, unsigned int* pEncoding, unsigned int* pPrecision)
{
MA_ASSERT(format != ma_format_unknown);
MA_ASSERT(pEncoding != NULL);
MA_ASSERT(pPrecision != NULL);

switch (format)
{
case ma_format_u8:
{
*pEncoding = AUDIO_ENCODING_ULINEAR;
*pPrecision = 8;
} break;

case ma_format_s24:
{
*pEncoding = (ma_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
*pPrecision = 24;
} break;

case ma_format_s32:
{
*pEncoding = (ma_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
*pPrecision = 32;
} break;

case ma_format_s16:
case ma_format_f32:
default:
{
*pEncoding = (ma_is_little_endian()) ? AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_SLINEAR_BE;
*pPrecision = 16;
} break;
}
}

static ma_format ma_format_from_prinfo__audio4(struct audio_prinfo* prinfo)
{
return ma_format_from_encoding__audio4(prinfo->encoding, prinfo->precision);
}
#else
static ma_format ma_format_from_swpar__audio4(struct audio_swpar* par)
{
if (par->bits == 8 && par->bps == 1 && par->sig == 0) {
return ma_format_u8;
}
if (par->bits == 16 && par->bps == 2 && par->sig == 1 && par->le == ma_is_little_endian()) {
return ma_format_s16;
}
if (par->bits == 24 && par->bps == 3 && par->sig == 1 && par->le == ma_is_little_endian()) {
return ma_format_s24;
}
if (par->bits == 32 && par->bps == 4 && par->sig == 1 && par->le == ma_is_little_endian()) {
return ma_format_f32;
}


return ma_format_unknown;
}
#endif

static ma_result ma_context_get_device_info_from_fd__audio4(ma_context* pContext, ma_device_type deviceType, int fd, ma_device_info* pInfoOut)
{
audio_device_t fdDevice;
#if !defined(MA_AUDIO4_USE_NEW_API)
int counter = 0;
audio_info_t fdInfo;
#else
struct audio_swpar fdPar;
ma_format format;
#endif

MA_ASSERT(pContext != NULL);
MA_ASSERT(fd >= 0);
MA_ASSERT(pInfoOut != NULL);

(void)pContext;
(void)deviceType;

if (ioctl(fd, AUDIO_GETDEV, &fdDevice) < 0) {
return MA_ERROR; 
}


ma_strcpy_s(pInfoOut->name, sizeof(pInfoOut->name), fdDevice.name);

#if !defined(MA_AUDIO4_USE_NEW_API)

for (;;) {
audio_encoding_t encoding;
ma_format format;

MA_ZERO_OBJECT(&encoding);
encoding.index = counter;
if (ioctl(fd, AUDIO_GETENC, &encoding) < 0) {
break;
}

format = ma_format_from_encoding__audio4(encoding.encoding, encoding.precision);
if (format != ma_format_unknown) {
pInfoOut->formats[pInfoOut->formatCount++] = format;
}

counter += 1;
}

if (ioctl(fd, AUDIO_GETINFO, &fdInfo) < 0) {
return MA_ERROR;
}

if (deviceType == ma_device_type_playback) {
pInfoOut->minChannels = fdInfo.play.channels; 
pInfoOut->maxChannels = fdInfo.play.channels;
pInfoOut->minSampleRate = fdInfo.play.sample_rate;
pInfoOut->maxSampleRate = fdInfo.play.sample_rate;
} else {
pInfoOut->minChannels = fdInfo.record.channels;
pInfoOut->maxChannels = fdInfo.record.channels;
pInfoOut->minSampleRate = fdInfo.record.sample_rate;
pInfoOut->maxSampleRate = fdInfo.record.sample_rate;
}
#else
if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
return MA_ERROR;
}

format = ma_format_from_swpar__audio4(&fdPar);
if (format == ma_format_unknown) {
return MA_FORMAT_NOT_SUPPORTED;
}
pInfoOut->formats[pInfoOut->formatCount++] = format;

if (deviceType == ma_device_type_playback) {
pInfoOut->minChannels = fdPar.pchan;
pInfoOut->maxChannels = fdPar.pchan;
} else {
pInfoOut->minChannels = fdPar.rchan;
pInfoOut->maxChannels = fdPar.rchan;
}

pInfoOut->minSampleRate = fdPar.rate;
pInfoOut->maxSampleRate = fdPar.rate;
#endif

return MA_SUCCESS;
}

static ma_result ma_context_enumerate_devices__audio4(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
const int maxDevices = 64;
char devpath[256];
int iDevice;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);





for (iDevice = 0; iDevice < maxDevices; ++iDevice) {
struct stat st;
int fd;
ma_bool32 isTerminating = MA_FALSE;

ma_strcpy_s(devpath, sizeof(devpath), "/dev/audioctl");
ma_itoa_s(iDevice, devpath+strlen(devpath), sizeof(devpath)-strlen(devpath), 10);

if (stat(devpath, &st) < 0) {
break;
}




if (!isTerminating) {
fd = open(devpath, O_RDONLY, 0);
if (fd >= 0) {

ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_construct_device_id__audio4(deviceInfo.id.audio4, sizeof(deviceInfo.id.audio4), "/dev/audio", iDevice);
if (ma_context_get_device_info_from_fd__audio4(pContext, ma_device_type_playback, fd, &deviceInfo) == MA_SUCCESS) {
isTerminating = !callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}

close(fd);
}
}


if (!isTerminating) {
fd = open(devpath, O_WRONLY, 0);
if (fd >= 0) {

ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_construct_device_id__audio4(deviceInfo.id.audio4, sizeof(deviceInfo.id.audio4), "/dev/audio", iDevice);
if (ma_context_get_device_info_from_fd__audio4(pContext, ma_device_type_capture, fd, &deviceInfo) == MA_SUCCESS) {
isTerminating = !callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}

close(fd);
}
}

if (isTerminating) {
break;
}
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__audio4(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
int fd = -1;
int deviceIndex = -1;
char ctlid[256];
ma_result result;

MA_ASSERT(pContext != NULL);
(void)shareMode;





if (pDeviceID == NULL) {

ma_strcpy_s(ctlid, sizeof(ctlid), "/dev/audioctl");
} else {

result = ma_extract_device_index_from_id__audio4(pDeviceID->audio4, "/dev/audio", &deviceIndex);
if (result != MA_SUCCESS) {
return result;
}

ma_construct_device_id__audio4(ctlid, sizeof(ctlid), "/dev/audioctl", deviceIndex);
}

fd = open(ctlid, (deviceType == ma_device_type_playback) ? O_WRONLY : O_RDONLY, 0);
if (fd == -1) {
return MA_NO_DEVICE;
}

if (deviceIndex == -1) {
ma_strcpy_s(pDeviceInfo->id.audio4, sizeof(pDeviceInfo->id.audio4), "/dev/audio");
} else {
ma_construct_device_id__audio4(pDeviceInfo->id.audio4, sizeof(pDeviceInfo->id.audio4), "/dev/audio", deviceIndex);
}

result = ma_context_get_device_info_from_fd__audio4(pContext, deviceType, fd, pDeviceInfo);

close(fd);
return result;
}

static void ma_device_uninit__audio4(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
close(pDevice->audio4.fdCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
close(pDevice->audio4.fdPlayback);
}
}

static ma_result ma_device_init_fd__audio4(ma_context* pContext, const ma_device_config* pConfig, ma_device_type deviceType, ma_device* pDevice)
{
const char* pDefaultDeviceNames[] = {
"/dev/audio",
"/dev/audio0"
};
int fd;
int fdFlags = 0;
#if !defined(MA_AUDIO4_USE_NEW_API) 
audio_info_t fdInfo;
#else
struct audio_swpar fdPar;
#endif
ma_format internalFormat;
ma_uint32 internalChannels;
ma_uint32 internalSampleRate;
ma_uint32 internalPeriodSizeInFrames;
ma_uint32 internalPeriods;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(deviceType != ma_device_type_duplex);
MA_ASSERT(pDevice != NULL);

(void)pContext;


if (deviceType == ma_device_type_capture) {
fdFlags = O_RDONLY;
} else {
fdFlags = O_WRONLY;
}


if ((deviceType == ma_device_type_capture && pConfig->capture.pDeviceID == NULL) || (deviceType == ma_device_type_playback && pConfig->playback.pDeviceID == NULL)) {

size_t iDevice;
for (iDevice = 0; iDevice < ma_countof(pDefaultDeviceNames); ++iDevice) {
fd = open(pDefaultDeviceNames[iDevice], fdFlags, 0);
if (fd != -1) {
break;
}
}
} else {

fd = open((deviceType == ma_device_type_capture) ? pConfig->capture.pDeviceID->audio4 : pConfig->playback.pDeviceID->audio4, fdFlags, 0);
}

if (fd == -1) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to open device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

#if !defined(MA_AUDIO4_USE_NEW_API) 
AUDIO_INITINFO(&fdInfo);


if (deviceType == ma_device_type_capture) {
fdInfo.mode = AUMODE_RECORD;
ma_encoding_from_format__audio4(pConfig->capture.format, &fdInfo.record.encoding, &fdInfo.record.precision);
fdInfo.record.channels = pConfig->capture.channels;
fdInfo.record.sample_rate = pConfig->sampleRate;
} else {
fdInfo.mode = AUMODE_PLAY;
ma_encoding_from_format__audio4(pConfig->playback.format, &fdInfo.play.encoding, &fdInfo.play.precision);
fdInfo.play.channels = pConfig->playback.channels;
fdInfo.play.sample_rate = pConfig->sampleRate;
}

if (ioctl(fd, AUDIO_SETINFO, &fdInfo) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to set device format. AUDIO_SETINFO failed.", MA_FORMAT_NOT_SUPPORTED);
}

if (ioctl(fd, AUDIO_GETINFO, &fdInfo) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] AUDIO_GETINFO failed.", MA_FORMAT_NOT_SUPPORTED);
}

if (deviceType == ma_device_type_capture) {
internalFormat = ma_format_from_prinfo__audio4(&fdInfo.record);
internalChannels = fdInfo.record.channels;
internalSampleRate = fdInfo.record.sample_rate;
} else {
internalFormat = ma_format_from_prinfo__audio4(&fdInfo.play);
internalChannels = fdInfo.play.channels;
internalSampleRate = fdInfo.play.sample_rate;
}

if (internalFormat == ma_format_unknown) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by miniaudio. The device is unusable.", MA_FORMAT_NOT_SUPPORTED);
}


{
ma_uint32 internalPeriodSizeInBytes;

internalPeriodSizeInFrames = pConfig->periodSizeInFrames;
if (internalPeriodSizeInFrames == 0) {
internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, internalSampleRate);
}

internalPeriodSizeInBytes = internalPeriodSizeInFrames * ma_get_bytes_per_frame(internalFormat, internalChannels);
if (internalPeriodSizeInBytes < 16) {
internalPeriodSizeInBytes = 16;
}

internalPeriods = pConfig->periods;
if (internalPeriods < 2) {
internalPeriods = 2;
}


AUDIO_INITINFO(&fdInfo);
fdInfo.hiwat = internalPeriods;
fdInfo.lowat = internalPeriods-1;
fdInfo.blocksize = internalPeriodSizeInBytes;
if (ioctl(fd, AUDIO_SETINFO, &fdInfo) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to set internal buffer size. AUDIO_SETINFO failed.", MA_FORMAT_NOT_SUPPORTED);
}

internalPeriods = fdInfo.hiwat;
internalPeriodSizeInFrames = fdInfo.blocksize / ma_get_bytes_per_frame(internalFormat, internalChannels);
}
#else

if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to retrieve initial device parameters.", MA_FORMAT_NOT_SUPPORTED);
}

internalFormat = ma_format_from_swpar__audio4(&fdPar);
internalChannels = (deviceType == ma_device_type_capture) ? fdPar.rchan : fdPar.pchan;
internalSampleRate = fdPar.rate;

if (internalFormat == ma_format_unknown) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by miniaudio. The device is unusable.", MA_FORMAT_NOT_SUPPORTED);
}


{
ma_uint32 internalPeriodSizeInBytes;

internalPeriodSizeInFrames = pConfig->periodSizeInFrames;
if (internalPeriodSizeInFrames == 0) {
internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, internalSampleRate);
}


internalPeriodSizeInBytes = internalPeriodSizeInFrames * ma_get_bytes_per_frame(internalFormat, internalChannels);
if (internalPeriodSizeInBytes < 16) {
internalPeriodSizeInBytes = 16;
}

fdPar.nblks = pConfig->periods;
fdPar.round = internalPeriodSizeInBytes;

if (ioctl(fd, AUDIO_SETPAR, &fdPar) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to set device parameters.", MA_FORMAT_NOT_SUPPORTED);
}

if (ioctl(fd, AUDIO_GETPAR, &fdPar) < 0) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to retrieve actual device parameters.", MA_FORMAT_NOT_SUPPORTED);
}
}

internalFormat = ma_format_from_swpar__audio4(&fdPar);
internalChannels = (deviceType == ma_device_type_capture) ? fdPar.rchan : fdPar.pchan;
internalSampleRate = fdPar.rate;
internalPeriods = fdPar.nblks;
internalPeriodSizeInFrames = fdPar.round / ma_get_bytes_per_frame(internalFormat, internalChannels);
#endif

if (internalFormat == ma_format_unknown) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] The device's internal device format is not supported by miniaudio. The device is unusable.", MA_FORMAT_NOT_SUPPORTED);
}

if (deviceType == ma_device_type_capture) {
pDevice->audio4.fdCapture = fd;
pDevice->capture.internalFormat = internalFormat;
pDevice->capture.internalChannels = internalChannels;
pDevice->capture.internalSampleRate = internalSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sound4, internalChannels, pDevice->capture.internalChannelMap);
pDevice->capture.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->capture.internalPeriods = internalPeriods;
} else {
pDevice->audio4.fdPlayback = fd;
pDevice->playback.internalFormat = internalFormat;
pDevice->playback.internalChannels = internalChannels;
pDevice->playback.internalSampleRate = internalSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sound4, internalChannels, pDevice->playback.internalChannelMap);
pDevice->playback.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->playback.internalPeriods = internalPeriods;
}

return MA_SUCCESS;
}

static ma_result ma_device_init__audio4(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->audio4);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

pDevice->audio4.fdCapture = -1;
pDevice->audio4.fdPlayback = -1;






#if defined(__NetBSD_Version__) && __NetBSD_Version__ >= 800000000

if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}
#else

#endif

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_fd__audio4(pContext, pConfig, ma_device_type_capture, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_fd__audio4(pContext, pConfig, ma_device_type_playback, pDevice);
if (result != MA_SUCCESS) {
if (pConfig->deviceType == ma_device_type_duplex) {
close(pDevice->audio4.fdCapture);
}
return result;
}
}

return MA_SUCCESS;
}

#if 0
static ma_result ma_device_start__audio4(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (pDevice->audio4.fdCapture == -1) {
return MA_INVALID_ARGS;
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
if (pDevice->audio4.fdPlayback == -1) {
return MA_INVALID_ARGS;
}
}

return MA_SUCCESS;
}
#endif

static ma_result ma_device_stop_fd__audio4(ma_device* pDevice, int fd)
{
if (fd == -1) {
return MA_INVALID_ARGS;
}

#if !defined(MA_AUDIO4_USE_NEW_API)
if (ioctl(fd, AUDIO_FLUSH, 0) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to stop device. AUDIO_FLUSH failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}
#else
if (ioctl(fd, AUDIO_STOP, 0) < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to stop device. AUDIO_STOP failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}
#endif

return MA_SUCCESS;
}

static ma_result ma_device_stop__audio4(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_result result;

result = ma_device_stop_fd__audio4(pDevice, pDevice->audio4.fdCapture);
if (result != MA_SUCCESS) {
return result;
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_result result;


#if !defined(MA_AUDIO4_USE_NEW_API)
ioctl(pDevice->audio4.fdPlayback, AUDIO_DRAIN, 0);
#endif


result = ma_device_stop_fd__audio4(pDevice, pDevice->audio4.fdPlayback);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_write__audio4(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
int result;

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

result = write(pDevice->audio4.fdPlayback, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
if (result < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to write data to the device.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
}

if (pFramesWritten != NULL) {
*pFramesWritten = (ma_uint32)result / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
}

return MA_SUCCESS;
}

static ma_result ma_device_read__audio4(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
int result;

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

result = read(pDevice->audio4.fdCapture, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
if (result < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[audio4] Failed to read data from the device.", MA_FAILED_TO_READ_DATA_FROM_DEVICE);
}

if (pFramesRead != NULL) {
*pFramesRead = (ma_uint32)result / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
}

return MA_SUCCESS;
}

static ma_result ma_device_main_loop__audio4(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;



while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__audio4(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__audio4(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__audio4(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{

ma_uint8 intermediaryBuffer[8192];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__audio4(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}



ma_device_stop__audio4(pDevice);

return result;
}

static ma_result ma_context_uninit__audio4(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_audio4);

(void)pContext;
return MA_SUCCESS;
}

static ma_result ma_context_init__audio4(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

(void)pConfig;

pContext->onUninit = ma_context_uninit__audio4;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__audio4;
pContext->onEnumDevices = ma_context_enumerate_devices__audio4;
pContext->onGetDeviceInfo = ma_context_get_device_info__audio4;
pContext->onDeviceInit = ma_device_init__audio4;
pContext->onDeviceUninit = ma_device_uninit__audio4;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__audio4;

return MA_SUCCESS;
}
#endif 







#if defined(MA_HAS_OSS)
#include <sys/ioctl.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/soundcard.h>

#if !defined(SNDCTL_DSP_HALT)
#define SNDCTL_DSP_HALT SNDCTL_DSP_RESET
#endif

static int ma_open_temp_device__oss()
{

int fd = open("/dev/mixer", O_RDONLY, 0);
if (fd >= 0) {
return fd;
}

return -1;
}

static ma_result ma_context_open_device__oss(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, int* pfd)
{
const char* deviceName;
int flags;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pfd != NULL);
(void)pContext;

*pfd = -1;


if (deviceType == ma_device_type_duplex) {
return MA_INVALID_ARGS;
}

deviceName = "/dev/dsp";
if (pDeviceID != NULL) {
deviceName = pDeviceID->oss;
}

flags = (deviceType == ma_device_type_playback) ? O_WRONLY : O_RDONLY;
if (shareMode == ma_share_mode_exclusive) {
flags |= O_EXCL;
}

*pfd = open(deviceName, flags, 0);
if (*pfd == -1) {
return MA_FAILED_TO_OPEN_BACKEND_DEVICE;
}

return MA_SUCCESS;
}

static ma_bool32 ma_context_is_device_id_equal__oss(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->oss, pID1->oss) == 0;
}

static ma_result ma_context_enumerate_devices__oss(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
int fd;
oss_sysinfo si;
int result;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);

fd = ma_open_temp_device__oss();
if (fd == -1) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open a temporary device for retrieving system information used for device enumeration.", MA_NO_BACKEND);
}

result = ioctl(fd, SNDCTL_SYSINFO, &si);
if (result != -1) {
int iAudioDevice;
for (iAudioDevice = 0; iAudioDevice < si.numaudios; ++iAudioDevice) {
oss_audioinfo ai;
ai.dev = iAudioDevice;
result = ioctl(fd, SNDCTL_AUDIOINFO, &ai);
if (result != -1) {
if (ai.devnode[0] != '\0') { 
ma_device_info deviceInfo;
ma_bool32 isTerminating = MA_FALSE;

MA_ZERO_OBJECT(&deviceInfo);


ma_strncpy_s(deviceInfo.id.oss, sizeof(deviceInfo.id.oss), ai.devnode, (size_t)-1);






if (ai.handle[0] != '\0') {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), ai.handle, (size_t)-1);
} else {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), ai.name, (size_t)-1);
}


if (!isTerminating && (ai.caps & PCM_CAP_OUTPUT) != 0) {
isTerminating = !callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}
if (!isTerminating && (ai.caps & PCM_CAP_INPUT) != 0) {
isTerminating = !callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}

if (isTerminating) {
break;
}
}
}
}
} else {
close(fd);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve system information for device enumeration.", MA_NO_BACKEND);
}

close(fd);
return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__oss(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_bool32 foundDevice;
int fdTemp;
oss_sysinfo si;
int result;

MA_ASSERT(pContext != NULL);
(void)shareMode;


if (pDeviceID == NULL) {
if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}

return MA_SUCCESS;
}



foundDevice = MA_FALSE;

fdTemp = ma_open_temp_device__oss();
if (fdTemp == -1) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open a temporary device for retrieving system information used for device enumeration.", MA_NO_BACKEND);
}

result = ioctl(fdTemp, SNDCTL_SYSINFO, &si);
if (result != -1) {
int iAudioDevice;
for (iAudioDevice = 0; iAudioDevice < si.numaudios; ++iAudioDevice) {
oss_audioinfo ai;
ai.dev = iAudioDevice;
result = ioctl(fdTemp, SNDCTL_AUDIOINFO, &ai);
if (result != -1) {
if (ma_strcmp(ai.devnode, pDeviceID->oss) == 0) {

if ((deviceType == ma_device_type_playback && ((ai.caps & PCM_CAP_OUTPUT) != 0)) ||
(deviceType == ma_device_type_capture && ((ai.caps & PCM_CAP_INPUT) != 0))) {
unsigned int formatMask;


ma_strncpy_s(pDeviceInfo->id.oss, sizeof(pDeviceInfo->id.oss), ai.devnode, (size_t)-1);






if (ai.handle[0] != '\0') {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), ai.handle, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), ai.name, (size_t)-1);
}

pDeviceInfo->minChannels = ai.min_channels;
pDeviceInfo->maxChannels = ai.max_channels;
pDeviceInfo->minSampleRate = ai.min_rate;
pDeviceInfo->maxSampleRate = ai.max_rate;
pDeviceInfo->formatCount = 0;

if (deviceType == ma_device_type_playback) {
formatMask = ai.oformats;
} else {
formatMask = ai.iformats;
}

if ((formatMask & AFMT_U8) != 0) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_u8;
}
if (((formatMask & AFMT_S16_LE) != 0 && ma_is_little_endian()) || (AFMT_S16_BE && ma_is_big_endian())) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_s16;
}
if (((formatMask & AFMT_S32_LE) != 0 && ma_is_little_endian()) || (AFMT_S32_BE && ma_is_big_endian())) {
pDeviceInfo->formats[pDeviceInfo->formatCount++] = ma_format_s32;
}

foundDevice = MA_TRUE;
break;
}
}
}
}
} else {
close(fdTemp);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve system information for device enumeration.", MA_NO_BACKEND);
}


close(fdTemp);

if (!foundDevice) {
return MA_NO_DEVICE;
}

return MA_SUCCESS;
}

static void ma_device_uninit__oss(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
close(pDevice->oss.fdCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
close(pDevice->oss.fdPlayback);
}
}

static int ma_format_to_oss(ma_format format)
{
int ossFormat = AFMT_U8;
switch (format) {
case ma_format_s16: ossFormat = (ma_is_little_endian()) ? AFMT_S16_LE : AFMT_S16_BE; break;
case ma_format_s24: ossFormat = (ma_is_little_endian()) ? AFMT_S32_LE : AFMT_S32_BE; break;
case ma_format_s32: ossFormat = (ma_is_little_endian()) ? AFMT_S32_LE : AFMT_S32_BE; break;
case ma_format_f32: ossFormat = (ma_is_little_endian()) ? AFMT_S16_LE : AFMT_S16_BE; break;
case ma_format_u8:
default: ossFormat = AFMT_U8; break;
}

return ossFormat;
}

static ma_format ma_format_from_oss(int ossFormat)
{
if (ossFormat == AFMT_U8) {
return ma_format_u8;
} else {
if (ma_is_little_endian()) {
switch (ossFormat) {
case AFMT_S16_LE: return ma_format_s16;
case AFMT_S32_LE: return ma_format_s32;
default: return ma_format_unknown;
}
} else {
switch (ossFormat) {
case AFMT_S16_BE: return ma_format_s16;
case AFMT_S32_BE: return ma_format_s32;
default: return ma_format_unknown;
}
}
}

return ma_format_unknown;
}

static ma_result ma_device_init_fd__oss(ma_context* pContext, const ma_device_config* pConfig, ma_device_type deviceType, ma_device* pDevice)
{
ma_result result;
int ossResult;
int fd;
const ma_device_id* pDeviceID = NULL;
ma_share_mode shareMode;
int ossFormat;
int ossChannels;
int ossSampleRate;
int ossFragment;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(deviceType != ma_device_type_duplex);
MA_ASSERT(pDevice != NULL);

(void)pContext;

if (deviceType == ma_device_type_capture) {
pDeviceID = pConfig->capture.pDeviceID;
shareMode = pConfig->capture.shareMode;
ossFormat = ma_format_to_oss(pConfig->capture.format);
ossChannels = (int)pConfig->capture.channels;
ossSampleRate = (int)pConfig->sampleRate;
} else {
pDeviceID = pConfig->playback.pDeviceID;
shareMode = pConfig->playback.shareMode;
ossFormat = ma_format_to_oss(pConfig->playback.format);
ossChannels = (int)pConfig->playback.channels;
ossSampleRate = (int)pConfig->sampleRate;
}

result = ma_context_open_device__oss(pContext, deviceType, pDeviceID, shareMode, &fd);
if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}









ossResult = ioctl(fd, SNDCTL_DSP_SETFMT, &ossFormat);
if (ossResult == -1) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to set format.", MA_FORMAT_NOT_SUPPORTED);
}


ossResult = ioctl(fd, SNDCTL_DSP_CHANNELS, &ossChannels);
if (ossResult == -1) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to set channel count.", MA_FORMAT_NOT_SUPPORTED);
}


ossResult = ioctl(fd, SNDCTL_DSP_SPEED, &ossSampleRate);
if (ossResult == -1) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to set sample rate.", MA_FORMAT_NOT_SUPPORTED);
}










{
ma_uint32 periodSizeInFrames;
ma_uint32 periodSizeInBytes;
ma_uint32 ossFragmentSizePower;

periodSizeInFrames = pConfig->periodSizeInFrames;
if (periodSizeInFrames == 0) {
periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, (ma_uint32)ossSampleRate);
}

periodSizeInBytes = ma_round_to_power_of_2(periodSizeInFrames * ma_get_bytes_per_frame(ma_format_from_oss(ossFormat), ossChannels));
if (periodSizeInBytes < 16) {
periodSizeInBytes = 16;
}

ossFragmentSizePower = 4;
periodSizeInBytes >>= 4;
while (periodSizeInBytes >>= 1) {
ossFragmentSizePower += 1;
}

ossFragment = (int)((pConfig->periods << 16) | ossFragmentSizePower);
ossResult = ioctl(fd, SNDCTL_DSP_SETFRAGMENT, &ossFragment);
if (ossResult == -1) {
close(fd);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to set fragment size and period count.", MA_FORMAT_NOT_SUPPORTED);
}
}


if (deviceType == ma_device_type_capture) {
pDevice->oss.fdCapture = fd;
pDevice->capture.internalFormat = ma_format_from_oss(ossFormat);
pDevice->capture.internalChannels = ossChannels;
pDevice->capture.internalSampleRate = ossSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sound4, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
pDevice->capture.internalPeriods = (ma_uint32)(ossFragment >> 16);
pDevice->capture.internalPeriodSizeInFrames = (ma_uint32)(1 << (ossFragment & 0xFFFF)) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);

if (pDevice->capture.internalFormat == ma_format_unknown) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] The device's internal format is not supported by miniaudio.", MA_FORMAT_NOT_SUPPORTED);
}
} else {
pDevice->oss.fdPlayback = fd;
pDevice->playback.internalFormat = ma_format_from_oss(ossFormat);
pDevice->playback.internalChannels = ossChannels;
pDevice->playback.internalSampleRate = ossSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_sound4, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
pDevice->playback.internalPeriods = (ma_uint32)(ossFragment >> 16);
pDevice->playback.internalPeriodSizeInFrames = (ma_uint32)(1 << (ossFragment & 0xFFFF)) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);

if (pDevice->playback.internalFormat == ma_format_unknown) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] The device's internal format is not supported by miniaudio.", MA_FORMAT_NOT_SUPPORTED);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_init__oss(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDevice != NULL);

MA_ZERO_OBJECT(&pDevice->oss);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_fd__oss(pContext, pConfig, ma_device_type_capture, pDevice);
if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_result result = ma_device_init_fd__oss(pContext, pConfig, ma_device_type_playback, pDevice);
if (result != MA_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open device.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__oss(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);














if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
int result = ioctl(pDevice->oss.fdCapture, SNDCTL_DSP_HALT, 0);
if (result == -1) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to stop device. SNDCTL_DSP_HALT failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
int result = ioctl(pDevice->oss.fdPlayback, SNDCTL_DSP_HALT, 0);
if (result == -1) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to stop device. SNDCTL_DSP_HALT failed.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_write__oss(ma_device* pDevice, const void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesWritten)
{
int resultOSS;

if (pFramesWritten != NULL) {
*pFramesWritten = 0;
}

resultOSS = write(pDevice->oss.fdPlayback, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
if (resultOSS < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to send data from the client to the device.", MA_FAILED_TO_SEND_DATA_TO_DEVICE);
}

if (pFramesWritten != NULL) {
*pFramesWritten = (ma_uint32)resultOSS / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
}

return MA_SUCCESS;
}

static ma_result ma_device_read__oss(ma_device* pDevice, void* pPCMFrames, ma_uint32 frameCount, ma_uint32* pFramesRead)
{
int resultOSS;

if (pFramesRead != NULL) {
*pFramesRead = 0;
}

resultOSS = read(pDevice->oss.fdCapture, pPCMFrames, frameCount * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));
if (resultOSS < 0) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OSS] Failed to read data from the device to be sent to the client.", MA_FAILED_TO_READ_DATA_FROM_DEVICE);
}

if (pFramesRead != NULL) {
*pFramesRead = (ma_uint32)resultOSS / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
}

return MA_SUCCESS;
}

static ma_result ma_device_main_loop__oss(ma_device* pDevice)
{
ma_result result = MA_SUCCESS;
ma_bool32 exitLoop = MA_FALSE;



while (ma_device__get_state(pDevice) == MA_STATE_STARTED && !exitLoop) {
switch (pDevice->type)
{
case ma_device_type_duplex:
{

ma_uint32 totalCapturedDeviceFramesProcessed = 0;
ma_uint32 capturedDevicePeriodSizeInFrames = ma_min(pDevice->capture.internalPeriodSizeInFrames, pDevice->playback.internalPeriodSizeInFrames);

while (totalCapturedDeviceFramesProcessed < capturedDevicePeriodSizeInFrames) {
ma_uint8 capturedDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackDeviceData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedDeviceDataCapInFrames = sizeof(capturedDeviceData) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 playbackDeviceDataCapInFrames = sizeof(playbackDeviceData) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 capturedDeviceFramesRemaining;
ma_uint32 capturedDeviceFramesProcessed;
ma_uint32 capturedDeviceFramesToProcess;
ma_uint32 capturedDeviceFramesToTryProcessing = capturedDevicePeriodSizeInFrames - totalCapturedDeviceFramesProcessed;
if (capturedDeviceFramesToTryProcessing > capturedDeviceDataCapInFrames) {
capturedDeviceFramesToTryProcessing = capturedDeviceDataCapInFrames;
}

result = ma_device_read__oss(pDevice, capturedDeviceData, capturedDeviceFramesToTryProcessing, &capturedDeviceFramesToProcess);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedDeviceFramesRemaining = capturedDeviceFramesToProcess;
capturedDeviceFramesProcessed = 0;

for (;;) {
ma_uint8 capturedClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint8 playbackClientData[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 capturedClientDataCapInFrames = sizeof(capturedClientData) / ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels);
ma_uint32 playbackClientDataCapInFrames = sizeof(playbackClientData) / ma_get_bytes_per_frame(pDevice->playback.format, pDevice->playback.channels);
ma_uint64 capturedClientFramesToProcessThisIteration = ma_min(capturedClientDataCapInFrames, playbackClientDataCapInFrames);
ma_uint64 capturedDeviceFramesToProcessThisIteration = capturedDeviceFramesRemaining;
ma_uint8* pRunningCapturedDeviceFrames = ma_offset_ptr(capturedDeviceData, capturedDeviceFramesProcessed * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels));


result = ma_data_converter_process_pcm_frames(&pDevice->capture.converter, pRunningCapturedDeviceFrames, &capturedDeviceFramesToProcessThisIteration, capturedClientData, &capturedClientFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
break;
}





if (capturedClientFramesToProcessThisIteration == 0) {
break;
}

ma_device__on_data(pDevice, playbackClientData, capturedClientData, (ma_uint32)capturedClientFramesToProcessThisIteration); 

capturedDeviceFramesProcessed += (ma_uint32)capturedDeviceFramesToProcessThisIteration; 
capturedDeviceFramesRemaining -= (ma_uint32)capturedDeviceFramesToProcessThisIteration; 


for (;;) {
ma_uint64 convertedClientFrameCount = capturedClientFramesToProcessThisIteration;
ma_uint64 convertedDeviceFrameCount = playbackDeviceDataCapInFrames;
result = ma_data_converter_process_pcm_frames(&pDevice->playback.converter, playbackClientData, &convertedClientFrameCount, playbackDeviceData, &convertedDeviceFrameCount);
if (result != MA_SUCCESS) {
break;
}

result = ma_device_write__oss(pDevice, playbackDeviceData, (ma_uint32)convertedDeviceFrameCount, NULL); 
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

capturedClientFramesToProcessThisIteration -= (ma_uint32)convertedClientFrameCount; 
if (capturedClientFramesToProcessThisIteration == 0) {
break;
}
}


if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}
}

totalCapturedDeviceFramesProcessed += capturedDeviceFramesProcessed;
}
} break;

case ma_device_type_capture:
{

ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->capture.internalPeriodSizeInFrames;
ma_uint32 framesReadThisPeriod = 0;
while (framesReadThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesReadThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToReadThisIteration = framesRemainingInPeriod;
if (framesToReadThisIteration > intermediaryBufferSizeInFrames) {
framesToReadThisIteration = intermediaryBufferSizeInFrames;
}

result = ma_device_read__oss(pDevice, intermediaryBuffer, framesToReadThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

ma_device__send_frames_to_client(pDevice, framesProcessed, intermediaryBuffer);

framesReadThisPeriod += framesProcessed;
}
} break;

case ma_device_type_playback:
{

ma_uint8 intermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
ma_uint32 intermediaryBufferSizeInFrames = sizeof(intermediaryBuffer) / ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
ma_uint32 periodSizeInFrames = pDevice->playback.internalPeriodSizeInFrames;
ma_uint32 framesWrittenThisPeriod = 0;
while (framesWrittenThisPeriod < periodSizeInFrames) {
ma_uint32 framesRemainingInPeriod = periodSizeInFrames - framesWrittenThisPeriod;
ma_uint32 framesProcessed;
ma_uint32 framesToWriteThisIteration = framesRemainingInPeriod;
if (framesToWriteThisIteration > intermediaryBufferSizeInFrames) {
framesToWriteThisIteration = intermediaryBufferSizeInFrames;
}

ma_device__read_frames_from_client(pDevice, framesToWriteThisIteration, intermediaryBuffer);

result = ma_device_write__oss(pDevice, intermediaryBuffer, framesToWriteThisIteration, &framesProcessed);
if (result != MA_SUCCESS) {
exitLoop = MA_TRUE;
break;
}

framesWrittenThisPeriod += framesProcessed;
}
} break;


case ma_device_type_loopback:
default: break;
}
}



ma_device_stop__oss(pDevice);

return result;
}

static ma_result ma_context_uninit__oss(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_oss);

(void)pContext;
return MA_SUCCESS;
}

static ma_result ma_context_init__oss(const ma_context_config* pConfig, ma_context* pContext)
{
int fd;
int ossVersion;
int result;

MA_ASSERT(pContext != NULL);

(void)pConfig;


fd = ma_open_temp_device__oss();
if (fd == -1) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to open temporary device for retrieving system properties.", MA_NO_BACKEND); 
}


ossVersion = 0;
result = ioctl(fd, OSS_GETVERSION, &ossVersion);
if (result == -1) {
close(fd);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "[OSS] Failed to retrieve OSS version.", MA_NO_BACKEND);
}

pContext->oss.versionMajor = ((ossVersion & 0xFF0000) >> 16);
pContext->oss.versionMinor = ((ossVersion & 0x00FF00) >> 8);

pContext->onUninit = ma_context_uninit__oss;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__oss;
pContext->onEnumDevices = ma_context_enumerate_devices__oss;
pContext->onGetDeviceInfo = ma_context_get_device_info__oss;
pContext->onDeviceInit = ma_device_init__oss;
pContext->onDeviceUninit = ma_device_uninit__oss;
pContext->onDeviceStart = NULL; 
pContext->onDeviceStop = NULL; 
pContext->onDeviceMainLoop = ma_device_main_loop__oss;

close(fd);
return MA_SUCCESS;
}
#endif 







#if defined(MA_HAS_AAUDIO)


#define MA_AAUDIO_UNSPECIFIED 0

typedef int32_t ma_aaudio_result_t;
typedef int32_t ma_aaudio_direction_t;
typedef int32_t ma_aaudio_sharing_mode_t;
typedef int32_t ma_aaudio_format_t;
typedef int32_t ma_aaudio_stream_state_t;
typedef int32_t ma_aaudio_performance_mode_t;
typedef int32_t ma_aaudio_data_callback_result_t;


#define MA_AAUDIO_OK 0


#define MA_AAUDIO_DIRECTION_OUTPUT 0
#define MA_AAUDIO_DIRECTION_INPUT 1


#define MA_AAUDIO_SHARING_MODE_EXCLUSIVE 0
#define MA_AAUDIO_SHARING_MODE_SHARED 1


#define MA_AAUDIO_FORMAT_PCM_I16 1
#define MA_AAUDIO_FORMAT_PCM_FLOAT 2


#define MA_AAUDIO_STREAM_STATE_UNINITIALIZED 0
#define MA_AAUDIO_STREAM_STATE_UNKNOWN 1
#define MA_AAUDIO_STREAM_STATE_OPEN 2
#define MA_AAUDIO_STREAM_STATE_STARTING 3
#define MA_AAUDIO_STREAM_STATE_STARTED 4
#define MA_AAUDIO_STREAM_STATE_PAUSING 5
#define MA_AAUDIO_STREAM_STATE_PAUSED 6
#define MA_AAUDIO_STREAM_STATE_FLUSHING 7
#define MA_AAUDIO_STREAM_STATE_FLUSHED 8
#define MA_AAUDIO_STREAM_STATE_STOPPING 9
#define MA_AAUDIO_STREAM_STATE_STOPPED 10
#define MA_AAUDIO_STREAM_STATE_CLOSING 11
#define MA_AAUDIO_STREAM_STATE_CLOSED 12
#define MA_AAUDIO_STREAM_STATE_DISCONNECTED 13


#define MA_AAUDIO_PERFORMANCE_MODE_NONE 10
#define MA_AAUDIO_PERFORMANCE_MODE_POWER_SAVING 11
#define MA_AAUDIO_PERFORMANCE_MODE_LOW_LATENCY 12


#define MA_AAUDIO_CALLBACK_RESULT_CONTINUE 0
#define MA_AAUDIO_CALLBACK_RESULT_STOP 1


typedef struct ma_AAudioStreamBuilder_t* ma_AAudioStreamBuilder;
typedef struct ma_AAudioStream_t* ma_AAudioStream;

typedef ma_aaudio_data_callback_result_t (* ma_AAudioStream_dataCallback) (ma_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t numFrames);
typedef void (* ma_AAudioStream_errorCallback)(ma_AAudioStream *pStream, void *pUserData, ma_aaudio_result_t error);

typedef ma_aaudio_result_t (* MA_PFN_AAudio_createStreamBuilder) (ma_AAudioStreamBuilder** ppBuilder);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStreamBuilder_delete) (ma_AAudioStreamBuilder* pBuilder);
typedef void (* MA_PFN_AAudioStreamBuilder_setDeviceId) (ma_AAudioStreamBuilder* pBuilder, int32_t deviceId);
typedef void (* MA_PFN_AAudioStreamBuilder_setDirection) (ma_AAudioStreamBuilder* pBuilder, ma_aaudio_direction_t direction);
typedef void (* MA_PFN_AAudioStreamBuilder_setSharingMode) (ma_AAudioStreamBuilder* pBuilder, ma_aaudio_sharing_mode_t sharingMode);
typedef void (* MA_PFN_AAudioStreamBuilder_setFormat) (ma_AAudioStreamBuilder* pBuilder, ma_aaudio_format_t format);
typedef void (* MA_PFN_AAudioStreamBuilder_setChannelCount) (ma_AAudioStreamBuilder* pBuilder, int32_t channelCount);
typedef void (* MA_PFN_AAudioStreamBuilder_setSampleRate) (ma_AAudioStreamBuilder* pBuilder, int32_t sampleRate);
typedef void (* MA_PFN_AAudioStreamBuilder_setBufferCapacityInFrames)(ma_AAudioStreamBuilder* pBuilder, int32_t numFrames);
typedef void (* MA_PFN_AAudioStreamBuilder_setFramesPerDataCallback) (ma_AAudioStreamBuilder* pBuilder, int32_t numFrames);
typedef void (* MA_PFN_AAudioStreamBuilder_setDataCallback) (ma_AAudioStreamBuilder* pBuilder, ma_AAudioStream_dataCallback callback, void* pUserData);
typedef void (* MA_PFN_AAudioStreamBuilder_setErrorCallback) (ma_AAudioStreamBuilder* pBuilder, ma_AAudioStream_errorCallback callback, void* pUserData);
typedef void (* MA_PFN_AAudioStreamBuilder_setPerformanceMode) (ma_AAudioStreamBuilder* pBuilder, ma_aaudio_performance_mode_t mode);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStreamBuilder_openStream) (ma_AAudioStreamBuilder* pBuilder, ma_AAudioStream** ppStream);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStream_close) (ma_AAudioStream* pStream);
typedef ma_aaudio_stream_state_t (* MA_PFN_AAudioStream_getState) (ma_AAudioStream* pStream);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStream_waitForStateChange) (ma_AAudioStream* pStream, ma_aaudio_stream_state_t inputState, ma_aaudio_stream_state_t* pNextState, int64_t timeoutInNanoseconds);
typedef ma_aaudio_format_t (* MA_PFN_AAudioStream_getFormat) (ma_AAudioStream* pStream);
typedef int32_t (* MA_PFN_AAudioStream_getChannelCount) (ma_AAudioStream* pStream);
typedef int32_t (* MA_PFN_AAudioStream_getSampleRate) (ma_AAudioStream* pStream);
typedef int32_t (* MA_PFN_AAudioStream_getBufferCapacityInFrames) (ma_AAudioStream* pStream);
typedef int32_t (* MA_PFN_AAudioStream_getFramesPerDataCallback) (ma_AAudioStream* pStream);
typedef int32_t (* MA_PFN_AAudioStream_getFramesPerBurst) (ma_AAudioStream* pStream);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStream_requestStart) (ma_AAudioStream* pStream);
typedef ma_aaudio_result_t (* MA_PFN_AAudioStream_requestStop) (ma_AAudioStream* pStream);

static ma_result ma_result_from_aaudio(ma_aaudio_result_t resultAA)
{
switch (resultAA)
{
case MA_AAUDIO_OK: return MA_SUCCESS;
default: break;
}

return MA_ERROR;
}

static void ma_stream_error_callback__aaudio(ma_AAudioStream* pStream, void* pUserData, ma_aaudio_result_t error)
{
ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

(void)error;

#if defined(MA_DEBUG_OUTPUT)
printf("[AAudio] ERROR CALLBACK: error=%d, AAudioStream_getState()=%d\n", error, ((MA_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream));
#endif





if (((MA_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream) == MA_AAUDIO_STREAM_STATE_DISCONNECTED) {
#if defined(MA_DEBUG_OUTPUT)
printf("[AAudio] Device Disconnected.\n");
#endif
}
}

static ma_aaudio_data_callback_result_t ma_stream_data_callback_capture__aaudio(ma_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t frameCount)
{
ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, frameCount, pAudioData, &pDevice->aaudio.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, frameCount, pAudioData); 
}

(void)pStream;
return MA_AAUDIO_CALLBACK_RESULT_CONTINUE;
}

static ma_aaudio_data_callback_result_t ma_stream_data_callback_playback__aaudio(ma_AAudioStream* pStream, void* pUserData, void* pAudioData, int32_t frameCount)
{
ma_device* pDevice = (ma_device*)pUserData;
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, frameCount, pAudioData, &pDevice->aaudio.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, frameCount, pAudioData); 
}

(void)pStream;
return MA_AAUDIO_CALLBACK_RESULT_CONTINUE;
}

static ma_result ma_open_stream__aaudio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, const ma_device_config* pConfig, const ma_device* pDevice, ma_AAudioStream** ppStream)
{
ma_AAudioStreamBuilder* pBuilder;
ma_aaudio_result_t resultAA;

MA_ASSERT(deviceType != ma_device_type_duplex); 

*ppStream = NULL;

resultAA = ((MA_PFN_AAudio_createStreamBuilder)pContext->aaudio.AAudio_createStreamBuilder)(&pBuilder);
if (resultAA != MA_AAUDIO_OK) {
return ma_result_from_aaudio(resultAA);
}

if (pDeviceID != NULL) {
((MA_PFN_AAudioStreamBuilder_setDeviceId)pContext->aaudio.AAudioStreamBuilder_setDeviceId)(pBuilder, pDeviceID->aaudio);
}

((MA_PFN_AAudioStreamBuilder_setDirection)pContext->aaudio.AAudioStreamBuilder_setDirection)(pBuilder, (deviceType == ma_device_type_playback) ? MA_AAUDIO_DIRECTION_OUTPUT : MA_AAUDIO_DIRECTION_INPUT);
((MA_PFN_AAudioStreamBuilder_setSharingMode)pContext->aaudio.AAudioStreamBuilder_setSharingMode)(pBuilder, (shareMode == ma_share_mode_shared) ? MA_AAUDIO_SHARING_MODE_SHARED : MA_AAUDIO_SHARING_MODE_EXCLUSIVE);

if (pConfig != NULL) {
ma_uint32 bufferCapacityInFrames;

if (pDevice == NULL || !pDevice->usingDefaultSampleRate) {
((MA_PFN_AAudioStreamBuilder_setSampleRate)pContext->aaudio.AAudioStreamBuilder_setSampleRate)(pBuilder, pConfig->sampleRate);
}

if (deviceType == ma_device_type_capture) {
if (pDevice == NULL || !pDevice->capture.usingDefaultChannels) {
((MA_PFN_AAudioStreamBuilder_setChannelCount)pContext->aaudio.AAudioStreamBuilder_setChannelCount)(pBuilder, pConfig->capture.channels);
}
if (pDevice == NULL || !pDevice->capture.usingDefaultFormat) {
((MA_PFN_AAudioStreamBuilder_setFormat)pContext->aaudio.AAudioStreamBuilder_setFormat)(pBuilder, (pConfig->capture.format == ma_format_s16) ? MA_AAUDIO_FORMAT_PCM_I16 : MA_AAUDIO_FORMAT_PCM_FLOAT);
}
} else {
if (pDevice == NULL || !pDevice->playback.usingDefaultChannels) {
((MA_PFN_AAudioStreamBuilder_setChannelCount)pContext->aaudio.AAudioStreamBuilder_setChannelCount)(pBuilder, pConfig->playback.channels);
}
if (pDevice == NULL || !pDevice->playback.usingDefaultFormat) {
((MA_PFN_AAudioStreamBuilder_setFormat)pContext->aaudio.AAudioStreamBuilder_setFormat)(pBuilder, (pConfig->playback.format == ma_format_s16) ? MA_AAUDIO_FORMAT_PCM_I16 : MA_AAUDIO_FORMAT_PCM_FLOAT);
}
}

bufferCapacityInFrames = pConfig->periodSizeInFrames * pConfig->periods;
if (bufferCapacityInFrames == 0) {
bufferCapacityInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, pConfig->sampleRate) * pConfig->periods;
}

((MA_PFN_AAudioStreamBuilder_setBufferCapacityInFrames)pContext->aaudio.AAudioStreamBuilder_setBufferCapacityInFrames)(pBuilder, bufferCapacityInFrames);
((MA_PFN_AAudioStreamBuilder_setFramesPerDataCallback)pContext->aaudio.AAudioStreamBuilder_setFramesPerDataCallback)(pBuilder, bufferCapacityInFrames / pConfig->periods);

if (deviceType == ma_device_type_capture) {
((MA_PFN_AAudioStreamBuilder_setDataCallback)pContext->aaudio.AAudioStreamBuilder_setDataCallback)(pBuilder, ma_stream_data_callback_capture__aaudio, (void*)pDevice);
} else {
((MA_PFN_AAudioStreamBuilder_setDataCallback)pContext->aaudio.AAudioStreamBuilder_setDataCallback)(pBuilder, ma_stream_data_callback_playback__aaudio, (void*)pDevice);
}


((MA_PFN_AAudioStreamBuilder_setPerformanceMode)pContext->aaudio.AAudioStreamBuilder_setPerformanceMode)(pBuilder, (pConfig->performanceProfile == ma_performance_profile_low_latency) ? MA_AAUDIO_PERFORMANCE_MODE_LOW_LATENCY : MA_AAUDIO_PERFORMANCE_MODE_NONE);
}

((MA_PFN_AAudioStreamBuilder_setErrorCallback)pContext->aaudio.AAudioStreamBuilder_setErrorCallback)(pBuilder, ma_stream_error_callback__aaudio, (void*)pDevice);

resultAA = ((MA_PFN_AAudioStreamBuilder_openStream)pContext->aaudio.AAudioStreamBuilder_openStream)(pBuilder, ppStream);
if (resultAA != MA_AAUDIO_OK) {
*ppStream = NULL;
((MA_PFN_AAudioStreamBuilder_delete)pContext->aaudio.AAudioStreamBuilder_delete)(pBuilder);
return ma_result_from_aaudio(resultAA);
}

((MA_PFN_AAudioStreamBuilder_delete)pContext->aaudio.AAudioStreamBuilder_delete)(pBuilder);
return MA_SUCCESS;
}

static ma_result ma_close_stream__aaudio(ma_context* pContext, ma_AAudioStream* pStream)
{
return ma_result_from_aaudio(((MA_PFN_AAudioStream_close)pContext->aaudio.AAudioStream_close)(pStream));
}

static ma_bool32 ma_has_default_device__aaudio(ma_context* pContext, ma_device_type deviceType)
{

ma_AAudioStream* pStream;
ma_result result = ma_open_stream__aaudio(pContext, deviceType, NULL, ma_share_mode_shared, NULL, NULL, &pStream);
if (result != MA_SUCCESS) {
return MA_FALSE;
}

ma_close_stream__aaudio(pContext, pStream);
return MA_TRUE;
}

static ma_result ma_wait_for_simple_state_transition__aaudio(ma_context* pContext, ma_AAudioStream* pStream, ma_aaudio_stream_state_t oldState, ma_aaudio_stream_state_t newState)
{
ma_aaudio_stream_state_t actualNewState;
ma_aaudio_result_t resultAA = ((MA_PFN_AAudioStream_waitForStateChange)pContext->aaudio.AAudioStream_waitForStateChange)(pStream, oldState, &actualNewState, 5000000000); 
if (resultAA != MA_AAUDIO_OK) {
return ma_result_from_aaudio(resultAA);
}

if (newState != actualNewState) {
return MA_ERROR; 
}

return MA_SUCCESS;
}


static ma_bool32 ma_context_is_device_id_equal__aaudio(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return pID0->aaudio == pID1->aaudio;
}

static ma_result ma_context_enumerate_devices__aaudio(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult = MA_TRUE;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);




if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.aaudio = MA_AAUDIO_UNSPECIFIED;
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);

if (ma_has_default_device__aaudio(pContext, ma_device_type_playback)) {
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}
}


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.aaudio = MA_AAUDIO_UNSPECIFIED;
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);

if (ma_has_default_device__aaudio(pContext, ma_device_type_capture)) {
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__aaudio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_AAudioStream* pStream;
ma_result result;

MA_ASSERT(pContext != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}


if (pDeviceID != NULL) {
pDeviceInfo->id.aaudio = pDeviceID->aaudio;
} else {
pDeviceInfo->id.aaudio = MA_AAUDIO_UNSPECIFIED;
}


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}



result = ma_open_stream__aaudio(pContext, deviceType, pDeviceID, shareMode, NULL, NULL, &pStream);
if (result != MA_SUCCESS) {
return result;
}

pDeviceInfo->minChannels = ((MA_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)(pStream);
pDeviceInfo->maxChannels = pDeviceInfo->minChannels;
pDeviceInfo->minSampleRate = ((MA_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)(pStream);
pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;

ma_close_stream__aaudio(pContext, pStream);
pStream = NULL;



pDeviceInfo->formatCount = 2;
pDeviceInfo->formats[0] = ma_format_s16;
pDeviceInfo->formats[1] = ma_format_f32;

return MA_SUCCESS;
}


static void ma_device_uninit__aaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_close_stream__aaudio(pDevice->pContext, (ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
pDevice->aaudio.pStreamCapture = NULL;
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_close_stream__aaudio(pDevice->pContext, (ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
pDevice->aaudio.pStreamPlayback = NULL;
}

if (pDevice->type == ma_device_type_duplex) {
ma_pcm_rb_uninit(&pDevice->aaudio.duplexRB);
}
}

static ma_result ma_device_init__aaudio(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;

MA_ASSERT(pDevice != NULL);

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}


if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
int32_t bufferCapacityInFrames;
int32_t framesPerDataCallback;

result = ma_open_stream__aaudio(pContext, ma_device_type_capture, pConfig->capture.pDeviceID, pConfig->capture.shareMode, pConfig, pDevice, (ma_AAudioStream**)&pDevice->aaudio.pStreamCapture);
if (result != MA_SUCCESS) {
return result; 
}

pDevice->capture.internalFormat = (((MA_PFN_AAudioStream_getFormat)pContext->aaudio.AAudioStream_getFormat)((ma_AAudioStream*)pDevice->aaudio.pStreamCapture) == MA_AAUDIO_FORMAT_PCM_I16) ? ma_format_s16 : ma_format_f32;
pDevice->capture.internalChannels = ((MA_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)((ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
pDevice->capture.internalSampleRate = ((MA_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)((ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
ma_get_standard_channel_map(ma_standard_channel_map_default, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap); 

bufferCapacityInFrames = ((MA_PFN_AAudioStream_getBufferCapacityInFrames)pContext->aaudio.AAudioStream_getBufferCapacityInFrames)((ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
framesPerDataCallback = ((MA_PFN_AAudioStream_getFramesPerDataCallback)pContext->aaudio.AAudioStream_getFramesPerDataCallback)((ma_AAudioStream*)pDevice->aaudio.pStreamCapture);

if (framesPerDataCallback > 0) {
pDevice->capture.internalPeriodSizeInFrames = framesPerDataCallback;
pDevice->capture.internalPeriods = bufferCapacityInFrames / framesPerDataCallback;
} else {
pDevice->capture.internalPeriodSizeInFrames = bufferCapacityInFrames;
pDevice->capture.internalPeriods = 1;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
int32_t bufferCapacityInFrames;
int32_t framesPerDataCallback;

result = ma_open_stream__aaudio(pContext, ma_device_type_playback, pConfig->playback.pDeviceID, pConfig->playback.shareMode, pConfig, pDevice, (ma_AAudioStream**)&pDevice->aaudio.pStreamPlayback);
if (result != MA_SUCCESS) {
return result; 
}

pDevice->playback.internalFormat = (((MA_PFN_AAudioStream_getFormat)pContext->aaudio.AAudioStream_getFormat)((ma_AAudioStream*)pDevice->aaudio.pStreamPlayback) == MA_AAUDIO_FORMAT_PCM_I16) ? ma_format_s16 : ma_format_f32;
pDevice->playback.internalChannels = ((MA_PFN_AAudioStream_getChannelCount)pContext->aaudio.AAudioStream_getChannelCount)((ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
pDevice->playback.internalSampleRate = ((MA_PFN_AAudioStream_getSampleRate)pContext->aaudio.AAudioStream_getSampleRate)((ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
ma_get_standard_channel_map(ma_standard_channel_map_default, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap); 

bufferCapacityInFrames = ((MA_PFN_AAudioStream_getBufferCapacityInFrames)pContext->aaudio.AAudioStream_getBufferCapacityInFrames)((ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
framesPerDataCallback = ((MA_PFN_AAudioStream_getFramesPerDataCallback)pContext->aaudio.AAudioStream_getFramesPerDataCallback)((ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);

if (framesPerDataCallback > 0) {
pDevice->playback.internalPeriodSizeInFrames = framesPerDataCallback;
pDevice->playback.internalPeriods = bufferCapacityInFrames / framesPerDataCallback;
} else {
pDevice->playback.internalPeriodSizeInFrames = bufferCapacityInFrames;
pDevice->playback.internalPeriods = 1;
}
}

if (pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 rbSizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalPeriodSizeInFrames) * pDevice->capture.internalPeriods;
ma_result result = ma_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->pContext->allocationCallbacks, &pDevice->aaudio.duplexRB);
if (result != MA_SUCCESS) {
if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_close_stream__aaudio(pDevice->pContext, (ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_close_stream__aaudio(pDevice->pContext, (ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
}
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[AAudio] Failed to initialize ring buffer.", result);
}


{
ma_uint32 marginSizeInFrames = rbSizeInFrames / pDevice->capture.internalPeriods;
void* pMarginData;
ma_pcm_rb_acquire_write(&pDevice->aaudio.duplexRB, &marginSizeInFrames, &pMarginData);
{
MA_ZERO_MEMORY(pMarginData, marginSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels));
}
ma_pcm_rb_commit_write(&pDevice->aaudio.duplexRB, marginSizeInFrames, pMarginData);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_start_stream__aaudio(ma_device* pDevice, ma_AAudioStream* pStream)
{
ma_aaudio_result_t resultAA;
ma_aaudio_stream_state_t currentState;

MA_ASSERT(pDevice != NULL);

resultAA = ((MA_PFN_AAudioStream_requestStart)pDevice->pContext->aaudio.AAudioStream_requestStart)(pStream);
if (resultAA != MA_AAUDIO_OK) {
return ma_result_from_aaudio(resultAA);
}




currentState = ((MA_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream);
if (currentState != MA_AAUDIO_STREAM_STATE_STARTED) {
ma_result result;

if (currentState != MA_AAUDIO_STREAM_STATE_STARTING) {
return MA_ERROR; 
}

result = ma_wait_for_simple_state_transition__aaudio(pDevice->pContext, pStream, currentState, MA_AAUDIO_STREAM_STATE_STARTED);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop_stream__aaudio(ma_device* pDevice, ma_AAudioStream* pStream)
{
ma_aaudio_result_t resultAA;
ma_aaudio_stream_state_t currentState;

MA_ASSERT(pDevice != NULL);









resultAA = ((MA_PFN_AAudioStream_requestStop)pDevice->pContext->aaudio.AAudioStream_requestStop)(pStream);
if (resultAA != MA_AAUDIO_OK) {
return ma_result_from_aaudio(resultAA);
}


currentState = ((MA_PFN_AAudioStream_getState)pDevice->pContext->aaudio.AAudioStream_getState)(pStream);
if (currentState != MA_AAUDIO_STREAM_STATE_STOPPED) {
ma_result result;

if (currentState != MA_AAUDIO_STREAM_STATE_STOPPING) {
return MA_ERROR; 
}

result = ma_wait_for_simple_state_transition__aaudio(pDevice->pContext, pStream, currentState, MA_AAUDIO_STREAM_STATE_STOPPED);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_start__aaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_result result = ma_device_start_stream__aaudio(pDevice, (ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
if (result != MA_SUCCESS) {
return result;
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_result result = ma_device_start_stream__aaudio(pDevice, (ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
if (result != MA_SUCCESS) {
if (pDevice->type == ma_device_type_duplex) {
ma_device_stop_stream__aaudio(pDevice, (ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
}
return result;
}
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__aaudio(ma_device* pDevice)
{
ma_stop_proc onStop;

MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_result result = ma_device_stop_stream__aaudio(pDevice, (ma_AAudioStream*)pDevice->aaudio.pStreamCapture);
if (result != MA_SUCCESS) {
return result;
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_result result = ma_device_stop_stream__aaudio(pDevice, (ma_AAudioStream*)pDevice->aaudio.pStreamPlayback);
if (result != MA_SUCCESS) {
return result;
}
}

onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}

return MA_SUCCESS;
}


static ma_result ma_context_uninit__aaudio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_aaudio);

ma_dlclose(pContext, pContext->aaudio.hAAudio);
pContext->aaudio.hAAudio = NULL;

return MA_SUCCESS;
}

static ma_result ma_context_init__aaudio(const ma_context_config* pConfig, ma_context* pContext)
{
const char* libNames[] = {
"libaaudio.so"
};
size_t i;

for (i = 0; i < ma_countof(libNames); ++i) {
pContext->aaudio.hAAudio = ma_dlopen(pContext, libNames[i]);
if (pContext->aaudio.hAAudio != NULL) {
break;
}
}

if (pContext->aaudio.hAAudio == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pContext->aaudio.AAudio_createStreamBuilder = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudio_createStreamBuilder");
pContext->aaudio.AAudioStreamBuilder_delete = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_delete");
pContext->aaudio.AAudioStreamBuilder_setDeviceId = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDeviceId");
pContext->aaudio.AAudioStreamBuilder_setDirection = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDirection");
pContext->aaudio.AAudioStreamBuilder_setSharingMode = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setSharingMode");
pContext->aaudio.AAudioStreamBuilder_setFormat = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setFormat");
pContext->aaudio.AAudioStreamBuilder_setChannelCount = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setChannelCount");
pContext->aaudio.AAudioStreamBuilder_setSampleRate = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setSampleRate");
pContext->aaudio.AAudioStreamBuilder_setBufferCapacityInFrames = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setBufferCapacityInFrames");
pContext->aaudio.AAudioStreamBuilder_setFramesPerDataCallback = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setFramesPerDataCallback");
pContext->aaudio.AAudioStreamBuilder_setDataCallback = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setDataCallback");
pContext->aaudio.AAudioStreamBuilder_setErrorCallback = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setErrorCallback");
pContext->aaudio.AAudioStreamBuilder_setPerformanceMode = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_setPerformanceMode");
pContext->aaudio.AAudioStreamBuilder_openStream = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStreamBuilder_openStream");
pContext->aaudio.AAudioStream_close = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_close");
pContext->aaudio.AAudioStream_getState = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getState");
pContext->aaudio.AAudioStream_waitForStateChange = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_waitForStateChange");
pContext->aaudio.AAudioStream_getFormat = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getFormat");
pContext->aaudio.AAudioStream_getChannelCount = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getChannelCount");
pContext->aaudio.AAudioStream_getSampleRate = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getSampleRate");
pContext->aaudio.AAudioStream_getBufferCapacityInFrames = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getBufferCapacityInFrames");
pContext->aaudio.AAudioStream_getFramesPerDataCallback = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getFramesPerDataCallback");
pContext->aaudio.AAudioStream_getFramesPerBurst = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_getFramesPerBurst");
pContext->aaudio.AAudioStream_requestStart = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_requestStart");
pContext->aaudio.AAudioStream_requestStop = (ma_proc)ma_dlsym(pContext, pContext->aaudio.hAAudio, "AAudioStream_requestStop");

pContext->isBackendAsynchronous = MA_TRUE;

pContext->onUninit = ma_context_uninit__aaudio;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__aaudio;
pContext->onEnumDevices = ma_context_enumerate_devices__aaudio;
pContext->onGetDeviceInfo = ma_context_get_device_info__aaudio;
pContext->onDeviceInit = ma_device_init__aaudio;
pContext->onDeviceUninit = ma_device_uninit__aaudio;
pContext->onDeviceStart = ma_device_start__aaudio;
pContext->onDeviceStop = ma_device_stop__aaudio;

(void)pConfig;
return MA_SUCCESS;
}
#endif 







#if defined(MA_HAS_OPENSL)
#include <SLES/OpenSLES.h>
#if defined(MA_ANDROID)
#include <SLES/OpenSLES_Android.h>
#endif


SLObjectItf g_maEngineObjectSL = NULL;
SLEngineItf g_maEngineSL = NULL;
ma_uint32 g_maOpenSLInitCounter = 0;

#define MA_OPENSL_OBJ(p) (*((SLObjectItf)(p)))
#define MA_OPENSL_OUTPUTMIX(p) (*((SLOutputMixItf)(p)))
#define MA_OPENSL_PLAY(p) (*((SLPlayItf)(p)))
#define MA_OPENSL_RECORD(p) (*((SLRecordItf)(p)))

#if defined(MA_ANDROID)
#define MA_OPENSL_BUFFERQUEUE(p) (*((SLAndroidSimpleBufferQueueItf)(p)))
#else
#define MA_OPENSL_BUFFERQUEUE(p) (*((SLBufferQueueItf)(p)))
#endif


static ma_uint8 ma_channel_id_to_ma__opensl(SLuint32 id)
{
switch (id)
{
case SL_SPEAKER_FRONT_LEFT: return MA_CHANNEL_FRONT_LEFT;
case SL_SPEAKER_FRONT_RIGHT: return MA_CHANNEL_FRONT_RIGHT;
case SL_SPEAKER_FRONT_CENTER: return MA_CHANNEL_FRONT_CENTER;
case SL_SPEAKER_LOW_FREQUENCY: return MA_CHANNEL_LFE;
case SL_SPEAKER_BACK_LEFT: return MA_CHANNEL_BACK_LEFT;
case SL_SPEAKER_BACK_RIGHT: return MA_CHANNEL_BACK_RIGHT;
case SL_SPEAKER_FRONT_LEFT_OF_CENTER: return MA_CHANNEL_FRONT_LEFT_CENTER;
case SL_SPEAKER_FRONT_RIGHT_OF_CENTER: return MA_CHANNEL_FRONT_RIGHT_CENTER;
case SL_SPEAKER_BACK_CENTER: return MA_CHANNEL_BACK_CENTER;
case SL_SPEAKER_SIDE_LEFT: return MA_CHANNEL_SIDE_LEFT;
case SL_SPEAKER_SIDE_RIGHT: return MA_CHANNEL_SIDE_RIGHT;
case SL_SPEAKER_TOP_CENTER: return MA_CHANNEL_TOP_CENTER;
case SL_SPEAKER_TOP_FRONT_LEFT: return MA_CHANNEL_TOP_FRONT_LEFT;
case SL_SPEAKER_TOP_FRONT_CENTER: return MA_CHANNEL_TOP_FRONT_CENTER;
case SL_SPEAKER_TOP_FRONT_RIGHT: return MA_CHANNEL_TOP_FRONT_RIGHT;
case SL_SPEAKER_TOP_BACK_LEFT: return MA_CHANNEL_TOP_BACK_LEFT;
case SL_SPEAKER_TOP_BACK_CENTER: return MA_CHANNEL_TOP_BACK_CENTER;
case SL_SPEAKER_TOP_BACK_RIGHT: return MA_CHANNEL_TOP_BACK_RIGHT;
default: return 0;
}
}


static SLuint32 ma_channel_id_to_opensl(ma_uint8 id)
{
switch (id)
{
case MA_CHANNEL_MONO: return SL_SPEAKER_FRONT_CENTER;
case MA_CHANNEL_FRONT_LEFT: return SL_SPEAKER_FRONT_LEFT;
case MA_CHANNEL_FRONT_RIGHT: return SL_SPEAKER_FRONT_RIGHT;
case MA_CHANNEL_FRONT_CENTER: return SL_SPEAKER_FRONT_CENTER;
case MA_CHANNEL_LFE: return SL_SPEAKER_LOW_FREQUENCY;
case MA_CHANNEL_BACK_LEFT: return SL_SPEAKER_BACK_LEFT;
case MA_CHANNEL_BACK_RIGHT: return SL_SPEAKER_BACK_RIGHT;
case MA_CHANNEL_FRONT_LEFT_CENTER: return SL_SPEAKER_FRONT_LEFT_OF_CENTER;
case MA_CHANNEL_FRONT_RIGHT_CENTER: return SL_SPEAKER_FRONT_RIGHT_OF_CENTER;
case MA_CHANNEL_BACK_CENTER: return SL_SPEAKER_BACK_CENTER;
case MA_CHANNEL_SIDE_LEFT: return SL_SPEAKER_SIDE_LEFT;
case MA_CHANNEL_SIDE_RIGHT: return SL_SPEAKER_SIDE_RIGHT;
case MA_CHANNEL_TOP_CENTER: return SL_SPEAKER_TOP_CENTER;
case MA_CHANNEL_TOP_FRONT_LEFT: return SL_SPEAKER_TOP_FRONT_LEFT;
case MA_CHANNEL_TOP_FRONT_CENTER: return SL_SPEAKER_TOP_FRONT_CENTER;
case MA_CHANNEL_TOP_FRONT_RIGHT: return SL_SPEAKER_TOP_FRONT_RIGHT;
case MA_CHANNEL_TOP_BACK_LEFT: return SL_SPEAKER_TOP_BACK_LEFT;
case MA_CHANNEL_TOP_BACK_CENTER: return SL_SPEAKER_TOP_BACK_CENTER;
case MA_CHANNEL_TOP_BACK_RIGHT: return SL_SPEAKER_TOP_BACK_RIGHT;
default: return 0;
}
}


static SLuint32 ma_channel_map_to_channel_mask__opensl(const ma_channel channelMap[MA_MAX_CHANNELS], ma_uint32 channels)
{
SLuint32 channelMask = 0;
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
channelMask |= ma_channel_id_to_opensl(channelMap[iChannel]);
}

return channelMask;
}


static void ma_channel_mask_to_channel_map__opensl(SLuint32 channelMask, ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
if (channels == 1 && channelMask == 0) {
channelMap[0] = MA_CHANNEL_MONO;
} else if (channels == 2 && channelMask == 0) {
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
} else {
if (channels == 1 && (channelMask & SL_SPEAKER_FRONT_CENTER) != 0) {
channelMap[0] = MA_CHANNEL_MONO;
} else {

ma_uint32 iChannel = 0;
ma_uint32 iBit;
for (iBit = 0; iBit < 32; ++iBit) {
SLuint32 bitValue = (channelMask & (1UL << iBit));
if (bitValue != 0) {

channelMap[iChannel] = ma_channel_id_to_ma__opensl(bitValue);
iChannel += 1;
}
}
}
}
}

static SLuint32 ma_round_to_standard_sample_rate__opensl(SLuint32 samplesPerSec)
{
if (samplesPerSec <= SL_SAMPLINGRATE_8) {
return SL_SAMPLINGRATE_8;
}
if (samplesPerSec <= SL_SAMPLINGRATE_11_025) {
return SL_SAMPLINGRATE_11_025;
}
if (samplesPerSec <= SL_SAMPLINGRATE_12) {
return SL_SAMPLINGRATE_12;
}
if (samplesPerSec <= SL_SAMPLINGRATE_16) {
return SL_SAMPLINGRATE_16;
}
if (samplesPerSec <= SL_SAMPLINGRATE_22_05) {
return SL_SAMPLINGRATE_22_05;
}
if (samplesPerSec <= SL_SAMPLINGRATE_24) {
return SL_SAMPLINGRATE_24;
}
if (samplesPerSec <= SL_SAMPLINGRATE_32) {
return SL_SAMPLINGRATE_32;
}
if (samplesPerSec <= SL_SAMPLINGRATE_44_1) {
return SL_SAMPLINGRATE_44_1;
}
if (samplesPerSec <= SL_SAMPLINGRATE_48) {
return SL_SAMPLINGRATE_48;
}


#if !defined(MA_ANDROID)
if (samplesPerSec <= SL_SAMPLINGRATE_64) {
return SL_SAMPLINGRATE_64;
}
if (samplesPerSec <= SL_SAMPLINGRATE_88_2) {
return SL_SAMPLINGRATE_88_2;
}
if (samplesPerSec <= SL_SAMPLINGRATE_96) {
return SL_SAMPLINGRATE_96;
}
if (samplesPerSec <= SL_SAMPLINGRATE_192) {
return SL_SAMPLINGRATE_192;
}
#endif

return SL_SAMPLINGRATE_16;
}


static ma_bool32 ma_context_is_device_id_equal__opensl(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return pID0->opensl == pID1->opensl;
}

static ma_result ma_context_enumerate_devices__opensl(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return MA_INVALID_OPERATION;
}






#if 0 && !defined(MA_ANDROID)
ma_bool32 isTerminated = MA_FALSE;

SLuint32 pDeviceIDs[128];
SLint32 deviceCount = sizeof(pDeviceIDs) / sizeof(pDeviceIDs[0]);

SLAudioIODeviceCapabilitiesItf deviceCaps;
SLresult resultSL = (*g_maEngineObjectSL)->GetInterface(g_maEngineObjectSL, SL_IID_AUDIOIODEVICECAPABILITIES, &deviceCaps);
if (resultSL != SL_RESULT_SUCCESS) {

goto return_default_device;
}


if (!isTerminated) {
resultSL = (*deviceCaps)->GetAvailableAudioOutputs(deviceCaps, &deviceCount, pDeviceIDs);
if (resultSL != SL_RESULT_SUCCESS) {
return MA_NO_DEVICE;
}

for (SLint32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.opensl = pDeviceIDs[iDevice];

SLAudioOutputDescriptor desc;
resultSL = (*deviceCaps)->QueryAudioOutputCapabilities(deviceCaps, deviceInfo.id.opensl, &desc);
if (resultSL == SL_RESULT_SUCCESS) {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), (const char*)desc.pDeviceName, (size_t)-1);

ma_bool32 cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
if (cbResult == MA_FALSE) {
isTerminated = MA_TRUE;
break;
}
}
}
}


if (!isTerminated) {
resultSL = (*deviceCaps)->GetAvailableAudioInputs(deviceCaps, &deviceCount, pDeviceIDs);
if (resultSL != SL_RESULT_SUCCESS) {
return MA_NO_DEVICE;
}

for (SLint32 iDevice = 0; iDevice < deviceCount; ++iDevice) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
deviceInfo.id.opensl = pDeviceIDs[iDevice];

SLAudioInputDescriptor desc;
resultSL = (*deviceCaps)->QueryAudioInputCapabilities(deviceCaps, deviceInfo.id.opensl, &desc);
if (resultSL == SL_RESULT_SUCCESS) {
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), (const char*)desc.deviceName, (size_t)-1);

ma_bool32 cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
if (cbResult == MA_FALSE) {
isTerminated = MA_TRUE;
break;
}
}
}
}

return MA_SUCCESS;
#else
goto return_default_device;
#endif

return_default_device:;
cbResult = MA_TRUE;


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}


if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__opensl(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
MA_ASSERT(pContext != NULL);

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return MA_INVALID_OPERATION;
}


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}






#if 0 && !defined(MA_ANDROID)
SLAudioIODeviceCapabilitiesItf deviceCaps;
SLresult resultSL = (*g_maEngineObjectSL)->GetInterface(g_maEngineObjectSL, SL_IID_AUDIOIODEVICECAPABILITIES, &deviceCaps);
if (resultSL != SL_RESULT_SUCCESS) {

goto return_default_device;
}

if (deviceType == ma_device_type_playback) {
SLAudioOutputDescriptor desc;
resultSL = (*deviceCaps)->QueryAudioOutputCapabilities(deviceCaps, pDeviceID->opensl, &desc);
if (resultSL != SL_RESULT_SUCCESS) {
return MA_NO_DEVICE;
}

ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (const char*)desc.pDeviceName, (size_t)-1);
} else {
SLAudioInputDescriptor desc;
resultSL = (*deviceCaps)->QueryAudioInputCapabilities(deviceCaps, pDeviceID->opensl, &desc);
if (resultSL != SL_RESULT_SUCCESS) {
return MA_NO_DEVICE;
}

ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), (const char*)desc.deviceName, (size_t)-1);
}

goto return_detailed_info;
#else
goto return_default_device;
#endif

return_default_device:
if (pDeviceID != NULL) {
if ((deviceType == ma_device_type_playback && pDeviceID->opensl != SL_DEFAULTDEVICEID_AUDIOOUTPUT) ||
(deviceType == ma_device_type_capture && pDeviceID->opensl != SL_DEFAULTDEVICEID_AUDIOINPUT)) {
return MA_NO_DEVICE; 
}
}


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}

goto return_detailed_info;


return_detailed_info:






pDeviceInfo->minChannels = 1;
pDeviceInfo->maxChannels = 2;
pDeviceInfo->minSampleRate = 8000;
pDeviceInfo->maxSampleRate = 48000;
pDeviceInfo->formatCount = 2;
pDeviceInfo->formats[0] = ma_format_u8;
pDeviceInfo->formats[1] = ma_format_s16;
#if defined(MA_ANDROID) && __ANDROID_API__ >= 21
pDeviceInfo->formats[pDeviceInfo->formatCount] = ma_format_f32;
pDeviceInfo->formatCount += 1;
#endif

return MA_SUCCESS;
}


#if defined(MA_ANDROID)

static void ma_buffer_queue_callback_capture__opensl_android(SLAndroidSimpleBufferQueueItf pBufferQueue, void* pUserData)
{
ma_device* pDevice = (ma_device*)pUserData;
size_t periodSizeInBytes;
ma_uint8* pBuffer;
SLresult resultSL;

MA_ASSERT(pDevice != NULL);

(void)pBufferQueue;








if (pDevice->state != MA_STATE_STARTED) {
return;
}


if (pDevice->opensl.isDrainingCapture) {
return;
}

periodSizeInBytes = pDevice->capture.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
pBuffer = pDevice->opensl.pBufferCapture + (pDevice->opensl.currentBufferIndexCapture * periodSizeInBytes);

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, pDevice->capture.internalPeriodSizeInFrames, pBuffer, &pDevice->opensl.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, pDevice->capture.internalPeriodSizeInFrames, pBuffer);
}

resultSL = MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, pBuffer, periodSizeInBytes);
if (resultSL != SL_RESULT_SUCCESS) {
return;
}

pDevice->opensl.currentBufferIndexCapture = (pDevice->opensl.currentBufferIndexCapture + 1) % pDevice->capture.internalPeriods;
}

static void ma_buffer_queue_callback_playback__opensl_android(SLAndroidSimpleBufferQueueItf pBufferQueue, void* pUserData)
{
ma_device* pDevice = (ma_device*)pUserData;
size_t periodSizeInBytes;
ma_uint8* pBuffer;
SLresult resultSL;

MA_ASSERT(pDevice != NULL);

(void)pBufferQueue;


if (pDevice->state != MA_STATE_STARTED) {
return;
}


if (pDevice->opensl.isDrainingPlayback) {
return;
}

periodSizeInBytes = pDevice->playback.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
pBuffer = pDevice->opensl.pBufferPlayback + (pDevice->opensl.currentBufferIndexPlayback * periodSizeInBytes);

if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, pDevice->playback.internalPeriodSizeInFrames, pBuffer, &pDevice->opensl.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, pDevice->playback.internalPeriodSizeInFrames, pBuffer);
}

resultSL = MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, pBuffer, periodSizeInBytes);
if (resultSL != SL_RESULT_SUCCESS) {
return;
}

pDevice->opensl.currentBufferIndexPlayback = (pDevice->opensl.currentBufferIndexPlayback + 1) % pDevice->playback.internalPeriods;
}
#endif

static void ma_device_uninit__opensl(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return;
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (pDevice->opensl.pAudioRecorderObj) {
MA_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->Destroy((SLObjectItf)pDevice->opensl.pAudioRecorderObj);
}

ma__free_from_callbacks(pDevice->opensl.pBufferCapture, &pDevice->pContext->allocationCallbacks);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
if (pDevice->opensl.pAudioPlayerObj) {
MA_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->Destroy((SLObjectItf)pDevice->opensl.pAudioPlayerObj);
}
if (pDevice->opensl.pOutputMixObj) {
MA_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->Destroy((SLObjectItf)pDevice->opensl.pOutputMixObj);
}

ma__free_from_callbacks(pDevice->opensl.pBufferPlayback, &pDevice->pContext->allocationCallbacks);
}

if (pDevice->type == ma_device_type_duplex) {
ma_pcm_rb_uninit(&pDevice->opensl.duplexRB);
}
}

#if defined(MA_ANDROID) && __ANDROID_API__ >= 21
typedef SLAndroidDataFormat_PCM_EX ma_SLDataFormat_PCM;
#else
typedef SLDataFormat_PCM ma_SLDataFormat_PCM;
#endif

static ma_result ma_SLDataFormat_PCM_init__opensl(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, const ma_channel* channelMap, ma_SLDataFormat_PCM* pDataFormat)
{
#if defined(MA_ANDROID) && __ANDROID_API__ >= 21
if (format == ma_format_f32) {
pDataFormat->formatType = SL_ANDROID_DATAFORMAT_PCM_EX;
pDataFormat->representation = SL_ANDROID_PCM_REPRESENTATION_FLOAT;
} else {
pDataFormat->formatType = SL_DATAFORMAT_PCM;
}
#else
pDataFormat->formatType = SL_DATAFORMAT_PCM;
#endif

pDataFormat->numChannels = channels;
((SLDataFormat_PCM*)pDataFormat)->samplesPerSec = ma_round_to_standard_sample_rate__opensl(sampleRate * 1000); 
pDataFormat->bitsPerSample = ma_get_bytes_per_sample(format)*8;
pDataFormat->channelMask = ma_channel_map_to_channel_mask__opensl(channelMap, channels);
pDataFormat->endianness = (ma_is_little_endian()) ? SL_BYTEORDER_LITTLEENDIAN : SL_BYTEORDER_BIGENDIAN;







#if defined(MA_ANDROID)
if (pDataFormat->numChannels > 2) {
pDataFormat->numChannels = 2;
}
#if __ANDROID_API__ >= 21
if (pDataFormat->formatType == SL_ANDROID_DATAFORMAT_PCM_EX) {

MA_ASSERT(pDataFormat->representation == SL_ANDROID_PCM_REPRESENTATION_FLOAT);
if (pDataFormat->bitsPerSample > 32) {
pDataFormat->bitsPerSample = 32;
}
} else {
if (pDataFormat->bitsPerSample > 16) {
pDataFormat->bitsPerSample = 16;
}
}
#else
if (pDataFormat->bitsPerSample > 16) {
pDataFormat->bitsPerSample = 16;
}
#endif
if (((SLDataFormat_PCM*)pDataFormat)->samplesPerSec > SL_SAMPLINGRATE_48) {
((SLDataFormat_PCM*)pDataFormat)->samplesPerSec = SL_SAMPLINGRATE_48;
}
#endif

pDataFormat->containerSize = pDataFormat->bitsPerSample; 

return MA_SUCCESS;
}

static ma_result ma_deconstruct_SLDataFormat_PCM__opensl(ma_SLDataFormat_PCM* pDataFormat, ma_format* pFormat, ma_uint32* pChannels, ma_uint32* pSampleRate, ma_channel* pChannelMap)
{
ma_bool32 isFloatingPoint = MA_FALSE;
#if defined(MA_ANDROID) && __ANDROID_API__ >= 21
if (pDataFormat->formatType == SL_ANDROID_DATAFORMAT_PCM_EX) {
MA_ASSERT(pDataFormat->representation == SL_ANDROID_PCM_REPRESENTATION_FLOAT);
isFloatingPoint = MA_TRUE;
}
#endif
if (isFloatingPoint) {
if (pDataFormat->bitsPerSample == 32) {
*pFormat = ma_format_f32;
}
} else {
if (pDataFormat->bitsPerSample == 8) {
*pFormat = ma_format_u8;
} else if (pDataFormat->bitsPerSample == 16) {
*pFormat = ma_format_s16;
} else if (pDataFormat->bitsPerSample == 24) {
*pFormat = ma_format_s24;
} else if (pDataFormat->bitsPerSample == 32) {
*pFormat = ma_format_s32;
}
}

*pChannels = pDataFormat->numChannels;
*pSampleRate = ((SLDataFormat_PCM*)pDataFormat)->samplesPerSec / 1000;
ma_channel_mask_to_channel_map__opensl(pDataFormat->channelMask, pDataFormat->numChannels, pChannelMap);

return MA_SUCCESS;
}

static ma_result ma_device_init__opensl(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
#if defined(MA_ANDROID)
SLDataLocator_AndroidSimpleBufferQueue queue;
SLresult resultSL;
ma_uint32 periodSizeInFrames;
size_t bufferSizeInBytes;
const SLInterfaceID itfIDs1[] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};
const SLboolean itfIDsRequired1[] = {SL_BOOLEAN_TRUE};
#endif

(void)pContext;

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return MA_INVALID_OPERATION;
}

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}






#if defined(MA_ANDROID)

if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}


MA_ASSERT(pDevice != NULL);
MA_ZERO_OBJECT(&pDevice->opensl);

queue.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;
queue.numBuffers = pConfig->periods;


if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
ma_SLDataFormat_PCM pcm;
SLDataLocator_IODevice locatorDevice;
SLDataSource source;
SLDataSink sink;

ma_SLDataFormat_PCM_init__opensl(pConfig->capture.format, pConfig->capture.channels, pConfig->sampleRate, pConfig->capture.channelMap, &pcm);

locatorDevice.locatorType = SL_DATALOCATOR_IODEVICE;
locatorDevice.deviceType = SL_IODEVICE_AUDIOINPUT;
locatorDevice.deviceID = (pConfig->capture.pDeviceID == NULL) ? SL_DEFAULTDEVICEID_AUDIOINPUT : pConfig->capture.pDeviceID->opensl;
locatorDevice.device = NULL;

source.pLocator = &locatorDevice;
source.pFormat = NULL;

sink.pLocator = &queue;
sink.pFormat = (SLDataFormat_PCM*)&pcm;

resultSL = (*g_maEngineSL)->CreateAudioRecorder(g_maEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioRecorderObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
if (resultSL == SL_RESULT_CONTENT_UNSUPPORTED) {

pcm.formatType = SL_DATAFORMAT_PCM;
pcm.numChannels = 1;
((SLDataFormat_PCM*)&pcm)->samplesPerSec = SL_SAMPLINGRATE_16; 
pcm.bitsPerSample = 16;
pcm.containerSize = pcm.bitsPerSample; 
pcm.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
resultSL = (*g_maEngineSL)->CreateAudioRecorder(g_maEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioRecorderObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
}

if (resultSL != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to create audio recorder.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->Realize((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_BOOLEAN_FALSE) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize audio recorder.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_IID_RECORD, &pDevice->opensl.pAudioRecorder) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_RECORD interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioRecorderObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioRecorderObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &pDevice->opensl.pBufferQueueCapture) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_ANDROIDSIMPLEBUFFERQUEUE interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->RegisterCallback((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, ma_buffer_queue_callback_capture__opensl_android, pDevice) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to register buffer queue callback.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


ma_deconstruct_SLDataFormat_PCM__opensl(&pcm, &pDevice->capture.internalFormat, &pDevice->capture.internalChannels, &pDevice->capture.internalSampleRate, pDevice->capture.internalChannelMap);


periodSizeInFrames = pConfig->periodSizeInFrames;
if (periodSizeInFrames == 0) {
periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, pDevice->capture.internalSampleRate);
}
pDevice->capture.internalPeriods = pConfig->periods;
pDevice->capture.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->opensl.currentBufferIndexCapture = 0;

bufferSizeInBytes = pDevice->capture.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels) * pDevice->capture.internalPeriods;
pDevice->opensl.pBufferCapture = (ma_uint8*)ma__calloc_from_callbacks(bufferSizeInBytes, &pContext->allocationCallbacks);
if (pDevice->opensl.pBufferCapture == NULL) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to allocate memory for data buffer.", MA_OUT_OF_MEMORY);
}
MA_ZERO_MEMORY(pDevice->opensl.pBufferCapture, bufferSizeInBytes);
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
ma_SLDataFormat_PCM pcm;
SLDataSource source;
SLDataLocator_OutputMix outmixLocator;
SLDataSink sink;

ma_SLDataFormat_PCM_init__opensl(pConfig->playback.format, pConfig->playback.channels, pConfig->sampleRate, pConfig->playback.channelMap, &pcm);

resultSL = (*g_maEngineSL)->CreateOutputMix(g_maEngineSL, (SLObjectItf*)&pDevice->opensl.pOutputMixObj, 0, NULL, NULL);
if (resultSL != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to create output mix.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->Realize((SLObjectItf)pDevice->opensl.pOutputMixObj, SL_BOOLEAN_FALSE)) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize output mix object.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pOutputMixObj)->GetInterface((SLObjectItf)pDevice->opensl.pOutputMixObj, SL_IID_OUTPUTMIX, &pDevice->opensl.pOutputMix) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_OUTPUTMIX interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


if (pConfig->playback.pDeviceID != NULL) {
SLuint32 deviceID_OpenSL = pConfig->playback.pDeviceID->opensl;
MA_OPENSL_OUTPUTMIX(pDevice->opensl.pOutputMix)->ReRoute((SLOutputMixItf)pDevice->opensl.pOutputMix, 1, &deviceID_OpenSL);
}

source.pLocator = &queue;
source.pFormat = (SLDataFormat_PCM*)&pcm;

outmixLocator.locatorType = SL_DATALOCATOR_OUTPUTMIX;
outmixLocator.outputMix = (SLObjectItf)pDevice->opensl.pOutputMixObj;

sink.pLocator = &outmixLocator;
sink.pFormat = NULL;

resultSL = (*g_maEngineSL)->CreateAudioPlayer(g_maEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioPlayerObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
if (resultSL == SL_RESULT_CONTENT_UNSUPPORTED) {

pcm.formatType = SL_DATAFORMAT_PCM;
pcm.numChannels = 2;
((SLDataFormat_PCM*)&pcm)->samplesPerSec = SL_SAMPLINGRATE_16;
pcm.bitsPerSample = 16;
pcm.containerSize = pcm.bitsPerSample; 
pcm.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;
resultSL = (*g_maEngineSL)->CreateAudioPlayer(g_maEngineSL, (SLObjectItf*)&pDevice->opensl.pAudioPlayerObj, &source, &sink, 1, itfIDs1, itfIDsRequired1);
}

if (resultSL != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to create audio player.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->Realize((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_BOOLEAN_FALSE) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to realize audio player.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_IID_PLAY, &pDevice->opensl.pAudioPlayer) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_PLAY interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_OBJ(pDevice->opensl.pAudioPlayerObj)->GetInterface((SLObjectItf)pDevice->opensl.pAudioPlayerObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &pDevice->opensl.pBufferQueuePlayback) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to retrieve SL_IID_ANDROIDSIMPLEBUFFERQUEUE interface.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}

if (MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->RegisterCallback((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, ma_buffer_queue_callback_playback__opensl_android, pDevice) != SL_RESULT_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to register buffer queue callback.", MA_FAILED_TO_OPEN_BACKEND_DEVICE);
}


ma_deconstruct_SLDataFormat_PCM__opensl(&pcm, &pDevice->playback.internalFormat, &pDevice->playback.internalChannels, &pDevice->playback.internalSampleRate, pDevice->playback.internalChannelMap);


periodSizeInFrames = pConfig->periodSizeInFrames;
if (periodSizeInFrames == 0) {
periodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, pDevice->playback.internalSampleRate);
}
pDevice->playback.internalPeriods = pConfig->periods;
pDevice->playback.internalPeriodSizeInFrames = periodSizeInFrames;
pDevice->opensl.currentBufferIndexPlayback = 0;

bufferSizeInBytes = pDevice->playback.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels) * pDevice->playback.internalPeriods;
pDevice->opensl.pBufferPlayback = (ma_uint8*)ma__calloc_from_callbacks(bufferSizeInBytes, &pContext->allocationCallbacks);
if (pDevice->opensl.pBufferPlayback == NULL) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to allocate memory for data buffer.", MA_OUT_OF_MEMORY);
}
MA_ZERO_MEMORY(pDevice->opensl.pBufferPlayback, bufferSizeInBytes);
}

if (pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 rbSizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalPeriodSizeInFrames) * pDevice->capture.internalPeriods;
ma_result result = ma_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->pContext->allocationCallbacks, &pDevice->opensl.duplexRB);
if (result != MA_SUCCESS) {
ma_device_uninit__opensl(pDevice);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to initialize ring buffer.", result);
}


{
ma_uint32 marginSizeInFrames = rbSizeInFrames / pDevice->capture.internalPeriods;
void* pMarginData;
ma_pcm_rb_acquire_write(&pDevice->opensl.duplexRB, &marginSizeInFrames, &pMarginData);
{
MA_ZERO_MEMORY(pMarginData, marginSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels));
}
ma_pcm_rb_commit_write(&pDevice->opensl.duplexRB, marginSizeInFrames, pMarginData);
}
}

return MA_SUCCESS;
#else
return MA_NO_BACKEND; 
#endif
}

static ma_result ma_device_start__opensl(ma_device* pDevice)
{
SLresult resultSL;
size_t periodSizeInBytes;
ma_uint32 iPeriod;

MA_ASSERT(pDevice != NULL);

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return MA_INVALID_OPERATION;
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
resultSL = MA_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_RECORDING);
if (resultSL != SL_RESULT_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to start internal capture device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}

periodSizeInBytes = pDevice->capture.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.internalFormat, pDevice->capture.internalChannels);
for (iPeriod = 0; iPeriod < pDevice->capture.internalPeriods; ++iPeriod) {
resultSL = MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture, pDevice->opensl.pBufferCapture + (periodSizeInBytes * iPeriod), periodSizeInBytes);
if (resultSL != SL_RESULT_SUCCESS) {
MA_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_STOPPED);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to enqueue buffer for capture device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
resultSL = MA_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_PLAYING);
if (resultSL != SL_RESULT_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to start internal playback device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}


if (pDevice->type == ma_device_type_duplex) {
MA_ZERO_MEMORY(pDevice->opensl.pBufferPlayback, pDevice->playback.internalPeriodSizeInFrames * pDevice->playback.internalPeriods * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels));
} else {
ma_device__read_frames_from_client(pDevice, pDevice->playback.internalPeriodSizeInFrames * pDevice->playback.internalPeriods, pDevice->opensl.pBufferPlayback);
}

periodSizeInBytes = pDevice->playback.internalPeriodSizeInFrames * ma_get_bytes_per_frame(pDevice->playback.internalFormat, pDevice->playback.internalChannels);
for (iPeriod = 0; iPeriod < pDevice->playback.internalPeriods; ++iPeriod) {
resultSL = MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Enqueue((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback, pDevice->opensl.pBufferPlayback + (periodSizeInBytes * iPeriod), periodSizeInBytes);
if (resultSL != SL_RESULT_SUCCESS) {
MA_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_STOPPED);
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to enqueue buffer for playback device.", MA_FAILED_TO_START_BACKEND_DEVICE);
}
}
}

return MA_SUCCESS;
}

static ma_result ma_device_drain__opensl(ma_device* pDevice, ma_device_type deviceType)
{
SLAndroidSimpleBufferQueueItf pBufferQueue;

MA_ASSERT(deviceType == ma_device_type_capture || deviceType == ma_device_type_playback);

if (pDevice->type == ma_device_type_capture) {
pBufferQueue = (SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture;
pDevice->opensl.isDrainingCapture = MA_TRUE;
} else {
pBufferQueue = (SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback;
pDevice->opensl.isDrainingPlayback = MA_TRUE;
}

for (;;) {
SLAndroidSimpleBufferQueueState state;

MA_OPENSL_BUFFERQUEUE(pBufferQueue)->GetState(pBufferQueue, &state);
if (state.count == 0) {
break;
}

ma_sleep(10);
}

if (pDevice->type == ma_device_type_capture) {
pDevice->opensl.isDrainingCapture = MA_FALSE;
} else {
pDevice->opensl.isDrainingPlayback = MA_FALSE;
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__opensl(ma_device* pDevice)
{
SLresult resultSL;
ma_stop_proc onStop;

MA_ASSERT(pDevice != NULL);

MA_ASSERT(g_maOpenSLInitCounter > 0); 
if (g_maOpenSLInitCounter == 0) {
return MA_INVALID_OPERATION;
}

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_device_drain__opensl(pDevice, ma_device_type_capture);

resultSL = MA_OPENSL_RECORD(pDevice->opensl.pAudioRecorder)->SetRecordState((SLRecordItf)pDevice->opensl.pAudioRecorder, SL_RECORDSTATE_STOPPED);
if (resultSL != SL_RESULT_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to stop internal capture device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueueCapture)->Clear((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueueCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_device_drain__opensl(pDevice, ma_device_type_playback);

resultSL = MA_OPENSL_PLAY(pDevice->opensl.pAudioPlayer)->SetPlayState((SLPlayItf)pDevice->opensl.pAudioPlayer, SL_PLAYSTATE_STOPPED);
if (resultSL != SL_RESULT_SUCCESS) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "[OpenSL] Failed to stop internal playback device.", MA_FAILED_TO_STOP_BACKEND_DEVICE);
}

MA_OPENSL_BUFFERQUEUE(pDevice->opensl.pBufferQueuePlayback)->Clear((SLAndroidSimpleBufferQueueItf)pDevice->opensl.pBufferQueuePlayback);
}


onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}

return MA_SUCCESS;
}


static ma_result ma_context_uninit__opensl(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_opensl);
(void)pContext;


if (g_maOpenSLInitCounter > 0) {
if (ma_atomic_decrement_32(&g_maOpenSLInitCounter) == 0) {
(*g_maEngineObjectSL)->Destroy(g_maEngineObjectSL);
}
}

return MA_SUCCESS;
}

static ma_result ma_context_init__opensl(const ma_context_config* pConfig, ma_context* pContext)
{
MA_ASSERT(pContext != NULL);

(void)pConfig;


if (ma_atomic_increment_32(&g_maOpenSLInitCounter) == 1) {
SLresult resultSL = slCreateEngine(&g_maEngineObjectSL, 0, NULL, 0, NULL, NULL);
if (resultSL != SL_RESULT_SUCCESS) {
ma_atomic_decrement_32(&g_maOpenSLInitCounter);
return MA_NO_BACKEND;
}

(*g_maEngineObjectSL)->Realize(g_maEngineObjectSL, SL_BOOLEAN_FALSE);

resultSL = (*g_maEngineObjectSL)->GetInterface(g_maEngineObjectSL, SL_IID_ENGINE, &g_maEngineSL);
if (resultSL != SL_RESULT_SUCCESS) {
(*g_maEngineObjectSL)->Destroy(g_maEngineObjectSL);
ma_atomic_decrement_32(&g_maOpenSLInitCounter);
return MA_NO_BACKEND;
}
}

pContext->isBackendAsynchronous = MA_TRUE;

pContext->onUninit = ma_context_uninit__opensl;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__opensl;
pContext->onEnumDevices = ma_context_enumerate_devices__opensl;
pContext->onGetDeviceInfo = ma_context_get_device_info__opensl;
pContext->onDeviceInit = ma_device_init__opensl;
pContext->onDeviceUninit = ma_device_uninit__opensl;
pContext->onDeviceStart = ma_device_start__opensl;
pContext->onDeviceStop = ma_device_stop__opensl;

return MA_SUCCESS;
}
#endif 







#if defined(MA_HAS_WEBAUDIO)
#include <emscripten/emscripten.h>

static ma_bool32 ma_is_capture_supported__webaudio()
{
return EM_ASM_INT({
return (navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined);
}, 0) != 0; 
}

#if defined(__cplusplus)
extern "C" {
#endif
EMSCRIPTEN_KEEPALIVE void ma_device_process_pcm_frames_capture__webaudio(ma_device* pDevice, int frameCount, float* pFrames)
{
if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_capture(pDevice, (ma_uint32)frameCount, pFrames, &pDevice->webaudio.duplexRB);
} else {
ma_device__send_frames_to_client(pDevice, (ma_uint32)frameCount, pFrames); 
}
}

EMSCRIPTEN_KEEPALIVE void ma_device_process_pcm_frames_playback__webaudio(ma_device* pDevice, int frameCount, float* pFrames)
{
if (pDevice->type == ma_device_type_duplex) {
ma_device__handle_duplex_callback_playback(pDevice, (ma_uint32)frameCount, pFrames, &pDevice->webaudio.duplexRB);
} else {
ma_device__read_frames_from_client(pDevice, (ma_uint32)frameCount, pFrames); 
}
}
#if defined(__cplusplus)
}
#endif

static ma_bool32 ma_context_is_device_id_equal__webaudio(ma_context* pContext, const ma_device_id* pID0, const ma_device_id* pID1)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pID0 != NULL);
MA_ASSERT(pID1 != NULL);
(void)pContext;

return ma_strcmp(pID0->webaudio, pID1->webaudio) == 0;
}

static ma_result ma_context_enumerate_devices__webaudio(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_bool32 cbResult = MA_TRUE;

MA_ASSERT(pContext != NULL);
MA_ASSERT(callback != NULL);




if (cbResult) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_playback, &deviceInfo, pUserData);
}


if (cbResult) {
if (ma_is_capture_supported__webaudio()) {
ma_device_info deviceInfo;
MA_ZERO_OBJECT(&deviceInfo);
ma_strncpy_s(deviceInfo.name, sizeof(deviceInfo.name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
cbResult = callback(pContext, ma_device_type_capture, &deviceInfo, pUserData);
}
}

return MA_SUCCESS;
}

static ma_result ma_context_get_device_info__webaudio(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
MA_ASSERT(pContext != NULL);


if (shareMode == ma_share_mode_exclusive) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

if (deviceType == ma_device_type_capture && !ma_is_capture_supported__webaudio()) {
return MA_NO_DEVICE;
}


MA_ZERO_MEMORY(pDeviceInfo->id.webaudio, sizeof(pDeviceInfo->id.webaudio));


if (deviceType == ma_device_type_playback) {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_PLAYBACK_DEVICE_NAME, (size_t)-1);
} else {
ma_strncpy_s(pDeviceInfo->name, sizeof(pDeviceInfo->name), MA_DEFAULT_CAPTURE_DEVICE_NAME, (size_t)-1);
}


pDeviceInfo->minChannels = 1;
pDeviceInfo->maxChannels = MA_MAX_CHANNELS;
if (pDeviceInfo->maxChannels > 32) {
pDeviceInfo->maxChannels = 32; 
}


pDeviceInfo->minSampleRate = EM_ASM_INT({
try {
var temp = new (window.AudioContext || window.webkitAudioContext)();
var sampleRate = temp.sampleRate;
temp.close();
return sampleRate;
} catch(e) {
return 0;
}
}, 0); 
pDeviceInfo->maxSampleRate = pDeviceInfo->minSampleRate;
if (pDeviceInfo->minSampleRate == 0) {
return MA_NO_DEVICE;
}


pDeviceInfo->formatCount = 1;
pDeviceInfo->formats[0] = ma_format_f32;

return MA_SUCCESS;
}


static void ma_device_uninit_by_index__webaudio(ma_device* pDevice, ma_device_type deviceType, int deviceIndex)
{
MA_ASSERT(pDevice != NULL);

EM_ASM({
var device = miniaudio.get_device_by_index($0);


if (device.scriptNode !== undefined) {
device.scriptNode.onaudioprocess = function(e) {}; 
device.scriptNode.disconnect();
device.scriptNode = undefined;
}
if (device.streamNode !== undefined) {
device.streamNode.disconnect();
device.streamNode = undefined;
}





device.webaudio.close();
device.webaudio = undefined;


if (device.intermediaryBuffer !== undefined) {
Module._free(device.intermediaryBuffer);
device.intermediaryBuffer = undefined;
device.intermediaryBufferView = undefined;
device.intermediaryBufferSizeInBytes = undefined;
}


miniaudio.untrack_device_by_index($0);
}, deviceIndex, deviceType);
}

static void ma_device_uninit__webaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_device_uninit_by_index__webaudio(pDevice, ma_device_type_capture, pDevice->webaudio.indexCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_device_uninit_by_index__webaudio(pDevice, ma_device_type_playback, pDevice->webaudio.indexPlayback);
}

if (pDevice->type == ma_device_type_duplex) {
ma_pcm_rb_uninit(&pDevice->webaudio.duplexRB);
}
}

static ma_result ma_device_init_by_type__webaudio(ma_context* pContext, const ma_device_config* pConfig, ma_device_type deviceType, ma_device* pDevice)
{
int deviceIndex;
ma_uint32 internalPeriodSizeInFrames;

MA_ASSERT(pContext != NULL);
MA_ASSERT(pConfig != NULL);
MA_ASSERT(deviceType != ma_device_type_duplex);
MA_ASSERT(pDevice != NULL);

if (deviceType == ma_device_type_capture && !ma_is_capture_supported__webaudio()) {
return MA_NO_DEVICE;
}


internalPeriodSizeInFrames = pConfig->periodSizeInFrames;
if (internalPeriodSizeInFrames == 0) {
internalPeriodSizeInFrames = ma_calculate_buffer_size_in_frames_from_milliseconds(pConfig->periodSizeInMilliseconds, pConfig->sampleRate);
}


if (internalPeriodSizeInFrames < 256) {
internalPeriodSizeInFrames = 256;
} else if (internalPeriodSizeInFrames > 16384) {
internalPeriodSizeInFrames = 16384;
} else {
internalPeriodSizeInFrames = ma_next_power_of_2(internalPeriodSizeInFrames);
}


deviceIndex = EM_ASM_INT({
var channels = $0;
var sampleRate = $1;
var bufferSize = $2; 
var isCapture = $3;
var pDevice = $4;

if (typeof(miniaudio) === 'undefined') {
return -1; 
}

var device = {};


device.webaudio = new (window.AudioContext || window.webkitAudioContext)({sampleRate:sampleRate});
device.webaudio.suspend();





device.intermediaryBufferSizeInBytes = channels * bufferSize * 4;
device.intermediaryBuffer = Module._malloc(device.intermediaryBufferSizeInBytes);
device.intermediaryBufferView = new Float32Array(Module.HEAPF32.buffer, device.intermediaryBuffer, device.intermediaryBufferSizeInBytes);

















device.scriptNode = device.webaudio.createScriptProcessor(bufferSize, channels, channels);

if (isCapture) {
device.scriptNode.onaudioprocess = function(e) {
if (device.intermediaryBuffer === undefined) {
return; 
}


for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
e.outputBuffer.getChannelData(iChannel).fill(0.0);
}


var sendSilence = false;
if (device.streamNode === undefined) {
sendSilence = true;
}


if (e.inputBuffer.numberOfChannels != channels) {
console.log("Capture: Channel count mismatch. " + e.inputBufer.numberOfChannels + " != " + channels + ". Sending silence.");
sendSilence = true;
}


var totalFramesProcessed = 0;
while (totalFramesProcessed < e.inputBuffer.length) {
var framesRemaining = e.inputBuffer.length - totalFramesProcessed;
var framesToProcess = framesRemaining;
if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) {
framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4);
}


if (sendSilence) {
device.intermediaryBufferView.fill(0.0);
} else {
for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) {
for (var iChannel = 0; iChannel < e.inputBuffer.numberOfChannels; ++iChannel) {
device.intermediaryBufferView[iFrame*channels + iChannel] = e.inputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame];
}
}
}


ccall("ma_device_process_pcm_frames_capture__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]);

totalFramesProcessed += framesToProcess;
}
};

navigator.mediaDevices.getUserMedia({audio:true, video:false})
.then(function(stream) {
device.streamNode = device.webaudio.createMediaStreamSource(stream);
device.streamNode.connect(device.scriptNode);
device.scriptNode.connect(device.webaudio.destination);
})
.catch(function(error) {

device.scriptNode.connect(device.webaudio.destination);
});
} else {
device.scriptNode.onaudioprocess = function(e) {
if (device.intermediaryBuffer === undefined) {
return; 
}

var outputSilence = false;


if (e.outputBuffer.numberOfChannels != channels) {
console.log("Playback: Channel count mismatch. " + e.outputBufer.numberOfChannels + " != " + channels + ". Outputting silence.");
outputSilence = true;
return;
}


var totalFramesProcessed = 0;
while (totalFramesProcessed < e.outputBuffer.length) {
var framesRemaining = e.outputBuffer.length - totalFramesProcessed;
var framesToProcess = framesRemaining;
if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) {
framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4);
}


ccall("ma_device_process_pcm_frames_playback__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]);


if (outputSilence) {
for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
e.outputBuffer.getChannelData(iChannel).fill(0.0);
}
} else {
for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) {
for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) {
e.outputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame] = device.intermediaryBufferView[iFrame*channels + iChannel];
}
}
}

totalFramesProcessed += framesToProcess;
}
};

device.scriptNode.connect(device.webaudio.destination);
}

return miniaudio.track_device(device);
}, (deviceType == ma_device_type_capture) ? pConfig->capture.channels : pConfig->playback.channels, pConfig->sampleRate, internalPeriodSizeInFrames, deviceType == ma_device_type_capture, pDevice);

if (deviceIndex < 0) {
return MA_FAILED_TO_OPEN_BACKEND_DEVICE;
}

if (deviceType == ma_device_type_capture) {
pDevice->webaudio.indexCapture = deviceIndex;
pDevice->capture.internalFormat = ma_format_f32;
pDevice->capture.internalChannels = pConfig->capture.channels;
ma_get_standard_channel_map(ma_standard_channel_map_webaudio, pDevice->capture.internalChannels, pDevice->capture.internalChannelMap);
pDevice->capture.internalSampleRate = EM_ASM_INT({ return miniaudio.get_device_by_index($0).webaudio.sampleRate; }, deviceIndex);
pDevice->capture.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->capture.internalPeriods = 1;
} else {
pDevice->webaudio.indexPlayback = deviceIndex;
pDevice->playback.internalFormat = ma_format_f32;
pDevice->playback.internalChannels = pConfig->playback.channels;
ma_get_standard_channel_map(ma_standard_channel_map_webaudio, pDevice->playback.internalChannels, pDevice->playback.internalChannelMap);
pDevice->playback.internalSampleRate = EM_ASM_INT({ return miniaudio.get_device_by_index($0).webaudio.sampleRate; }, deviceIndex);
pDevice->playback.internalPeriodSizeInFrames = internalPeriodSizeInFrames;
pDevice->playback.internalPeriods = 1;
}

return MA_SUCCESS;
}

static ma_result ma_device_init__webaudio(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;

if (pConfig->deviceType == ma_device_type_loopback) {
return MA_DEVICE_TYPE_NOT_SUPPORTED;
}


if (((pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) && pConfig->playback.shareMode == ma_share_mode_exclusive) ||
((pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) && pConfig->capture.shareMode == ma_share_mode_exclusive)) {
return MA_SHARE_MODE_NOT_SUPPORTED;
}

if (pConfig->deviceType == ma_device_type_capture || pConfig->deviceType == ma_device_type_duplex) {
result = ma_device_init_by_type__webaudio(pContext, pConfig, ma_device_type_capture, pDevice);
if (result != MA_SUCCESS) {
return result;
}
}

if (pConfig->deviceType == ma_device_type_playback || pConfig->deviceType == ma_device_type_duplex) {
result = ma_device_init_by_type__webaudio(pContext, pConfig, ma_device_type_playback, pDevice);
if (result != MA_SUCCESS) {
if (pConfig->deviceType == ma_device_type_duplex) {
ma_device_uninit_by_index__webaudio(pDevice, ma_device_type_capture, pDevice->webaudio.indexCapture);
}
return result;
}
}






if (pConfig->deviceType == ma_device_type_duplex) {
ma_uint32 rbSizeInFrames = (ma_uint32)ma_calculate_frame_count_after_resampling(pDevice->sampleRate, pDevice->capture.internalSampleRate, pDevice->capture.internalPeriodSizeInFrames) * 2;
result = ma_pcm_rb_init(pDevice->capture.format, pDevice->capture.channels, rbSizeInFrames, NULL, &pDevice->pContext->allocationCallbacks, &pDevice->webaudio.duplexRB);
if (result != MA_SUCCESS) {
if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
ma_device_uninit_by_index__webaudio(pDevice, ma_device_type_capture, pDevice->webaudio.indexCapture);
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
ma_device_uninit_by_index__webaudio(pDevice, ma_device_type_playback, pDevice->webaudio.indexPlayback);
}
return result;
}


{
ma_uint32 marginSizeInFrames = rbSizeInFrames / 3; 
void* pMarginData;
ma_pcm_rb_acquire_write(&pDevice->webaudio.duplexRB, &marginSizeInFrames, &pMarginData);
{
MA_ZERO_MEMORY(pMarginData, marginSizeInFrames * ma_get_bytes_per_frame(pDevice->capture.format, pDevice->capture.channels));
}
ma_pcm_rb_commit_write(&pDevice->webaudio.duplexRB, marginSizeInFrames, pMarginData);
}
}

return MA_SUCCESS;
}

static ma_result ma_device_start__webaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);

if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
EM_ASM({
miniaudio.get_device_by_index($0).webaudio.resume();
}, pDevice->webaudio.indexCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
EM_ASM({
miniaudio.get_device_by_index($0).webaudio.resume();
}, pDevice->webaudio.indexPlayback);
}

return MA_SUCCESS;
}

static ma_result ma_device_stop__webaudio(ma_device* pDevice)
{
MA_ASSERT(pDevice != NULL);











if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
EM_ASM({
miniaudio.get_device_by_index($0).webaudio.suspend();
}, pDevice->webaudio.indexCapture);
}

if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
EM_ASM({
miniaudio.get_device_by_index($0).webaudio.suspend();
}, pDevice->webaudio.indexPlayback);
}

ma_stop_proc onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}

return MA_SUCCESS;
}

static ma_result ma_context_uninit__webaudio(ma_context* pContext)
{
MA_ASSERT(pContext != NULL);
MA_ASSERT(pContext->backend == ma_backend_webaudio);


(void)pContext;

return MA_SUCCESS;
}

static ma_result ma_context_init__webaudio(const ma_context_config* pConfig, ma_context* pContext)
{
int resultFromJS;

MA_ASSERT(pContext != NULL);


resultFromJS = EM_ASM_INT({
if ((window.AudioContext || window.webkitAudioContext) === undefined) {
return 0; 
}

if (typeof(miniaudio) === 'undefined') {
miniaudio = {};
miniaudio.devices = []; 

miniaudio.track_device = function(device) {

for (var iDevice = 0; iDevice < miniaudio.devices.length; ++iDevice) {
if (miniaudio.devices[iDevice] == null) {
miniaudio.devices[iDevice] = device;
return iDevice;
}
}


miniaudio.devices.push(device);
return miniaudio.devices.length - 1;
};

miniaudio.untrack_device_by_index = function(deviceIndex) {

miniaudio.devices[deviceIndex] = null;


while (miniaudio.devices.length > 0) {
if (miniaudio.devices[miniaudio.devices.length-1] == null) {
miniaudio.devices.pop();
} else {
break;
}
}
};

miniaudio.untrack_device = function(device) {
for (var iDevice = 0; iDevice < miniaudio.devices.length; ++iDevice) {
if (miniaudio.devices[iDevice] == device) {
return miniaudio.untrack_device_by_index(iDevice);
}
}
};

miniaudio.get_device_by_index = function(deviceIndex) {
return miniaudio.devices[deviceIndex];
};
}

return 1;
}, 0); 

if (resultFromJS != 1) {
return MA_FAILED_TO_INIT_BACKEND;
}


pContext->isBackendAsynchronous = MA_TRUE;

pContext->onUninit = ma_context_uninit__webaudio;
pContext->onDeviceIDEqual = ma_context_is_device_id_equal__webaudio;
pContext->onEnumDevices = ma_context_enumerate_devices__webaudio;
pContext->onGetDeviceInfo = ma_context_get_device_info__webaudio;
pContext->onDeviceInit = ma_device_init__webaudio;
pContext->onDeviceUninit = ma_device_uninit__webaudio;
pContext->onDeviceStart = ma_device_start__webaudio;
pContext->onDeviceStop = ma_device_stop__webaudio;

(void)pConfig; 
return MA_SUCCESS;
}
#endif 



static ma_bool32 ma__is_channel_map_valid(const ma_channel* channelMap, ma_uint32 channels)
{

if (channelMap[0] != MA_CHANNEL_NONE) {
ma_uint32 iChannel;

if (channels == 0) {
return MA_FALSE; 
}


for (iChannel = 0; iChannel < channels; ++iChannel) {
ma_uint32 jChannel;
for (jChannel = iChannel + 1; jChannel < channels; ++jChannel) {
if (channelMap[iChannel] == channelMap[jChannel]) {
return MA_FALSE;
}
}
}
}

return MA_TRUE;
}


static ma_result ma_device__post_init_setup(ma_device* pDevice, ma_device_type deviceType)
{
ma_result result;

MA_ASSERT(pDevice != NULL);

if (deviceType == ma_device_type_capture || deviceType == ma_device_type_duplex) {
if (pDevice->capture.usingDefaultFormat) {
pDevice->capture.format = pDevice->capture.internalFormat;
}
if (pDevice->capture.usingDefaultChannels) {
pDevice->capture.channels = pDevice->capture.internalChannels;
}
if (pDevice->capture.usingDefaultChannelMap) {
if (pDevice->capture.internalChannels == pDevice->capture.channels) {
ma_channel_map_copy(pDevice->capture.channelMap, pDevice->capture.internalChannelMap, pDevice->capture.channels);
} else {
ma_get_standard_channel_map(ma_standard_channel_map_default, pDevice->capture.channels, pDevice->capture.channelMap);
}
}
}

if (deviceType == ma_device_type_playback || deviceType == ma_device_type_duplex) {
if (pDevice->playback.usingDefaultFormat) {
pDevice->playback.format = pDevice->playback.internalFormat;
}
if (pDevice->playback.usingDefaultChannels) {
pDevice->playback.channels = pDevice->playback.internalChannels;
}
if (pDevice->playback.usingDefaultChannelMap) {
if (pDevice->playback.internalChannels == pDevice->playback.channels) {
ma_channel_map_copy(pDevice->playback.channelMap, pDevice->playback.internalChannelMap, pDevice->playback.channels);
} else {
ma_get_standard_channel_map(ma_standard_channel_map_default, pDevice->playback.channels, pDevice->playback.channelMap);
}
}
}

if (pDevice->usingDefaultSampleRate) {
if (deviceType == ma_device_type_capture || deviceType == ma_device_type_duplex) {
pDevice->sampleRate = pDevice->capture.internalSampleRate;
} else {
pDevice->sampleRate = pDevice->playback.internalSampleRate;
}
}


if (deviceType == ma_device_type_capture || deviceType == ma_device_type_duplex || deviceType == ma_device_type_loopback) {

ma_data_converter_config converterConfig = ma_data_converter_config_init_default();
converterConfig.formatIn = pDevice->capture.internalFormat;
converterConfig.channelsIn = pDevice->capture.internalChannels;
converterConfig.sampleRateIn = pDevice->capture.internalSampleRate;
ma_channel_map_copy(converterConfig.channelMapIn, pDevice->capture.internalChannelMap, pDevice->capture.internalChannels);
converterConfig.formatOut = pDevice->capture.format;
converterConfig.channelsOut = pDevice->capture.channels;
converterConfig.sampleRateOut = pDevice->sampleRate;
ma_channel_map_copy(converterConfig.channelMapOut, pDevice->capture.channelMap, pDevice->capture.channels);
converterConfig.resampling.allowDynamicSampleRate = MA_FALSE;
converterConfig.resampling.algorithm = pDevice->resampling.algorithm;
converterConfig.resampling.linear.lpfCount = pDevice->resampling.linear.lpfCount;
converterConfig.resampling.speex.quality = pDevice->resampling.speex.quality;

result = ma_data_converter_init(&converterConfig, &pDevice->capture.converter);
if (result != MA_SUCCESS) {
return result;
}
}

if (deviceType == ma_device_type_playback || deviceType == ma_device_type_duplex) {

ma_data_converter_config converterConfig = ma_data_converter_config_init_default();
converterConfig.formatIn = pDevice->playback.format;
converterConfig.channelsIn = pDevice->playback.channels;
converterConfig.sampleRateIn = pDevice->sampleRate;
ma_channel_map_copy(converterConfig.channelMapIn, pDevice->playback.channelMap, pDevice->playback.channels);
converterConfig.formatOut = pDevice->playback.internalFormat;
converterConfig.channelsOut = pDevice->playback.internalChannels;
converterConfig.sampleRateOut = pDevice->playback.internalSampleRate;
ma_channel_map_copy(converterConfig.channelMapOut, pDevice->playback.internalChannelMap, pDevice->playback.internalChannels);
converterConfig.resampling.allowDynamicSampleRate = MA_FALSE;
converterConfig.resampling.algorithm = pDevice->resampling.algorithm;
converterConfig.resampling.linear.lpfCount = pDevice->resampling.linear.lpfCount;
converterConfig.resampling.speex.quality = pDevice->resampling.speex.quality;

result = ma_data_converter_init(&converterConfig, &pDevice->playback.converter);
if (result != MA_SUCCESS) {
return result;
}
}

return MA_SUCCESS;
}


static ma_thread_result MA_THREADCALL ma_worker_thread(void* pData)
{
ma_device* pDevice = (ma_device*)pData;
MA_ASSERT(pDevice != NULL);

#if defined(MA_WIN32)
ma_CoInitializeEx(pDevice->pContext, NULL, MA_COINIT_VALUE);
#endif







ma_device__set_state(pDevice, MA_STATE_STOPPED);
ma_event_signal(&pDevice->stopEvent);

for (;;) { 
ma_stop_proc onStop;


ma_event_wait(&pDevice->wakeupEvent);


pDevice->workResult = MA_SUCCESS;


if (ma_device__get_state(pDevice) == MA_STATE_UNINITIALIZED) {
break;
}






MA_ASSERT(ma_device__get_state(pDevice) == MA_STATE_STARTING);


ma_device__set_state(pDevice, MA_STATE_STARTED);
ma_event_signal(&pDevice->startEvent);

if (pDevice->pContext->onDeviceMainLoop != NULL) {
pDevice->pContext->onDeviceMainLoop(pDevice);
} else {
ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "No main loop implementation.", MA_API_NOT_FOUND);
}






if (ma_device__get_state(pDevice) != MA_STATE_UNINITIALIZED) {
if (pDevice->pContext->onDeviceStop) {
pDevice->pContext->onDeviceStop(pDevice);
}
}


onStop = pDevice->onStop;
if (onStop) {
onStop(pDevice);
}






if (ma_device__get_state(pDevice) != MA_STATE_UNINITIALIZED) {
ma_device__set_state(pDevice, MA_STATE_STOPPED);
ma_event_signal(&pDevice->stopEvent);
}
}


ma_event_signal(&pDevice->stopEvent); 

#if defined(MA_WIN32)
ma_CoUninitialize(pDevice->pContext);
#endif

return (ma_thread_result)0;
}



static ma_bool32 ma_device__is_initialized(ma_device* pDevice)
{
if (pDevice == NULL) {
return MA_FALSE;
}

return ma_device__get_state(pDevice) != MA_STATE_UNINITIALIZED;
}


#if defined(MA_WIN32)
static ma_result ma_context_uninit_backend_apis__win32(ma_context* pContext)
{
ma_CoUninitialize(pContext);
ma_dlclose(pContext, pContext->win32.hUser32DLL);
ma_dlclose(pContext, pContext->win32.hOle32DLL);
ma_dlclose(pContext, pContext->win32.hAdvapi32DLL);

return MA_SUCCESS;
}

static ma_result ma_context_init_backend_apis__win32(ma_context* pContext)
{
#if defined(MA_WIN32_DESKTOP)

pContext->win32.hOle32DLL = ma_dlopen(pContext, "ole32.dll");
if (pContext->win32.hOle32DLL == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pContext->win32.CoInitializeEx = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "CoInitializeEx");
pContext->win32.CoUninitialize = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "CoUninitialize");
pContext->win32.CoCreateInstance = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "CoCreateInstance");
pContext->win32.CoTaskMemFree = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "CoTaskMemFree");
pContext->win32.PropVariantClear = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "PropVariantClear");
pContext->win32.StringFromGUID2 = (ma_proc)ma_dlsym(pContext, pContext->win32.hOle32DLL, "StringFromGUID2");



pContext->win32.hUser32DLL = ma_dlopen(pContext, "user32.dll");
if (pContext->win32.hUser32DLL == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pContext->win32.GetForegroundWindow = (ma_proc)ma_dlsym(pContext, pContext->win32.hUser32DLL, "GetForegroundWindow");
pContext->win32.GetDesktopWindow = (ma_proc)ma_dlsym(pContext, pContext->win32.hUser32DLL, "GetDesktopWindow");



pContext->win32.hAdvapi32DLL = ma_dlopen(pContext, "advapi32.dll");
if (pContext->win32.hAdvapi32DLL == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pContext->win32.RegOpenKeyExA = (ma_proc)ma_dlsym(pContext, pContext->win32.hAdvapi32DLL, "RegOpenKeyExA");
pContext->win32.RegCloseKey = (ma_proc)ma_dlsym(pContext, pContext->win32.hAdvapi32DLL, "RegCloseKey");
pContext->win32.RegQueryValueExA = (ma_proc)ma_dlsym(pContext, pContext->win32.hAdvapi32DLL, "RegQueryValueExA");
#endif

ma_CoInitializeEx(pContext, NULL, MA_COINIT_VALUE);
return MA_SUCCESS;
}
#else
static ma_result ma_context_uninit_backend_apis__nix(ma_context* pContext)
{
#if defined(MA_USE_RUNTIME_LINKING_FOR_PTHREAD) && !defined(MA_NO_RUNTIME_LINKING)
ma_dlclose(pContext, pContext->posix.pthreadSO);
#else
(void)pContext;
#endif

return MA_SUCCESS;
}

static ma_result ma_context_init_backend_apis__nix(ma_context* pContext)
{

#if defined(MA_USE_RUNTIME_LINKING_FOR_PTHREAD) && !defined(MA_NO_RUNTIME_LINKING)
const char* libpthreadFileNames[] = {
"libpthread.so",
"libpthread.so.0",
"libpthread.dylib"
};
size_t i;

for (i = 0; i < sizeof(libpthreadFileNames) / sizeof(libpthreadFileNames[0]); ++i) {
pContext->posix.pthreadSO = ma_dlopen(pContext, libpthreadFileNames[i]);
if (pContext->posix.pthreadSO != NULL) {
break;
}
}

if (pContext->posix.pthreadSO == NULL) {
return MA_FAILED_TO_INIT_BACKEND;
}

pContext->posix.pthread_create = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_create");
pContext->posix.pthread_join = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_join");
pContext->posix.pthread_mutex_init = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_mutex_init");
pContext->posix.pthread_mutex_destroy = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_mutex_destroy");
pContext->posix.pthread_mutex_lock = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_mutex_lock");
pContext->posix.pthread_mutex_unlock = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_mutex_unlock");
pContext->posix.pthread_cond_init = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_cond_init");
pContext->posix.pthread_cond_destroy = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_cond_destroy");
pContext->posix.pthread_cond_wait = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_cond_wait");
pContext->posix.pthread_cond_signal = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_cond_signal");
pContext->posix.pthread_attr_init = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_attr_init");
pContext->posix.pthread_attr_destroy = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_attr_destroy");
pContext->posix.pthread_attr_setschedpolicy = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_attr_setschedpolicy");
pContext->posix.pthread_attr_getschedparam = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_attr_getschedparam");
pContext->posix.pthread_attr_setschedparam = (ma_proc)ma_dlsym(pContext, pContext->posix.pthreadSO, "pthread_attr_setschedparam");
#else
pContext->posix.pthread_create = (ma_proc)pthread_create;
pContext->posix.pthread_join = (ma_proc)pthread_join;
pContext->posix.pthread_mutex_init = (ma_proc)pthread_mutex_init;
pContext->posix.pthread_mutex_destroy = (ma_proc)pthread_mutex_destroy;
pContext->posix.pthread_mutex_lock = (ma_proc)pthread_mutex_lock;
pContext->posix.pthread_mutex_unlock = (ma_proc)pthread_mutex_unlock;
pContext->posix.pthread_cond_init = (ma_proc)pthread_cond_init;
pContext->posix.pthread_cond_destroy = (ma_proc)pthread_cond_destroy;
pContext->posix.pthread_cond_wait = (ma_proc)pthread_cond_wait;
pContext->posix.pthread_cond_signal = (ma_proc)pthread_cond_signal;
pContext->posix.pthread_attr_init = (ma_proc)pthread_attr_init;
pContext->posix.pthread_attr_destroy = (ma_proc)pthread_attr_destroy;
#if !defined(__EMSCRIPTEN__)
pContext->posix.pthread_attr_setschedpolicy = (ma_proc)pthread_attr_setschedpolicy;
pContext->posix.pthread_attr_getschedparam = (ma_proc)pthread_attr_getschedparam;
pContext->posix.pthread_attr_setschedparam = (ma_proc)pthread_attr_setschedparam;
#endif
#endif

return MA_SUCCESS;
}
#endif

static ma_result ma_context_init_backend_apis(ma_context* pContext)
{
ma_result result;
#if defined(MA_WIN32)
result = ma_context_init_backend_apis__win32(pContext);
#else
result = ma_context_init_backend_apis__nix(pContext);
#endif

return result;
}

static ma_result ma_context_uninit_backend_apis(ma_context* pContext)
{
ma_result result;
#if defined(MA_WIN32)
result = ma_context_uninit_backend_apis__win32(pContext);
#else
result = ma_context_uninit_backend_apis__nix(pContext);
#endif

return result;
}


static ma_bool32 ma_context_is_backend_asynchronous(ma_context* pContext)
{
return pContext->isBackendAsynchronous;
}


ma_context_config ma_context_config_init()
{
ma_context_config config;
MA_ZERO_OBJECT(&config);

return config;
}

ma_result ma_context_init(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pConfig, ma_context* pContext)
{
ma_result result;
ma_context_config config;
ma_backend defaultBackends[ma_backend_null+1];
ma_uint32 iBackend;
ma_backend* pBackendsToIterate;
ma_uint32 backendsToIterateCount;

if (pContext == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pContext);


if (pConfig != NULL) {
config = *pConfig;
} else {
config = ma_context_config_init();
}

pContext->logCallback = config.logCallback;
pContext->threadPriority = config.threadPriority;
pContext->pUserData = config.pUserData;

result = ma_allocation_callbacks_init_copy(&pContext->allocationCallbacks, &config.allocationCallbacks);
if (result != MA_SUCCESS) {
return result;
}


result = ma_context_init_backend_apis(pContext);
if (result != MA_SUCCESS) {
return result;
}

for (iBackend = 0; iBackend <= ma_backend_null; ++iBackend) {
defaultBackends[iBackend] = (ma_backend)iBackend;
}

pBackendsToIterate = (ma_backend*)backends;
backendsToIterateCount = backendCount;
if (pBackendsToIterate == NULL) {
pBackendsToIterate = (ma_backend*)defaultBackends;
backendsToIterateCount = ma_countof(defaultBackends);
}

MA_ASSERT(pBackendsToIterate != NULL);

for (iBackend = 0; iBackend < backendsToIterateCount; ++iBackend) {
ma_backend backend = pBackendsToIterate[iBackend];

result = MA_NO_BACKEND;
switch (backend) {
#if defined(MA_HAS_WASAPI)
case ma_backend_wasapi:
{
result = ma_context_init__wasapi(&config, pContext);
} break;
#endif
#if defined(MA_HAS_DSOUND)
case ma_backend_dsound:
{
result = ma_context_init__dsound(&config, pContext);
} break;
#endif
#if defined(MA_HAS_WINMM)
case ma_backend_winmm:
{
result = ma_context_init__winmm(&config, pContext);
} break;
#endif
#if defined(MA_HAS_ALSA)
case ma_backend_alsa:
{
result = ma_context_init__alsa(&config, pContext);
} break;
#endif
#if defined(MA_HAS_PULSEAUDIO)
case ma_backend_pulseaudio:
{
result = ma_context_init__pulse(&config, pContext);
} break;
#endif
#if defined(MA_HAS_JACK)
case ma_backend_jack:
{
result = ma_context_init__jack(&config, pContext);
} break;
#endif
#if defined(MA_HAS_COREAUDIO)
case ma_backend_coreaudio:
{
result = ma_context_init__coreaudio(&config, pContext);
} break;
#endif
#if defined(MA_HAS_SNDIO)
case ma_backend_sndio:
{
result = ma_context_init__sndio(&config, pContext);
} break;
#endif
#if defined(MA_HAS_AUDIO4)
case ma_backend_audio4:
{
result = ma_context_init__audio4(&config, pContext);
} break;
#endif
#if defined(MA_HAS_OSS)
case ma_backend_oss:
{
result = ma_context_init__oss(&config, pContext);
} break;
#endif
#if defined(MA_HAS_AAUDIO)
case ma_backend_aaudio:
{
result = ma_context_init__aaudio(&config, pContext);
} break;
#endif
#if defined(MA_HAS_OPENSL)
case ma_backend_opensl:
{
result = ma_context_init__opensl(&config, pContext);
} break;
#endif
#if defined(MA_HAS_WEBAUDIO)
case ma_backend_webaudio:
{
result = ma_context_init__webaudio(&config, pContext);
} break;
#endif
#if defined(MA_HAS_NULL)
case ma_backend_null:
{
result = ma_context_init__null(&config, pContext);
} break;
#endif

default: break;
}


if (result == MA_SUCCESS) {
result = ma_mutex_init(pContext, &pContext->deviceEnumLock);
if (result != MA_SUCCESS) {
ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_WARNING, "Failed to initialize mutex for device enumeration. ma_context_get_devices() is not thread safe.", MA_FAILED_TO_CREATE_MUTEX);
}
result = ma_mutex_init(pContext, &pContext->deviceInfoLock);
if (result != MA_SUCCESS) {
ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_WARNING, "Failed to initialize mutex for device info retrieval. ma_context_get_device_info() is not thread safe.", MA_FAILED_TO_CREATE_MUTEX);
}

#if defined(MA_DEBUG_OUTPUT)
printf("[miniaudio] Endian: %s\n", ma_is_little_endian() ? "LE" : "BE");
printf("[miniaudio] SSE2: %s\n", ma_has_sse2() ? "YES" : "NO");
printf("[miniaudio] AVX2: %s\n", ma_has_avx2() ? "YES" : "NO");
printf("[miniaudio] AVX512F: %s\n", ma_has_avx512f() ? "YES" : "NO");
printf("[miniaudio] NEON: %s\n", ma_has_neon() ? "YES" : "NO");
#endif

pContext->backend = backend;
return result;
}
}


MA_ZERO_OBJECT(pContext); 
return MA_NO_BACKEND;
}

ma_result ma_context_uninit(ma_context* pContext)
{
if (pContext == NULL) {
return MA_INVALID_ARGS;
}

pContext->onUninit(pContext);

ma_mutex_uninit(&pContext->deviceEnumLock);
ma_mutex_uninit(&pContext->deviceInfoLock);
ma__free_from_callbacks(pContext->pDeviceInfos, &pContext->allocationCallbacks);
ma_context_uninit_backend_apis(pContext);

return MA_SUCCESS;
}


ma_result ma_context_enumerate_devices(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData)
{
ma_result result;

if (pContext == NULL || pContext->onEnumDevices == NULL || callback == NULL) {
return MA_INVALID_ARGS;
}

ma_mutex_lock(&pContext->deviceEnumLock);
{
result = pContext->onEnumDevices(pContext, callback, pUserData);
}
ma_mutex_unlock(&pContext->deviceEnumLock);

return result;
}


static ma_bool32 ma_context_get_devices__enum_callback(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pInfo, void* pUserData)
{









const ma_uint32 bufferExpansionCount = 2;
const ma_uint32 totalDeviceInfoCount = pContext->playbackDeviceInfoCount + pContext->captureDeviceInfoCount;

if (pContext->deviceInfoCapacity >= totalDeviceInfoCount) {
ma_uint32 oldCapacity = pContext->deviceInfoCapacity;
ma_uint32 newCapacity = oldCapacity + bufferExpansionCount;
ma_device_info* pNewInfos = (ma_device_info*)ma__realloc_from_callbacks(pContext->pDeviceInfos, sizeof(*pContext->pDeviceInfos)*newCapacity, sizeof(*pContext->pDeviceInfos)*oldCapacity, &pContext->allocationCallbacks);
if (pNewInfos == NULL) {
return MA_FALSE; 
}

pContext->pDeviceInfos = pNewInfos;
pContext->deviceInfoCapacity = newCapacity;
}

if (deviceType == ma_device_type_playback) {



ma_uint32 iFirstCaptureDevice = pContext->playbackDeviceInfoCount;
size_t iCaptureDevice;
for (iCaptureDevice = totalDeviceInfoCount; iCaptureDevice > iFirstCaptureDevice; --iCaptureDevice) {
pContext->pDeviceInfos[iCaptureDevice] = pContext->pDeviceInfos[iCaptureDevice-1];
}


pContext->pDeviceInfos[iFirstCaptureDevice] = *pInfo;
pContext->playbackDeviceInfoCount += 1;
} else {

pContext->pDeviceInfos[totalDeviceInfoCount] = *pInfo;
pContext->captureDeviceInfoCount += 1;
}

(void)pUserData;
return MA_TRUE;
}

ma_result ma_context_get_devices(ma_context* pContext, ma_device_info** ppPlaybackDeviceInfos, ma_uint32* pPlaybackDeviceCount, ma_device_info** ppCaptureDeviceInfos, ma_uint32* pCaptureDeviceCount)
{
ma_result result;


if (ppPlaybackDeviceInfos != NULL) *ppPlaybackDeviceInfos = NULL;
if (pPlaybackDeviceCount != NULL) *pPlaybackDeviceCount = 0;
if (ppCaptureDeviceInfos != NULL) *ppCaptureDeviceInfos = NULL;
if (pCaptureDeviceCount != NULL) *pCaptureDeviceCount = 0;

if (pContext == NULL || pContext->onEnumDevices == NULL) {
return MA_INVALID_ARGS;
}


ma_mutex_lock(&pContext->deviceEnumLock);
{

pContext->playbackDeviceInfoCount = 0;
pContext->captureDeviceInfoCount = 0;


result = pContext->onEnumDevices(pContext, ma_context_get_devices__enum_callback, NULL);
if (result == MA_SUCCESS) {

if (ppPlaybackDeviceInfos != NULL) {
*ppPlaybackDeviceInfos = pContext->pDeviceInfos;
}
if (pPlaybackDeviceCount != NULL) {
*pPlaybackDeviceCount = pContext->playbackDeviceInfoCount;
}


if (ppCaptureDeviceInfos != NULL) {
*ppCaptureDeviceInfos = pContext->pDeviceInfos + pContext->playbackDeviceInfoCount; 
}
if (pCaptureDeviceCount != NULL) {
*pCaptureDeviceCount = pContext->captureDeviceInfoCount;
}
}
}
ma_mutex_unlock(&pContext->deviceEnumLock);

return result;
}

ma_result ma_context_get_device_info(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_share_mode shareMode, ma_device_info* pDeviceInfo)
{
ma_device_info deviceInfo;


if (pContext == NULL || pDeviceInfo == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(&deviceInfo);


if (pDeviceID != NULL) {
MA_COPY_MEMORY(&deviceInfo.id, pDeviceID, sizeof(*pDeviceID));
}


if (pContext->onGetDeviceInfo != NULL) {
ma_result result;
ma_mutex_lock(&pContext->deviceInfoLock);
{
result = pContext->onGetDeviceInfo(pContext, deviceType, pDeviceID, shareMode, &deviceInfo);
}
ma_mutex_unlock(&pContext->deviceInfoLock);


deviceInfo.minChannels = ma_max(deviceInfo.minChannels, MA_MIN_CHANNELS);
deviceInfo.maxChannels = ma_min(deviceInfo.maxChannels, MA_MAX_CHANNELS);
deviceInfo.minSampleRate = ma_max(deviceInfo.minSampleRate, MA_MIN_SAMPLE_RATE);
deviceInfo.maxSampleRate = ma_min(deviceInfo.maxSampleRate, MA_MAX_SAMPLE_RATE);

*pDeviceInfo = deviceInfo;
return result;
}


return MA_ERROR;
}

ma_bool32 ma_context_is_loopback_supported(ma_context* pContext)
{
if (pContext == NULL) {
return MA_FALSE;
}

return ma_is_loopback_supported(pContext->backend);
}


ma_device_config ma_device_config_init(ma_device_type deviceType)
{
ma_device_config config;
MA_ZERO_OBJECT(&config);
config.deviceType = deviceType;


config.resampling.algorithm = ma_resample_algorithm_linear;
config.resampling.linear.lpfCount = ma_min(MA_DEFAULT_RESAMPLER_LPF_FILTERS, MA_MAX_RESAMPLER_LPF_FILTERS);
config.resampling.speex.quality = 3;

return config;
}

ma_result ma_device_init(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;
ma_device_config config;

if (pContext == NULL) {
return ma_device_init_ex(NULL, 0, NULL, pConfig, pDevice);
}
if (pDevice == NULL) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with invalid arguments (pDevice == NULL).", MA_INVALID_ARGS);
}
if (pConfig == NULL) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with invalid arguments (pConfig == NULL).", MA_INVALID_ARGS);
}


config = *pConfig;


if (config.deviceType != ma_device_type_playback && config.deviceType != ma_device_type_capture && config.deviceType != ma_device_type_duplex && config.deviceType != ma_device_type_loopback) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with an invalid config. Device type is invalid. Make sure the device type has been set in the config.", MA_INVALID_DEVICE_CONFIG);
}

if (config.deviceType == ma_device_type_capture || config.deviceType == ma_device_type_duplex) {
if (config.capture.channels > MA_MAX_CHANNELS) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with an invalid config. Capture channel count cannot exceed 32.", MA_INVALID_DEVICE_CONFIG);
}
if (!ma__is_channel_map_valid(config.capture.channelMap, config.capture.channels)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with invalid config. Capture channel map is invalid.", MA_INVALID_DEVICE_CONFIG);
}
}

if (config.deviceType == ma_device_type_playback || config.deviceType == ma_device_type_duplex || config.deviceType == ma_device_type_loopback) {
if (config.playback.channels > MA_MAX_CHANNELS) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with an invalid config. Playback channel count cannot exceed 32.", MA_INVALID_DEVICE_CONFIG);
}
if (!ma__is_channel_map_valid(config.playback.channelMap, config.playback.channels)) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "ma_device_init() called with invalid config. Playback channel map is invalid.", MA_INVALID_DEVICE_CONFIG);
}
}


MA_ZERO_OBJECT(pDevice);
pDevice->pContext = pContext;


pDevice->pUserData = config.pUserData;
pDevice->onData = config.dataCallback;
pDevice->onStop = config.stopCallback;

if (((ma_uintptr)pDevice % sizeof(pDevice)) != 0) {
if (pContext->logCallback) {
pContext->logCallback(pContext, pDevice, MA_LOG_LEVEL_WARNING, "WARNING: ma_device_init() called for a device that is not properly aligned. Thread safety is not supported.");
}
}

pDevice->noPreZeroedOutputBuffer = config.noPreZeroedOutputBuffer;
pDevice->noClip = config.noClip;
pDevice->masterVolumeFactor = 1;





if (config.sampleRate == 0) {
config.sampleRate = MA_DEFAULT_SAMPLE_RATE;
pDevice->usingDefaultSampleRate = MA_TRUE;
}

if (config.capture.format == ma_format_unknown) {
config.capture.format = MA_DEFAULT_FORMAT;
pDevice->capture.usingDefaultFormat = MA_TRUE;
}
if (config.capture.channels == 0) {
config.capture.channels = MA_DEFAULT_CHANNELS;
pDevice->capture.usingDefaultChannels = MA_TRUE;
}
if (config.capture.channelMap[0] == MA_CHANNEL_NONE) {
pDevice->capture.usingDefaultChannelMap = MA_TRUE;
}

if (config.playback.format == ma_format_unknown) {
config.playback.format = MA_DEFAULT_FORMAT;
pDevice->playback.usingDefaultFormat = MA_TRUE;
}
if (config.playback.channels == 0) {
config.playback.channels = MA_DEFAULT_CHANNELS;
pDevice->playback.usingDefaultChannels = MA_TRUE;
}
if (config.playback.channelMap[0] == MA_CHANNEL_NONE) {
pDevice->playback.usingDefaultChannelMap = MA_TRUE;
}



if (config.periods == 0) {
config.periods = MA_DEFAULT_PERIODS;
pDevice->usingDefaultPeriods = MA_TRUE;
}





if (config.deviceType == ma_device_type_duplex && config.periods < 3) {
config.periods = 3;
}


if (config.periodSizeInMilliseconds == 0 && config.periodSizeInFrames == 0) {
config.periodSizeInMilliseconds = (config.performanceProfile == ma_performance_profile_low_latency) ? MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_LOW_LATENCY : MA_DEFAULT_PERIOD_SIZE_IN_MILLISECONDS_CONSERVATIVE;
pDevice->usingDefaultBufferSize = MA_TRUE;
}



pDevice->type = config.deviceType;
pDevice->sampleRate = config.sampleRate;
pDevice->resampling.algorithm = config.resampling.algorithm;
pDevice->resampling.linear.lpfCount = config.resampling.linear.lpfCount;
pDevice->resampling.speex.quality = config.resampling.speex.quality;

pDevice->capture.shareMode = config.capture.shareMode;
pDevice->capture.format = config.capture.format;
pDevice->capture.channels = config.capture.channels;
ma_channel_map_copy(pDevice->capture.channelMap, config.capture.channelMap, config.capture.channels);

pDevice->playback.shareMode = config.playback.shareMode;
pDevice->playback.format = config.playback.format;
pDevice->playback.channels = config.playback.channels;
ma_channel_map_copy(pDevice->playback.channelMap, config.playback.channelMap, config.playback.channels);



pDevice->capture.internalFormat = pDevice->capture.format;
pDevice->capture.internalChannels = pDevice->capture.channels;
pDevice->capture.internalSampleRate = pDevice->sampleRate;
ma_channel_map_copy(pDevice->capture.internalChannelMap, pDevice->capture.channelMap, pDevice->capture.channels);

pDevice->playback.internalFormat = pDevice->playback.format;
pDevice->playback.internalChannels = pDevice->playback.channels;
pDevice->playback.internalSampleRate = pDevice->sampleRate;
ma_channel_map_copy(pDevice->playback.internalChannelMap, pDevice->playback.channelMap, pDevice->playback.channels);


if (ma_mutex_init(pContext, &pDevice->lock) != MA_SUCCESS) {
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "Failed to create mutex.", MA_FAILED_TO_CREATE_MUTEX);
}








if (ma_event_init(pContext, &pDevice->wakeupEvent) != MA_SUCCESS) {
ma_mutex_uninit(&pDevice->lock);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "Failed to create worker thread wakeup event.", MA_FAILED_TO_CREATE_EVENT);
}
if (ma_event_init(pContext, &pDevice->startEvent) != MA_SUCCESS) {
ma_event_uninit(&pDevice->wakeupEvent);
ma_mutex_uninit(&pDevice->lock);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "Failed to create worker thread start event.", MA_FAILED_TO_CREATE_EVENT);
}
if (ma_event_init(pContext, &pDevice->stopEvent) != MA_SUCCESS) {
ma_event_uninit(&pDevice->startEvent);
ma_event_uninit(&pDevice->wakeupEvent);
ma_mutex_uninit(&pDevice->lock);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "Failed to create worker thread stop event.", MA_FAILED_TO_CREATE_EVENT);
}


result = pContext->onDeviceInit(pContext, &config, pDevice);
if (result != MA_SUCCESS) {
return result;
}

ma_device__post_init_setup(pDevice, pConfig->deviceType);



if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
if (pDevice->capture.name[0] == '\0') {
if (ma_context__try_get_device_name_by_id(pContext, ma_device_type_capture, config.capture.pDeviceID, pDevice->capture.name, sizeof(pDevice->capture.name)) != MA_SUCCESS) {
ma_strncpy_s(pDevice->capture.name, sizeof(pDevice->capture.name), (config.capture.pDeviceID == NULL) ? MA_DEFAULT_CAPTURE_DEVICE_NAME : "Capture Device", (size_t)-1);
}
}
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex || pDevice->type == ma_device_type_loopback) {
if (pDevice->playback.name[0] == '\0') {
if (ma_context__try_get_device_name_by_id(pContext, ma_device_type_playback, config.playback.pDeviceID, pDevice->playback.name, sizeof(pDevice->playback.name)) != MA_SUCCESS) {
ma_strncpy_s(pDevice->playback.name, sizeof(pDevice->playback.name), (config.playback.pDeviceID == NULL) ? MA_DEFAULT_PLAYBACK_DEVICE_NAME : "Playback Device", (size_t)-1);
}
}
}



if (!ma_context_is_backend_asynchronous(pContext)) {

if (ma_thread_create(pContext, &pDevice->thread, ma_worker_thread, pDevice) != MA_SUCCESS) {
ma_device_uninit(pDevice);
return ma_context_post_error(pContext, NULL, MA_LOG_LEVEL_ERROR, "Failed to create worker thread.", MA_FAILED_TO_CREATE_THREAD);
}


ma_event_wait(&pDevice->stopEvent);
} else {
ma_device__set_state(pDevice, MA_STATE_STOPPED);
}


#if defined(MA_DEBUG_OUTPUT)
printf("[%s]\n", ma_get_backend_name(pDevice->pContext->backend));
if (pDevice->type == ma_device_type_capture || pDevice->type == ma_device_type_duplex) {
printf(" %s (%s)\n", pDevice->capture.name, "Capture");
printf(" Format: %s -> %s\n", ma_get_format_name(pDevice->capture.format), ma_get_format_name(pDevice->capture.internalFormat));
printf(" Channels: %d -> %d\n", pDevice->capture.channels, pDevice->capture.internalChannels);
printf(" Sample Rate: %d -> %d\n", pDevice->sampleRate, pDevice->capture.internalSampleRate);
printf(" Buffer Size: %d*%d (%d)\n", pDevice->capture.internalPeriodSizeInFrames, pDevice->capture.internalPeriods, (pDevice->capture.internalPeriodSizeInFrames * pDevice->capture.internalPeriods));
printf(" Conversion:\n");
printf(" Pre Format Conversion: %s\n", pDevice->capture.converter.hasPreFormatConversion ? "YES" : "NO");
printf(" Post Format Conversion: %s\n", pDevice->capture.converter.hasPostFormatConversion ? "YES" : "NO");
printf(" Channel Routing: %s\n", pDevice->capture.converter.hasChannelConverter ? "YES" : "NO");
printf(" Resampling: %s\n", pDevice->capture.converter.hasResampler ? "YES" : "NO");
printf(" Passthrough: %s\n", pDevice->capture.converter.isPassthrough ? "YES" : "NO");
}
if (pDevice->type == ma_device_type_playback || pDevice->type == ma_device_type_duplex) {
printf(" %s (%s)\n", pDevice->playback.name, "Playback");
printf(" Format: %s -> %s\n", ma_get_format_name(pDevice->playback.format), ma_get_format_name(pDevice->playback.internalFormat));
printf(" Channels: %d -> %d\n", pDevice->playback.channels, pDevice->playback.internalChannels);
printf(" Sample Rate: %d -> %d\n", pDevice->sampleRate, pDevice->playback.internalSampleRate);
printf(" Buffer Size: %d*%d (%d)\n", pDevice->playback.internalPeriodSizeInFrames, pDevice->playback.internalPeriods, (pDevice->playback.internalPeriodSizeInFrames * pDevice->playback.internalPeriods));
printf(" Conversion:\n");
printf(" Pre Format Conversion: %s\n", pDevice->playback.converter.hasPreFormatConversion ? "YES" : "NO");
printf(" Post Format Conversion: %s\n", pDevice->playback.converter.hasPostFormatConversion ? "YES" : "NO");
printf(" Channel Routing: %s\n", pDevice->playback.converter.hasChannelConverter ? "YES" : "NO");
printf(" Resampling: %s\n", pDevice->playback.converter.hasResampler ? "YES" : "NO");
printf(" Passthrough: %s\n", pDevice->playback.converter.isPassthrough ? "YES" : "NO");
}
#endif


MA_ASSERT(ma_device__get_state(pDevice) == MA_STATE_STOPPED);
return MA_SUCCESS;
}

ma_result ma_device_init_ex(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pContextConfig, const ma_device_config* pConfig, ma_device* pDevice)
{
ma_result result;
ma_context* pContext;
ma_backend defaultBackends[ma_backend_null+1];
ma_uint32 iBackend;
ma_backend* pBackendsToIterate;
ma_uint32 backendsToIterateCount;
ma_allocation_callbacks allocationCallbacks;

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

if (pContextConfig != NULL) {
result = ma_allocation_callbacks_init_copy(&allocationCallbacks, &pContextConfig->allocationCallbacks);
if (result != MA_SUCCESS) {
return result;
}
} else {
allocationCallbacks = ma_allocation_callbacks_init_default();
}


pContext = (ma_context*)ma__malloc_from_callbacks(sizeof(*pContext), &allocationCallbacks);
if (pContext == NULL) {
return MA_OUT_OF_MEMORY;
}

for (iBackend = 0; iBackend <= ma_backend_null; ++iBackend) {
defaultBackends[iBackend] = (ma_backend)iBackend;
}

pBackendsToIterate = (ma_backend*)backends;
backendsToIterateCount = backendCount;
if (pBackendsToIterate == NULL) {
pBackendsToIterate = (ma_backend*)defaultBackends;
backendsToIterateCount = ma_countof(defaultBackends);
}

result = MA_NO_BACKEND;

for (iBackend = 0; iBackend < backendsToIterateCount; ++iBackend) {
result = ma_context_init(&pBackendsToIterate[iBackend], 1, pContextConfig, pContext);
if (result == MA_SUCCESS) {
result = ma_device_init(pContext, pConfig, pDevice);
if (result == MA_SUCCESS) {
break; 
} else {
ma_context_uninit(pContext); 
}
}
}

if (result != MA_SUCCESS) {
ma__free_from_callbacks(pContext, &allocationCallbacks);
return result;
}

pDevice->isOwnerOfContext = MA_TRUE;
return result;
}

void ma_device_uninit(ma_device* pDevice)
{
if (!ma_device__is_initialized(pDevice)) {
return;
}


if (ma_device_is_started(pDevice)) {
ma_device_stop(pDevice);
}


ma_device__set_state(pDevice, MA_STATE_UNINITIALIZED);


if (!ma_context_is_backend_asynchronous(pDevice->pContext)) {
ma_event_signal(&pDevice->wakeupEvent);
ma_thread_wait(&pDevice->thread);
}

pDevice->pContext->onDeviceUninit(pDevice);

ma_event_uninit(&pDevice->stopEvent);
ma_event_uninit(&pDevice->startEvent);
ma_event_uninit(&pDevice->wakeupEvent);
ma_mutex_uninit(&pDevice->lock);

if (pDevice->isOwnerOfContext) {
ma_allocation_callbacks allocationCallbacks = pDevice->pContext->allocationCallbacks;

ma_context_uninit(pDevice->pContext);
ma__free_from_callbacks(pDevice->pContext, &allocationCallbacks);
}

MA_ZERO_OBJECT(pDevice);
}

ma_result ma_device_start(ma_device* pDevice)
{
ma_result result;

if (pDevice == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "ma_device_start() called with invalid arguments (pDevice == NULL).", MA_INVALID_ARGS);
}

if (ma_device__get_state(pDevice) == MA_STATE_UNINITIALIZED) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "ma_device_start() called for an uninitialized device.", MA_DEVICE_NOT_INITIALIZED);
}

if (ma_device__get_state(pDevice) == MA_STATE_STARTED) {
return ma_post_error(pDevice, MA_LOG_LEVEL_WARNING, "ma_device_start() called when the device is already started.", MA_INVALID_OPERATION); 
}

result = MA_ERROR;
ma_mutex_lock(&pDevice->lock);
{

MA_ASSERT(ma_device__get_state(pDevice) == MA_STATE_STOPPED);

ma_device__set_state(pDevice, MA_STATE_STARTING);


if (ma_context_is_backend_asynchronous(pDevice->pContext)) {
result = pDevice->pContext->onDeviceStart(pDevice);
if (result == MA_SUCCESS) {
ma_device__set_state(pDevice, MA_STATE_STARTED);
}
} else {




ma_event_signal(&pDevice->wakeupEvent);





ma_event_wait(&pDevice->startEvent);
result = pDevice->workResult;
}
}
ma_mutex_unlock(&pDevice->lock);

return result;
}

ma_result ma_device_stop(ma_device* pDevice)
{
ma_result result;

if (pDevice == NULL) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "ma_device_stop() called with invalid arguments (pDevice == NULL).", MA_INVALID_ARGS);
}

if (ma_device__get_state(pDevice) == MA_STATE_UNINITIALIZED) {
return ma_post_error(pDevice, MA_LOG_LEVEL_ERROR, "ma_device_stop() called for an uninitialized device.", MA_DEVICE_NOT_INITIALIZED);
}

if (ma_device__get_state(pDevice) == MA_STATE_STOPPED) {
return ma_post_error(pDevice, MA_LOG_LEVEL_WARNING, "ma_device_stop() called when the device is already stopped.", MA_INVALID_OPERATION); 
}

result = MA_ERROR;
ma_mutex_lock(&pDevice->lock);
{

MA_ASSERT(ma_device__get_state(pDevice) == MA_STATE_STARTED);

ma_device__set_state(pDevice, MA_STATE_STOPPING);



if (pDevice->pContext->onDeviceStop) {
result = pDevice->pContext->onDeviceStop(pDevice);
} else {
result = MA_SUCCESS;
}


if (ma_context_is_backend_asynchronous(pDevice->pContext)) {
ma_device__set_state(pDevice, MA_STATE_STOPPED);
} else {






ma_event_wait(&pDevice->stopEvent);
result = MA_SUCCESS;
}
}
ma_mutex_unlock(&pDevice->lock);

return result;
}

ma_bool32 ma_device_is_started(ma_device* pDevice)
{
if (pDevice == NULL) {
return MA_FALSE;
}

return ma_device__get_state(pDevice) == MA_STATE_STARTED;
}

ma_result ma_device_set_master_volume(ma_device* pDevice, float volume)
{
if (pDevice == NULL) {
return MA_INVALID_ARGS;
}

if (volume < 0.0f || volume > 1.0f) {
return MA_INVALID_ARGS;
}

pDevice->masterVolumeFactor = volume;

return MA_SUCCESS;
}

ma_result ma_device_get_master_volume(ma_device* pDevice, float* pVolume)
{
if (pVolume == NULL) {
return MA_INVALID_ARGS;
}

if (pDevice == NULL) {
*pVolume = 0;
return MA_INVALID_ARGS;
}

*pVolume = pDevice->masterVolumeFactor;

return MA_SUCCESS;
}

ma_result ma_device_set_master_gain_db(ma_device* pDevice, float gainDB)
{
if (gainDB > 0) {
return MA_INVALID_ARGS;
}

return ma_device_set_master_volume(pDevice, ma_gain_db_to_factor(gainDB));
}

ma_result ma_device_get_master_gain_db(ma_device* pDevice, float* pGainDB)
{
float factor;
ma_result result;

if (pGainDB == NULL) {
return MA_INVALID_ARGS;
}

result = ma_device_get_master_volume(pDevice, &factor);
if (result != MA_SUCCESS) {
*pGainDB = 0;
return result;
}

*pGainDB = ma_factor_to_gain_db(factor);

return MA_SUCCESS;
}
#endif 







#if !defined(MA_BIQUAD_FIXED_POINT_SHIFT)
#define MA_BIQUAD_FIXED_POINT_SHIFT 14
#endif

static ma_int32 ma_biquad_float_to_fp(double x)
{
return (ma_int32)(x * (1 << MA_BIQUAD_FIXED_POINT_SHIFT));
}

ma_biquad_config ma_biquad_config_init(ma_format format, ma_uint32 channels, double b0, double b1, double b2, double a0, double a1, double a2)
{
ma_biquad_config config;

MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.b0 = b0;
config.b1 = b1;
config.b2 = b2;
config.a0 = a0;
config.a1 = a1;
config.a2 = a2;

return config;
}

ma_result ma_biquad_init(const ma_biquad_config* pConfig, ma_biquad* pBQ)
{
if (pBQ == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pBQ);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

return ma_biquad_reinit(pConfig, pBQ);
}

ma_result ma_biquad_reinit(const ma_biquad_config* pConfig, ma_biquad* pBQ)
{
if (pBQ == NULL || pConfig == NULL) {
return MA_INVALID_ARGS;
}

if (pConfig->a0 == 0) {
return MA_INVALID_ARGS; 
}


if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
return MA_INVALID_ARGS;
}


if (pBQ->format != ma_format_unknown && pBQ->format != pConfig->format) {
return MA_INVALID_OPERATION;
}


if (pBQ->channels != 0 && pBQ->channels != pConfig->channels) {
return MA_INVALID_OPERATION;
}


pBQ->format = pConfig->format;
pBQ->channels = pConfig->channels;


if (pConfig->format == ma_format_f32) {
pBQ->b0.f32 = (float)(pConfig->b0 / pConfig->a0);
pBQ->b1.f32 = (float)(pConfig->b1 / pConfig->a0);
pBQ->b2.f32 = (float)(pConfig->b2 / pConfig->a0);
pBQ->a1.f32 = (float)(pConfig->a1 / pConfig->a0);
pBQ->a2.f32 = (float)(pConfig->a2 / pConfig->a0);
} else {
pBQ->b0.s32 = ma_biquad_float_to_fp(pConfig->b0 / pConfig->a0);
pBQ->b1.s32 = ma_biquad_float_to_fp(pConfig->b1 / pConfig->a0);
pBQ->b2.s32 = ma_biquad_float_to_fp(pConfig->b2 / pConfig->a0);
pBQ->a1.s32 = ma_biquad_float_to_fp(pConfig->a1 / pConfig->a0);
pBQ->a2.s32 = ma_biquad_float_to_fp(pConfig->a2 / pConfig->a0);
}

return MA_SUCCESS;
}

static MA_INLINE void ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(ma_biquad* pBQ, float* pY, const float* pX)
{
ma_uint32 c;
const float b0 = pBQ->b0.f32;
const float b1 = pBQ->b1.f32;
const float b2 = pBQ->b2.f32;
const float a1 = pBQ->a1.f32;
const float a2 = pBQ->a2.f32;

for (c = 0; c < pBQ->channels; c += 1) {
float r1 = pBQ->r1[c].f32;
float r2 = pBQ->r2[c].f32;
float x = pX[c];
float y;

y = b0*x + r1;
r1 = b1*x - a1*y + r2;
r2 = b2*x - a2*y;

pY[c] = y;
pBQ->r1[c].f32 = r1;
pBQ->r2[c].f32 = r2;
}
}

static MA_INLINE void ma_biquad_process_pcm_frame_f32(ma_biquad* pBQ, float* pY, const float* pX)
{
ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(pBQ, pY, pX);
}

static MA_INLINE void ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(ma_biquad* pBQ, ma_int16* pY, const ma_int16* pX)
{
ma_uint32 c;
const ma_int32 b0 = pBQ->b0.s32;
const ma_int32 b1 = pBQ->b1.s32;
const ma_int32 b2 = pBQ->b2.s32;
const ma_int32 a1 = pBQ->a1.s32;
const ma_int32 a2 = pBQ->a2.s32;

for (c = 0; c < pBQ->channels; c += 1) {
ma_int32 r1 = pBQ->r1[c].s32;
ma_int32 r2 = pBQ->r2[c].s32;
ma_int32 x = pX[c];
ma_int32 y;

y = (b0*x + r1) >> MA_BIQUAD_FIXED_POINT_SHIFT;
r1 = (b1*x - a1*y + r2);
r2 = (b2*x - a2*y);

pY[c] = (ma_int16)ma_clamp(y, -32768, 32767);
pBQ->r1[c].s32 = r1;
pBQ->r2[c].s32 = r2;
}
}

static MA_INLINE void ma_biquad_process_pcm_frame_s16(ma_biquad* pBQ, ma_int16* pY, const ma_int16* pX)
{
ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(pBQ, pY, pX);
}

ma_result ma_biquad_process_pcm_frames(ma_biquad* pBQ, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
ma_uint32 n;

if (pBQ == NULL || pFramesOut == NULL || pFramesIn == NULL) {
return MA_INVALID_ARGS;
}



if (pBQ->format == ma_format_f32) {
float* pY = ( float*)pFramesOut;
const float* pX = (const float*)pFramesIn;

for (n = 0; n < frameCount; n += 1) {
ma_biquad_process_pcm_frame_f32__direct_form_2_transposed(pBQ, pY, pX);
pY += pBQ->channels;
pX += pBQ->channels;
}
} else if (pBQ->format == ma_format_s16) {
ma_int16* pY = ( ma_int16*)pFramesOut;
const ma_int16* pX = (const ma_int16*)pFramesIn;

for (n = 0; n < frameCount; n += 1) {
ma_biquad_process_pcm_frame_s16__direct_form_2_transposed(pBQ, pY, pX);
pY += pBQ->channels;
pX += pBQ->channels;
}
} else {
MA_ASSERT(MA_FALSE);
return MA_INVALID_ARGS; 
}

return MA_SUCCESS;
}

ma_uint32 ma_biquad_get_latency(ma_biquad* pBQ)
{
if (pBQ == NULL) {
return 0;
}

return 2;
}







ma_lpf_config ma_lpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)
{
ma_lpf_config config;

MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.sampleRate = sampleRate;
config.cutoffFrequency = cutoffFrequency;

return config;
}

static MA_INLINE ma_biquad_config ma_lpf__get_biquad_config(const ma_lpf_config* pConfig)
{
ma_biquad_config bqConfig;
double q;
double w;
double s;
double c;
double a;

MA_ASSERT(pConfig != NULL);

q = 0.707107;
w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
s = ma_sin(w);
c = ma_cos(w);
a = s / (2*q);

bqConfig.b0 = (1 - c) / 2;
bqConfig.b1 = 1 - c;
bqConfig.b2 = (1 - c) / 2;
bqConfig.a0 = 1 + a;
bqConfig.a1 = -2 * c;
bqConfig.a2 = 1 - a;

bqConfig.format = pConfig->format;
bqConfig.channels = pConfig->channels;

return bqConfig;
}

ma_result ma_lpf_init(const ma_lpf_config* pConfig, ma_lpf* pLPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pLPF == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pLPF);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_lpf__get_biquad_config(pConfig);
result = ma_biquad_init(&bqConfig, &pLPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

ma_result ma_lpf_reinit(const ma_lpf_config* pConfig, ma_lpf* pLPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pLPF == NULL || pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_lpf__get_biquad_config(pConfig);
result = ma_biquad_reinit(&bqConfig, &pLPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

static MA_INLINE void ma_lpf_process_pcm_frame_s16(ma_lpf* pLPF, ma_int16* pFrameOut, const ma_int16* pFrameIn)
{
ma_biquad_process_pcm_frame_s16(&pLPF->bq, pFrameOut, pFrameIn);
}

static MA_INLINE void ma_lpf_process_pcm_frame_f32(ma_lpf* pLPF, float* pFrameOut, const float* pFrameIn)
{
ma_biquad_process_pcm_frame_f32(&pLPF->bq, pFrameOut, pFrameIn);
}

ma_result ma_lpf_process_pcm_frames(ma_lpf* pLPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
if (pLPF == NULL) {
return MA_INVALID_ARGS;
}

return ma_biquad_process_pcm_frames(&pLPF->bq, pFramesOut, pFramesIn, frameCount);
}

ma_uint32 ma_lpf_get_latency(ma_lpf* pLPF)
{
if (pLPF == NULL) {
return 0;
}

return ma_biquad_get_latency(&pLPF->bq);
}







ma_hpf_config ma_hpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)
{
ma_hpf_config config;

MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.sampleRate = sampleRate;
config.cutoffFrequency = cutoffFrequency;

return config;
}

static MA_INLINE ma_biquad_config ma_hpf__get_biquad_config(const ma_hpf_config* pConfig)
{
ma_biquad_config bqConfig;
double q;
double w;
double s;
double c;
double a;

MA_ASSERT(pConfig != NULL);

q = 0.707107;
w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
s = ma_sin(w);
c = ma_cos(w);
a = s / (2*q);

bqConfig.b0 = (1 + c) / 2;
bqConfig.b1 = -(1 + c);
bqConfig.b2 = (1 + c) / 2;
bqConfig.a0 = 1 + a;
bqConfig.a1 = -2 * c;
bqConfig.a2 = 1 - a;

bqConfig.format = pConfig->format;
bqConfig.channels = pConfig->channels;

return bqConfig;
}

ma_result ma_hpf_init(const ma_hpf_config* pConfig, ma_hpf* pHPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pHPF == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pHPF);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_hpf__get_biquad_config(pConfig);
result = ma_biquad_init(&bqConfig, &pHPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

ma_result ma_hpf_reinit(const ma_hpf_config* pConfig, ma_hpf* pHPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pHPF == NULL || pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_hpf__get_biquad_config(pConfig);
result = ma_biquad_reinit(&bqConfig, &pHPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

ma_result ma_hpf_process_pcm_frames(ma_hpf* pHPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
if (pHPF == NULL) {
return MA_INVALID_ARGS;
}

return ma_biquad_process_pcm_frames(&pHPF->bq, pFramesOut, pFramesIn, frameCount);
}

ma_uint32 ma_hpf_get_latency(ma_hpf* pHPF)
{
if (pHPF == NULL) {
return 0;
}

return ma_biquad_get_latency(&pHPF->bq);
}







ma_bpf_config ma_bpf_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRate, double cutoffFrequency)
{
ma_bpf_config config;

MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.sampleRate = sampleRate;
config.cutoffFrequency = cutoffFrequency;

return config;
}


static MA_INLINE ma_biquad_config ma_bpf__get_biquad_config(const ma_bpf_config* pConfig)
{
ma_biquad_config bqConfig;
double q;
double w;
double s;
double c;
double a;

MA_ASSERT(pConfig != NULL);

q = 0.707107;
w = 2 * MA_PI_D * pConfig->cutoffFrequency / pConfig->sampleRate;
s = ma_sin(w);
c = ma_cos(w);
a = s / (2*q);

bqConfig.b0 = q * a;
bqConfig.b1 = 0;
bqConfig.b2 = -q * a;
bqConfig.a0 = 1 + a;
bqConfig.a1 = -2 * c;
bqConfig.a2 = 1 - a;

bqConfig.format = pConfig->format;
bqConfig.channels = pConfig->channels;

return bqConfig;
}

ma_result ma_bpf_init(const ma_bpf_config* pConfig, ma_bpf* pBPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pBPF == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pBPF);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_bpf__get_biquad_config(pConfig);
result = ma_biquad_init(&bqConfig, &pBPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

ma_result ma_bpf_reinit(const ma_bpf_config* pConfig, ma_bpf* pBPF)
{
ma_result result;
ma_biquad_config bqConfig;

if (pBPF == NULL || pConfig == NULL) {
return MA_INVALID_ARGS;
}

bqConfig = ma_bpf__get_biquad_config(pConfig);
result = ma_biquad_reinit(&bqConfig, &pBPF->bq);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

ma_result ma_bpf_process_pcm_frames(ma_bpf* pBPF, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
if (pBPF == NULL) {
return MA_INVALID_ARGS;
}

return ma_biquad_process_pcm_frames(&pBPF->bq, pFramesOut, pFramesIn, frameCount);
}

ma_uint32 ma_bpf_get_latency(ma_bpf* pBPF)
{
if (pBPF == NULL) {
return 0;
}

return ma_biquad_get_latency(&pBPF->bq);
}








ma_linear_resampler_config ma_linear_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
ma_linear_resampler_config config;
MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.sampleRateIn = sampleRateIn;
config.sampleRateOut = sampleRateOut;
config.lpfCount = 1;
config.lpfNyquistFactor = 1;

return config;
}

static ma_result ma_linear_resampler_set_rate_internal(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_bool32 isResamplerAlreadyInitialized)
{
ma_uint32 gcf;

if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

if (sampleRateIn == 0 || sampleRateOut == 0) {
return MA_INVALID_ARGS;
}


gcf = ma_gcf_u32(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut);
pResampler->config.sampleRateIn /= gcf;
pResampler->config.sampleRateOut /= gcf;

if (pResampler->config.lpfCount > 0) {
ma_result result;
ma_uint32 iFilter;
ma_uint32 lpfSampleRate;
double lpfCutoffFrequency;
ma_lpf_config lpfConfig;

if (pResampler->config.lpfCount > MA_MAX_RESAMPLER_LPF_FILTERS) {
return MA_INVALID_ARGS;
}

lpfSampleRate = (ma_uint32)(ma_max(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut));
lpfCutoffFrequency = ( double)(ma_min(pResampler->config.sampleRateIn, pResampler->config.sampleRateOut) * 0.5 * pResampler->config.lpfNyquistFactor);

lpfConfig = ma_lpf_config_init(pResampler->config.format, pResampler->config.channels, lpfSampleRate, lpfCutoffFrequency);





result = MA_SUCCESS;
for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
if (isResamplerAlreadyInitialized) {
result = ma_lpf_reinit(&lpfConfig, &pResampler->lpf[iFilter]);
} else {
result = ma_lpf_init(&lpfConfig, &pResampler->lpf[iFilter]);
}

if (result != MA_SUCCESS) {
break;
}
}

if (result != MA_SUCCESS) {
return result; 
}
}

pResampler->inAdvanceInt = pResampler->config.sampleRateIn / pResampler->config.sampleRateOut;
pResampler->inAdvanceFrac = pResampler->config.sampleRateIn % pResampler->config.sampleRateOut;


pResampler->inTimeInt += pResampler->inTimeFrac / pResampler->config.sampleRateOut;
pResampler->inTimeFrac = pResampler->inTimeFrac % pResampler->config.sampleRateOut;

return MA_SUCCESS;
}

ma_result ma_linear_resampler_init(const ma_linear_resampler_config* pConfig, ma_linear_resampler* pResampler)
{
ma_result result;

if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pResampler);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

pResampler->config = *pConfig;


result = ma_linear_resampler_set_rate_internal(pResampler, pConfig->sampleRateIn, pConfig->sampleRateOut, MA_FALSE);
if (result != MA_SUCCESS) {
return result;
}

pResampler->inTimeInt = 1; 
pResampler->inTimeFrac = 0;

return MA_SUCCESS;
}

void ma_linear_resampler_uninit(ma_linear_resampler* pResampler)
{
if (pResampler == NULL) {
return;
}
}

static MA_INLINE ma_int16 ma_linear_resampler_mix_s16(ma_int16 x, ma_int16 y, ma_int32 a, const ma_int32 shift)
{
ma_int32 b;
ma_int32 c;
ma_int32 r;

MA_ASSERT(a <= (1<<shift));

b = x * ((1<<shift) - a);
c = y * a;
r = b + c;

return (ma_int16)(r >> shift);
}

static void ma_linear_resampler_interpolate_frame_s16(ma_linear_resampler* pResampler, ma_int16* pFrameOut)
{
ma_uint32 c;
ma_uint32 a;
const ma_uint32 shift = 12;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameOut != NULL);

a = (pResampler->inTimeFrac << shift) / pResampler->config.sampleRateOut;

for (c = 0; c < pResampler->config.channels; c += 1) {
ma_int16 s = ma_linear_resampler_mix_s16(pResampler->x0.s16[c], pResampler->x1.s16[c], a, shift);
pFrameOut[c] = s;
}
}


static void ma_linear_resampler_interpolate_frame_f32(ma_linear_resampler* pResampler, float* pFrameOut)
{
ma_uint32 c;
float a;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameOut != NULL);

a = (float)pResampler->inTimeFrac / pResampler->config.sampleRateOut;

for (c = 0; c < pResampler->config.channels; c += 1) {
float s = ma_mix_f32_fast(pResampler->x0.f32[c], pResampler->x1.f32[c], a);
pFrameOut[c] = s;
}
}

static ma_result ma_linear_resampler_process_pcm_frames_s16_downsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
const ma_int16* pFramesInS16;
ma_int16* pFramesOutS16;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameCountIn != NULL);
MA_ASSERT(pFrameCountOut != NULL);

pFramesInS16 = (const ma_int16*)pFramesIn;
pFramesOutS16 = ( ma_int16*)pFramesOut;
frameCountIn = *pFrameCountIn;
frameCountOut = *pFrameCountOut;
framesProcessedIn = 0;
framesProcessedOut = 0;

for (;;) {
if (framesProcessedOut >= frameCountOut) {
break;
}


while (pResampler->inTimeInt > 0 && frameCountIn > 0) {
ma_uint32 iFilter;
ma_uint32 iChannel;

if (pFramesInS16 != NULL) {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
pResampler->x1.s16[iChannel] = pFramesInS16[iChannel];
}
pFramesInS16 += pResampler->config.channels;
} else {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
pResampler->x1.s16[iChannel] = 0;
}
}


for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
ma_lpf_process_pcm_frame_s16(&pResampler->lpf[iFilter], pResampler->x1.s16, pResampler->x1.s16);
}

frameCountIn -= 1;
framesProcessedIn += 1;
pResampler->inTimeInt -= 1;
}

if (pResampler->inTimeInt > 0) {
break; 
}


if (pFramesOutS16 != NULL) {
MA_ASSERT(pResampler->inTimeInt == 0);
ma_linear_resampler_interpolate_frame_s16(pResampler, pFramesOutS16);

pFramesOutS16 += pResampler->config.channels;
}

framesProcessedOut += 1;


pResampler->inTimeInt += pResampler->inAdvanceInt;
pResampler->inTimeFrac += pResampler->inAdvanceFrac;
if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
pResampler->inTimeInt += 1;
}
}

*pFrameCountIn = framesProcessedIn;
*pFrameCountOut = framesProcessedOut;

return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_s16_upsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
const ma_int16* pFramesInS16;
ma_int16* pFramesOutS16;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameCountIn != NULL);
MA_ASSERT(pFrameCountOut != NULL);

pFramesInS16 = (const ma_int16*)pFramesIn;
pFramesOutS16 = ( ma_int16*)pFramesOut;
frameCountIn = *pFrameCountIn;
frameCountOut = *pFrameCountOut;
framesProcessedIn = 0;
framesProcessedOut = 0;

for (;;) {
ma_uint32 iFilter;

if (framesProcessedOut >= frameCountOut) {
break;
}


while (pResampler->inTimeInt > 0 && frameCountIn > 0) {
ma_uint32 iChannel;

if (pFramesInS16 != NULL) {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
pResampler->x1.s16[iChannel] = pFramesInS16[iChannel];
}
pFramesInS16 += pResampler->config.channels;
} else {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.s16[iChannel] = pResampler->x1.s16[iChannel];
pResampler->x1.s16[iChannel] = 0;
}
}

frameCountIn -= 1;
framesProcessedIn += 1;
pResampler->inTimeInt -= 1;
}

if (pResampler->inTimeInt > 0) {
break; 
}


if (pFramesOutS16 != NULL) {
MA_ASSERT(pResampler->inTimeInt == 0);
ma_linear_resampler_interpolate_frame_s16(pResampler, pFramesOutS16);


for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
ma_lpf_process_pcm_frame_s16(&pResampler->lpf[iFilter], pFramesOutS16, pFramesOutS16);
}

pFramesOutS16 += pResampler->config.channels;
}

framesProcessedOut += 1;


pResampler->inTimeInt += pResampler->inAdvanceInt;
pResampler->inTimeFrac += pResampler->inAdvanceFrac;
if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
pResampler->inTimeInt += 1;
}
}

*pFrameCountIn = framesProcessedIn;
*pFrameCountOut = framesProcessedOut;

return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_s16(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pResampler != NULL);

if (pResampler->config.sampleRateIn > pResampler->config.sampleRateOut) {
return ma_linear_resampler_process_pcm_frames_s16_downsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {
return ma_linear_resampler_process_pcm_frames_s16_upsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
}


static ma_result ma_linear_resampler_process_pcm_frames_f32_downsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
const float* pFramesInF32;
float* pFramesOutF32;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameCountIn != NULL);
MA_ASSERT(pFrameCountOut != NULL);

pFramesInF32 = (const float*)pFramesIn;
pFramesOutF32 = ( float*)pFramesOut;
frameCountIn = *pFrameCountIn;
frameCountOut = *pFrameCountOut;
framesProcessedIn = 0;
framesProcessedOut = 0;

for (;;) {
if (framesProcessedOut >= frameCountOut) {
break;
}


while (pResampler->inTimeInt > 0 && frameCountIn > 0) {
ma_uint32 iFilter;
ma_uint32 iChannel;

if (pFramesInF32 != NULL) {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
pResampler->x1.f32[iChannel] = pFramesInF32[iChannel];
}
pFramesInF32 += pResampler->config.channels;
} else {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
pResampler->x1.f32[iChannel] = 0;
}
}


for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
ma_lpf_process_pcm_frame_f32(&pResampler->lpf[iFilter], pResampler->x1.f32, pResampler->x1.f32);
}

frameCountIn -= 1;
framesProcessedIn += 1;
pResampler->inTimeInt -= 1;
}

if (pResampler->inTimeInt > 0) {
break; 
}


if (pFramesOutF32 != NULL) {
MA_ASSERT(pResampler->inTimeInt == 0);
ma_linear_resampler_interpolate_frame_f32(pResampler, pFramesOutF32);

pFramesOutF32 += pResampler->config.channels;
}

framesProcessedOut += 1;


pResampler->inTimeInt += pResampler->inAdvanceInt;
pResampler->inTimeFrac += pResampler->inAdvanceFrac;
if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
pResampler->inTimeInt += 1;
}
}

*pFrameCountIn = framesProcessedIn;
*pFrameCountOut = framesProcessedOut;

return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_f32_upsample(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
const float* pFramesInF32;
float* pFramesOutF32;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFrameCountIn != NULL);
MA_ASSERT(pFrameCountOut != NULL);

pFramesInF32 = (const float*)pFramesIn;
pFramesOutF32 = ( float*)pFramesOut;
frameCountIn = *pFrameCountIn;
frameCountOut = *pFrameCountOut;
framesProcessedIn = 0;
framesProcessedOut = 0;

for (;;) {
ma_uint32 iFilter;

if (framesProcessedOut >= frameCountOut) {
break;
}


while (pResampler->inTimeInt > 0 && frameCountIn > 0) {
ma_uint32 iChannel;

if (pFramesInF32 != NULL) {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
pResampler->x1.f32[iChannel] = pFramesInF32[iChannel];
}
pFramesInF32 += pResampler->config.channels;
} else {
for (iChannel = 0; iChannel < pResampler->config.channels; iChannel += 1) {
pResampler->x0.f32[iChannel] = pResampler->x1.f32[iChannel];
pResampler->x1.f32[iChannel] = 0;
}
}

frameCountIn -= 1;
framesProcessedIn += 1;
pResampler->inTimeInt -= 1;
}

if (pResampler->inTimeInt > 0) {
break; 
}


if (pFramesOutF32 != NULL) {
MA_ASSERT(pResampler->inTimeInt == 0);
ma_linear_resampler_interpolate_frame_f32(pResampler, pFramesOutF32);


for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
ma_lpf_process_pcm_frame_f32(&pResampler->lpf[iFilter], pFramesOutF32, pFramesOutF32);
}

pFramesOutF32 += pResampler->config.channels;
}

framesProcessedOut += 1;


pResampler->inTimeInt += pResampler->inAdvanceInt;
pResampler->inTimeFrac += pResampler->inAdvanceFrac;
if (pResampler->inTimeFrac >= pResampler->config.sampleRateOut) {
pResampler->inTimeFrac -= pResampler->config.sampleRateOut;
pResampler->inTimeInt += 1;
}
}

*pFrameCountIn = framesProcessedIn;
*pFrameCountOut = framesProcessedOut;

return MA_SUCCESS;
}

static ma_result ma_linear_resampler_process_pcm_frames_f32(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pResampler != NULL);

if (pResampler->config.sampleRateIn > pResampler->config.sampleRateOut) {
return ma_linear_resampler_process_pcm_frames_f32_downsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {
return ma_linear_resampler_process_pcm_frames_f32_upsample(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
}


ma_result ma_linear_resampler_process_pcm_frames(ma_linear_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

if (pResampler->config.format == ma_format_s16) {
return ma_linear_resampler_process_pcm_frames_s16(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else if (pResampler->config.format == ma_format_f32) {
return ma_linear_resampler_process_pcm_frames_f32(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

MA_ASSERT(MA_FALSE);
return MA_INVALID_ARGS;
}
}


ma_result ma_linear_resampler_set_rate(ma_linear_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
return ma_linear_resampler_set_rate_internal(pResampler, sampleRateIn, sampleRateOut, MA_TRUE);
}

ma_result ma_linear_resampler_set_rate_ratio(ma_linear_resampler* pResampler, float ratioInOut)
{
ma_uint32 n;
ma_uint32 d;

d = 1000000; 
n = (ma_uint32)(ratioInOut * d);

if (n == 0) {
return MA_INVALID_ARGS; 
}

MA_ASSERT(n != 0);

return ma_linear_resampler_set_rate(pResampler, n, d);
}


ma_uint64 ma_linear_resampler_get_required_input_frame_count(ma_linear_resampler* pResampler, ma_uint64 outputFrameCount)
{
ma_uint64 count;

if (pResampler == NULL) {
return 0;
}

if (outputFrameCount == 0) {
return 0;
}


count = pResampler->inTimeInt;
outputFrameCount -= 1;


count += outputFrameCount * pResampler->inAdvanceInt;
count += (pResampler->inTimeFrac + (outputFrameCount * pResampler->inAdvanceFrac)) / pResampler->config.sampleRateOut;

return count;
}

ma_uint64 ma_linear_resampler_get_expected_output_frame_count(ma_linear_resampler* pResampler, ma_uint64 inputFrameCount)
{
ma_uint64 outputFrameCount;
ma_uint64 inTimeInt;
ma_uint64 inTimeFrac;

if (pResampler == NULL) {
return 0;
}



outputFrameCount = 0;
inTimeInt = pResampler->inTimeInt;
inTimeFrac = pResampler->inTimeFrac;

for (;;) {
while (inTimeInt > 0 && inputFrameCount > 0) {
inputFrameCount -= 1;
inTimeInt -= 1;
}

if (inTimeInt > 0) {
break;
}

outputFrameCount += 1;


inTimeInt += pResampler->inAdvanceInt;
inTimeFrac += pResampler->inAdvanceFrac;
if (inTimeFrac >= pResampler->config.sampleRateOut) {
inTimeFrac -= pResampler->config.sampleRateOut;
inTimeInt += 1;
}
}

return outputFrameCount;
}

ma_uint64 ma_linear_resampler_get_input_latency(ma_linear_resampler* pResampler)
{
ma_uint32 latency;
ma_uint32 iFilter;

if (pResampler == NULL) {
return 0;
}

latency = 1;
for (iFilter = 0; iFilter < pResampler->config.lpfCount; iFilter += 1) {
latency += ma_lpf_get_latency(&pResampler->lpf[iFilter]);
}

return latency;
}

ma_uint64 ma_linear_resampler_get_output_latency(ma_linear_resampler* pResampler)
{
if (pResampler == NULL) {
return 0;
}

return ma_linear_resampler_get_input_latency(pResampler) * pResampler->config.sampleRateOut / pResampler->config.sampleRateIn;
}


#if defined(ma_speex_resampler_h)
#define MA_HAS_SPEEX_RESAMPLER

static ma_result ma_result_from_speex_err(int err)
{
switch (err)
{
case RESAMPLER_ERR_SUCCESS: return MA_SUCCESS;
case RESAMPLER_ERR_ALLOC_FAILED: return MA_OUT_OF_MEMORY;
case RESAMPLER_ERR_BAD_STATE: return MA_ERROR;
case RESAMPLER_ERR_INVALID_ARG: return MA_INVALID_ARGS;
case RESAMPLER_ERR_PTR_OVERLAP: return MA_INVALID_ARGS;
case RESAMPLER_ERR_OVERFLOW: return MA_ERROR;
default: return MA_ERROR;
}
}
#endif 

ma_resampler_config ma_resampler_config_init(ma_format format, ma_uint32 channels, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut, ma_resample_algorithm algorithm)
{
ma_resampler_config config;

MA_ZERO_OBJECT(&config);
config.format = format;
config.channels = channels;
config.sampleRateIn = sampleRateIn;
config.sampleRateOut = sampleRateOut;
config.algorithm = algorithm;


config.linear.lpfCount = 1;
config.linear.lpfNyquistFactor = 1;


config.speex.quality = 3; 

return config;
}

ma_result ma_resampler_init(const ma_resampler_config* pConfig, ma_resampler* pResampler)
{
ma_result result;

if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pResampler);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

if (pConfig->format != ma_format_f32 && pConfig->format != ma_format_s16) {
return MA_INVALID_ARGS;
}

pResampler->config = *pConfig;

switch (pConfig->algorithm)
{
case ma_resample_algorithm_linear:
{
ma_linear_resampler_config linearConfig;
linearConfig = ma_linear_resampler_config_init(pConfig->format, pConfig->channels, pConfig->sampleRateIn, pConfig->sampleRateOut);
linearConfig.lpfCount = pConfig->linear.lpfCount;
linearConfig.lpfNyquistFactor = pConfig->linear.lpfNyquistFactor;

result = ma_linear_resampler_init(&linearConfig, &pResampler->state.linear);
if (result != MA_SUCCESS) {
return result;
}
} break;

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
int speexErr;
pResampler->state.speex.pSpeexResamplerState = speex_resampler_init(pConfig->channels, pConfig->sampleRateIn, pConfig->sampleRateOut, pConfig->speex.quality, &speexErr);
if (pResampler->state.speex.pSpeexResamplerState == NULL) {
return ma_result_from_speex_err(speexErr);
}
#else

return MA_NO_BACKEND;
#endif
} break;

default: return MA_INVALID_ARGS;
}

return MA_SUCCESS;
}

void ma_resampler_uninit(ma_resampler* pResampler)
{
if (pResampler == NULL) {
return;
}

if (pResampler->config.algorithm == ma_resample_algorithm_linear) {
ma_linear_resampler_uninit(&pResampler->state.linear);
}

#if defined(MA_HAS_SPEEX_RESAMPLER)
if (pResampler->config.algorithm == ma_resample_algorithm_speex) {
speex_resampler_destroy((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState);
}
#endif
}

static ma_result ma_resampler_process_pcm_frames__read__linear(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
return ma_linear_resampler_process_pcm_frames(&pResampler->state.linear, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}

#if defined(MA_HAS_SPEEX_RESAMPLER)
static ma_result ma_resampler_process_pcm_frames__read__speex(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
int speexErr;
ma_uint64 frameCountOut;
ma_uint64 frameCountIn;
ma_uint64 framesProcessedOut;
ma_uint64 framesProcessedIn;
unsigned int framesPerIteration = UINT_MAX;

MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFrameCountOut != NULL);
MA_ASSERT(pFrameCountIn != NULL);







frameCountOut = *pFrameCountOut;
frameCountIn = *pFrameCountIn;
framesProcessedOut = 0;
framesProcessedIn = 0;

while (framesProcessedOut < frameCountOut && framesProcessedIn < frameCountIn) {
unsigned int frameCountInThisIteration;
unsigned int frameCountOutThisIteration;
const void* pFramesInThisIteration;
void* pFramesOutThisIteration;

frameCountInThisIteration = framesPerIteration;
if ((ma_uint64)frameCountInThisIteration > (frameCountIn - framesProcessedIn)) {
frameCountInThisIteration = (unsigned int)(frameCountIn - framesProcessedIn);
}

frameCountOutThisIteration = framesPerIteration;
if ((ma_uint64)frameCountOutThisIteration > (frameCountOut - framesProcessedOut)) {
frameCountOutThisIteration = (unsigned int)(frameCountOut - framesProcessedOut);
}

pFramesInThisIteration = ma_offset_ptr(pFramesIn, framesProcessedIn * ma_get_bytes_per_frame(pResampler->config.format, pResampler->config.channels));
pFramesOutThisIteration = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pResampler->config.format, pResampler->config.channels));

if (pResampler->config.format == ma_format_f32) {
speexErr = speex_resampler_process_interleaved_float((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState, (const float*)pFramesInThisIteration, &frameCountInThisIteration, (float*)pFramesOutThisIteration, &frameCountOutThisIteration);
} else if (pResampler->config.format == ma_format_s16) {
speexErr = speex_resampler_process_interleaved_int((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState, (const spx_int16_t*)pFramesInThisIteration, &frameCountInThisIteration, (spx_int16_t*)pFramesOutThisIteration, &frameCountOutThisIteration);
} else {

MA_ASSERT(MA_FALSE);
return MA_INVALID_OPERATION;
}

if (speexErr != RESAMPLER_ERR_SUCCESS) {
return ma_result_from_speex_err(speexErr);
}

framesProcessedIn += frameCountInThisIteration;
framesProcessedOut += frameCountOutThisIteration;
}

*pFrameCountOut = framesProcessedOut;
*pFrameCountIn = framesProcessedIn;

return MA_SUCCESS;
}
#endif

static ma_result ma_resampler_process_pcm_frames__read(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pResampler != NULL);
MA_ASSERT(pFramesOut != NULL);


if (pFrameCountOut == NULL) {
return MA_INVALID_ARGS;
}


if (pFrameCountIn == NULL || pFramesIn == NULL) {
return MA_INVALID_ARGS;
}

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_resampler_process_pcm_frames__read__linear(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
return ma_resampler_process_pcm_frames__read__speex(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
#else
break;
#endif
}

default: break;
}


MA_ASSERT(MA_FALSE);
return MA_INVALID_ARGS;
}


static ma_result ma_resampler_process_pcm_frames__seek__linear(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pResampler != NULL);


return ma_linear_resampler_process_pcm_frames(&pResampler->state.linear, pFramesIn, pFrameCountIn, NULL, pFrameCountOut);
}

#if defined(MA_HAS_SPEEX_RESAMPLER)
static ma_result ma_resampler_process_pcm_frames__seek__speex(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, ma_uint64* pFrameCountOut)
{

float devnull[8192];
ma_uint64 totalOutputFramesToProcess;
ma_uint64 totalOutputFramesProcessed;
ma_uint64 totalInputFramesProcessed;
ma_uint32 bpf;
ma_result result;

MA_ASSERT(pResampler != NULL);

totalOutputFramesProcessed = 0;
totalInputFramesProcessed = 0;
bpf = ma_get_bytes_per_frame(pResampler->config.format, pResampler->config.channels);

if (pFrameCountOut != NULL) {

totalOutputFramesToProcess = *pFrameCountOut;
} else {

MA_ASSERT(pFrameCountIn != NULL);
totalOutputFramesToProcess = ma_resampler_get_expected_output_frame_count(pResampler, *pFrameCountIn);
}

if (pFramesIn != NULL) {

MA_ASSERT(pFrameCountIn != NULL);
while (totalOutputFramesProcessed < totalOutputFramesToProcess && totalInputFramesProcessed < *pFrameCountIn) {
ma_uint64 inputFramesToProcessThisIteration = (*pFrameCountIn - totalInputFramesProcessed);
ma_uint64 outputFramesToProcessThisIteration = (totalOutputFramesToProcess - totalOutputFramesProcessed);
if (outputFramesToProcessThisIteration > sizeof(devnull) / bpf) {
outputFramesToProcessThisIteration = sizeof(devnull) / bpf;
}

result = ma_resampler_process_pcm_frames__read(pResampler, ma_offset_ptr(pFramesIn, totalInputFramesProcessed*bpf), &inputFramesToProcessThisIteration, ma_offset_ptr(devnull, totalOutputFramesProcessed*bpf), &outputFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
return result;
}

totalOutputFramesProcessed += outputFramesToProcessThisIteration;
totalInputFramesProcessed += inputFramesToProcessThisIteration;
}
} else {

while (totalOutputFramesProcessed < totalOutputFramesToProcess) {
ma_uint64 inputFramesToProcessThisIteration = 16384;
ma_uint64 outputFramesToProcessThisIteration = (totalOutputFramesToProcess - totalOutputFramesProcessed);
if (outputFramesToProcessThisIteration > sizeof(devnull) / bpf) {
outputFramesToProcessThisIteration = sizeof(devnull) / bpf;
}

result = ma_resampler_process_pcm_frames__read(pResampler, NULL, &inputFramesToProcessThisIteration, ma_offset_ptr(devnull, totalOutputFramesProcessed*bpf), &outputFramesToProcessThisIteration);
if (result != MA_SUCCESS) {
return result;
}

totalOutputFramesProcessed += outputFramesToProcessThisIteration;
totalInputFramesProcessed += inputFramesToProcessThisIteration;
}
}


if (pFrameCountIn != NULL) {
*pFrameCountIn = totalInputFramesProcessed;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = totalOutputFramesProcessed;
}

return MA_SUCCESS;
}
#endif

static ma_result ma_resampler_process_pcm_frames__seek(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pResampler != NULL);

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_resampler_process_pcm_frames__seek__linear(pResampler, pFramesIn, pFrameCountIn, pFrameCountOut);
} break;

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
return ma_resampler_process_pcm_frames__seek__speex(pResampler, pFramesIn, pFrameCountIn, pFrameCountOut);
#else
break;
#endif
};

default: break;
}


MA_ASSERT(MA_FALSE);
return MA_INVALID_ARGS;
}


ma_result ma_resampler_process_pcm_frames(ma_resampler* pResampler, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

if (pFrameCountOut == NULL && pFrameCountIn == NULL) {
return MA_INVALID_ARGS;
}

if (pFramesOut != NULL) {

return ma_resampler_process_pcm_frames__read(pResampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

return ma_resampler_process_pcm_frames__seek(pResampler, pFramesIn, pFrameCountIn, pFrameCountOut);
}
}

ma_result ma_resampler_set_rate(ma_resampler* pResampler, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

if (sampleRateIn == 0 || sampleRateOut == 0) {
return MA_INVALID_ARGS;
}

pResampler->config.sampleRateIn = sampleRateIn;
pResampler->config.sampleRateOut = sampleRateOut;

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_linear_resampler_set_rate(&pResampler->state.linear, sampleRateIn, sampleRateOut);
} break;

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
return ma_result_from_speex_err(speex_resampler_set_rate((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState, sampleRateIn, sampleRateOut));
#else
break;
#endif
};

default: break;
}


MA_ASSERT(MA_FALSE);
return MA_INVALID_OPERATION;
}

ma_result ma_resampler_set_rate_ratio(ma_resampler* pResampler, float ratio)
{
if (pResampler == NULL) {
return MA_INVALID_ARGS;
}

if (pResampler->config.algorithm == ma_resample_algorithm_linear) {
return ma_linear_resampler_set_rate_ratio(&pResampler->state.linear, ratio);
} else {

ma_uint32 n;
ma_uint32 d;

d = 1000000; 
n = (ma_uint32)(ratio * d);

if (n == 0) {
return MA_INVALID_ARGS; 
}

MA_ASSERT(n != 0);

return ma_resampler_set_rate(pResampler, n, d);
}
}

ma_uint64 ma_resampler_get_required_input_frame_count(ma_resampler* pResampler, ma_uint64 outputFrameCount)
{
if (pResampler == NULL) {
return 0;
}

if (outputFrameCount == 0) {
return 0;
}

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_linear_resampler_get_required_input_frame_count(&pResampler->state.linear, outputFrameCount);
}

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
ma_uint64 count;
int speexErr = ma_speex_resampler_get_required_input_frame_count((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState, outputFrameCount, &count);
if (speexErr != RESAMPLER_ERR_SUCCESS) {
return 0;
}

return count;
#else
break;
#endif
}

default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}

ma_uint64 ma_resampler_get_expected_output_frame_count(ma_resampler* pResampler, ma_uint64 inputFrameCount)
{
if (pResampler == NULL) {
return 0; 
}

if (inputFrameCount == 0) {
return 0;
}

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_linear_resampler_get_expected_output_frame_count(&pResampler->state.linear, inputFrameCount);
}

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
ma_uint64 count;
int speexErr = ma_speex_resampler_get_expected_output_frame_count((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState, inputFrameCount, &count);
if (speexErr != RESAMPLER_ERR_SUCCESS) {
return 0;
}

return count;
#else
break;
#endif
}

default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}

ma_uint64 ma_resampler_get_input_latency(ma_resampler* pResampler)
{
if (pResampler == NULL) {
return 0;
}

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_linear_resampler_get_input_latency(&pResampler->state.linear);
}

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
return (ma_uint64)ma_speex_resampler_get_input_latency((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState);
#else
break;
#endif
}

default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}

ma_uint64 ma_resampler_get_output_latency(ma_resampler* pResampler)
{
if (pResampler == NULL) {
return 0;
}

switch (pResampler->config.algorithm)
{
case ma_resample_algorithm_linear:
{
return ma_linear_resampler_get_output_latency(&pResampler->state.linear);
}

case ma_resample_algorithm_speex:
{
#if defined(MA_HAS_SPEEX_RESAMPLER)
return (ma_uint64)ma_speex_resampler_get_output_latency((SpeexResamplerState*)pResampler->state.speex.pSpeexResamplerState);
#else
break;
#endif
}

default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}






#if !defined(MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT)
#define MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT 12
#endif

#define MA_PLANE_LEFT 0
#define MA_PLANE_RIGHT 1
#define MA_PLANE_FRONT 2
#define MA_PLANE_BACK 3
#define MA_PLANE_BOTTOM 4
#define MA_PLANE_TOP 5

float g_maChannelPlaneRatios[MA_CHANNEL_POSITION_COUNT][6] = {
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.5f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.5f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f}, 
{ 0.0f, 0.5f, 0.0f, 0.5f, 0.0f, 0.0f}, 
{ 0.25f, 0.0f, 0.75f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.25f, 0.75f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f}, 
{ 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f}, 
{ 0.33f, 0.0f, 0.33f, 0.0f, 0.0f, 0.34f}, 
{ 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.5f}, 
{ 0.0f, 0.33f, 0.33f, 0.0f, 0.0f, 0.34f}, 
{ 0.33f, 0.0f, 0.0f, 0.33f, 0.0f, 0.34f}, 
{ 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.5f}, 
{ 0.0f, 0.33f, 0.0f, 0.33f, 0.0f, 0.34f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, 
};

float ma_calculate_channel_position_rectangular_weight(ma_channel channelPositionA, ma_channel channelPositionB)
{






























float contribution = 
g_maChannelPlaneRatios[channelPositionA][0] * g_maChannelPlaneRatios[channelPositionB][0] +
g_maChannelPlaneRatios[channelPositionA][1] * g_maChannelPlaneRatios[channelPositionB][1] +
g_maChannelPlaneRatios[channelPositionA][2] * g_maChannelPlaneRatios[channelPositionB][2] +
g_maChannelPlaneRatios[channelPositionA][3] * g_maChannelPlaneRatios[channelPositionB][3] +
g_maChannelPlaneRatios[channelPositionA][4] * g_maChannelPlaneRatios[channelPositionB][4] +
g_maChannelPlaneRatios[channelPositionA][5] * g_maChannelPlaneRatios[channelPositionB][5];

return contribution;
}

ma_channel_converter_config ma_channel_converter_config_init(ma_format format, ma_uint32 channelsIn, const ma_channel channelMapIn[MA_MAX_CHANNELS], ma_uint32 channelsOut, const ma_channel channelMapOut[MA_MAX_CHANNELS], ma_channel_mix_mode mixingMode)
{
ma_channel_converter_config config;
MA_ZERO_OBJECT(&config);
config.format = format;
config.channelsIn = channelsIn;
config.channelsOut = channelsOut;
ma_channel_map_copy(config.channelMapIn, channelMapIn, channelsIn);
ma_channel_map_copy(config.channelMapOut, channelMapOut, channelsOut);
config.mixingMode = mixingMode;

return config;
}

static ma_int32 ma_channel_converter_float_to_fp(float x)
{
return (ma_int32)(x * (1<<MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT));
}

static ma_bool32 ma_is_spatial_channel_position(ma_channel channelPosition)
{
int i;

if (channelPosition == MA_CHANNEL_NONE || channelPosition == MA_CHANNEL_MONO || channelPosition == MA_CHANNEL_LFE) {
return MA_FALSE;
}

for (i = 0; i < 6; ++i) { 
if (g_maChannelPlaneRatios[channelPosition][i] != 0) {
return MA_TRUE;
}
}

return MA_FALSE;
}

ma_result ma_channel_converter_init(const ma_channel_converter_config* pConfig, ma_channel_converter* pConverter)
{
ma_uint32 iChannelIn;
ma_uint32 iChannelOut;

if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pConverter);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

if (!ma_channel_map_valid(pConfig->channelsIn, pConfig->channelMapIn)) {
return MA_INVALID_ARGS; 
}
if (!ma_channel_map_valid(pConfig->channelsOut, pConfig->channelMapOut)) {
return MA_INVALID_ARGS; 
}

if (pConfig->format != ma_format_s16 && pConfig->format != ma_format_f32) {
return MA_INVALID_ARGS; 
}

pConverter->format = pConfig->format;
pConverter->channelsIn = pConfig->channelsIn;
pConverter->channelsOut = pConfig->channelsOut;
ma_channel_map_copy(pConverter->channelMapIn, pConfig->channelMapIn, pConfig->channelsIn);
ma_channel_map_copy(pConverter->channelMapOut, pConfig->channelMapOut, pConfig->channelsOut);
pConverter->mixingMode = pConfig->mixingMode;

for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; iChannelIn += 1) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
if (pConverter->format == ma_format_s16) {
pConverter->weights.f32[iChannelIn][iChannelOut] = pConfig->weights[iChannelIn][iChannelOut];
} else {
pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fp(pConfig->weights[iChannelIn][iChannelOut]);
}
}
}




if (pConverter->channelsIn == pConverter->channelsOut) {
if (ma_channel_map_equal(pConverter->channelsIn, pConverter->channelMapIn, pConverter->channelMapOut)) {
pConverter->isPassthrough = MA_TRUE;
}
if (ma_channel_map_blank(pConverter->channelsIn, pConverter->channelMapIn) || ma_channel_map_blank(pConverter->channelsOut, pConverter->channelMapOut)) {
pConverter->isPassthrough = MA_TRUE;
}
}






if (!pConverter->isPassthrough) {
if (pConverter->channelsIn == 1 && pConverter->channelMapIn[0] == MA_CHANNEL_MONO) {

pConverter->isSimpleMonoExpansion = MA_TRUE;
if (ma_channel_map_contains_channel_position(pConverter->channelsOut, pConverter->channelMapOut, MA_CHANNEL_LFE)) {
pConverter->isSimpleMonoExpansion = MA_FALSE;
}
}
}


if (!pConverter->isPassthrough) {
if (pConverter->channelsOut == 1 && pConverter->channelMapOut[0] == MA_CHANNEL_MONO && pConverter->channelsIn == 2) {

pConverter->isStereoToMono = MA_TRUE;
if (ma_channel_map_contains_channel_position(pConverter->channelsIn, pConverter->channelMapIn, MA_CHANNEL_LFE)) {
pConverter->isStereoToMono = MA_FALSE;
}
}
}










if (!pConverter->isPassthrough) {
if (pConverter->channelsIn == pConverter->channelsOut) {
ma_bool32 areAllChannelPositionsPresent = MA_TRUE;
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_bool32 isInputChannelPositionInOutput = MA_FALSE;
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
if (pConverter->channelMapIn[iChannelIn] == pConverter->channelMapOut[iChannelOut]) {
isInputChannelPositionInOutput = MA_TRUE;
break;
}
}

if (!isInputChannelPositionInOutput) {
areAllChannelPositionsPresent = MA_FALSE;
break;
}
}

if (areAllChannelPositionsPresent) {
pConverter->isSimpleShuffle = MA_TRUE;





for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
if (pConverter->channelMapIn[iChannelIn] == pConverter->channelMapOut[iChannelOut]) {
pConverter->shuffleTable[iChannelIn] = (ma_uint8)iChannelOut;
break;
}
}
}
}
}
}












for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_channel channelPosOut = pConverter->channelMapOut[iChannelOut];

if (channelPosIn == channelPosOut) {
if (pConverter->format == ma_format_s16) {
pConverter->weights.s16[iChannelIn][iChannelOut] = (1 << MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT);
} else {
pConverter->weights.f32[iChannelIn][iChannelOut] = 1;
}
}
}
}





for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

if (channelPosIn == MA_CHANNEL_MONO) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_channel channelPosOut = pConverter->channelMapOut[iChannelOut];

if (channelPosOut != MA_CHANNEL_NONE && channelPosOut != MA_CHANNEL_MONO && channelPosOut != MA_CHANNEL_LFE) {
if (pConverter->format == ma_format_s16) {
pConverter->weights.s16[iChannelIn][iChannelOut] = (1 << MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT);
} else {
pConverter->weights.f32[iChannelIn][iChannelOut] = 1;
}
}
}
}
}


{
ma_uint32 len = 0;
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

if (channelPosIn != MA_CHANNEL_NONE && channelPosIn != MA_CHANNEL_MONO && channelPosIn != MA_CHANNEL_LFE) {
len += 1;
}
}

if (len > 0) {
float monoWeight = 1.0f / len;

for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_channel channelPosOut = pConverter->channelMapOut[iChannelOut];

if (channelPosOut == MA_CHANNEL_MONO) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

if (channelPosIn != MA_CHANNEL_NONE && channelPosIn != MA_CHANNEL_MONO && channelPosIn != MA_CHANNEL_LFE) {
if (pConverter->format == ma_format_s16) {
pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fp(monoWeight);
} else {
pConverter->weights.f32[iChannelIn][iChannelOut] = monoWeight;
}
}
}
}
}
}
}



switch (pConverter->mixingMode)
{
case ma_channel_mix_mode_rectangular:
{

for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

if (ma_is_spatial_channel_position(channelPosIn)) {
if (!ma_channel_map_contains_channel_position(pConverter->channelsOut, pConverter->channelMapOut, channelPosIn)) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_channel channelPosOut = pConverter->channelMapOut[iChannelOut];

if (ma_is_spatial_channel_position(channelPosOut)) {
float weight = 0;
if (pConverter->mixingMode == ma_channel_mix_mode_rectangular) {
weight = ma_calculate_channel_position_rectangular_weight(channelPosIn, channelPosOut);
}


if (pConverter->format == ma_format_s16) {
if (pConverter->weights.s16[iChannelIn][iChannelOut] == 0) {
pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fp(weight);
}
} else {
if (pConverter->weights.f32[iChannelIn][iChannelOut] == 0) {
pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
}
}
}
}
}
}
}


for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_channel channelPosOut = pConverter->channelMapOut[iChannelOut];

if (ma_is_spatial_channel_position(channelPosOut)) {
if (!ma_channel_map_contains_channel_position(pConverter->channelsIn, pConverter->channelMapIn, channelPosOut)) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
ma_channel channelPosIn = pConverter->channelMapIn[iChannelIn];

if (ma_is_spatial_channel_position(channelPosIn)) {
float weight = 0;
if (pConverter->mixingMode == ma_channel_mix_mode_rectangular) {
weight = ma_calculate_channel_position_rectangular_weight(channelPosIn, channelPosOut);
}


if (pConverter->format == ma_format_s16) {
if (pConverter->weights.s16[iChannelIn][iChannelOut] == 0) {
pConverter->weights.s16[iChannelIn][iChannelOut] = ma_channel_converter_float_to_fp(weight);
}
} else {
if (pConverter->weights.f32[iChannelIn][iChannelOut] == 0) {
pConverter->weights.f32[iChannelIn][iChannelOut] = weight;
}
}
}
}
}
}
}
} break;

case ma_channel_mix_mode_custom_weights:
case ma_channel_mix_mode_simple:
default:
{

} break;
}


return MA_SUCCESS;
}

void ma_channel_converter_uninit(ma_channel_converter* pConverter)
{
if (pConverter == NULL) {
return;
}
}

static ma_result ma_channel_converter_process_pcm_frames__passthrough(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
MA_ASSERT(pConverter != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFramesIn != NULL);

ma_copy_memory_64(pFramesOut, pFramesIn, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));
return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__simple_shuffle(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
ma_uint32 iFrame;
ma_uint32 iChannelIn;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFramesIn != NULL);
MA_ASSERT(pConverter->channelsIn == pConverter->channelsOut);

if (pConverter->format == ma_format_s16) {
ma_int16* pFramesOutS16 = ( ma_int16*)pFramesOut;
const ma_int16* pFramesInS16 = (const ma_int16*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
pFramesOutS16[pConverter->shuffleTable[iChannelIn]] = pFramesInS16[iChannelIn];
}
}
} else {
float* pFramesOutF32 = ( float*)pFramesOut;
const float* pFramesInF32 = (const float*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
pFramesOutF32[pConverter->shuffleTable[iChannelIn]] = pFramesInF32[iChannelIn];
}
}
}

return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__simple_mono_expansion(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
ma_uint64 iFrame;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFramesIn != NULL);

if (pConverter->format == ma_format_s16) {
ma_int16* pFramesOutS16 = ( ma_int16*)pFramesOut;
const ma_int16* pFramesInS16 = (const ma_int16*)pFramesIn;

if (pConverter->channelsOut == 2) {
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
pFramesOutS16[iFrame*2 + 0] = pFramesInS16[iFrame];
pFramesOutS16[iFrame*2 + 1] = pFramesInS16[iFrame];
}
} else {
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
pFramesOutS16[iFrame*pConverter->channelsOut + iChannel] = pFramesInS16[iFrame];
}
}
}
} else {
float* pFramesOutF32 = ( float*)pFramesOut;
const float* pFramesInF32 = (const float*)pFramesIn;

if (pConverter->channelsOut == 2) {
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
pFramesOutF32[iFrame*2 + 0] = pFramesInF32[iFrame];
pFramesOutF32[iFrame*2 + 1] = pFramesInF32[iFrame];
}
} else {
for (iFrame = 0; iFrame < frameCount; ++iFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < pConverter->channelsOut; iChannel += 1) {
pFramesOutF32[iFrame*pConverter->channelsOut + iChannel] = pFramesInF32[iFrame];
}
}
}
}

return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__stereo_to_mono(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
ma_uint64 iFrame;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFramesIn != NULL);
MA_ASSERT(pConverter->channelsIn == 2);
MA_ASSERT(pConverter->channelsOut == 1);

if (pConverter->format == ma_format_s16) {
ma_int16* pFramesOutS16 = ( ma_int16*)pFramesOut;
const ma_int16* pFramesInS16 = (const ma_int16*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; ++iFrame) {
pFramesOutS16[iFrame] = (ma_int16)(((ma_int32)pFramesInS16[iFrame*2+0] + (ma_int32)pFramesInS16[iFrame*2+1]) / 2);
}
} else {
float* pFramesOutF32 = ( float*)pFramesOut;
const float* pFramesInF32 = (const float*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; ++iFrame) {
pFramesOutF32[iFrame] = (pFramesInF32[iFrame*2+0] + pFramesInF32[iFrame*2+0]) * 0.5f;
}
}

return MA_SUCCESS;
}

static ma_result ma_channel_converter_process_pcm_frames__weights(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
ma_uint32 iFrame;
ma_uint32 iChannelIn;
ma_uint32 iChannelOut;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pFramesIn != NULL);




ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));


if (pConverter->format == ma_format_s16) {
ma_int16* pFramesOutS16 = ( ma_int16*)pFramesOut;
const ma_int16* pFramesInS16 = (const ma_int16*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
ma_int32 s = pFramesOutS16[iFrame*pConverter->channelsOut + iChannelOut];
s += (pFramesInS16[iFrame*pConverter->channelsIn + iChannelIn] * pConverter->weights.s16[iChannelIn][iChannelOut]) >> MA_CHANNEL_CONVERTER_FIXED_POINT_SHIFT;

pFramesOutS16[iFrame*pConverter->channelsOut + iChannelOut] = (ma_int16)ma_clamp(s, -32768, 32767);
}
}
}
} else {
float* pFramesOutF32 = ( float*)pFramesOut;
const float* pFramesInF32 = (const float*)pFramesIn;

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
for (iChannelIn = 0; iChannelIn < pConverter->channelsIn; ++iChannelIn) {
for (iChannelOut = 0; iChannelOut < pConverter->channelsOut; ++iChannelOut) {
pFramesOutF32[iFrame*pConverter->channelsOut + iChannelOut] += pFramesInF32[iFrame*pConverter->channelsIn + iChannelIn] * pConverter->weights.f32[iChannelIn][iChannelOut];
}
}
}
}

return MA_SUCCESS;
}

ma_result ma_channel_converter_process_pcm_frames(ma_channel_converter* pConverter, void* pFramesOut, const void* pFramesIn, ma_uint64 frameCount)
{
if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

if (pFramesOut == NULL) {
return MA_INVALID_ARGS;
}

if (pFramesIn == NULL) {
ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->format, pConverter->channelsOut));
return MA_SUCCESS;
}

if (pConverter->isPassthrough) {
return ma_channel_converter_process_pcm_frames__passthrough(pConverter, pFramesOut, pFramesIn, frameCount);
} else if (pConverter->isSimpleShuffle) {
return ma_channel_converter_process_pcm_frames__simple_shuffle(pConverter, pFramesOut, pFramesIn, frameCount);
} else if (pConverter->isSimpleMonoExpansion) {
return ma_channel_converter_process_pcm_frames__simple_mono_expansion(pConverter, pFramesOut, pFramesIn, frameCount);
} else if (pConverter->isStereoToMono) {
return ma_channel_converter_process_pcm_frames__stereo_to_mono(pConverter, pFramesOut, pFramesIn, frameCount);
} else {
return ma_channel_converter_process_pcm_frames__weights(pConverter, pFramesOut, pFramesIn, frameCount);
}
}







ma_data_converter_config ma_data_converter_config_init_default()
{
ma_data_converter_config config;
MA_ZERO_OBJECT(&config);

config.ditherMode = ma_dither_mode_none;
config.resampling.algorithm = ma_resample_algorithm_linear;
config.resampling.allowDynamicSampleRate = MA_FALSE; 


config.resampling.linear.lpfCount = 1;
config.resampling.linear.lpfNyquistFactor = 1;


config.resampling.speex.quality = 3;

return config;
}

ma_data_converter_config ma_data_converter_config_init(ma_format formatIn, ma_format formatOut, ma_uint32 channelsIn, ma_uint32 channelsOut, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
ma_data_converter_config config = ma_data_converter_config_init_default();
config.formatIn = formatIn;
config.formatOut = formatOut;
config.channelsIn = channelsIn;
config.channelsOut = channelsOut;
config.sampleRateIn = sampleRateIn;
config.sampleRateOut = sampleRateOut;

return config;
}

ma_result ma_data_converter_init(const ma_data_converter_config* pConfig, ma_data_converter* pConverter)
{
ma_result result;
ma_format midFormat;

if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pConverter);

if (pConfig == NULL) {
return MA_INVALID_ARGS;
}

pConverter->config = *pConfig;







if (pConverter->config.formatOut == ma_format_s16 || pConverter->config.formatOut == ma_format_f32) {
midFormat = pConverter->config.formatOut;
} else if (pConverter->config.formatIn == ma_format_s16 || pConverter->config.formatIn == ma_format_f32) {
midFormat = pConverter->config.formatIn;
} else {
midFormat = ma_format_f32;
}

if (pConverter->config.formatIn != midFormat) {
pConverter->hasPreFormatConversion = MA_TRUE;
}
if (pConverter->config.formatOut != midFormat) {
pConverter->hasPostFormatConversion = MA_TRUE;
}



{
ma_uint32 iChannelIn;
ma_uint32 iChannelOut;
ma_channel_converter_config channelConverterConfig;

channelConverterConfig = ma_channel_converter_config_init(midFormat, pConverter->config.channelsIn, pConverter->config.channelMapIn, pConverter->config.channelsOut, pConverter->config.channelMapOut, pConverter->config.channelMixMode);


for (iChannelIn = 0; iChannelIn < pConverter->config.channelsIn; iChannelIn += 1) {
for (iChannelOut = 0; iChannelOut < pConverter->config.channelsOut; iChannelOut += 1) {
channelConverterConfig.weights[iChannelIn][iChannelOut] = pConverter->config.channelWeights[iChannelIn][iChannelOut];
}
}

result = ma_channel_converter_init(&channelConverterConfig, &pConverter->channelConverter);
if (result != MA_SUCCESS) {
return result;
}


if (pConverter->channelConverter.isPassthrough == MA_FALSE) {
pConverter->hasChannelConverter = MA_TRUE;
}
}



if (pConverter->config.resampling.allowDynamicSampleRate == MA_FALSE) {
pConverter->config.resampling.allowDynamicSampleRate = pConverter->config.sampleRateIn != pConverter->config.sampleRateOut;
}


if (pConverter->config.resampling.allowDynamicSampleRate) {
ma_resampler_config resamplerConfig;
ma_uint32 resamplerChannels;


if (pConverter->config.channelsIn < pConverter->config.channelsOut) {
resamplerChannels = pConverter->config.channelsIn;
} else {
resamplerChannels = pConverter->config.channelsOut;
}

resamplerConfig = ma_resampler_config_init(midFormat, resamplerChannels, pConverter->config.sampleRateIn, pConverter->config.sampleRateOut, pConverter->config.resampling.algorithm);
resamplerConfig.linear.lpfCount = pConverter->config.resampling.linear.lpfCount;
resamplerConfig.linear.lpfNyquistFactor = pConverter->config.resampling.linear.lpfNyquistFactor;
resamplerConfig.speex.quality = pConverter->config.resampling.speex.quality;

result = ma_resampler_init(&resamplerConfig, &pConverter->resampler);
if (result != MA_SUCCESS) {
return result;
}

pConverter->hasResampler = MA_TRUE;
}


if (pConverter->hasPreFormatConversion == MA_FALSE &&
pConverter->hasPostFormatConversion == MA_FALSE &&
pConverter->hasChannelConverter == MA_FALSE &&
pConverter->hasResampler == MA_FALSE) {
pConverter->isPassthrough = MA_TRUE;
}

return MA_SUCCESS;
}

void ma_data_converter_uninit(ma_data_converter* pConverter)
{
if (pConverter == NULL) {
return;
}

if (pConverter->hasResampler) {
ma_resampler_uninit(&pConverter->resampler);
}
}

static ma_result ma_data_converter_process_pcm_frames__passthrough(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 frameCount;

MA_ASSERT(pConverter != NULL);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

frameCount = ma_min(frameCountIn, frameCountOut);

if (pFramesOut != NULL) {
if (pFramesIn != NULL) {
ma_copy_memory_64(pFramesOut, pFramesIn, frameCount * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
} else {
ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = frameCount;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = frameCount;
}

return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__format_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 frameCount;

MA_ASSERT(pConverter != NULL);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

frameCount = ma_min(frameCountIn, frameCountOut);

if (pFramesOut != NULL) {
if (pFramesIn != NULL) {
ma_convert_pcm_frames_format(pFramesOut, pConverter->config.formatOut, pFramesIn, pConverter->config.formatIn, frameCount, pConverter->config.channelsIn, pConverter->config.ditherMode);
} else {
ma_zero_memory_64(pFramesOut, frameCount * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = frameCount;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = frameCount;
}

return MA_SUCCESS;
}


static ma_result ma_data_converter_process_pcm_frames__resample_with_format_conversion(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_result result = MA_SUCCESS;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;

MA_ASSERT(pConverter != NULL);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

framesProcessedIn = 0;
framesProcessedOut = 0;

while (framesProcessedOut < frameCountOut) {
ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
const ma_uint32 tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->resampler.config.format, pConverter->resampler.config.channels);
const void* pFramesInThisIteration;
void* pFramesOutThisIteration;
ma_uint64 frameCountInThisIteration;
ma_uint64 frameCountOutThisIteration;

if (pFramesIn != NULL) {
pFramesInThisIteration = ma_offset_ptr(pFramesIn, framesProcessedIn * ma_get_bytes_per_frame(pConverter->config.formatIn, pConverter->config.channelsIn));
} else {
pFramesInThisIteration = NULL;
}

if (pFramesOut != NULL) {
pFramesOutThisIteration = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
} else {
pFramesOutThisIteration = NULL;
}


if (pConverter->hasPreFormatConversion) {
ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
const ma_uint32 tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->resampler.config.format, pConverter->resampler.config.channels);

frameCountInThisIteration = (frameCountIn - framesProcessedIn);
if (frameCountInThisIteration > tempBufferInCap) {
frameCountInThisIteration = tempBufferInCap;
}

if (pConverter->hasPostFormatConversion) {
if (frameCountInThisIteration > tempBufferOutCap) {
frameCountInThisIteration = tempBufferOutCap;
}
}

if (pFramesInThisIteration != NULL) {
ma_convert_pcm_frames_format(pTempBufferIn, pConverter->resampler.config.format, pFramesInThisIteration, pConverter->config.formatIn, frameCountInThisIteration, pConverter->config.channelsIn, pConverter->config.ditherMode);
} else {
MA_ZERO_MEMORY(pTempBufferIn, sizeof(pTempBufferIn));
}

frameCountOutThisIteration = (frameCountOut - framesProcessedOut);

if (pConverter->hasPostFormatConversion) {

if (frameCountOutThisIteration > tempBufferOutCap) {
frameCountOutThisIteration = tempBufferOutCap;
}

result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferIn, &frameCountInThisIteration, pTempBufferOut, &frameCountOutThisIteration);
} else {

result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferIn, &frameCountInThisIteration, pFramesOutThisIteration, &frameCountOutThisIteration);
}

if (result != MA_SUCCESS) {
break;
}
} else {

MA_ASSERT(pConverter->hasPostFormatConversion == MA_TRUE);

frameCountInThisIteration = (frameCountIn - framesProcessedIn);
frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
if (frameCountOutThisIteration > tempBufferOutCap) {
frameCountOutThisIteration = tempBufferOutCap;
}

result = ma_resampler_process_pcm_frames(&pConverter->resampler, pFramesInThisIteration, &frameCountInThisIteration, pTempBufferOut, &frameCountOutThisIteration);
if (result != MA_SUCCESS) {
break;
}
}


if (pConverter->hasPostFormatConversion) {
if (pFramesOutThisIteration != NULL) {
ma_convert_pcm_frames_format(pFramesOutThisIteration, pConverter->config.formatOut, pTempBufferOut, pConverter->resampler.config.format, frameCountOutThisIteration, pConverter->resampler.config.channels, pConverter->config.ditherMode);
}
}

framesProcessedIn += frameCountInThisIteration;
framesProcessedOut += frameCountOutThisIteration;

MA_ASSERT(framesProcessedIn <= frameCountIn);
MA_ASSERT(framesProcessedOut <= frameCountOut);

if (frameCountOutThisIteration == 0) {
break; 
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = framesProcessedIn;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = framesProcessedOut;
}

return result;
}

static ma_result ma_data_converter_process_pcm_frames__resample_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
MA_ASSERT(pConverter != NULL);

if (pConverter->hasPreFormatConversion == MA_FALSE && pConverter->hasPostFormatConversion == MA_FALSE) {

return ma_resampler_process_pcm_frames(&pConverter->resampler, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

return ma_data_converter_process_pcm_frames__resample_with_format_conversion(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
}

static ma_result ma_data_converter_process_pcm_frames__channels_only(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_result result;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 frameCount;

MA_ASSERT(pConverter != NULL);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

frameCount = ma_min(frameCountIn, frameCountOut);

if (pConverter->hasPreFormatConversion == MA_FALSE && pConverter->hasPostFormatConversion == MA_FALSE) {

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pFramesOut, pFramesIn, frameCount);
if (result != MA_SUCCESS) {
return result;
}
} else {

ma_uint64 framesProcessed = 0;

while (framesProcessed < frameCount) {
ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
const ma_uint32 tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);
const void* pFramesInThisIteration;
void* pFramesOutThisIteration;
ma_uint64 frameCountThisIteration;

if (pFramesIn != NULL) {
pFramesInThisIteration = ma_offset_ptr(pFramesIn, framesProcessed * ma_get_bytes_per_frame(pConverter->config.formatIn, pConverter->config.channelsIn));
} else {
pFramesInThisIteration = NULL;
}

if (pFramesOut != NULL) {
pFramesOutThisIteration = ma_offset_ptr(pFramesOut, framesProcessed * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
} else {
pFramesOutThisIteration = NULL;
}


if (pConverter->hasPreFormatConversion) {
ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE];
const ma_uint32 tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsIn);

frameCountThisIteration = (frameCount - framesProcessed);
if (frameCountThisIteration > tempBufferInCap) {
frameCountThisIteration = tempBufferInCap;
}

if (pConverter->hasPostFormatConversion) {
if (frameCountThisIteration > tempBufferOutCap) {
frameCountThisIteration = tempBufferOutCap;
}
}

if (pFramesInThisIteration != NULL) {
ma_convert_pcm_frames_format(pTempBufferIn, pConverter->channelConverter.format, pFramesInThisIteration, pConverter->config.formatIn, frameCountThisIteration, pConverter->config.channelsIn, pConverter->config.ditherMode);
} else {
MA_ZERO_MEMORY(pTempBufferIn, sizeof(pTempBufferIn));
}

if (pConverter->hasPostFormatConversion) {

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferOut, pTempBufferIn, frameCountThisIteration);
} else {

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pFramesOutThisIteration, pTempBufferIn, frameCountThisIteration);
}

if (result != MA_SUCCESS) {
break;
}
} else {

MA_ASSERT(pConverter->hasPostFormatConversion == MA_TRUE);

frameCountThisIteration = (frameCount - framesProcessed);
if (frameCountThisIteration > tempBufferOutCap) {
frameCountThisIteration = tempBufferOutCap;
}

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferOut, pFramesInThisIteration, frameCountThisIteration);
if (result != MA_SUCCESS) {
break;
}
}


if (pConverter->hasPostFormatConversion) {
if (pFramesOutThisIteration != NULL) {
ma_convert_pcm_frames_format(pFramesOutThisIteration, pConverter->config.formatOut, pTempBufferOut, pConverter->channelConverter.format, frameCountThisIteration, pConverter->channelConverter.channelsOut, pConverter->config.ditherMode);
}
}

framesProcessed += frameCountThisIteration;
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = frameCount;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = frameCount;
}

return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__resampling_first(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_result result;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;
ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferInCap;
ma_uint8 pTempBufferMid[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferMidCap;
ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferOutCap;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pConverter->resampler.config.format == pConverter->channelConverter.format);
MA_ASSERT(pConverter->resampler.config.channels == pConverter->channelConverter.channelsIn);
MA_ASSERT(pConverter->resampler.config.channels < pConverter->channelConverter.channelsOut);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

framesProcessedIn = 0;
framesProcessedOut = 0;

tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->resampler.config.format, pConverter->resampler.config.channels);
tempBufferMidCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->resampler.config.format, pConverter->resampler.config.channels);
tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);

while (framesProcessedOut < frameCountOut) {
ma_uint64 frameCountInThisIteration;
ma_uint64 frameCountOutThisIteration;
const void* pRunningFramesIn = NULL;
void* pRunningFramesOut = NULL;
const void* pResampleBufferIn;
void* pChannelsBufferOut;

if (pFramesIn != NULL) {
pRunningFramesIn = ma_offset_ptr(pFramesIn, framesProcessedIn * ma_get_bytes_per_frame(pConverter->config.formatIn, pConverter->config.channelsIn));
}
if (pFramesOut != NULL) {
pRunningFramesOut = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
}


frameCountInThisIteration = (frameCountIn - framesProcessedIn);

if (pConverter->hasPreFormatConversion) {
if (frameCountInThisIteration > tempBufferInCap) {
frameCountInThisIteration = tempBufferInCap;
}
}

frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
if (frameCountOutThisIteration > tempBufferMidCap) {
frameCountOutThisIteration = tempBufferMidCap;
}


if (pConverter->hasPostFormatConversion) {
if (frameCountOutThisIteration > tempBufferOutCap) {
frameCountOutThisIteration = tempBufferOutCap;
}
}


{
ma_uint64 requiredInputFrameCount = ma_resampler_get_required_input_frame_count(&pConverter->resampler, frameCountOutThisIteration);
if (frameCountInThisIteration > requiredInputFrameCount) {
frameCountInThisIteration = requiredInputFrameCount;
}
}

if (pConverter->hasPreFormatConversion) {
if (pFramesIn != NULL) {
ma_convert_pcm_frames_format(pTempBufferIn, pConverter->resampler.config.format, pRunningFramesIn, pConverter->config.formatIn, frameCountInThisIteration, pConverter->config.channelsIn, pConverter->config.ditherMode);
pResampleBufferIn = pTempBufferIn;
} else {
pResampleBufferIn = NULL;
}
} else {
pResampleBufferIn = pRunningFramesIn;
}

result = ma_resampler_process_pcm_frames(&pConverter->resampler, pResampleBufferIn, &frameCountInThisIteration, pTempBufferMid, &frameCountOutThisIteration);
if (result != MA_SUCCESS) {
return result;
}






if (pFramesOut != NULL) {
if (pConverter->hasPostFormatConversion) {
pChannelsBufferOut = pTempBufferOut;
} else {
pChannelsBufferOut = pRunningFramesOut;
}

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pChannelsBufferOut, pTempBufferMid, frameCountOutThisIteration);
if (result != MA_SUCCESS) {
return result;
}


if (pConverter->hasPostFormatConversion) {
ma_convert_pcm_frames_format(pRunningFramesOut, pConverter->config.formatOut, pChannelsBufferOut, pConverter->channelConverter.format, frameCountOutThisIteration, pConverter->channelConverter.channelsOut, pConverter->config.ditherMode);
}
}


framesProcessedIn += frameCountInThisIteration;
framesProcessedOut += frameCountOutThisIteration;

MA_ASSERT(framesProcessedIn <= frameCountIn);
MA_ASSERT(framesProcessedOut <= frameCountOut);

if (frameCountOutThisIteration == 0) {
break; 
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = framesProcessedIn;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = framesProcessedOut;
}

return MA_SUCCESS;
}

static ma_result ma_data_converter_process_pcm_frames__channels_first(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
ma_result result;
ma_uint64 frameCountIn;
ma_uint64 frameCountOut;
ma_uint64 framesProcessedIn;
ma_uint64 framesProcessedOut;
ma_uint8 pTempBufferIn[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferInCap;
ma_uint8 pTempBufferMid[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferMidCap;
ma_uint8 pTempBufferOut[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 tempBufferOutCap;

MA_ASSERT(pConverter != NULL);
MA_ASSERT(pConverter->resampler.config.format == pConverter->channelConverter.format);
MA_ASSERT(pConverter->resampler.config.channels == pConverter->channelConverter.channelsOut);
MA_ASSERT(pConverter->resampler.config.channels < pConverter->channelConverter.channelsIn);

frameCountIn = 0;
if (pFrameCountIn != NULL) {
frameCountIn = *pFrameCountIn;
}

frameCountOut = 0;
if (pFrameCountOut != NULL) {
frameCountOut = *pFrameCountOut;
}

framesProcessedIn = 0;
framesProcessedOut = 0;

tempBufferInCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsIn);
tempBufferMidCap = sizeof(pTempBufferIn) / ma_get_bytes_per_frame(pConverter->channelConverter.format, pConverter->channelConverter.channelsOut);
tempBufferOutCap = sizeof(pTempBufferOut) / ma_get_bytes_per_frame(pConverter->resampler.config.format, pConverter->resampler.config.channels);

while (framesProcessedOut < frameCountOut) {
ma_uint64 frameCountInThisIteration;
ma_uint64 frameCountOutThisIteration;
const void* pRunningFramesIn = NULL;
void* pRunningFramesOut = NULL;
const void* pChannelsBufferIn;
void* pResampleBufferOut;

if (pFramesIn != NULL) {
pRunningFramesIn = ma_offset_ptr(pFramesIn, framesProcessedIn * ma_get_bytes_per_frame(pConverter->config.formatIn, pConverter->config.channelsIn));
}
if (pFramesOut != NULL) {
pRunningFramesOut = ma_offset_ptr(pFramesOut, framesProcessedOut * ma_get_bytes_per_frame(pConverter->config.formatOut, pConverter->config.channelsOut));
}


frameCountInThisIteration = (frameCountIn - framesProcessedIn);

if (pConverter->hasPreFormatConversion) {
if (frameCountInThisIteration > tempBufferInCap) {
frameCountInThisIteration = tempBufferInCap;
}

if (pRunningFramesIn != NULL) {
ma_convert_pcm_frames_format(pTempBufferIn, pConverter->channelConverter.format, pRunningFramesIn, pConverter->config.formatIn, frameCountInThisIteration, pConverter->config.channelsIn, pConverter->config.ditherMode);
pChannelsBufferIn = pTempBufferIn;
} else {
pChannelsBufferIn = NULL;
}
} else {
pChannelsBufferIn = pRunningFramesIn;
}





if (frameCountInThisIteration > tempBufferMidCap) {
frameCountInThisIteration = tempBufferMidCap;
}





frameCountOutThisIteration = (frameCountOut - framesProcessedOut);
if (frameCountOutThisIteration > tempBufferMidCap) {
frameCountOutThisIteration = tempBufferMidCap;
}

if (pConverter->hasPostFormatConversion) {
ma_uint64 requiredInputFrameCount;

if (frameCountOutThisIteration > tempBufferOutCap) {
frameCountOutThisIteration = tempBufferOutCap;
}

requiredInputFrameCount = ma_resampler_get_required_input_frame_count(&pConverter->resampler, frameCountOutThisIteration);
if (frameCountInThisIteration > requiredInputFrameCount) {
frameCountInThisIteration = requiredInputFrameCount;
}
}

result = ma_channel_converter_process_pcm_frames(&pConverter->channelConverter, pTempBufferMid, pChannelsBufferIn, frameCountInThisIteration);
if (result != MA_SUCCESS) {
return result;
}



if (pConverter->hasPostFormatConversion) {
pResampleBufferOut = pTempBufferOut;
} else {
pResampleBufferOut = pRunningFramesOut;
}

result = ma_resampler_process_pcm_frames(&pConverter->resampler, pTempBufferMid, &frameCountInThisIteration, pResampleBufferOut, &frameCountOutThisIteration);
if (result != MA_SUCCESS) {
return result;
}


if (pConverter->hasPostFormatConversion) {
if (pRunningFramesOut != NULL) {
ma_convert_pcm_frames_format(pRunningFramesOut, pConverter->config.formatOut, pResampleBufferOut, pConverter->resampler.config.format, frameCountOutThisIteration, pConverter->config.channelsOut, pConverter->config.ditherMode);
}
}

framesProcessedIn += frameCountInThisIteration;
framesProcessedOut += frameCountOutThisIteration;

MA_ASSERT(framesProcessedIn <= frameCountIn);
MA_ASSERT(framesProcessedOut <= frameCountOut);

if (frameCountOutThisIteration == 0) {
break; 
}
}

if (pFrameCountIn != NULL) {
*pFrameCountIn = framesProcessedIn;
}
if (pFrameCountOut != NULL) {
*pFrameCountOut = framesProcessedOut;
}

return MA_SUCCESS;
}

ma_result ma_data_converter_process_pcm_frames(ma_data_converter* pConverter, const void* pFramesIn, ma_uint64* pFrameCountIn, void* pFramesOut, ma_uint64* pFrameCountOut)
{
if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

if (pConverter->isPassthrough) {
return ma_data_converter_process_pcm_frames__passthrough(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}






if (pConverter->config.channelsIn < pConverter->config.channelsOut) {

MA_ASSERT(pConverter->hasChannelConverter == MA_TRUE);

if (pConverter->hasResampler) {

return ma_data_converter_process_pcm_frames__resampling_first(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

return ma_data_converter_process_pcm_frames__channels_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
} else {

if (pConverter->hasChannelConverter) {
if (pConverter->hasResampler) {

return ma_data_converter_process_pcm_frames__channels_first(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

return ma_data_converter_process_pcm_frames__channels_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
} else {

if (pConverter->hasResampler) {

return ma_data_converter_process_pcm_frames__resample_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
} else {

return ma_data_converter_process_pcm_frames__format_only(pConverter, pFramesIn, pFrameCountIn, pFramesOut, pFrameCountOut);
}
}
}
}

ma_result ma_data_converter_set_rate(ma_data_converter* pConverter, ma_uint32 sampleRateIn, ma_uint32 sampleRateOut)
{
if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

if (pConverter->hasResampler == MA_FALSE) {
return MA_INVALID_OPERATION; 
}

return ma_resampler_set_rate(&pConverter->resampler, sampleRateIn, sampleRateOut);
}

ma_result ma_data_converter_set_rate_ratio(ma_data_converter* pConverter, float ratioInOut)
{
if (pConverter == NULL) {
return MA_INVALID_ARGS;
}

if (pConverter->hasResampler == MA_FALSE) {
return MA_INVALID_OPERATION; 
}

return ma_resampler_set_rate_ratio(&pConverter->resampler, ratioInOut);
}

ma_uint64 ma_data_converter_get_required_input_frame_count(ma_data_converter* pConverter, ma_uint64 outputFrameCount)
{
if (pConverter == NULL) {
return 0;
}

if (pConverter->hasResampler) {
return ma_resampler_get_required_input_frame_count(&pConverter->resampler, outputFrameCount);
} else {
return outputFrameCount; 
}
}

ma_uint64 ma_data_converter_get_expected_output_frame_count(ma_data_converter* pConverter, ma_uint64 inputFrameCount)
{
if (pConverter == NULL) {
return 0;
}

if (pConverter->hasResampler) {
return ma_resampler_get_expected_output_frame_count(&pConverter->resampler, inputFrameCount);
} else {
return inputFrameCount; 
}
}

ma_uint64 ma_data_converter_get_input_latency(ma_data_converter* pConverter)
{
if (pConverter == NULL) {
return 0;
}

if (pConverter->hasResampler) {
return ma_resampler_get_input_latency(&pConverter->resampler);
}

return 0; 
}

ma_uint64 ma_data_converter_get_output_latency(ma_data_converter* pConverter)
{
if (pConverter == NULL) {
return 0;
}

if (pConverter->hasResampler) {
return ma_resampler_get_output_latency(&pConverter->resampler);
}

return 0; 
}










void ma_pcm_u8_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
(void)ditherMode;
ma_copy_memory_64(dst, src, count * sizeof(ma_uint8));
}


static MA_INLINE void ma_pcm_u8_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int16* dst_s16 = (ma_int16*)dst;
const ma_uint8* src_u8 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int16 x = src_u8[i];
x = x - 128;
x = x << 8;
dst_s16[i] = x;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_u8_to_s16__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_u8_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_u8_to_s16__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_u8_to_s16__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_u8_to_s16__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_u8_to_s16__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_u8_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_u8_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_s24 = (ma_uint8*)dst;
const ma_uint8* src_u8 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int16 x = src_u8[i];
x = x - 128;

dst_s24[i*3+0] = 0;
dst_s24[i*3+1] = 0;
dst_s24[i*3+2] = (ma_uint8)((ma_int8)x);
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_u8_to_s24__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_u8_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_u8_to_s24__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_u8_to_s24__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_u8_to_s24__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_u8_to_s24__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_u8_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_u8_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int32* dst_s32 = (ma_int32*)dst;
const ma_uint8* src_u8 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = src_u8[i];
x = x - 128;
x = x << 24;
dst_s32[i] = x;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_u8_to_s32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_u8_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_u8_to_s32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_u8_to_s32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_u8_to_s32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_u8_to_s32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_u8_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_u8_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
float* dst_f32 = (float*)dst;
const ma_uint8* src_u8 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
float x = (float)src_u8[i];
x = x * 0.00784313725490196078f; 
x = x - 1; 

dst_f32[i] = x;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_u8_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_u8_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_u8_to_f32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_u8_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_u8_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_u8_to_f32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_u8_to_f32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_u8_to_f32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_u8_to_f32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_u8_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
}


#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
static MA_INLINE void ma_pcm_interleave_u8__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_uint8* dst_u8 = (ma_uint8*)dst;
const ma_uint8** src_u8 = (const ma_uint8**)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
}
}
}
#else
static MA_INLINE void ma_pcm_interleave_u8__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_uint8* dst_u8 = (ma_uint8*)dst;
const ma_uint8** src_u8 = (const ma_uint8**)src;

if (channels == 1) {
ma_copy_memory_64(dst, src[0], frameCount * sizeof(ma_uint8));
} else if (channels == 2) {
ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
dst_u8[iFrame*2 + 0] = src_u8[0][iFrame];
dst_u8[iFrame*2 + 1] = src_u8[1][iFrame];
}
} else {
ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_u8[iFrame*channels + iChannel] = src_u8[iChannel][iFrame];
}
}
}
}
#endif

void ma_pcm_interleave_u8(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_interleave_u8__reference(dst, src, frameCount, channels);
#else
ma_pcm_interleave_u8__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_u8__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_uint8** dst_u8 = (ma_uint8**)dst;
const ma_uint8* src_u8 = (const ma_uint8*)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_u8[iChannel][iFrame] = src_u8[iFrame*channels + iChannel];
}
}
}

static MA_INLINE void ma_pcm_deinterleave_u8__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
}

void ma_pcm_deinterleave_u8(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_deinterleave_u8__reference(dst, src, frameCount, channels);
#else
ma_pcm_deinterleave_u8__optimized(dst, src, frameCount, channels);
#endif
}



static MA_INLINE void ma_pcm_s16_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_u8 = (ma_uint8*)dst;
const ma_int16* src_s16 = (const ma_int16*)src;

if (ditherMode == ma_dither_mode_none) {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int16 x = src_s16[i];
x = x >> 8;
x = x + 128;
dst_u8[i] = (ma_uint8)x;
}
} else {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int16 x = src_s16[i];


ma_int32 dither = ma_dither_s32(ditherMode, -0x80, 0x7F);
if ((x + dither) <= 0x7FFF) {
x = (ma_int16)(x + dither);
} else {
x = 0x7FFF;
}

x = x >> 8;
x = x + 128;
dst_u8[i] = (ma_uint8)x;
}
}
}

static MA_INLINE void ma_pcm_s16_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s16_to_u8__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s16_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s16_to_u8__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s16_to_u8__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s16_to_u8__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s16_to_u8__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s16_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
}


void ma_pcm_s16_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
(void)ditherMode;
ma_copy_memory_64(dst, src, count * sizeof(ma_int16));
}


static MA_INLINE void ma_pcm_s16_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_s24 = (ma_uint8*)dst;
const ma_int16* src_s16 = (const ma_int16*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
dst_s24[i*3+0] = 0;
dst_s24[i*3+1] = (ma_uint8)(src_s16[i] & 0xFF);
dst_s24[i*3+2] = (ma_uint8)(src_s16[i] >> 8);
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s16_to_s24__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s16_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s16_to_s24__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s16_to_s24__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s16_to_s24__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s16_to_s24__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s16_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s16_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int32* dst_s32 = (ma_int32*)dst;
const ma_int16* src_s16 = (const ma_int16*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
dst_s32[i] = src_s16[i] << 16;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s16_to_s32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s16_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s16_to_s32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s16_to_s32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s16_to_s32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s16_to_s32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s16_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s16_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
float* dst_f32 = (float*)dst;
const ma_int16* src_s16 = (const ma_int16*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
float x = (float)src_s16[i];

#if 0

x = x + 32768.0f; 
x = x * 0.00003051804379339284f; 
x = x - 1; 
#else

x = x * 0.000030517578125f; 
#endif

dst_f32[i] = x;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_s16_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s16_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s16_to_f32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s16_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s16_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s16_to_f32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s16_to_f32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s16_to_f32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s16_to_f32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s16_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_interleave_s16__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_int16* dst_s16 = (ma_int16*)dst;
const ma_int16** src_s16 = (const ma_int16**)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_s16[iFrame*channels + iChannel] = src_s16[iChannel][iFrame];
}
}
}

static MA_INLINE void ma_pcm_interleave_s16__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_interleave_s16__reference(dst, src, frameCount, channels);
}

void ma_pcm_interleave_s16(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_interleave_s16__reference(dst, src, frameCount, channels);
#else
ma_pcm_interleave_s16__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s16__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_int16** dst_s16 = (ma_int16**)dst;
const ma_int16* src_s16 = (const ma_int16*)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_s16[iChannel][iFrame] = src_s16[iFrame*channels + iChannel];
}
}
}

static MA_INLINE void ma_pcm_deinterleave_s16__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
}

void ma_pcm_deinterleave_s16(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_deinterleave_s16__reference(dst, src, frameCount, channels);
#else
ma_pcm_deinterleave_s16__optimized(dst, src, frameCount, channels);
#endif
}



static MA_INLINE void ma_pcm_s24_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_u8 = (ma_uint8*)dst;
const ma_uint8* src_s24 = (const ma_uint8*)src;

if (ditherMode == ma_dither_mode_none) {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int8 x = (ma_int8)src_s24[i*3 + 2] + 128;
dst_u8[i] = (ma_uint8)x;
}
} else {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);


ma_int32 dither = ma_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
if ((ma_int64)x + dither <= 0x7FFFFFFF) {
x = x + dither;
} else {
x = 0x7FFFFFFF;
}

x = x >> 24;
x = x + 128;
dst_u8[i] = (ma_uint8)x;
}
}
}

static MA_INLINE void ma_pcm_s24_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s24_to_u8__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s24_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s24_to_u8__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s24_to_u8__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s24_to_u8__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s24_to_u8__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s24_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s24_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int16* dst_s16 = (ma_int16*)dst;
const ma_uint8* src_s24 = (const ma_uint8*)src;

if (ditherMode == ma_dither_mode_none) {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_uint16 dst_lo = ((ma_uint16)src_s24[i*3 + 1]);
ma_uint16 dst_hi = ((ma_uint16)src_s24[i*3 + 2]) << 8;
dst_s16[i] = (ma_int16)dst_lo | dst_hi;
}
} else {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);


ma_int32 dither = ma_dither_s32(ditherMode, -0x8000, 0x7FFF);
if ((ma_int64)x + dither <= 0x7FFFFFFF) {
x = x + dither;
} else {
x = 0x7FFFFFFF;
}

x = x >> 16;
dst_s16[i] = (ma_int16)x;
}
}
}

static MA_INLINE void ma_pcm_s24_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s24_to_s16__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s24_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s24_to_s16__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s24_to_s16__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s24_to_s16__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s24_to_s16__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s24_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
}


void ma_pcm_s24_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
(void)ditherMode;

ma_copy_memory_64(dst, src, count * 3);
}


static MA_INLINE void ma_pcm_s24_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int32* dst_s32 = (ma_int32*)dst;
const ma_uint8* src_s24 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
dst_s32[i] = (ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24);
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_s24_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s24_to_s32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s24_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s24_to_s32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s24_to_s32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s24_to_s32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s24_to_s32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s24_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s24_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
float* dst_f32 = (float*)dst;
const ma_uint8* src_s24 = (const ma_uint8*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
float x = (float)(((ma_int32)(((ma_uint32)(src_s24[i*3+0]) << 8) | ((ma_uint32)(src_s24[i*3+1]) << 16) | ((ma_uint32)(src_s24[i*3+2])) << 24)) >> 8);

#if 0

x = x + 8388608.0f; 
x = x * 0.00000011920929665621f; 
x = x - 1; 
#else

x = x * 0.00000011920928955078125f; 
#endif

dst_f32[i] = x;
}

(void)ditherMode;
}

static MA_INLINE void ma_pcm_s24_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s24_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s24_to_f32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s24_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s24_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s24_to_f32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s24_to_f32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s24_to_f32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s24_to_f32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s24_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_interleave_s24__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_uint8* dst8 = (ma_uint8*)dst;
const ma_uint8** src8 = (const ma_uint8**)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst8[iFrame*3*channels + iChannel*3 + 0] = src8[iChannel][iFrame*3 + 0];
dst8[iFrame*3*channels + iChannel*3 + 1] = src8[iChannel][iFrame*3 + 1];
dst8[iFrame*3*channels + iChannel*3 + 2] = src8[iChannel][iFrame*3 + 2];
}
}
}

static MA_INLINE void ma_pcm_interleave_s24__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_interleave_s24__reference(dst, src, frameCount, channels);
}

void ma_pcm_interleave_s24(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_interleave_s24__reference(dst, src, frameCount, channels);
#else
ma_pcm_interleave_s24__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s24__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_uint8** dst8 = (ma_uint8**)dst;
const ma_uint8* src8 = (const ma_uint8*)src;

ma_uint32 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst8[iChannel][iFrame*3 + 0] = src8[iFrame*3*channels + iChannel*3 + 0];
dst8[iChannel][iFrame*3 + 1] = src8[iFrame*3*channels + iChannel*3 + 1];
dst8[iChannel][iFrame*3 + 2] = src8[iFrame*3*channels + iChannel*3 + 2];
}
}
}

static MA_INLINE void ma_pcm_deinterleave_s24__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
}

void ma_pcm_deinterleave_s24(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_deinterleave_s24__reference(dst, src, frameCount, channels);
#else
ma_pcm_deinterleave_s24__optimized(dst, src, frameCount, channels);
#endif
}




static MA_INLINE void ma_pcm_s32_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_u8 = (ma_uint8*)dst;
const ma_int32* src_s32 = (const ma_int32*)src;

if (ditherMode == ma_dither_mode_none) {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = src_s32[i];
x = x >> 24;
x = x + 128;
dst_u8[i] = (ma_uint8)x;
}
} else {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = src_s32[i];


ma_int32 dither = ma_dither_s32(ditherMode, -0x800000, 0x7FFFFF);
if ((ma_int64)x + dither <= 0x7FFFFFFF) {
x = x + dither;
} else {
x = 0x7FFFFFFF;
}

x = x >> 24;
x = x + 128;
dst_u8[i] = (ma_uint8)x;
}
}
}

static MA_INLINE void ma_pcm_s32_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s32_to_u8__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s32_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s32_to_u8__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s32_to_u8__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s32_to_u8__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s32_to_u8__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s32_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int16* dst_s16 = (ma_int16*)dst;
const ma_int32* src_s32 = (const ma_int32*)src;

if (ditherMode == ma_dither_mode_none) {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = src_s32[i];
x = x >> 16;
dst_s16[i] = (ma_int16)x;
}
} else {
ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 x = src_s32[i];


ma_int32 dither = ma_dither_s32(ditherMode, -0x8000, 0x7FFF);
if ((ma_int64)x + dither <= 0x7FFFFFFF) {
x = x + dither;
} else {
x = 0x7FFFFFFF;
}

x = x >> 16;
dst_s16[i] = (ma_int16)x;
}
}
}

static MA_INLINE void ma_pcm_s32_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s32_to_s16__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s32_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s32_to_s16__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s32_to_s16__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s32_to_s16__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s32_to_s16__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_s32_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_s24 = (ma_uint8*)dst;
const ma_int32* src_s32 = (const ma_int32*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_uint32 x = (ma_uint32)src_s32[i];
dst_s24[i*3+0] = (ma_uint8)((x & 0x0000FF00) >> 8);
dst_s24[i*3+1] = (ma_uint8)((x & 0x00FF0000) >> 16);
dst_s24[i*3+2] = (ma_uint8)((x & 0xFF000000) >> 24);
}

(void)ditherMode; 
}

static MA_INLINE void ma_pcm_s32_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s32_to_s24__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s32_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s32_to_s24__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s32_to_s24__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s32_to_s24__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s32_to_s24__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
}


void ma_pcm_s32_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
(void)ditherMode;

ma_copy_memory_64(dst, src, count * sizeof(ma_int32));
}


static MA_INLINE void ma_pcm_s32_to_f32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
float* dst_f32 = (float*)dst;
const ma_int32* src_s32 = (const ma_int32*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
double x = src_s32[i];

#if 0
x = x + 2147483648.0;
x = x * 0.0000000004656612873077392578125;
x = x - 1;
#else
x = x / 2147483648.0;
#endif

dst_f32[i] = (float)x;
}

(void)ditherMode; 
}

static MA_INLINE void ma_pcm_s32_to_f32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_s32_to_f32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_s32_to_f32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_s32_to_f32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_s32_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_s32_to_f32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_s32_to_f32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_s32_to_f32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_s32_to_f32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_s32_to_f32__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_interleave_s32__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_int32* dst_s32 = (ma_int32*)dst;
const ma_int32** src_s32 = (const ma_int32**)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_s32[iFrame*channels + iChannel] = src_s32[iChannel][iFrame];
}
}
}

static MA_INLINE void ma_pcm_interleave_s32__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_interleave_s32__reference(dst, src, frameCount, channels);
}

void ma_pcm_interleave_s32(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_interleave_s32__reference(dst, src, frameCount, channels);
#else
ma_pcm_interleave_s32__optimized(dst, src, frameCount, channels);
#endif
}


static MA_INLINE void ma_pcm_deinterleave_s32__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_int32** dst_s32 = (ma_int32**)dst;
const ma_int32* src_s32 = (const ma_int32*)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_s32[iChannel][iFrame] = src_s32[iFrame*channels + iChannel];
}
}
}

static MA_INLINE void ma_pcm_deinterleave_s32__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
}

void ma_pcm_deinterleave_s32(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_deinterleave_s32__reference(dst, src, frameCount, channels);
#else
ma_pcm_deinterleave_s32__optimized(dst, src, frameCount, channels);
#endif
}



static MA_INLINE void ma_pcm_f32_to_u8__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;

ma_uint8* dst_u8 = (ma_uint8*)dst;
const float* src_f32 = (const float*)src;

float ditherMin = 0;
float ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -128;
ditherMax = 1.0f / 127;
}

for (i = 0; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 
x = x + 1; 
x = x * 127.5f; 

dst_u8[i] = (ma_uint8)x;
}
}

static MA_INLINE void ma_pcm_f32_to_u8__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_u8__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_f32_to_u8__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_u8__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_f32_to_u8(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_f32_to_u8__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_f32_to_u8__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_f32_to_u8__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_f32_to_u8__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_f32_to_u8__optimized(dst, src, count, ditherMode);
}
#endif
}

#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
static MA_INLINE void ma_pcm_f32_to_s16__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;

ma_int16* dst_s16 = (ma_int16*)dst;
const float* src_f32 = (const float*)src;

float ditherMin = 0;
float ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -32768;
ditherMax = 1.0f / 32767;
}

for (i = 0; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 

#if 0

x = x + 1; 
x = x * 32767.5f; 
x = x - 32768.0f; 
#else

x = x * 32767.0f; 
#endif

dst_s16[i] = (ma_int16)x;
}
}
#else
static MA_INLINE void ma_pcm_f32_to_s16__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;
ma_uint64 i4;
ma_uint64 count4;

ma_int16* dst_s16 = (ma_int16*)dst;
const float* src_f32 = (const float*)src;

float ditherMin = 0;
float ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -32768;
ditherMax = 1.0f / 32767;
}


i = 0;
count4 = count >> 2;
for (i4 = 0; i4 < count4; i4 += 1) {
float d0 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
float d1 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
float d2 = ma_dither_f32(ditherMode, ditherMin, ditherMax);
float d3 = ma_dither_f32(ditherMode, ditherMin, ditherMax);

float x0 = src_f32[i+0];
float x1 = src_f32[i+1];
float x2 = src_f32[i+2];
float x3 = src_f32[i+3];

x0 = x0 + d0;
x1 = x1 + d1;
x2 = x2 + d2;
x3 = x3 + d3;

x0 = ((x0 < -1) ? -1 : ((x0 > 1) ? 1 : x0));
x1 = ((x1 < -1) ? -1 : ((x1 > 1) ? 1 : x1));
x2 = ((x2 < -1) ? -1 : ((x2 > 1) ? 1 : x2));
x3 = ((x3 < -1) ? -1 : ((x3 > 1) ? 1 : x3));

x0 = x0 * 32767.0f;
x1 = x1 * 32767.0f;
x2 = x2 * 32767.0f;
x3 = x3 * 32767.0f;

dst_s16[i+0] = (ma_int16)x0;
dst_s16[i+1] = (ma_int16)x1;
dst_s16[i+2] = (ma_int16)x2;
dst_s16[i+3] = (ma_int16)x3;

i += 4;
}


for (; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 
x = x * 32767.0f; 

dst_s16[i] = (ma_int16)x;
}
}
#endif

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s16__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;
ma_uint64 i8;
ma_uint64 count8;
ma_int16* dst_s16;
const float* src_f32;
float ditherMin;
float ditherMax;


if ((((ma_uintptr)dst & 15) != 0) || (((ma_uintptr)src & 15) != 0)) {
ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
return;
}

dst_s16 = (ma_int16*)dst;
src_f32 = (const float*)src;

ditherMin = 0;
ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -32768;
ditherMax = 1.0f / 32767;
}

i = 0;


count8 = count >> 3;
for (i8 = 0; i8 < count8; i8 += 1) {
__m128 d0;
__m128 d1;
__m128 x0;
__m128 x1;

if (ditherMode == ma_dither_mode_none) {
d0 = _mm_set1_ps(0);
d1 = _mm_set1_ps(0);
} else if (ditherMode == ma_dither_mode_rectangle) {
d0 = _mm_set_ps(
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax)
);
d1 = _mm_set_ps(
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax)
);
} else {
d0 = _mm_set_ps(
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax)
);
d1 = _mm_set_ps(
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax)
);
}

x0 = *((__m128*)(src_f32 + i) + 0);
x1 = *((__m128*)(src_f32 + i) + 1);

x0 = _mm_add_ps(x0, d0);
x1 = _mm_add_ps(x1, d1);

x0 = _mm_mul_ps(x0, _mm_set1_ps(32767.0f));
x1 = _mm_mul_ps(x1, _mm_set1_ps(32767.0f));

_mm_stream_si128(((__m128i*)(dst_s16 + i)), _mm_packs_epi32(_mm_cvttps_epi32(x0), _mm_cvttps_epi32(x1)));

i += 8;
}



for (; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 
x = x * 32767.0f; 

dst_s16[i] = (ma_int16)x;
}
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_f32_to_s16__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;
ma_uint64 i16;
ma_uint64 count16;
ma_int16* dst_s16;
const float* src_f32;
float ditherMin;
float ditherMax;


if ((((ma_uintptr)dst & 31) != 0) || (((ma_uintptr)src & 31) != 0)) {
ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
return;
}

dst_s16 = (ma_int16*)dst;
src_f32 = (const float*)src;

ditherMin = 0;
ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -32768;
ditherMax = 1.0f / 32767;
}

i = 0;


count16 = count >> 4;
for (i16 = 0; i16 < count16; i16 += 1) {
__m256 d0;
__m256 d1;
__m256 x0;
__m256 x1;
__m256i i0;
__m256i i1;
__m256i p0;
__m256i p1;
__m256i r;

if (ditherMode == ma_dither_mode_none) {
d0 = _mm256_set1_ps(0);
d1 = _mm256_set1_ps(0);
} else if (ditherMode == ma_dither_mode_rectangle) {
d0 = _mm256_set_ps(
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax)
);
d1 = _mm256_set_ps(
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax),
ma_dither_f32_rectangle(ditherMin, ditherMax)
);
} else {
d0 = _mm256_set_ps(
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax)
);
d1 = _mm256_set_ps(
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax),
ma_dither_f32_triangle(ditherMin, ditherMax)
);
}

x0 = *((__m256*)(src_f32 + i) + 0);
x1 = *((__m256*)(src_f32 + i) + 1);

x0 = _mm256_add_ps(x0, d0);
x1 = _mm256_add_ps(x1, d1);

x0 = _mm256_mul_ps(x0, _mm256_set1_ps(32767.0f));
x1 = _mm256_mul_ps(x1, _mm256_set1_ps(32767.0f));


i0 = _mm256_cvttps_epi32(x0);
i1 = _mm256_cvttps_epi32(x1);
p0 = _mm256_permute2x128_si256(i0, i1, 0 | 32);
p1 = _mm256_permute2x128_si256(i0, i1, 1 | 48);
r = _mm256_packs_epi32(p0, p1);

_mm256_stream_si256(((__m256i*)(dst_s16 + i)), r);

i += 16;
}



for (; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 
x = x * 32767.0f; 

dst_s16[i] = (ma_int16)x;
}
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s16__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint64 i;
ma_uint64 i8;
ma_uint64 count8;
ma_int16* dst_s16;
const float* src_f32;
float ditherMin;
float ditherMax;

if (!ma_has_neon()) {
return ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
}


if ((((ma_uintptr)dst & 15) != 0) || (((ma_uintptr)src & 15) != 0)) {
ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
return;
}

dst_s16 = (ma_int16*)dst;
src_f32 = (const float*)src;

ditherMin = 0;
ditherMax = 0;
if (ditherMode != ma_dither_mode_none) {
ditherMin = 1.0f / -32768;
ditherMax = 1.0f / 32767;
}

i = 0;


count8 = count >> 3;
for (i8 = 0; i8 < count8; i8 += 1) {
float32x4_t d0;
float32x4_t d1;
float32x4_t x0;
float32x4_t x1;
int32x4_t i0;
int32x4_t i1;

if (ditherMode == ma_dither_mode_none) {
d0 = vmovq_n_f32(0);
d1 = vmovq_n_f32(0);
} else if (ditherMode == ma_dither_mode_rectangle) {
float d0v[4];
d0v[0] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d0v[1] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d0v[2] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d0v[3] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d0 = vld1q_f32(d0v);

float d1v[4];
d1v[0] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d1v[1] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d1v[2] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d1v[3] = ma_dither_f32_rectangle(ditherMin, ditherMax);
d1 = vld1q_f32(d1v);
} else {
float d0v[4];
d0v[0] = ma_dither_f32_triangle(ditherMin, ditherMax);
d0v[1] = ma_dither_f32_triangle(ditherMin, ditherMax);
d0v[2] = ma_dither_f32_triangle(ditherMin, ditherMax);
d0v[3] = ma_dither_f32_triangle(ditherMin, ditherMax);
d0 = vld1q_f32(d0v);

float d1v[4];
d1v[0] = ma_dither_f32_triangle(ditherMin, ditherMax);
d1v[1] = ma_dither_f32_triangle(ditherMin, ditherMax);
d1v[2] = ma_dither_f32_triangle(ditherMin, ditherMax);
d1v[3] = ma_dither_f32_triangle(ditherMin, ditherMax);
d1 = vld1q_f32(d1v);
}

x0 = *((float32x4_t*)(src_f32 + i) + 0);
x1 = *((float32x4_t*)(src_f32 + i) + 1);

x0 = vaddq_f32(x0, d0);
x1 = vaddq_f32(x1, d1);

x0 = vmulq_n_f32(x0, 32767.0f);
x1 = vmulq_n_f32(x1, 32767.0f);

i0 = vcvtq_s32_f32(x0);
i1 = vcvtq_s32_f32(x1);
*((int16x8_t*)(dst_s16 + i)) = vcombine_s16(vqmovn_s32(i0), vqmovn_s32(i1));

i += 8;
}



for (; i < count; i += 1) {
float x = src_f32[i];
x = x + ma_dither_f32(ditherMode, ditherMin, ditherMax);
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 
x = x * 32767.0f; 

dst_s16[i] = (ma_int16)x;
}
}
#endif

void ma_pcm_f32_to_s16(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_f32_to_s16__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_f32_to_s16__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_f32_to_s16__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_f32_to_s16__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_f32_to_s16__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_f32_to_s24__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_uint8* dst_s24 = (ma_uint8*)dst;
const float* src_f32 = (const float*)src;

ma_uint64 i;
for (i = 0; i < count; i += 1) {
ma_int32 r;
float x = src_f32[i];
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 

#if 0

x = x + 1; 
x = x * 8388607.5f; 
x = x - 8388608.0f; 
#else

x = x * 8388607.0f; 
#endif

r = (ma_int32)x;
dst_s24[(i*3)+0] = (ma_uint8)((r & 0x0000FF) >> 0);
dst_s24[(i*3)+1] = (ma_uint8)((r & 0x00FF00) >> 8);
dst_s24[(i*3)+2] = (ma_uint8)((r & 0xFF0000) >> 16);
}

(void)ditherMode; 
}

static MA_INLINE void ma_pcm_f32_to_s24__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s24__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_f32_to_s24__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s24__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_f32_to_s24(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_f32_to_s24__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_f32_to_s24__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_f32_to_s24__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_f32_to_s24__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_f32_to_s24__optimized(dst, src, count, ditherMode);
}
#endif
}


static MA_INLINE void ma_pcm_f32_to_s32__reference(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_int32* dst_s32 = (ma_int32*)dst;
const float* src_f32 = (const float*)src;

ma_uint32 i;
for (i = 0; i < count; i += 1) {
double x = src_f32[i];
x = ((x < -1) ? -1 : ((x > 1) ? 1 : x)); 

#if 0

x = x + 1; 
x = x * 2147483647.5; 
x = x - 2147483648.0; 
#else

x = x * 2147483647.0; 
#endif

dst_s32[i] = (ma_int32)x;
}

(void)ditherMode; 
}

static MA_INLINE void ma_pcm_f32_to_s32__optimized(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
}

#if defined(MA_SUPPORT_SSE2)
static MA_INLINE void ma_pcm_f32_to_s32__sse2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_AVX2)
static MA_INLINE void ma_pcm_f32_to_s32__avx2(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
#if defined(MA_SUPPORT_NEON)
static MA_INLINE void ma_pcm_f32_to_s32__neon(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif

void ma_pcm_f32_to_s32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_f32_to_s32__reference(dst, src, count, ditherMode);
#else
#if MA_PREFERRED_SIMD == MA_SIMD_AVX2
if (ma_has_avx2()) {
ma_pcm_f32_to_s32__avx2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_SSE2
if (ma_has_sse2()) {
ma_pcm_f32_to_s32__sse2(dst, src, count, ditherMode);
} else
#elif MA_PREFERRED_SIMD == MA_SIMD_NEON
if (ma_has_neon()) {
ma_pcm_f32_to_s32__neon(dst, src, count, ditherMode);
} else
#endif
{
ma_pcm_f32_to_s32__optimized(dst, src, count, ditherMode);
}
#endif
}


void ma_pcm_f32_to_f32(void* dst, const void* src, ma_uint64 count, ma_dither_mode ditherMode)
{
(void)ditherMode;

ma_copy_memory_64(dst, src, count * sizeof(float));
}


static void ma_pcm_interleave_f32__reference(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
float* dst_f32 = (float*)dst;
const float** src_f32 = (const float**)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_f32[iFrame*channels + iChannel] = src_f32[iChannel][iFrame];
}
}
}

static void ma_pcm_interleave_f32__optimized(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_interleave_f32__reference(dst, src, frameCount, channels);
}

void ma_pcm_interleave_f32(void* dst, const void** src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_interleave_f32__reference(dst, src, frameCount, channels);
#else
ma_pcm_interleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


static void ma_pcm_deinterleave_f32__reference(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
float** dst_f32 = (float**)dst;
const float* src_f32 = (const float*)src;

ma_uint64 iFrame;
for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; iChannel += 1) {
dst_f32[iChannel][iFrame] = src_f32[iFrame*channels + iChannel];
}
}
}

static void ma_pcm_deinterleave_f32__optimized(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
ma_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
}

void ma_pcm_deinterleave_f32(void** dst, const void* src, ma_uint64 frameCount, ma_uint32 channels)
{
#if defined(MA_USE_REFERENCE_CONVERSION_APIS)
ma_pcm_deinterleave_f32__reference(dst, src, frameCount, channels);
#else
ma_pcm_deinterleave_f32__optimized(dst, src, frameCount, channels);
#endif
}


void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode)
{
if (formatOut == formatIn) {
ma_copy_memory_64(pOut, pIn, sampleCount * ma_get_bytes_per_sample(formatOut));
return;
}

switch (formatIn)
{
case ma_format_u8:
{
switch (formatOut)
{
case ma_format_s16: ma_pcm_u8_to_s16(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s24: ma_pcm_u8_to_s24(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s32: ma_pcm_u8_to_s32(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_f32: ma_pcm_u8_to_f32(pOut, pIn, sampleCount, ditherMode); return;
default: break;
}
} break;

case ma_format_s16:
{
switch (formatOut)
{
case ma_format_u8: ma_pcm_s16_to_u8( pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s24: ma_pcm_s16_to_s24(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s32: ma_pcm_s16_to_s32(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_f32: ma_pcm_s16_to_f32(pOut, pIn, sampleCount, ditherMode); return;
default: break;
}
} break;

case ma_format_s24:
{
switch (formatOut)
{
case ma_format_u8: ma_pcm_s24_to_u8( pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s16: ma_pcm_s24_to_s16(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s32: ma_pcm_s24_to_s32(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_f32: ma_pcm_s24_to_f32(pOut, pIn, sampleCount, ditherMode); return;
default: break;
}
} break;

case ma_format_s32:
{
switch (formatOut)
{
case ma_format_u8: ma_pcm_s32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s16: ma_pcm_s32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s24: ma_pcm_s32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_f32: ma_pcm_s32_to_f32(pOut, pIn, sampleCount, ditherMode); return;
default: break;
}
} break;

case ma_format_f32:
{
switch (formatOut)
{
case ma_format_u8: ma_pcm_f32_to_u8( pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s16: ma_pcm_f32_to_s16(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s24: ma_pcm_f32_to_s24(pOut, pIn, sampleCount, ditherMode); return;
case ma_format_s32: ma_pcm_f32_to_s32(pOut, pIn, sampleCount, ditherMode); return;
default: break;
}
} break;

default: break;
}
}

void ma_convert_pcm_frames_format(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 frameCount, ma_uint32 channels, ma_dither_mode ditherMode)
{
ma_pcm_convert(pOut, formatOut, pIn, formatIn, frameCount * channels, ditherMode);
}

void ma_deinterleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void* pInterleavedPCMFrames, void** ppDeinterleavedPCMFrames)
{
if (pInterleavedPCMFrames == NULL || ppDeinterleavedPCMFrames == NULL) {
return; 
}


switch (format) {
case ma_format_s16:
{
const ma_int16* pSrcS16 = (const ma_int16*)pInterleavedPCMFrames;
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
ma_int16* pDstS16 = (ma_int16*)ppDeinterleavedPCMFrames[iChannel];
pDstS16[iPCMFrame] = pSrcS16[iPCMFrame*channels+iChannel];
}
}
} break;

case ma_format_f32:
{
const float* pSrcF32 = (const float*)pInterleavedPCMFrames;
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
float* pDstF32 = (float*)ppDeinterleavedPCMFrames[iChannel];
pDstF32[iPCMFrame] = pSrcF32[iPCMFrame*channels+iChannel];
}
}
} break;

default:
{
ma_uint32 sampleSizeInBytes = ma_get_bytes_per_sample(format);
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
void* pDst = ma_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
const void* pSrc = ma_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
memcpy(pDst, pSrc, sampleSizeInBytes);
}
}
} break;
}
}

void ma_interleave_pcm_frames(ma_format format, ma_uint32 channels, ma_uint64 frameCount, const void** ppDeinterleavedPCMFrames, void* pInterleavedPCMFrames)
{
switch (format)
{
case ma_format_s16:
{
ma_int16* pDstS16 = (ma_int16*)pInterleavedPCMFrames;
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
const ma_int16* pSrcS16 = (const ma_int16*)ppDeinterleavedPCMFrames[iChannel];
pDstS16[iPCMFrame*channels+iChannel] = pSrcS16[iPCMFrame];
}
}
} break;

case ma_format_f32:
{
float* pDstF32 = (float*)pInterleavedPCMFrames;
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
const float* pSrcF32 = (const float*)ppDeinterleavedPCMFrames[iChannel];
pDstF32[iPCMFrame*channels+iChannel] = pSrcF32[iPCMFrame];
}
}
} break;

default:
{
ma_uint32 sampleSizeInBytes = ma_get_bytes_per_sample(format);
ma_uint64 iPCMFrame;
for (iPCMFrame = 0; iPCMFrame < frameCount; ++iPCMFrame) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
void* pDst = ma_offset_ptr(pInterleavedPCMFrames, (iPCMFrame*channels+iChannel)*sampleSizeInBytes);
const void* pSrc = ma_offset_ptr(ppDeinterleavedPCMFrames[iChannel], iPCMFrame*sampleSizeInBytes);
memcpy(pDst, pSrc, sampleSizeInBytes);
}
}
} break;
}
}








static void ma_get_standard_channel_map_microsoft(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{

switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
} break;

case 3: 
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
} break;

case 4:
{
#if !defined(MA_USE_QUAD_MICROSOFT_CHANNEL_MAP)

channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_BACK_CENTER;
#else

channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
#endif
} break;

case 5: 
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_BACK_LEFT;
channelMap[4] = MA_CHANNEL_BACK_RIGHT;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_SIDE_LEFT;
channelMap[5] = MA_CHANNEL_SIDE_RIGHT;
} break;

case 7: 
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_BACK_CENTER;
channelMap[5] = MA_CHANNEL_SIDE_LEFT;
channelMap[6] = MA_CHANNEL_SIDE_RIGHT;
} break;

case 8:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_BACK_LEFT;
channelMap[5] = MA_CHANNEL_BACK_RIGHT;
channelMap[6] = MA_CHANNEL_SIDE_LEFT;
channelMap[7] = MA_CHANNEL_SIDE_RIGHT;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 8; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-8));
}
}
}

static void ma_get_standard_channel_map_alsa(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
} break;

case 7:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
channelMap[6] = MA_CHANNEL_BACK_CENTER;
} break;

case 8:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
channelMap[6] = MA_CHANNEL_SIDE_LEFT;
channelMap[7] = MA_CHANNEL_SIDE_RIGHT;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 8; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-8));
}
}
}

static void ma_get_standard_channel_map_rfc3551(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
channelMap[3] = MA_CHANNEL_BACK_CENTER;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_BACK_LEFT;
channelMap[4] = MA_CHANNEL_BACK_RIGHT;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_SIDE_LEFT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_FRONT_RIGHT;
channelMap[4] = MA_CHANNEL_SIDE_RIGHT;
channelMap[5] = MA_CHANNEL_BACK_CENTER;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 6; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-6));
}
}
}

static void ma_get_standard_channel_map_flac(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_BACK_LEFT;
channelMap[4] = MA_CHANNEL_BACK_RIGHT;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_BACK_LEFT;
channelMap[5] = MA_CHANNEL_BACK_RIGHT;
} break;

case 7:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_BACK_CENTER;
channelMap[5] = MA_CHANNEL_SIDE_LEFT;
channelMap[6] = MA_CHANNEL_SIDE_RIGHT;
} break;

case 8:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
channelMap[3] = MA_CHANNEL_LFE;
channelMap[4] = MA_CHANNEL_BACK_LEFT;
channelMap[5] = MA_CHANNEL_BACK_RIGHT;
channelMap[6] = MA_CHANNEL_SIDE_LEFT;
channelMap[7] = MA_CHANNEL_SIDE_RIGHT;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 8; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-8));
}
}
}

static void ma_get_standard_channel_map_vorbis(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{

switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
channelMap[3] = MA_CHANNEL_BACK_LEFT;
channelMap[4] = MA_CHANNEL_BACK_RIGHT;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
channelMap[3] = MA_CHANNEL_BACK_LEFT;
channelMap[4] = MA_CHANNEL_BACK_RIGHT;
channelMap[5] = MA_CHANNEL_LFE;
} break;

case 7:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
channelMap[3] = MA_CHANNEL_SIDE_LEFT;
channelMap[4] = MA_CHANNEL_SIDE_RIGHT;
channelMap[5] = MA_CHANNEL_BACK_CENTER;
channelMap[6] = MA_CHANNEL_LFE;
} break;

case 8:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_CENTER;
channelMap[2] = MA_CHANNEL_FRONT_RIGHT;
channelMap[3] = MA_CHANNEL_SIDE_LEFT;
channelMap[4] = MA_CHANNEL_SIDE_RIGHT;
channelMap[5] = MA_CHANNEL_BACK_LEFT;
channelMap[6] = MA_CHANNEL_BACK_RIGHT;
channelMap[7] = MA_CHANNEL_LFE;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 8; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-8));
}
}
}

static void ma_get_standard_channel_map_sound4(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_CENTER;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
} break;

case 6:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
} break;

case 7:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_BACK_CENTER;
channelMap[6] = MA_CHANNEL_LFE;
} break;

case 8:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
channelMap[6] = MA_CHANNEL_SIDE_LEFT;
channelMap[7] = MA_CHANNEL_SIDE_RIGHT;
} break;
}


if (channels > 8) {
ma_uint32 iChannel;
for (iChannel = 8; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-8));
}
}
}

static void ma_get_standard_channel_map_sndio(ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (channels)
{
case 1:
{
channelMap[0] = MA_CHANNEL_MONO;
} break;

case 2:
{
channelMap[0] = MA_CHANNEL_LEFT;
channelMap[1] = MA_CHANNEL_RIGHT;
} break;

case 3:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_FRONT_CENTER;
} break;

case 4:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
} break;

case 5:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
} break;

case 6:
default:
{
channelMap[0] = MA_CHANNEL_FRONT_LEFT;
channelMap[1] = MA_CHANNEL_FRONT_RIGHT;
channelMap[2] = MA_CHANNEL_BACK_LEFT;
channelMap[3] = MA_CHANNEL_BACK_RIGHT;
channelMap[4] = MA_CHANNEL_FRONT_CENTER;
channelMap[5] = MA_CHANNEL_LFE;
} break;
}


if (channels > 6) {
ma_uint32 iChannel;
for (iChannel = 6; iChannel < MA_MAX_CHANNELS; ++iChannel) {
channelMap[iChannel] = (ma_channel)(MA_CHANNEL_AUX_0 + (iChannel-6));
}
}
}

void ma_get_standard_channel_map(ma_standard_channel_map standardChannelMap, ma_uint32 channels, ma_channel channelMap[MA_MAX_CHANNELS])
{
switch (standardChannelMap)
{
case ma_standard_channel_map_alsa:
{
ma_get_standard_channel_map_alsa(channels, channelMap);
} break;

case ma_standard_channel_map_rfc3551:
{
ma_get_standard_channel_map_rfc3551(channels, channelMap);
} break;

case ma_standard_channel_map_flac:
{
ma_get_standard_channel_map_flac(channels, channelMap);
} break;

case ma_standard_channel_map_vorbis:
{
ma_get_standard_channel_map_vorbis(channels, channelMap);
} break;

case ma_standard_channel_map_sound4:
{
ma_get_standard_channel_map_sound4(channels, channelMap);
} break;

case ma_standard_channel_map_sndio:
{
ma_get_standard_channel_map_sndio(channels, channelMap);
} break;

case ma_standard_channel_map_microsoft:
default:
{
ma_get_standard_channel_map_microsoft(channels, channelMap);
} break;
}
}

void ma_channel_map_copy(ma_channel* pOut, const ma_channel* pIn, ma_uint32 channels)
{
if (pOut != NULL && pIn != NULL && channels > 0) {
MA_COPY_MEMORY(pOut, pIn, sizeof(*pOut) * channels);
}
}

ma_bool32 ma_channel_map_valid(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS])
{
if (channelMap == NULL) {
return MA_FALSE;
}


if (channels == 0) {
return MA_FALSE;
}


if (channels > 1) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
if (channelMap[iChannel] == MA_CHANNEL_MONO) {
return MA_FALSE;
}
}
}

return MA_TRUE;
}

ma_bool32 ma_channel_map_equal(ma_uint32 channels, const ma_channel channelMapA[MA_MAX_CHANNELS], const ma_channel channelMapB[MA_MAX_CHANNELS])
{
ma_uint32 iChannel;

if (channelMapA == channelMapB) {
return MA_FALSE;
}

if (channels == 0 || channels > MA_MAX_CHANNELS) {
return MA_FALSE;
}

for (iChannel = 0; iChannel < channels; ++iChannel) {
if (channelMapA[iChannel] != channelMapB[iChannel]) {
return MA_FALSE;
}
}

return MA_TRUE;
}

ma_bool32 ma_channel_map_blank(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS])
{
ma_uint32 iChannel;

for (iChannel = 0; iChannel < channels; ++iChannel) {
if (channelMap[iChannel] != MA_CHANNEL_NONE) {
return MA_FALSE;
}
}

return MA_TRUE;
}

ma_bool32 ma_channel_map_contains_channel_position(ma_uint32 channels, const ma_channel channelMap[MA_MAX_CHANNELS], ma_channel channelPosition)
{
ma_uint32 iChannel;
for (iChannel = 0; iChannel < channels; ++iChannel) {
if (channelMap[iChannel] == channelPosition) {
return MA_TRUE;
}
}

return MA_FALSE;
}








ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn)
{
ma_data_converter_config config;

config = ma_data_converter_config_init(formatIn, formatOut, channelsIn, channelsOut, sampleRateIn, sampleRateOut);
ma_get_standard_channel_map(ma_standard_channel_map_default, channelsOut, config.channelMapOut);
ma_get_standard_channel_map(ma_standard_channel_map_default, channelsIn, config.channelMapIn);
config.resampling.linear.lpfCount = ma_min(MA_DEFAULT_RESAMPLER_LPF_FILTERS, MA_MAX_RESAMPLER_LPF_FILTERS);

return ma_convert_frames_ex(pOut, frameCountOut, pIn, frameCountIn, &config);
}

ma_uint64 ma_convert_frames_ex(void* pOut, ma_uint64 frameCountOut, const void* pIn, ma_uint64 frameCountIn, const ma_data_converter_config* pConfig)
{
ma_result result;
ma_data_converter converter;

if (frameCountIn == 0 || pConfig == NULL) {
return 0;
}

result = ma_data_converter_init(pConfig, &converter);
if (result != MA_SUCCESS) {
return 0; 
}

if (pOut == NULL) {
frameCountOut = ma_data_converter_get_expected_output_frame_count(&converter, frameCountIn);
} else {
result = ma_data_converter_process_pcm_frames(&converter, pIn, &frameCountIn, pOut, &frameCountOut);
if (result != MA_SUCCESS) {
frameCountOut = 0;
}
}

ma_data_converter_uninit(&converter);
return frameCountOut;
}







MA_INLINE ma_uint32 ma_rb__extract_offset_in_bytes(ma_uint32 encodedOffset)
{
return encodedOffset & 0x7FFFFFFF;
}

MA_INLINE ma_uint32 ma_rb__extract_offset_loop_flag(ma_uint32 encodedOffset)
{
return encodedOffset & 0x80000000;
}

MA_INLINE void* ma_rb__get_read_ptr(ma_rb* pRB)
{
MA_ASSERT(pRB != NULL);
return ma_offset_ptr(pRB->pBuffer, ma_rb__extract_offset_in_bytes(pRB->encodedReadOffset));
}

MA_INLINE void* ma_rb__get_write_ptr(ma_rb* pRB)
{
MA_ASSERT(pRB != NULL);
return ma_offset_ptr(pRB->pBuffer, ma_rb__extract_offset_in_bytes(pRB->encodedWriteOffset));
}

MA_INLINE ma_uint32 ma_rb__construct_offset(ma_uint32 offsetInBytes, ma_uint32 offsetLoopFlag)
{
return offsetLoopFlag | offsetInBytes;
}

MA_INLINE void ma_rb__deconstruct_offset(ma_uint32 encodedOffset, ma_uint32* pOffsetInBytes, ma_uint32* pOffsetLoopFlag)
{
MA_ASSERT(pOffsetInBytes != NULL);
MA_ASSERT(pOffsetLoopFlag != NULL);

*pOffsetInBytes = ma_rb__extract_offset_in_bytes(encodedOffset);
*pOffsetLoopFlag = ma_rb__extract_offset_loop_flag(encodedOffset);
}


ma_result ma_rb_init_ex(size_t subbufferSizeInBytes, size_t subbufferCount, size_t subbufferStrideInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)
{
ma_result result;
const ma_uint32 maxSubBufferSize = 0x7FFFFFFF - (MA_SIMD_ALIGNMENT-1);

if (pRB == NULL) {
return MA_INVALID_ARGS;
}

if (subbufferSizeInBytes == 0 || subbufferCount == 0) {
return MA_INVALID_ARGS;
}

if (subbufferSizeInBytes > maxSubBufferSize) {
return MA_INVALID_ARGS; 
}


MA_ZERO_OBJECT(pRB);

result = ma_allocation_callbacks_init_copy(&pRB->allocationCallbacks, pAllocationCallbacks);
if (result != MA_SUCCESS) {
return result;
}

pRB->subbufferSizeInBytes = (ma_uint32)subbufferSizeInBytes;
pRB->subbufferCount = (ma_uint32)subbufferCount;

if (pOptionalPreallocatedBuffer != NULL) {
pRB->subbufferStrideInBytes = (ma_uint32)subbufferStrideInBytes;
pRB->pBuffer = pOptionalPreallocatedBuffer;
} else {
size_t bufferSizeInBytes;





pRB->subbufferStrideInBytes = (pRB->subbufferSizeInBytes + (MA_SIMD_ALIGNMENT-1)) & ~MA_SIMD_ALIGNMENT;

bufferSizeInBytes = (size_t)pRB->subbufferCount*pRB->subbufferStrideInBytes;
pRB->pBuffer = ma_aligned_malloc(bufferSizeInBytes, MA_SIMD_ALIGNMENT, &pRB->allocationCallbacks);
if (pRB->pBuffer == NULL) {
return MA_OUT_OF_MEMORY;
}

MA_ZERO_MEMORY(pRB->pBuffer, bufferSizeInBytes);
pRB->ownsBuffer = MA_TRUE;
}

return MA_SUCCESS;
}

ma_result ma_rb_init(size_t bufferSizeInBytes, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_rb* pRB)
{
return ma_rb_init_ex(bufferSizeInBytes, 1, 0, pOptionalPreallocatedBuffer, pAllocationCallbacks, pRB);
}

void ma_rb_uninit(ma_rb* pRB)
{
if (pRB == NULL) {
return;
}

if (pRB->ownsBuffer) {
ma_aligned_free(pRB->pBuffer, &pRB->allocationCallbacks);
}
}

void ma_rb_reset(ma_rb* pRB)
{
if (pRB == NULL) {
return;
}

pRB->encodedReadOffset = 0;
pRB->encodedWriteOffset = 0;
}

ma_result ma_rb_acquire_read(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
size_t bytesAvailable;
size_t bytesRequested;

if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
return MA_INVALID_ARGS;
}


writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);





if (readOffsetLoopFlag == writeOffsetLoopFlag) {
bytesAvailable = writeOffsetInBytes - readOffsetInBytes;
} else {
bytesAvailable = pRB->subbufferSizeInBytes - readOffsetInBytes;
}

bytesRequested = *pSizeInBytes;
if (bytesRequested > bytesAvailable) {
bytesRequested = bytesAvailable;
}

*pSizeInBytes = bytesRequested;
(*ppBufferOut) = ma_rb__get_read_ptr(pRB);

return MA_SUCCESS;
}

ma_result ma_rb_commit_read(ma_rb* pRB, size_t sizeInBytes, void* pBufferOut)
{
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
ma_uint32 newReadOffsetInBytes;
ma_uint32 newReadOffsetLoopFlag;

if (pRB == NULL) {
return MA_INVALID_ARGS;
}


if (pBufferOut != ma_rb__get_read_ptr(pRB)) {
return MA_INVALID_ARGS;
}

readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);


newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + sizeInBytes);
if (newReadOffsetInBytes > pRB->subbufferSizeInBytes) {
return MA_INVALID_ARGS; 
}


newReadOffsetLoopFlag = readOffsetLoopFlag;
if (newReadOffsetInBytes == pRB->subbufferSizeInBytes) {
newReadOffsetInBytes = 0;
newReadOffsetLoopFlag ^= 0x80000000;
}

ma_atomic_exchange_32(&pRB->encodedReadOffset, ma_rb__construct_offset(newReadOffsetLoopFlag, newReadOffsetInBytes));
return MA_SUCCESS;
}

ma_result ma_rb_acquire_write(ma_rb* pRB, size_t* pSizeInBytes, void** ppBufferOut)
{
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;
size_t bytesAvailable;
size_t bytesRequested;

if (pRB == NULL || pSizeInBytes == NULL || ppBufferOut == NULL) {
return MA_INVALID_ARGS;
}


readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);






if (writeOffsetLoopFlag == readOffsetLoopFlag) {
bytesAvailable = pRB->subbufferSizeInBytes - writeOffsetInBytes;
} else {
bytesAvailable = readOffsetInBytes - writeOffsetInBytes;
}

bytesRequested = *pSizeInBytes;
if (bytesRequested > bytesAvailable) {
bytesRequested = bytesAvailable;
}

*pSizeInBytes = bytesRequested;
*ppBufferOut = ma_rb__get_write_ptr(pRB);


if (pRB->clearOnWriteAcquire) {
MA_ZERO_MEMORY(*ppBufferOut, *pSizeInBytes);
}

return MA_SUCCESS;
}

ma_result ma_rb_commit_write(ma_rb* pRB, size_t sizeInBytes, void* pBufferOut)
{
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;
ma_uint32 newWriteOffsetInBytes;
ma_uint32 newWriteOffsetLoopFlag;

if (pRB == NULL) {
return MA_INVALID_ARGS;
}


if (pBufferOut != ma_rb__get_write_ptr(pRB)) {
return MA_INVALID_ARGS;
}

writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);


newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + sizeInBytes);
if (newWriteOffsetInBytes > pRB->subbufferSizeInBytes) {
return MA_INVALID_ARGS; 
}


newWriteOffsetLoopFlag = writeOffsetLoopFlag;
if (newWriteOffsetInBytes == pRB->subbufferSizeInBytes) {
newWriteOffsetInBytes = 0;
newWriteOffsetLoopFlag ^= 0x80000000;
}

ma_atomic_exchange_32(&pRB->encodedWriteOffset, ma_rb__construct_offset(newWriteOffsetLoopFlag, newWriteOffsetInBytes));
return MA_SUCCESS;
}

ma_result ma_rb_seek_read(ma_rb* pRB, size_t offsetInBytes)
{
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;
ma_uint32 newReadOffsetInBytes;
ma_uint32 newReadOffsetLoopFlag;

if (pRB == NULL || offsetInBytes > pRB->subbufferSizeInBytes) {
return MA_INVALID_ARGS;
}

readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

newReadOffsetInBytes = readOffsetInBytes;
newReadOffsetLoopFlag = readOffsetLoopFlag;


if (readOffsetLoopFlag == writeOffsetLoopFlag) {
if ((readOffsetInBytes + offsetInBytes) > writeOffsetInBytes) {
newReadOffsetInBytes = writeOffsetInBytes;
} else {
newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes);
}
} else {

if ((readOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
newReadOffsetLoopFlag ^= 0x80000000; 
} else {
newReadOffsetInBytes = (ma_uint32)(readOffsetInBytes + offsetInBytes);
}
}

ma_atomic_exchange_32(&pRB->encodedReadOffset, ma_rb__construct_offset(newReadOffsetInBytes, newReadOffsetLoopFlag));
return MA_SUCCESS;
}

ma_result ma_rb_seek_write(ma_rb* pRB, size_t offsetInBytes)
{
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;
ma_uint32 newWriteOffsetInBytes;
ma_uint32 newWriteOffsetLoopFlag;

if (pRB == NULL) {
return MA_INVALID_ARGS;
}

readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

newWriteOffsetInBytes = writeOffsetInBytes;
newWriteOffsetLoopFlag = writeOffsetLoopFlag;


if (readOffsetLoopFlag == writeOffsetLoopFlag) {

if ((writeOffsetInBytes + offsetInBytes) >= pRB->subbufferSizeInBytes) {
newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes) - pRB->subbufferSizeInBytes;
newWriteOffsetLoopFlag ^= 0x80000000; 
} else {
newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes);
}
} else {
if ((writeOffsetInBytes + offsetInBytes) > readOffsetInBytes) {
newWriteOffsetInBytes = readOffsetInBytes;
} else {
newWriteOffsetInBytes = (ma_uint32)(writeOffsetInBytes + offsetInBytes);
}
}

ma_atomic_exchange_32(&pRB->encodedWriteOffset, ma_rb__construct_offset(newWriteOffsetInBytes, newWriteOffsetLoopFlag));
return MA_SUCCESS;
}

ma_int32 ma_rb_pointer_distance(ma_rb* pRB)
{
ma_uint32 readOffset;
ma_uint32 readOffsetInBytes;
ma_uint32 readOffsetLoopFlag;
ma_uint32 writeOffset;
ma_uint32 writeOffsetInBytes;
ma_uint32 writeOffsetLoopFlag;

if (pRB == NULL) {
return 0;
}

readOffset = pRB->encodedReadOffset;
ma_rb__deconstruct_offset(readOffset, &readOffsetInBytes, &readOffsetLoopFlag);

writeOffset = pRB->encodedWriteOffset;
ma_rb__deconstruct_offset(writeOffset, &writeOffsetInBytes, &writeOffsetLoopFlag);

if (readOffsetLoopFlag == writeOffsetLoopFlag) {
return writeOffsetInBytes - readOffsetInBytes;
} else {
return writeOffsetInBytes + (pRB->subbufferSizeInBytes - readOffsetInBytes);
}
}

ma_uint32 ma_rb_available_read(ma_rb* pRB)
{
ma_int32 dist;

if (pRB == NULL) {
return 0;
}

dist = ma_rb_pointer_distance(pRB);
if (dist < 0) {
return 0;
}

return dist;
}

ma_uint32 ma_rb_available_write(ma_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return (ma_uint32)(ma_rb_get_subbuffer_size(pRB) - ma_rb_pointer_distance(pRB));
}

size_t ma_rb_get_subbuffer_size(ma_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return pRB->subbufferSizeInBytes;
}

size_t ma_rb_get_subbuffer_stride(ma_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

if (pRB->subbufferStrideInBytes == 0) {
return (size_t)pRB->subbufferSizeInBytes;
}

return (size_t)pRB->subbufferStrideInBytes;
}

size_t ma_rb_get_subbuffer_offset(ma_rb* pRB, size_t subbufferIndex)
{
if (pRB == NULL) {
return 0;
}

return subbufferIndex * ma_rb_get_subbuffer_stride(pRB);
}

void* ma_rb_get_subbuffer_ptr(ma_rb* pRB, size_t subbufferIndex, void* pBuffer)
{
if (pRB == NULL) {
return NULL;
}

return ma_offset_ptr(pBuffer, ma_rb_get_subbuffer_offset(pRB, subbufferIndex));
}


static MA_INLINE ma_uint32 ma_pcm_rb_get_bpf(ma_pcm_rb* pRB)
{
MA_ASSERT(pRB != NULL);

return ma_get_bytes_per_frame(pRB->format, pRB->channels);
}

ma_result ma_pcm_rb_init_ex(ma_format format, ma_uint32 channels, ma_uint32 subbufferSizeInFrames, ma_uint32 subbufferCount, ma_uint32 subbufferStrideInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)
{
ma_uint32 bpf;
ma_result result;

if (pRB == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pRB);

bpf = ma_get_bytes_per_frame(format, channels);
if (bpf == 0) {
return MA_INVALID_ARGS;
}

result = ma_rb_init_ex(subbufferSizeInFrames*bpf, subbufferCount, subbufferStrideInFrames*bpf, pOptionalPreallocatedBuffer, pAllocationCallbacks, &pRB->rb);
if (result != MA_SUCCESS) {
return result;
}

pRB->format = format;
pRB->channels = channels;

return MA_SUCCESS;
}

ma_result ma_pcm_rb_init(ma_format format, ma_uint32 channels, ma_uint32 bufferSizeInFrames, void* pOptionalPreallocatedBuffer, const ma_allocation_callbacks* pAllocationCallbacks, ma_pcm_rb* pRB)
{
return ma_pcm_rb_init_ex(format, channels, bufferSizeInFrames, 1, 0, pOptionalPreallocatedBuffer, pAllocationCallbacks, pRB);
}

void ma_pcm_rb_uninit(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return;
}

ma_rb_uninit(&pRB->rb);
}

void ma_pcm_rb_reset(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return;
}

ma_rb_reset(&pRB->rb);
}

ma_result ma_pcm_rb_acquire_read(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)
{
size_t sizeInBytes;
ma_result result;

if (pRB == NULL || pSizeInFrames == NULL) {
return MA_INVALID_ARGS;
}

sizeInBytes = *pSizeInFrames * ma_pcm_rb_get_bpf(pRB);

result = ma_rb_acquire_read(&pRB->rb, &sizeInBytes, ppBufferOut);
if (result != MA_SUCCESS) {
return result;
}

*pSizeInFrames = (ma_uint32)(sizeInBytes / (size_t)ma_pcm_rb_get_bpf(pRB));
return MA_SUCCESS;
}

ma_result ma_pcm_rb_commit_read(ma_pcm_rb* pRB, ma_uint32 sizeInFrames, void* pBufferOut)
{
if (pRB == NULL) {
return MA_INVALID_ARGS;
}

return ma_rb_commit_read(&pRB->rb, sizeInFrames * ma_pcm_rb_get_bpf(pRB), pBufferOut);
}

ma_result ma_pcm_rb_acquire_write(ma_pcm_rb* pRB, ma_uint32* pSizeInFrames, void** ppBufferOut)
{
size_t sizeInBytes;
ma_result result;

if (pRB == NULL) {
return MA_INVALID_ARGS;
}

sizeInBytes = *pSizeInFrames * ma_pcm_rb_get_bpf(pRB);

result = ma_rb_acquire_write(&pRB->rb, &sizeInBytes, ppBufferOut);
if (result != MA_SUCCESS) {
return result;
}

*pSizeInFrames = (ma_uint32)(sizeInBytes / ma_pcm_rb_get_bpf(pRB));
return MA_SUCCESS;
}

ma_result ma_pcm_rb_commit_write(ma_pcm_rb* pRB, ma_uint32 sizeInFrames, void* pBufferOut)
{
if (pRB == NULL) {
return MA_INVALID_ARGS;
}

return ma_rb_commit_write(&pRB->rb, sizeInFrames * ma_pcm_rb_get_bpf(pRB), pBufferOut);
}

ma_result ma_pcm_rb_seek_read(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)
{
if (pRB == NULL) {
return MA_INVALID_ARGS;
}

return ma_rb_seek_read(&pRB->rb, offsetInFrames * ma_pcm_rb_get_bpf(pRB));
}

ma_result ma_pcm_rb_seek_write(ma_pcm_rb* pRB, ma_uint32 offsetInFrames)
{
if (pRB == NULL) {
return MA_INVALID_ARGS;
}

return ma_rb_seek_write(&pRB->rb, offsetInFrames * ma_pcm_rb_get_bpf(pRB));
}

ma_int32 ma_pcm_rb_pointer_disance(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return ma_rb_pointer_distance(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

ma_uint32 ma_pcm_rb_available_read(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return ma_rb_available_read(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

ma_uint32 ma_pcm_rb_available_write(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return ma_rb_available_write(&pRB->rb) / ma_pcm_rb_get_bpf(pRB);
}

ma_uint32 ma_pcm_rb_get_subbuffer_size(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return (ma_uint32)(ma_rb_get_subbuffer_size(&pRB->rb) / ma_pcm_rb_get_bpf(pRB));
}

ma_uint32 ma_pcm_rb_get_subbuffer_stride(ma_pcm_rb* pRB)
{
if (pRB == NULL) {
return 0;
}

return (ma_uint32)(ma_rb_get_subbuffer_stride(&pRB->rb) / ma_pcm_rb_get_bpf(pRB));
}

ma_uint32 ma_pcm_rb_get_subbuffer_offset(ma_pcm_rb* pRB, ma_uint32 subbufferIndex)
{
if (pRB == NULL) {
return 0;
}

return (ma_uint32)(ma_rb_get_subbuffer_offset(&pRB->rb, subbufferIndex) / ma_pcm_rb_get_bpf(pRB));
}

void* ma_pcm_rb_get_subbuffer_ptr(ma_pcm_rb* pRB, ma_uint32 subbufferIndex, void* pBuffer)
{
if (pRB == NULL) {
return NULL;
}

return ma_rb_get_subbuffer_ptr(&pRB->rb, subbufferIndex, pBuffer);
}








void* ma_malloc(size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (pAllocationCallbacks != NULL) {
return ma__malloc_from_callbacks(sz, pAllocationCallbacks);
} else {
return ma__malloc_default(sz, NULL);
}
}

void* ma_realloc(void* p, size_t sz, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (pAllocationCallbacks != NULL) {
if (pAllocationCallbacks->onRealloc != NULL) {
return pAllocationCallbacks->onRealloc(p, sz, pAllocationCallbacks->pUserData);
} else {
return NULL; 
}
} else {
return ma__realloc_default(p, sz, NULL);
}
}

void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)
{
if (pAllocationCallbacks != NULL) {
ma__free_from_callbacks(p, pAllocationCallbacks);
} else {
ma__free_default(p, NULL);
}
}

void* ma_aligned_malloc(size_t sz, size_t alignment, const ma_allocation_callbacks* pAllocationCallbacks)
{
size_t extraBytes;
void* pUnaligned;
void* pAligned;

if (alignment == 0) {
return 0;
}

extraBytes = alignment-1 + sizeof(void*);

pUnaligned = ma_malloc(sz + extraBytes, pAllocationCallbacks);
if (pUnaligned == NULL) {
return NULL;
}

pAligned = (void*)(((ma_uintptr)pUnaligned + extraBytes) & ~((ma_uintptr)(alignment-1)));
((void**)pAligned)[-1] = pUnaligned;

return pAligned;
}

void ma_aligned_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks)
{
ma_free(((void**)p)[-1], pAllocationCallbacks);
}

const char* ma_get_format_name(ma_format format)
{
switch (format)
{
case ma_format_unknown: return "Unknown";
case ma_format_u8: return "8-bit Unsigned Integer";
case ma_format_s16: return "16-bit Signed Integer";
case ma_format_s24: return "24-bit Signed Integer (Tightly Packed)";
case ma_format_s32: return "32-bit Signed Integer";
case ma_format_f32: return "32-bit IEEE Floating Point";
default: return "Invalid";
}
}

void ma_blend_f32(float* pOut, float* pInA, float* pInB, float factor, ma_uint32 channels)
{
ma_uint32 i;
for (i = 0; i < channels; ++i) {
pOut[i] = ma_mix_f32(pInA[i], pInB[i], factor);
}
}


ma_uint32 ma_get_bytes_per_sample(ma_format format)
{
ma_uint32 sizes[] = {
0, 
1, 
2, 
3, 
4, 
4, 
};
return sizes[format];
}







#if !defined(MA_NO_DECODING)

static size_t ma_decoder_read_bytes(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead)
{
size_t bytesRead;

MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pBufferOut != NULL);

bytesRead = pDecoder->onRead(pDecoder, pBufferOut, bytesToRead);
pDecoder->readPointer += bytesRead;

return bytesRead;
}

static ma_bool32 ma_decoder_seek_bytes(ma_decoder* pDecoder, int byteOffset, ma_seek_origin origin)
{
ma_bool32 wasSuccessful;

MA_ASSERT(pDecoder != NULL);

wasSuccessful = pDecoder->onSeek(pDecoder, byteOffset, origin);
if (wasSuccessful) {
if (origin == ma_seek_origin_start) {
pDecoder->readPointer = (ma_uint64)byteOffset;
} else {
pDecoder->readPointer += byteOffset;
}
}

return wasSuccessful;
}


ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate)
{
ma_decoder_config config;
MA_ZERO_OBJECT(&config);
config.format = outputFormat;
config.channels = outputChannels;
config.sampleRate = outputSampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_default, config.channels, config.channelMap);
config.resampling.algorithm = ma_resample_algorithm_linear;
config.resampling.linear.lpfCount = ma_min(MA_DEFAULT_RESAMPLER_LPF_FILTERS, MA_MAX_RESAMPLER_LPF_FILTERS);
config.resampling.speex.quality = 3;

return config;
}

ma_decoder_config ma_decoder_config_init_copy(const ma_decoder_config* pConfig)
{
ma_decoder_config config;
if (pConfig != NULL) {
config = *pConfig;
} else {
MA_ZERO_OBJECT(&config);
}

return config;
}

static ma_result ma_decoder__init_data_converter(ma_decoder* pDecoder, const ma_decoder_config* pConfig)
{
ma_data_converter_config converterConfig;

MA_ASSERT(pDecoder != NULL);


if (pConfig->format == ma_format_unknown) {
pDecoder->outputFormat = pDecoder->internalFormat;
} else {
pDecoder->outputFormat = pConfig->format;
}

if (pConfig->channels == 0) {
pDecoder->outputChannels = pDecoder->internalChannels;
} else {
pDecoder->outputChannels = pConfig->channels;
}

if (pConfig->sampleRate == 0) {
pDecoder->outputSampleRate = pDecoder->internalSampleRate;
} else {
pDecoder->outputSampleRate = pConfig->sampleRate;
}

if (ma_channel_map_blank(pDecoder->outputChannels, pConfig->channelMap)) {
ma_get_standard_channel_map(ma_standard_channel_map_default, pDecoder->outputChannels, pDecoder->outputChannelMap);
} else {
MA_COPY_MEMORY(pDecoder->outputChannelMap, pConfig->channelMap, sizeof(pConfig->channelMap));
}


converterConfig = ma_data_converter_config_init(
pDecoder->internalFormat, pDecoder->outputFormat, 
pDecoder->internalChannels, pDecoder->outputChannels,
pDecoder->internalSampleRate, pDecoder->outputSampleRate
);
ma_channel_map_copy(converterConfig.channelMapIn, pDecoder->internalChannelMap, pDecoder->internalChannels);
ma_channel_map_copy(converterConfig.channelMapOut, pDecoder->outputChannelMap, pDecoder->outputChannels);
converterConfig.channelMixMode = pConfig->channelMixMode;
converterConfig.ditherMode = pConfig->ditherMode;
converterConfig.resampling.allowDynamicSampleRate = MA_FALSE; 
converterConfig.resampling.algorithm = pConfig->resampling.algorithm;
converterConfig.resampling.linear.lpfCount = pConfig->resampling.linear.lpfCount;
converterConfig.resampling.speex.quality = pConfig->resampling.speex.quality;

return ma_data_converter_init(&converterConfig, &pDecoder->converter);
}


#if defined(dr_wav_h)
#define MA_HAS_WAV

static size_t ma_decoder_internal_on_read__wav(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_read_bytes(pDecoder, pBufferOut, bytesToRead);
}

static drwav_bool32 ma_decoder_internal_on_seek__wav(void* pUserData, int offset, drwav_seek_origin origin)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_seek_bytes(pDecoder, offset, (origin == drwav_seek_origin_start) ? ma_seek_origin_start : ma_seek_origin_current);
}

static ma_uint64 ma_decoder_internal_on_read_pcm_frames__wav(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
drwav* pWav;

MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pFramesOut != NULL);

pWav = (drwav*)pDecoder->pInternalDecoder;
MA_ASSERT(pWav != NULL);

switch (pDecoder->internalFormat) {
case ma_format_s16: return drwav_read_pcm_frames_s16(pWav, frameCount, (drwav_int16*)pFramesOut);
case ma_format_s32: return drwav_read_pcm_frames_s32(pWav, frameCount, (drwav_int32*)pFramesOut);
case ma_format_f32: return drwav_read_pcm_frames_f32(pWav, frameCount, (float*)pFramesOut);
default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}

static ma_result ma_decoder_internal_on_seek_to_pcm_frame__wav(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
drwav* pWav;
drwav_bool32 result;

pWav = (drwav*)pDecoder->pInternalDecoder;
MA_ASSERT(pWav != NULL);

result = drwav_seek_to_pcm_frame(pWav, frameIndex);
if (result) {
return MA_SUCCESS;
} else {
return MA_ERROR;
}
}

static ma_result ma_decoder_internal_on_uninit__wav(ma_decoder* pDecoder)
{
drwav_uninit((drwav*)pDecoder->pInternalDecoder);
ma__free_from_callbacks(pDecoder->pInternalDecoder, &pDecoder->allocationCallbacks);
return MA_SUCCESS;
}

static ma_uint64 ma_decoder_internal_on_get_length_in_pcm_frames__wav(ma_decoder* pDecoder)
{
return ((drwav*)pDecoder->pInternalDecoder)->totalPCMFrameCount;
}

static ma_result ma_decoder_init_wav__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
drwav* pWav;
drwav_allocation_callbacks allocationCallbacks;

MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDecoder != NULL);

pWav = (drwav*)ma__malloc_from_callbacks(sizeof(*pWav), &pDecoder->allocationCallbacks);
if (pWav == NULL) {
return MA_OUT_OF_MEMORY;
}

allocationCallbacks.pUserData = pDecoder->allocationCallbacks.pUserData;
allocationCallbacks.onMalloc = pDecoder->allocationCallbacks.onMalloc;
allocationCallbacks.onRealloc = pDecoder->allocationCallbacks.onRealloc;
allocationCallbacks.onFree = pDecoder->allocationCallbacks.onFree;


if (!drwav_init(pWav, ma_decoder_internal_on_read__wav, ma_decoder_internal_on_seek__wav, pDecoder, &allocationCallbacks)) {
ma__free_from_callbacks(pWav, &pDecoder->allocationCallbacks);
return MA_ERROR;
}


pDecoder->onReadPCMFrames = ma_decoder_internal_on_read_pcm_frames__wav;
pDecoder->onSeekToPCMFrame = ma_decoder_internal_on_seek_to_pcm_frame__wav;
pDecoder->onUninit = ma_decoder_internal_on_uninit__wav;
pDecoder->onGetLengthInPCMFrames = ma_decoder_internal_on_get_length_in_pcm_frames__wav;
pDecoder->pInternalDecoder = pWav;


pDecoder->internalFormat = ma_format_unknown;
switch (pWav->translatedFormatTag) {
case DR_WAVE_FORMAT_PCM:
{
if (pWav->bitsPerSample == 8) {
pDecoder->internalFormat = ma_format_s16;
} else if (pWav->bitsPerSample == 16) {
pDecoder->internalFormat = ma_format_s16;
} else if (pWav->bitsPerSample == 32) {
pDecoder->internalFormat = ma_format_s32;
}
} break;

case DR_WAVE_FORMAT_IEEE_FLOAT:
{
if (pWav->bitsPerSample == 32) {
pDecoder->internalFormat = ma_format_f32;
}
} break;

case DR_WAVE_FORMAT_ALAW:
case DR_WAVE_FORMAT_MULAW:
case DR_WAVE_FORMAT_ADPCM:
case DR_WAVE_FORMAT_DVI_ADPCM:
{
pDecoder->internalFormat = ma_format_s16;
} break;
}

if (pDecoder->internalFormat == ma_format_unknown) {
pDecoder->internalFormat = ma_format_f32;
}

pDecoder->internalChannels = pWav->channels;
pDecoder->internalSampleRate = pWav->sampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_microsoft, pDecoder->internalChannels, pDecoder->internalChannelMap);

return MA_SUCCESS;
}
#endif 


#if defined(dr_flac_h)
#define MA_HAS_FLAC

static size_t ma_decoder_internal_on_read__flac(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_read_bytes(pDecoder, pBufferOut, bytesToRead);
}

static drflac_bool32 ma_decoder_internal_on_seek__flac(void* pUserData, int offset, drflac_seek_origin origin)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_seek_bytes(pDecoder, offset, (origin == drflac_seek_origin_start) ? ma_seek_origin_start : ma_seek_origin_current);
}

static ma_uint64 ma_decoder_internal_on_read_pcm_frames__flac(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
drflac* pFlac;

MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pFramesOut != NULL);

pFlac = (drflac*)pDecoder->pInternalDecoder;
MA_ASSERT(pFlac != NULL);

switch (pDecoder->internalFormat) {
case ma_format_s16: return drflac_read_pcm_frames_s16(pFlac, frameCount, (drflac_int16*)pFramesOut);
case ma_format_s32: return drflac_read_pcm_frames_s32(pFlac, frameCount, (drflac_int32*)pFramesOut);
case ma_format_f32: return drflac_read_pcm_frames_f32(pFlac, frameCount, (float*)pFramesOut);
default: break;
}


MA_ASSERT(MA_FALSE);
return 0;
}

static ma_result ma_decoder_internal_on_seek_to_pcm_frame__flac(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
drflac* pFlac;
drflac_bool32 result;

pFlac = (drflac*)pDecoder->pInternalDecoder;
MA_ASSERT(pFlac != NULL);

result = drflac_seek_to_pcm_frame(pFlac, frameIndex);
if (result) {
return MA_SUCCESS;
} else {
return MA_ERROR;
}
}

static ma_result ma_decoder_internal_on_uninit__flac(ma_decoder* pDecoder)
{
drflac_close((drflac*)pDecoder->pInternalDecoder);
return MA_SUCCESS;
}

static ma_uint64 ma_decoder_internal_on_get_length_in_pcm_frames__flac(ma_decoder* pDecoder)
{
return ((drflac*)pDecoder->pInternalDecoder)->totalPCMFrameCount;
}

static ma_result ma_decoder_init_flac__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
drflac* pFlac;
drflac_allocation_callbacks allocationCallbacks;

MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDecoder != NULL);

allocationCallbacks.pUserData = pDecoder->allocationCallbacks.pUserData;
allocationCallbacks.onMalloc = pDecoder->allocationCallbacks.onMalloc;
allocationCallbacks.onRealloc = pDecoder->allocationCallbacks.onRealloc;
allocationCallbacks.onFree = pDecoder->allocationCallbacks.onFree;


pFlac = drflac_open(ma_decoder_internal_on_read__flac, ma_decoder_internal_on_seek__flac, pDecoder, &allocationCallbacks);
if (pFlac == NULL) {
return MA_ERROR;
}


pDecoder->onReadPCMFrames = ma_decoder_internal_on_read_pcm_frames__flac;
pDecoder->onSeekToPCMFrame = ma_decoder_internal_on_seek_to_pcm_frame__flac;
pDecoder->onUninit = ma_decoder_internal_on_uninit__flac;
pDecoder->onGetLengthInPCMFrames = ma_decoder_internal_on_get_length_in_pcm_frames__flac;
pDecoder->pInternalDecoder = pFlac;





pDecoder->internalFormat = ma_format_s32;
if (pConfig->format == ma_format_s16) {
pDecoder->internalFormat = ma_format_s16;
} else if (pConfig->format == ma_format_f32) {
pDecoder->internalFormat = ma_format_f32;
}

pDecoder->internalChannels = pFlac->channels;
pDecoder->internalSampleRate = pFlac->sampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_flac, pDecoder->internalChannels, pDecoder->internalChannelMap);

return MA_SUCCESS;
}
#endif 


#if defined(STB_VORBIS_INCLUDE_STB_VORBIS_H)
#define MA_HAS_VORBIS


#define MA_VORBIS_DATA_CHUNK_SIZE 4096

typedef struct
{
stb_vorbis* pInternalVorbis;
ma_uint8* pData;
size_t dataSize;
size_t dataCapacity;
ma_uint32 framesConsumed; 
ma_uint32 framesRemaining; 
float** ppPacketData;
} ma_vorbis_decoder;

static ma_uint64 ma_vorbis_decoder_read_pcm_frames(ma_vorbis_decoder* pVorbis, ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
float* pFramesOutF;
ma_uint64 totalFramesRead;

MA_ASSERT(pVorbis != NULL);
MA_ASSERT(pDecoder != NULL);

pFramesOutF = (float*)pFramesOut;

totalFramesRead = 0;
while (frameCount > 0) {

while (pVorbis->framesRemaining > 0 && frameCount > 0) {
ma_uint32 iChannel;
for (iChannel = 0; iChannel < pDecoder->internalChannels; ++iChannel) {
pFramesOutF[0] = pVorbis->ppPacketData[iChannel][pVorbis->framesConsumed];
pFramesOutF += 1;
}

pVorbis->framesConsumed += 1;
pVorbis->framesRemaining -= 1;
frameCount -= 1;
totalFramesRead += 1;
}

if (frameCount == 0) {
break;
}

MA_ASSERT(pVorbis->framesRemaining == 0);


do
{
int samplesRead;
int consumedDataSize;

if (pVorbis->dataSize > INT_MAX) {
break; 
}

samplesRead = 0;
consumedDataSize = stb_vorbis_decode_frame_pushdata(pVorbis->pInternalVorbis, pVorbis->pData, (int)pVorbis->dataSize, NULL, (float***)&pVorbis->ppPacketData, &samplesRead);
if (consumedDataSize != 0) {
size_t leftoverDataSize = (pVorbis->dataSize - (size_t)consumedDataSize);
size_t i;
for (i = 0; i < leftoverDataSize; ++i) {
pVorbis->pData[i] = pVorbis->pData[i + consumedDataSize];
}

pVorbis->dataSize = leftoverDataSize;
pVorbis->framesConsumed = 0;
pVorbis->framesRemaining = samplesRead;
break;
} else {

size_t bytesRead;
if (pVorbis->dataCapacity == pVorbis->dataSize) {

size_t oldCap = pVorbis->dataCapacity;
size_t newCap = pVorbis->dataCapacity + MA_VORBIS_DATA_CHUNK_SIZE;
ma_uint8* pNewData;

pNewData = (ma_uint8*)ma__realloc_from_callbacks(pVorbis->pData, newCap, oldCap, &pDecoder->allocationCallbacks);
if (pNewData == NULL) {
return totalFramesRead; 
}

pVorbis->pData = pNewData;
pVorbis->dataCapacity = newCap;
}


bytesRead = ma_decoder_read_bytes(pDecoder, pVorbis->pData + pVorbis->dataSize, (pVorbis->dataCapacity - pVorbis->dataSize));
if (bytesRead == 0) {
return totalFramesRead; 
}

pVorbis->dataSize += bytesRead;
}
} while (MA_TRUE);
}

return totalFramesRead;
}

static ma_result ma_vorbis_decoder_seek_to_pcm_frame(ma_vorbis_decoder* pVorbis, ma_decoder* pDecoder, ma_uint64 frameIndex)
{
float buffer[4096];

MA_ASSERT(pVorbis != NULL);
MA_ASSERT(pDecoder != NULL);






if (!ma_decoder_seek_bytes(pDecoder, 0, ma_seek_origin_start)) {
return MA_ERROR;
}

stb_vorbis_flush_pushdata(pVorbis->pInternalVorbis);
pVorbis->framesConsumed = 0;
pVorbis->framesRemaining = 0;
pVorbis->dataSize = 0;

while (frameIndex > 0) {
ma_uint32 framesRead;
ma_uint32 framesToRead = ma_countof(buffer)/pDecoder->internalChannels;
if (framesToRead > frameIndex) {
framesToRead = (ma_uint32)frameIndex;
}

framesRead = (ma_uint32)ma_vorbis_decoder_read_pcm_frames(pVorbis, pDecoder, buffer, framesToRead);
if (framesRead == 0) {
return MA_ERROR;
}

frameIndex -= framesRead;
}

return MA_SUCCESS;
}


static ma_result ma_decoder_internal_on_seek_to_pcm_frame__vorbis(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
ma_vorbis_decoder* pVorbis = (ma_vorbis_decoder*)pDecoder->pInternalDecoder;
MA_ASSERT(pVorbis != NULL);

return ma_vorbis_decoder_seek_to_pcm_frame(pVorbis, pDecoder, frameIndex);
}

static ma_result ma_decoder_internal_on_uninit__vorbis(ma_decoder* pDecoder)
{
ma_vorbis_decoder* pVorbis = (ma_vorbis_decoder*)pDecoder->pInternalDecoder;
MA_ASSERT(pVorbis != NULL);

stb_vorbis_close(pVorbis->pInternalVorbis);
ma__free_from_callbacks(pVorbis->pData, &pDecoder->allocationCallbacks);
ma__free_from_callbacks(pVorbis, &pDecoder->allocationCallbacks);

return MA_SUCCESS;
}

static ma_uint64 ma_decoder_internal_on_read_pcm_frames__vorbis(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
ma_vorbis_decoder* pVorbis;

MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pDecoder->internalFormat == ma_format_f32);

pVorbis = (ma_vorbis_decoder*)pDecoder->pInternalDecoder;
MA_ASSERT(pVorbis != NULL);

return ma_vorbis_decoder_read_pcm_frames(pVorbis, pDecoder, pFramesOut, frameCount);
}

static ma_uint64 ma_decoder_internal_on_get_length_in_pcm_frames__vorbis(ma_decoder* pDecoder)
{

(void)pDecoder;
return 0;
}

static ma_result ma_decoder_init_vorbis__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
stb_vorbis* pInternalVorbis = NULL;
size_t dataSize = 0;
size_t dataCapacity = 0;
ma_uint8* pData = NULL;
stb_vorbis_info vorbisInfo;
size_t vorbisDataSize;
ma_vorbis_decoder* pVorbis;

MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDecoder != NULL);


do
{

ma_uint8* pNewData;
size_t bytesRead;
int vorbisError = 0;
int consumedDataSize = 0;
size_t oldCapacity = dataCapacity;

dataCapacity += MA_VORBIS_DATA_CHUNK_SIZE;
pNewData = (ma_uint8*)ma__realloc_from_callbacks(pData, dataCapacity, oldCapacity, &pDecoder->allocationCallbacks);
if (pNewData == NULL) {
ma__free_from_callbacks(pData, &pDecoder->allocationCallbacks);
return MA_OUT_OF_MEMORY;
}

pData = pNewData;


bytesRead = ma_decoder_read_bytes(pDecoder, pData + dataSize, (dataCapacity - dataSize));
if (bytesRead == 0) {
return MA_ERROR;
}

dataSize += bytesRead;
if (dataSize > INT_MAX) {
return MA_ERROR; 
}

pInternalVorbis = stb_vorbis_open_pushdata(pData, (int)dataSize, &consumedDataSize, &vorbisError, NULL);
if (pInternalVorbis != NULL) {




size_t leftoverDataSize = (dataSize - (size_t)consumedDataSize);
size_t i;
for (i = 0; i < leftoverDataSize; ++i) {
pData[i] = pData[i + consumedDataSize];
}

dataSize = leftoverDataSize;
break; 
} else {
if (vorbisError == VORBIS_need_more_data) {
continue;
} else {
return MA_ERROR; 
}
}
} while (MA_TRUE);



vorbisInfo = stb_vorbis_get_info(pInternalVorbis);


if (vorbisInfo.channels > MA_MAX_CHANNELS) {
stb_vorbis_close(pInternalVorbis);
ma__free_from_callbacks(pData, &pDecoder->allocationCallbacks);
return MA_ERROR; 
}

vorbisDataSize = sizeof(ma_vorbis_decoder) + sizeof(float)*vorbisInfo.max_frame_size;
pVorbis = (ma_vorbis_decoder*)ma__malloc_from_callbacks(vorbisDataSize, &pDecoder->allocationCallbacks);
if (pVorbis == NULL) {
stb_vorbis_close(pInternalVorbis);
ma__free_from_callbacks(pData, &pDecoder->allocationCallbacks);
return MA_OUT_OF_MEMORY;
}

MA_ZERO_MEMORY(pVorbis, vorbisDataSize);
pVorbis->pInternalVorbis = pInternalVorbis;
pVorbis->pData = pData;
pVorbis->dataSize = dataSize;
pVorbis->dataCapacity = dataCapacity;

pDecoder->onReadPCMFrames = ma_decoder_internal_on_read_pcm_frames__vorbis;
pDecoder->onSeekToPCMFrame = ma_decoder_internal_on_seek_to_pcm_frame__vorbis;
pDecoder->onUninit = ma_decoder_internal_on_uninit__vorbis;
pDecoder->onGetLengthInPCMFrames = ma_decoder_internal_on_get_length_in_pcm_frames__vorbis;
pDecoder->pInternalDecoder = pVorbis;


pDecoder->internalFormat = ma_format_f32;
pDecoder->internalChannels = vorbisInfo.channels;
pDecoder->internalSampleRate = vorbisInfo.sample_rate;
ma_get_standard_channel_map(ma_standard_channel_map_vorbis, pDecoder->internalChannels, pDecoder->internalChannelMap);

return MA_SUCCESS;
}
#endif 


#if defined(dr_mp3_h)
#define MA_HAS_MP3

static size_t ma_decoder_internal_on_read__mp3(void* pUserData, void* pBufferOut, size_t bytesToRead)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_read_bytes(pDecoder, pBufferOut, bytesToRead);
}

static drmp3_bool32 ma_decoder_internal_on_seek__mp3(void* pUserData, int offset, drmp3_seek_origin origin)
{
ma_decoder* pDecoder = (ma_decoder*)pUserData;
MA_ASSERT(pDecoder != NULL);

return ma_decoder_seek_bytes(pDecoder, offset, (origin == drmp3_seek_origin_start) ? ma_seek_origin_start : ma_seek_origin_current);
}

static ma_uint64 ma_decoder_internal_on_read_pcm_frames__mp3(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
drmp3* pMP3;

MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pFramesOut != NULL);
MA_ASSERT(pDecoder->internalFormat == ma_format_f32);

pMP3 = (drmp3*)pDecoder->pInternalDecoder;
MA_ASSERT(pMP3 != NULL);

return drmp3_read_pcm_frames_f32(pMP3, frameCount, (float*)pFramesOut);
}

static ma_result ma_decoder_internal_on_seek_to_pcm_frame__mp3(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
drmp3* pMP3;
drmp3_bool32 result;

pMP3 = (drmp3*)pDecoder->pInternalDecoder;
MA_ASSERT(pMP3 != NULL);

result = drmp3_seek_to_pcm_frame(pMP3, frameIndex);
if (result) {
return MA_SUCCESS;
} else {
return MA_ERROR;
}
}

static ma_result ma_decoder_internal_on_uninit__mp3(ma_decoder* pDecoder)
{
drmp3_uninit((drmp3*)pDecoder->pInternalDecoder);
ma__free_from_callbacks(pDecoder->pInternalDecoder, &pDecoder->allocationCallbacks);
return MA_SUCCESS;
}

static ma_uint64 ma_decoder_internal_on_get_length_in_pcm_frames__mp3(ma_decoder* pDecoder)
{
return drmp3_get_pcm_frame_count((drmp3*)pDecoder->pInternalDecoder);
}

static ma_result ma_decoder_init_mp3__internal(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
drmp3* pMP3;
drmp3_config mp3Config;
drmp3_allocation_callbacks allocationCallbacks;

MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDecoder != NULL);

pMP3 = (drmp3*)ma__malloc_from_callbacks(sizeof(*pMP3), &pDecoder->allocationCallbacks);
if (pMP3 == NULL) {
return MA_OUT_OF_MEMORY;
}

allocationCallbacks.pUserData = pDecoder->allocationCallbacks.pUserData;
allocationCallbacks.onMalloc = pDecoder->allocationCallbacks.onMalloc;
allocationCallbacks.onRealloc = pDecoder->allocationCallbacks.onRealloc;
allocationCallbacks.onFree = pDecoder->allocationCallbacks.onFree;












MA_ZERO_OBJECT(&mp3Config);
mp3Config.outputChannels = 2;
mp3Config.outputSampleRate = (pConfig->sampleRate != 0) ? pConfig->sampleRate : 44100;
if (!drmp3_init(pMP3, ma_decoder_internal_on_read__mp3, ma_decoder_internal_on_seek__mp3, pDecoder, &mp3Config, &allocationCallbacks)) {
ma__free_from_callbacks(pMP3, &pDecoder->allocationCallbacks);
return MA_ERROR;
}


pDecoder->onReadPCMFrames = ma_decoder_internal_on_read_pcm_frames__mp3;
pDecoder->onSeekToPCMFrame = ma_decoder_internal_on_seek_to_pcm_frame__mp3;
pDecoder->onUninit = ma_decoder_internal_on_uninit__mp3;
pDecoder->onGetLengthInPCMFrames = ma_decoder_internal_on_get_length_in_pcm_frames__mp3;
pDecoder->pInternalDecoder = pMP3;


pDecoder->internalFormat = ma_format_f32;
pDecoder->internalChannels = pMP3->channels;
pDecoder->internalSampleRate = pMP3->sampleRate;
ma_get_standard_channel_map(ma_standard_channel_map_default, pDecoder->internalChannels, pDecoder->internalChannelMap);

return MA_SUCCESS;
}
#endif 


static ma_uint64 ma_decoder_internal_on_read_pcm_frames__raw(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
ma_uint32 bpf;
ma_uint64 totalFramesRead;
void* pRunningFramesOut;


MA_ASSERT(pDecoder != NULL);
MA_ASSERT(pFramesOut != NULL);


bpf = ma_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels);

totalFramesRead = 0;
pRunningFramesOut = pFramesOut;

while (totalFramesRead < frameCount) {
ma_uint64 framesReadThisIteration;
ma_uint64 framesToReadThisIteration = (frameCount - totalFramesRead);
if (framesToReadThisIteration > MA_SIZE_MAX) {
framesToReadThisIteration = MA_SIZE_MAX;
}

framesReadThisIteration = ma_decoder_read_bytes(pDecoder, pRunningFramesOut, (size_t)framesToReadThisIteration * bpf) / bpf; 

totalFramesRead += framesReadThisIteration;
pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesReadThisIteration * bpf);

if (framesReadThisIteration < framesToReadThisIteration) {
break; 
}
}

return totalFramesRead;
}

static ma_result ma_decoder_internal_on_seek_to_pcm_frame__raw(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
ma_bool32 result = MA_FALSE;
ma_uint64 totalBytesToSeek;

MA_ASSERT(pDecoder != NULL);

if (pDecoder->onSeek == NULL) {
return MA_ERROR;
}


totalBytesToSeek = frameIndex * ma_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels);
if (totalBytesToSeek < 0x7FFFFFFF) {

result = ma_decoder_seek_bytes(pDecoder, (int)(frameIndex * ma_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels)), ma_seek_origin_start);
} else {

result = ma_decoder_seek_bytes(pDecoder, 0x7FFFFFFF, ma_seek_origin_start);
if (result == MA_TRUE) {
totalBytesToSeek -= 0x7FFFFFFF;

while (totalBytesToSeek > 0) {
ma_uint64 bytesToSeekThisIteration = totalBytesToSeek;
if (bytesToSeekThisIteration > 0x7FFFFFFF) {
bytesToSeekThisIteration = 0x7FFFFFFF;
}

result = ma_decoder_seek_bytes(pDecoder, (int)bytesToSeekThisIteration, ma_seek_origin_current);
if (result != MA_TRUE) {
break;
}

totalBytesToSeek -= bytesToSeekThisIteration;
}
}
}

if (result) {
return MA_SUCCESS;
} else {
return MA_ERROR;
}
}

static ma_result ma_decoder_internal_on_uninit__raw(ma_decoder* pDecoder)
{
(void)pDecoder;
return MA_SUCCESS;
}

static ma_uint64 ma_decoder_internal_on_get_length_in_pcm_frames__raw(ma_decoder* pDecoder)
{
(void)pDecoder;
return 0;
}

static ma_result ma_decoder_init_raw__internal(const ma_decoder_config* pConfigIn, const ma_decoder_config* pConfigOut, ma_decoder* pDecoder)
{
MA_ASSERT(pConfigIn != NULL);
MA_ASSERT(pConfigOut != NULL);
MA_ASSERT(pDecoder != NULL);

pDecoder->onReadPCMFrames = ma_decoder_internal_on_read_pcm_frames__raw;
pDecoder->onSeekToPCMFrame = ma_decoder_internal_on_seek_to_pcm_frame__raw;
pDecoder->onUninit = ma_decoder_internal_on_uninit__raw;
pDecoder->onGetLengthInPCMFrames = ma_decoder_internal_on_get_length_in_pcm_frames__raw;


pDecoder->internalFormat = pConfigIn->format;
pDecoder->internalChannels = pConfigIn->channels;
pDecoder->internalSampleRate = pConfigIn->sampleRate;
ma_channel_map_copy(pDecoder->internalChannelMap, pConfigIn->channelMap, pConfigIn->channels);

return MA_SUCCESS;
}

static ma_result ma_decoder__init_allocation_callbacks(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
MA_ASSERT(pDecoder != NULL);

if (pConfig != NULL) {
return ma_allocation_callbacks_init_copy(&pDecoder->allocationCallbacks, &pConfig->allocationCallbacks);
} else {
pDecoder->allocationCallbacks = ma_allocation_callbacks_init_default();
return MA_SUCCESS;
}
}

static ma_result ma_decoder__preinit(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result;

MA_ASSERT(pConfig != NULL);

if (pDecoder == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pDecoder);

if (onRead == NULL || onSeek == NULL) {
return MA_INVALID_ARGS;
}

pDecoder->onRead = onRead;
pDecoder->onSeek = onSeek;
pDecoder->pUserData = pUserData;

result = ma_decoder__init_allocation_callbacks(pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return MA_SUCCESS;
}

static ma_result ma_decoder__postinit(const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result;

result = ma_decoder__init_data_converter(pDecoder, pConfig);
if (result != MA_SUCCESS) {
return result;
}

return result;
}

ma_result ma_decoder_init_wav(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_WAV)
result = ma_decoder_init_wav__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_flac(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_FLAC)
result = ma_decoder_init_flac__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_vorbis(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_VORBIS)
result = ma_decoder_init_vorbis__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_mp3(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_MP3)
result = ma_decoder_init_mp3__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_raw(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfigIn, const ma_decoder_config* pConfigOut, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfigOut);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

result = ma_decoder_init_raw__internal(pConfigIn, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

static ma_result ma_decoder_init__internal(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = MA_NO_BACKEND;

MA_ASSERT(pConfig != NULL);
MA_ASSERT(pDecoder != NULL);


(void)onRead;
(void)onSeek;
(void)pUserData;
(void)pConfig;
(void)pDecoder;



#if defined(MA_HAS_WAV)
if (result != MA_SUCCESS) {
result = ma_decoder_init_wav__internal(pConfig, pDecoder);
if (result != MA_SUCCESS) {
onSeek(pDecoder, 0, ma_seek_origin_start);
}
}
#endif
#if defined(MA_HAS_FLAC)
if (result != MA_SUCCESS) {
result = ma_decoder_init_flac__internal(pConfig, pDecoder);
if (result != MA_SUCCESS) {
onSeek(pDecoder, 0, ma_seek_origin_start);
}
}
#endif
#if defined(MA_HAS_VORBIS)
if (result != MA_SUCCESS) {
result = ma_decoder_init_vorbis__internal(pConfig, pDecoder);
if (result != MA_SUCCESS) {
onSeek(pDecoder, 0, ma_seek_origin_start);
}
}
#endif
#if defined(MA_HAS_MP3)
if (result != MA_SUCCESS) {
result = ma_decoder_init_mp3__internal(pConfig, pDecoder);
if (result != MA_SUCCESS) {
onSeek(pDecoder, 0, ma_seek_origin_start);
}
}
#endif

if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(pConfig, pDecoder);
}

ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder__preinit(onRead, onSeek, pUserData, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init__internal(onRead, onSeek, pUserData, &config, pDecoder);
}


static size_t ma_decoder__on_read_memory(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead)
{
size_t bytesRemaining;

MA_ASSERT(pDecoder->memory.dataSize >= pDecoder->memory.currentReadPos);

bytesRemaining = pDecoder->memory.dataSize - pDecoder->memory.currentReadPos;
if (bytesToRead > bytesRemaining) {
bytesToRead = bytesRemaining;
}

if (bytesToRead > 0) {
MA_COPY_MEMORY(pBufferOut, pDecoder->memory.pData + pDecoder->memory.currentReadPos, bytesToRead);
pDecoder->memory.currentReadPos += bytesToRead;
}

return bytesToRead;
}

static ma_bool32 ma_decoder__on_seek_memory(ma_decoder* pDecoder, int byteOffset, ma_seek_origin origin)
{
if (origin == ma_seek_origin_current) {
if (byteOffset > 0) {
if (pDecoder->memory.currentReadPos + byteOffset > pDecoder->memory.dataSize) {
byteOffset = (int)(pDecoder->memory.dataSize - pDecoder->memory.currentReadPos); 
}
} else {
if (pDecoder->memory.currentReadPos < (size_t)-byteOffset) {
byteOffset = -(int)pDecoder->memory.currentReadPos; 
}
}


pDecoder->memory.currentReadPos += byteOffset;
} else {
if ((ma_uint32)byteOffset <= pDecoder->memory.dataSize) {
pDecoder->memory.currentReadPos = byteOffset;
} else {
pDecoder->memory.currentReadPos = pDecoder->memory.dataSize; 
}
}

return MA_TRUE;
}

static ma_result ma_decoder__preinit_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit(ma_decoder__on_read_memory, ma_decoder__on_seek_memory, NULL, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

if (pData == NULL || dataSize == 0) {
return MA_INVALID_ARGS;
}

pDecoder->memory.pData = (const ma_uint8*)pData;
pDecoder->memory.dataSize = dataSize;
pDecoder->memory.currentReadPos = 0;

(void)pConfig;
return MA_SUCCESS;
}

ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init__internal(ma_decoder__on_read_memory, ma_decoder__on_seek_memory, NULL, &config, pDecoder);
}

ma_result ma_decoder_init_memory_wav(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_WAV)
result = ma_decoder_init_wav__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_memory_flac(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_FLAC)
result = ma_decoder_init_flac__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_memory_vorbis(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_VORBIS)
result = ma_decoder_init_vorbis__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_memory_mp3(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfig); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_MP3)
result = ma_decoder_init_mp3__internal(&config, pDecoder);
#else
result = MA_NO_BACKEND;
#endif
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

ma_result ma_decoder_init_memory_raw(const void* pData, size_t dataSize, const ma_decoder_config* pConfigIn, const ma_decoder_config* pConfigOut, ma_decoder* pDecoder)
{
ma_decoder_config config;
ma_result result;

config = ma_decoder_config_init_copy(pConfigOut); 

result = ma_decoder__preinit_memory(pData, dataSize, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

result = ma_decoder_init_raw__internal(pConfigIn, &config, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__postinit(&config, pDecoder);
}

#if !defined(MA_NO_STDIO)
static const char* ma_path_file_name(const char* path)
{
const char* fileName;

if (path == NULL) {
return NULL;
}

fileName = path;


while (path[0] != '\0') {
if (path[0] == '/' || path[0] == '\\') {
fileName = path;
}

path += 1;
}


while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
fileName += 1;
}

return fileName;
}

static const wchar_t* ma_path_file_name_w(const wchar_t* path)
{
const wchar_t* fileName;

if (path == NULL) {
return NULL;
}

fileName = path;


while (path[0] != '\0') {
if (path[0] == '/' || path[0] == '\\') {
fileName = path;
}

path += 1;
}


while (fileName[0] != '\0' && (fileName[0] == '/' || fileName[0] == '\\')) {
fileName += 1;
}

return fileName;
}


static const char* ma_path_extension(const char* path)
{
const char* extension;
const char* lastOccurance;

if (path == NULL) {
path = "";
}

extension = ma_path_file_name(path);
lastOccurance = NULL;


while (extension[0] != '\0') {
if (extension[0] == '.') {
extension += 1;
lastOccurance = extension;
}

extension += 1;
}

return (lastOccurance != NULL) ? lastOccurance : extension;
}

static const wchar_t* ma_path_extension_w(const wchar_t* path)
{
const wchar_t* extension;
const wchar_t* lastOccurance;

if (path == NULL) {
path = L"";
}

extension = ma_path_file_name_w(path);
lastOccurance = NULL;


while (extension[0] != '\0') {
if (extension[0] == '.') {
extension += 1;
lastOccurance = extension;
}

extension += 1;
}

return (lastOccurance != NULL) ? lastOccurance : extension;
}


static ma_bool32 ma_path_extension_equal(const char* path, const char* extension)
{
const char* ext1;
const char* ext2;

if (path == NULL || extension == NULL) {
return MA_FALSE;
}

ext1 = extension;
ext2 = ma_path_extension(path);

#if defined(_MSC_VER) || defined(__DMC__)
return _stricmp(ext1, ext2) == 0;
#else
return strcasecmp(ext1, ext2) == 0;
#endif
}

static ma_bool32 ma_path_extension_equal_w(const wchar_t* path, const wchar_t* extension)
{
const wchar_t* ext1;
const wchar_t* ext2;

if (path == NULL || extension == NULL) {
return MA_FALSE;
}

ext1 = extension;
ext2 = ma_path_extension_w(path);

#if defined(_MSC_VER) || defined(__DMC__)
return _wcsicmp(ext1, ext2) == 0;
#else




{
char ext1MB[4096];
char ext2MB[4096];
const wchar_t* pext1 = ext1;
const wchar_t* pext2 = ext2;
mbstate_t mbs1;
mbstate_t mbs2;

MA_ZERO_OBJECT(&mbs1);
MA_ZERO_OBJECT(&mbs2);

if (wcsrtombs(ext1MB, &pext1, sizeof(ext1MB), &mbs1) == (size_t)-1) {
return MA_FALSE;
}
if (wcsrtombs(ext2MB, &pext2, sizeof(ext2MB), &mbs2) == (size_t)-1) {
return MA_FALSE;
}

return strcasecmp(ext1MB, ext2MB) == 0;
}
#endif
}


static size_t ma_decoder__on_read_stdio(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead)
{
return fread(pBufferOut, 1, bytesToRead, (FILE*)pDecoder->pUserData);
}

static ma_bool32 ma_decoder__on_seek_stdio(ma_decoder* pDecoder, int byteOffset, ma_seek_origin origin)
{
return fseek((FILE*)pDecoder->pUserData, byteOffset, (origin == ma_seek_origin_current) ? SEEK_CUR : SEEK_SET) == 0;
}

static ma_result ma_decoder__preinit_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result;
FILE* pFile;

if (pDecoder == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pDecoder);

if (pFilePath == NULL || pFilePath[0] == '\0') {
return MA_INVALID_ARGS;
}

result = ma_decoder__init_allocation_callbacks(pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(_MSC_VER) && _MSC_VER >= 1400
if (fopen_s(&pFile, pFilePath, "rb") != 0) {
return MA_ERROR;
}
#else
pFile = fopen(pFilePath, "rb");
if (pFile == NULL) {
return MA_ERROR;
}
#endif


pDecoder->pUserData = pFile;

return MA_SUCCESS;
}












#if defined(_WIN32)
#if defined(_MSC_VER) || defined(__MINGW64__) || !defined(__STRICT_ANSI__)
#define MA_HAS_WFOPEN
#endif
#endif

static ma_result ma_decoder__preinit_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result;
FILE* pFile;

if (pDecoder == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pDecoder);

if (pFilePath == NULL || pFilePath[0] == '\0') {
return MA_INVALID_ARGS;
}

result = ma_decoder__init_allocation_callbacks(pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

#if defined(MA_HAS_WFOPEN)

#if defined(_MSC_VER) && _MSC_VER >= 1400
if (_wfopen_s(&pFile, pFilePath, L"rb") != 0) {
return MA_ERROR;
}
#else
pFile = _wfopen(pFilePath, L"rb");
if (pFile == NULL) {
return MA_ERROR;
}
#endif
#else





{
mbstate_t mbs;
size_t lenMB;
const wchar_t* pFilePathTemp = pFilePath;
char* pFilePathMB = NULL;


MA_ZERO_OBJECT(&mbs);
lenMB = wcsrtombs(NULL, &pFilePathTemp, 0, &mbs);
if (lenMB == (size_t)-1) {
return MA_ERROR;
}

pFilePathMB = (char*)ma__malloc_from_callbacks(lenMB + 1, &pDecoder->allocationCallbacks);
if (pFilePathMB == NULL) {
return MA_OUT_OF_MEMORY;
}

pFilePathTemp = pFilePath;
MA_ZERO_OBJECT(&mbs);
wcsrtombs(pFilePathMB, &pFilePathTemp, lenMB + 1, &mbs);

pFile = fopen(pFilePathMB, "rb");

ma__free_from_callbacks(pFilePathMB, &pDecoder->allocationCallbacks);
}

if (pFile == NULL) {
return MA_ERROR;
}
#endif


pDecoder->pUserData = pFile;

(void)pConfig;
return MA_SUCCESS;
}

ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file(pFilePath, pConfig, pDecoder); 
if (result != MA_SUCCESS) {
return result;
}


if (ma_path_extension_equal(pFilePath, "wav")) {
result = ma_decoder_init_wav(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


if (ma_path_extension_equal(pFilePath, "flac")) {
result = ma_decoder_init_flac(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


if (ma_path_extension_equal(pFilePath, "mp3")) {
result = ma_decoder_init_mp3(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


return ma_decoder_init(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_wav(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_wav(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_flac(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_flac(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_vorbis(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_vorbis(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_mp3(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_mp3(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}


ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file_w(pFilePath, pConfig, pDecoder); 
if (result != MA_SUCCESS) {
return result;
}


if (ma_path_extension_equal_w(pFilePath, L"wav")) {
result = ma_decoder_init_wav(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


if (ma_path_extension_equal_w(pFilePath, L"flac")) {
result = ma_decoder_init_flac(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


if (ma_path_extension_equal_w(pFilePath, L"mp3")) {
result = ma_decoder_init_mp3(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
if (result == MA_SUCCESS) {
return MA_SUCCESS;
}

ma_decoder__on_seek_stdio(pDecoder, 0, ma_seek_origin_start);
}


return ma_decoder_init(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_wav_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file_w(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_wav(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_flac_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file_w(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_flac(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_vorbis_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file_w(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_vorbis(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}

ma_result ma_decoder_init_file_mp3_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)
{
ma_result result = ma_decoder__preinit_file_w(pFilePath, pConfig, pDecoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder_init_mp3(ma_decoder__on_read_stdio, ma_decoder__on_seek_stdio, pDecoder->pUserData, pConfig, pDecoder);
}
#endif 

ma_result ma_decoder_uninit(ma_decoder* pDecoder)
{
if (pDecoder == NULL) {
return MA_INVALID_ARGS;
}

if (pDecoder->onUninit) {
pDecoder->onUninit(pDecoder);
}

#if !defined(MA_NO_STDIO)

if (pDecoder->onRead == ma_decoder__on_read_stdio) {
fclose((FILE*)pDecoder->pUserData);
}
#endif

ma_data_converter_uninit(&pDecoder->converter);

return MA_SUCCESS;
}

ma_uint64 ma_decoder_get_length_in_pcm_frames(ma_decoder* pDecoder)
{
if (pDecoder == NULL) {
return 0;
}

if (pDecoder->onGetLengthInPCMFrames) {
ma_uint64 nativeLengthInPCMFrames = pDecoder->onGetLengthInPCMFrames(pDecoder);
if (pDecoder->internalSampleRate == pDecoder->outputSampleRate) {
return nativeLengthInPCMFrames;
} else {
return ma_calculate_frame_count_after_resampling(pDecoder->outputSampleRate, pDecoder->internalSampleRate, nativeLengthInPCMFrames);
}
}

return 0;
}

ma_uint64 ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount)
{
ma_result result;
ma_uint64 totalFramesReadOut;
ma_uint64 totalFramesReadIn;
void* pRunningFramesOut;

if (pDecoder == NULL) {
return 0;
}

if (pDecoder->onReadPCMFrames == NULL) {
return 0;
}


if (pDecoder->converter.isPassthrough) {
return pDecoder->onReadPCMFrames(pDecoder, pFramesOut, frameCount);
}


totalFramesReadOut = 0;
totalFramesReadIn = 0;
pRunningFramesOut = pFramesOut;

while (totalFramesReadOut < frameCount) {
ma_uint8 pIntermediaryBuffer[MA_DATA_CONVERTER_STACK_BUFFER_SIZE]; 
ma_uint64 intermediaryBufferCap = sizeof(pIntermediaryBuffer) / ma_get_bytes_per_frame(pDecoder->internalFormat, pDecoder->internalChannels);
ma_uint64 framesToReadThisIterationIn;
ma_uint64 framesReadThisIterationIn;
ma_uint64 framesToReadThisIterationOut;
ma_uint64 framesReadThisIterationOut;
ma_uint64 requiredInputFrameCount;

framesToReadThisIterationOut = (frameCount - totalFramesReadOut);
framesToReadThisIterationIn = framesToReadThisIterationOut;
if (framesToReadThisIterationIn > intermediaryBufferCap) {
framesToReadThisIterationIn = intermediaryBufferCap;
}

requiredInputFrameCount = ma_data_converter_get_required_input_frame_count(&pDecoder->converter, framesToReadThisIterationOut);
if (framesToReadThisIterationIn > requiredInputFrameCount) {
framesToReadThisIterationIn = requiredInputFrameCount;
}

if (requiredInputFrameCount > 0) {
framesReadThisIterationIn = pDecoder->onReadPCMFrames(pDecoder, pIntermediaryBuffer, framesToReadThisIterationIn);
totalFramesReadIn += framesReadThisIterationIn;
}





framesReadThisIterationOut = framesToReadThisIterationOut;
result = ma_data_converter_process_pcm_frames(&pDecoder->converter, pIntermediaryBuffer, &framesReadThisIterationIn, pRunningFramesOut, &framesReadThisIterationOut);
if (result != MA_SUCCESS) {
break;
}

totalFramesReadOut += framesReadThisIterationOut;
pRunningFramesOut = ma_offset_ptr(pRunningFramesOut, framesReadThisIterationOut * ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels));

if (framesReadThisIterationIn == 0 && framesReadThisIterationOut == 0) {
break; 
}
}

return totalFramesReadOut;
}

ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex)
{
if (pDecoder == NULL) {
return 0;
}

if (pDecoder->onSeekToPCMFrame) {
return pDecoder->onSeekToPCMFrame(pDecoder, frameIndex);
}


return MA_INVALID_ARGS;
}


static ma_result ma_decoder__full_decode_and_uninit(ma_decoder* pDecoder, ma_decoder_config* pConfigOut, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
ma_uint64 totalFrameCount;
ma_uint64 bpf;
ma_uint64 dataCapInFrames;
void* pPCMFramesOut;

MA_ASSERT(pDecoder != NULL);

totalFrameCount = 0;
bpf = ma_get_bytes_per_frame(pDecoder->outputFormat, pDecoder->outputChannels);


dataCapInFrames = 0;
pPCMFramesOut = NULL;
for (;;) {
ma_uint64 frameCountToTryReading;
ma_uint64 framesJustRead;


if (totalFrameCount == dataCapInFrames) {
void* pNewPCMFramesOut;
ma_uint64 oldDataCapInFrames = dataCapInFrames;
ma_uint64 newDataCapInFrames = dataCapInFrames*2;
if (newDataCapInFrames == 0) {
newDataCapInFrames = 4096;
}

if ((newDataCapInFrames * bpf) > MA_SIZE_MAX) {
ma__free_from_callbacks(pPCMFramesOut, &pDecoder->allocationCallbacks);
return MA_TOO_LARGE;
}


pNewPCMFramesOut = (void*)ma__realloc_from_callbacks(pPCMFramesOut, (size_t)(newDataCapInFrames * bpf), (size_t)(oldDataCapInFrames * bpf), &pDecoder->allocationCallbacks);
if (pNewPCMFramesOut == NULL) {
ma__free_from_callbacks(pPCMFramesOut, &pDecoder->allocationCallbacks);
return MA_OUT_OF_MEMORY;
}

dataCapInFrames = newDataCapInFrames;
pPCMFramesOut = pNewPCMFramesOut;
}

frameCountToTryReading = dataCapInFrames - totalFrameCount;
MA_ASSERT(frameCountToTryReading > 0);

framesJustRead = ma_decoder_read_pcm_frames(pDecoder, (ma_uint8*)pPCMFramesOut + (totalFrameCount * bpf), frameCountToTryReading);
totalFrameCount += framesJustRead;

if (framesJustRead < frameCountToTryReading) {
break;
}
}


if (pConfigOut != NULL) {
pConfigOut->format = pDecoder->outputFormat;
pConfigOut->channels = pDecoder->outputChannels;
pConfigOut->sampleRate = pDecoder->outputSampleRate;
ma_channel_map_copy(pConfigOut->channelMap, pDecoder->outputChannelMap, pDecoder->outputChannels);
}

if (ppPCMFramesOut != NULL) {
*ppPCMFramesOut = pPCMFramesOut;
} else {
ma__free_from_callbacks(pPCMFramesOut, &pDecoder->allocationCallbacks);
}

if (pFrameCountOut != NULL) {
*pFrameCountOut = totalFrameCount;
}

ma_decoder_uninit(pDecoder);
return MA_SUCCESS;
}

#if !defined(MA_NO_STDIO)
ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
ma_decoder_config config;
ma_decoder decoder;
ma_result result;

if (pFrameCountOut != NULL) {
*pFrameCountOut = 0;
}
if (ppPCMFramesOut != NULL) {
*ppPCMFramesOut = NULL;
}

if (pFilePath == NULL) {
return MA_INVALID_ARGS;
}

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder_init_file(pFilePath, &config, &decoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);
}
#endif

ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppPCMFramesOut)
{
ma_decoder_config config;
ma_decoder decoder;
ma_result result;

if (pFrameCountOut != NULL) {
*pFrameCountOut = 0;
}
if (ppPCMFramesOut != NULL) {
*ppPCMFramesOut = NULL;
}

if (pData == NULL || dataSize == 0) {
return MA_INVALID_ARGS;
}

config = ma_decoder_config_init_copy(pConfig);

result = ma_decoder_init_memory(pData, dataSize, &config, &decoder);
if (result != MA_SUCCESS) {
return result;
}

return ma_decoder__full_decode_and_uninit(&decoder, pConfig, pFrameCountOut, ppPCMFramesOut);
}

#endif 









ma_result ma_waveform_init(ma_waveform_type type, double amplitude, double frequency, ma_uint32 sampleRate, ma_waveform* pWaveform)
{
if (pWaveform == NULL) {
return MA_INVALID_ARGS;
}

MA_ZERO_OBJECT(pWaveform);

pWaveform->type = type;
pWaveform->amplitude = amplitude;
pWaveform->frequency = frequency;
pWaveform->deltaTime = 1.0 / sampleRate;
pWaveform->time = 0;

return MA_SUCCESS;
}

ma_result ma_waveform_set_amplitude(ma_waveform* pWaveform, double amplitude)
{
if (pWaveform == NULL) {
return MA_INVALID_ARGS;
}

pWaveform->amplitude = amplitude;
return MA_SUCCESS;
}

ma_result ma_waveform_set_frequency(ma_waveform* pWaveform, double frequency)
{
if (pWaveform == NULL) {
return MA_INVALID_ARGS;
}

pWaveform->frequency = frequency;
return MA_SUCCESS;
}

ma_result ma_waveform_set_sample_rate(ma_waveform* pWaveform, ma_uint32 sampleRate)
{
if (pWaveform == NULL) {
return MA_INVALID_ARGS;
}

pWaveform->deltaTime = 1.0 / sampleRate;
return MA_SUCCESS;
}

static float ma_waveform_sine_f32(double time, double frequency, double amplitude)
{
return (float)(ma_sin(MA_TAU_D * time * frequency) * amplitude);
}

static float ma_waveform_square_f32(double time, double frequency, double amplitude)
{
double t = time * frequency;
double f = t - (ma_uint64)t;
double r;

if (f < 0.5) {
r = amplitude;
} else {
r = -amplitude;
}

return (float)r;
}

static float ma_waveform_triangle_f32(double time, double frequency, double amplitude)
{
double t = time * frequency;
double f = t - (ma_uint64)t;
double r;

r = 2 * ma_abs(2 * (f - 0.5)) - 1;

return (float)(r * amplitude);
}

static float ma_waveform_sawtooth_f32(double time, double frequency, double amplitude)
{
double t = time * frequency;
double f = t - (ma_uint64)t;
double r;

r = 2 * (f - 0.5);

return (float)(r * amplitude);
}

static void ma_waveform_read_pcm_frames__sine(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
ma_uint64 iFrame;
ma_uint64 iChannel;
ma_uint32 bpf = ma_get_bytes_per_frame(format, channels);
ma_uint32 bps = ma_get_bytes_per_sample(format);

MA_ASSERT(pWaveform != NULL);
MA_ASSERT(pFramesOut != NULL);

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
float s = ma_waveform_sine_f32(pWaveform->time, pWaveform->frequency, pWaveform->amplitude);
pWaveform->time += pWaveform->deltaTime;

for (iChannel = 0; iChannel < channels; iChannel += 1) {
ma_pcm_convert(ma_offset_ptr(pFramesOut, iFrame*bpf + iChannel*bps), format, &s, ma_format_f32, 1, ma_dither_mode_none);
}
}
}

static void ma_waveform_read_pcm_frames__square(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
ma_uint64 iFrame;
ma_uint64 iChannel;
ma_uint32 bpf = ma_get_bytes_per_frame(format, channels);
ma_uint32 bps = ma_get_bytes_per_sample(format);

MA_ASSERT(pWaveform != NULL);
MA_ASSERT(pFramesOut != NULL);

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
float s = ma_waveform_square_f32(pWaveform->time, pWaveform->frequency, pWaveform->amplitude);
pWaveform->time += pWaveform->deltaTime;

for (iChannel = 0; iChannel < channels; iChannel += 1) {
ma_pcm_convert(ma_offset_ptr(pFramesOut, iFrame*bpf + iChannel*bps), format, &s, ma_format_f32, 1, ma_dither_mode_none);
}
}
}

static void ma_waveform_read_pcm_frames__triangle(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
ma_uint64 iFrame;
ma_uint64 iChannel;
ma_uint32 bpf = ma_get_bytes_per_frame(format, channels);
ma_uint32 bps = ma_get_bytes_per_sample(format);

MA_ASSERT(pWaveform != NULL);
MA_ASSERT(pFramesOut != NULL);

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
float s = ma_waveform_triangle_f32(pWaveform->time, pWaveform->frequency, pWaveform->amplitude);
pWaveform->time += pWaveform->deltaTime;

for (iChannel = 0; iChannel < channels; iChannel += 1) {
ma_pcm_convert(ma_offset_ptr(pFramesOut, iFrame*bpf + iChannel*bps), format, &s, ma_format_f32, 1, ma_dither_mode_none);
}
}
}

static void ma_waveform_read_pcm_frames__sawtooth(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
ma_uint64 iFrame;
ma_uint64 iChannel;
ma_uint32 bpf = ma_get_bytes_per_frame(format, channels);
ma_uint32 bps = ma_get_bytes_per_sample(format);

MA_ASSERT(pWaveform != NULL);
MA_ASSERT(pFramesOut != NULL);

for (iFrame = 0; iFrame < frameCount; iFrame += 1) {
float s = ma_waveform_sawtooth_f32(pWaveform->time, pWaveform->frequency, pWaveform->amplitude);
pWaveform->time += pWaveform->deltaTime;

for (iChannel = 0; iChannel < channels; iChannel += 1) {
ma_pcm_convert(ma_offset_ptr(pFramesOut, iFrame*bpf + iChannel*bps), format, &s, ma_format_f32, 1, ma_dither_mode_none);
}
}
}

ma_uint64 ma_waveform_read_pcm_frames(ma_waveform* pWaveform, void* pFramesOut, ma_uint64 frameCount, ma_format format, ma_uint32 channels)
{
if (pWaveform == NULL) {
return 0;
}

if (pFramesOut != NULL) {
switch (pWaveform->type)
{
case ma_waveform_type_sine:
{
ma_waveform_read_pcm_frames__sine(pWaveform, pFramesOut, frameCount, format, channels);
} break;

case ma_waveform_type_square:
{
ma_waveform_read_pcm_frames__square(pWaveform, pFramesOut, frameCount, format, channels);
} break;

case ma_waveform_type_triangle:
{
ma_waveform_read_pcm_frames__triangle(pWaveform, pFramesOut, frameCount, format, channels);
} break;

case ma_waveform_type_sawtooth:
{
ma_waveform_read_pcm_frames__sawtooth(pWaveform, pFramesOut, frameCount, format, channels);
} break;

default: return 0;
}
} else {
pWaveform->time += pWaveform->deltaTime * (ma_int64)frameCount; 
}

return frameCount;
}



#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif 
















































































































































































































































































































































































































































































































































































