<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\raylib-analysis\_cppstats_featurelocations\raylib\src\physac.h">







































































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_H</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSACDEF</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSACDEF</name></cpp:macro> <cpp:value>extern "C"</cpp:value></cpp:define> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSACDEF</name></cpp:macro> <cpp:value>extern</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_MALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_MALLOC</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>malloc(size)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_FREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_FREE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>free(ptr)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_MAX_BODIES</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_MAX_MANIFOLDS</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_MAX_VERTICES</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_CIRCLE_VERTICES</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_COLLISION_ITERATIONS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_PENETRATION_ALLOWANCE</name></cpp:macro> <cpp:value>0.05f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_PENETRATION_CORRECTION</name></cpp:macro> <cpp:value>0.4f</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_DEG2RAD</name></cpp:macro> <cpp:value>(PHYSAC_PI/180.0f)</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_STANDALONE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<typedef>typedef <type><enum>enum <block>{ <decl><name>false</name></decl>, <decl><name>true</name></decl> }</block></enum></type> <name>bool</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><struct>struct <name>Vector2</name> <block>{
<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y</name></decl>;</decl_stmt>
}</block></struct></type> <name>Vector2</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <name>PhysicsShapeType</name> <block>{ <decl><name>PHYSICS_CIRCLE</name></decl>, <decl><name>PHYSICS_POLYGON</name></decl> }</block></enum></type> <name>PhysicsShapeType</name>;</typedef>


<typedef>typedef <type><name><name>struct</name> <name>PhysicsBodyData</name></name> <modifier>*</modifier></type><name>PhysicsBody</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>InitPhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>RunPhysicsStep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsTimeStep</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>delta</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>bool</name></type> <name>IsPhysicsEnabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsGravity</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>y</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyCircle</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyRectangle</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>height</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyPolygon</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sides</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsAddForce</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsAddTorque</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>amount</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsShatter</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>position</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsBodiesCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>GetPhysicsBody</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsShapeType</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsShapeVerticesCount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>Vector2</name></type> <name>GetPhysicsShapeVertex</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vertex</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsBodyRotation</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>DestroyPhysicsBody</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>ResetPhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><name>PHYSACDEF</name> <name>void</name></type> <name>ClosePhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_NO_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACELOG</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACELOG</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_STANDALONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"raymath.h"</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><name>int</name> <name>__stdcall</name></type> <name>QueryPerformanceCounter</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <modifier>*</modifier></type><name>lpPerformanceCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name> <name>__stdcall</name></type> <name>QueryPerformanceFrequency</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <modifier>*</modifier></type><name>lpFrequency</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_POSIX_C_SOURCE</name> <operator>&lt;</operator> <literal type="number">199309L</literal></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_POSIX_C_SOURCE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX_C_SOURCE</name></cpp:macro> <cpp:value>199309L</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include> 
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_time.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>min</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)&lt;(b))?(a):(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>max</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)&gt;(b))?(a):(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_FLT_MAX</name></cpp:macro> <cpp:value>3.402823466e+38f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_EPSILON</name></cpp:macro> <cpp:value>0.000001f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_K</name></cpp:macro> <cpp:value>1.0f/3.0f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PHYSAC_VECTOR_ZERO</name></cpp:macro> <cpp:value>(Vector2){ 0.0f, 0.0f }</cpp:value></cpp:define>






<typedef>typedef <type><struct>struct <name>Matrix2x2</name> <block>{
<decl_stmt><decl><type><name>float</name></type> <name>m00</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>m01</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>m10</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>m11</name></decl>;</decl_stmt>
}</block></struct></type> <name>Matrix2x2</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PolygonData</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vertexCount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name><name>positions</name><index>[<expr><name>PHYSAC_MAX_VERTICES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name><name>normals</name><index>[<expr><name>PHYSAC_MAX_VERTICES</name></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>PolygonData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PhysicsShape</name> <block>{
<decl_stmt><decl><type><name>PhysicsShapeType</name></type> <name>type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>radius</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Matrix2x2</name></type> <name>transform</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PolygonData</name></type> <name>vertexData</name></decl>;</decl_stmt> 
}</block></struct></type> <name>PhysicsShape</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PhysicsBodyData</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>enabled</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name>position</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name>velocity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name>force</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>angularVelocity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>torque</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>orient</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>inertia</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>inverseInertia</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>mass</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>inverseMass</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>staticFriction</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>dynamicFriction</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>restitution</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>useGravity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>isGrounded</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>freezeOrient</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PhysicsShape</name></type> <name>shape</name></decl>;</decl_stmt> 
}</block></struct></type> <name>PhysicsBodyData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PhysicsManifoldData</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>penetration</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Vector2</name></type> <name><name>contacts</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>contactsCount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>restitution</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>dynamicFriction</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>staticFriction</name></decl>;</decl_stmt> 
}</block></struct></type> <name>PhysicsManifoldData</name><operator>,</operator> *<name>PhysicsManifold</name>;</typedef>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_NO_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_t</name></type> <name>physicsThreadId</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>usedMemory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>physicsThreadEnabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>baseTime</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>startTime</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>deltaTime</name> <init>= <expr><literal type="number">1.0</literal><operator>/</operator><literal type="number">60.0</literal><operator>/</operator><literal type="number">10.0</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>currentTime</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name> <name>int</name></type> <name>frequency</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>accumulator</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>stepsCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>Vector2</name></type> <name>gravityForce</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">9.81f</literal></expr> }</block></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>PhysicsBody</name></type> <name><name>bodies</name><index>[<expr><name>PHYSAC_MAX_BODIES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>physicsBodiesCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>PhysicsManifold</name></type> <name><name>contacts</name><index>[<expr><name>PHYSAC_MAX_MANIFOLDS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>physicsManifoldsCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 




<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FindAvailableBodyIndex</name><parameter_list>()</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>PolygonData</name></type> <name>CreateRandomPolygon</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sides</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>PolygonData</name></type> <name>CreateRectanglePolygon</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>PhysicsLoop</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PhysicsStep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FindAvailableManifoldIndex</name><parameter_list>()</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>PhysicsManifold</name></type> <name>CreatePhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>PhysicsBody</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestroyPhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SolvePhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SolveCircleToCircle</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SolveCircleToPolygon</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SolvePolygonToCircle</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SolvePolygonToPolygon</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsForces</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializePhysicsManifolds</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsImpulses</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsVelocity</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CorrectPhysicsPositions</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>FindAxisLeastPenetration</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>faceIndex</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>shapeA</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>shapeB</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FindIncidentFace</name><parameter_list>(<parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>v0</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>inc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Clip</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>normal</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>clip</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>faceA</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>faceB</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>BiasGreaterThan</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>valueA</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>valueB</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>Vector2</name></type> <name>TriangleBarycenter</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v3</name></decl></parameter>)</parameter_list>;</function_decl> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name> <name>int</name></type> <name>GetTimeCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>GetCurrentTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 


<function_decl><type><specifier>static</specifier> <name>Vector2</name></type> <name>MathCross</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>MathCrossVector2</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>MathLenSqr</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>MathDot</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>DistSqr</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MathNormalize</name><parameter_list>(<parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>vector</name></decl></parameter>)</parameter_list>;</function_decl> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_STANDALONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>Vector2</name></type> <name>Vector2Add</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>Vector2</name></type> <name>Vector2Subtract</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>Matrix2x2</name></type> <name>Mat2Radians</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Mat2Set</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name> <modifier>*</modifier></type><name>matrix</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>Matrix2x2</name></type> <name>Mat2Transpose</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name></type> <name>matrix</name></decl></parameter>)</parameter_list>;</function_decl> 
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>Vector2</name></type> <name>Mat2MultiplyVector2</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name></type> <name>matrix</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>;</function_decl> 





<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>InitPhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_NO_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>


<expr_stmt><expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>physicsThreadId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>PhysicsLoop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>InitTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics module initialized successfully\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>accumulator</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>bool</name></type> <name>IsPhysicsEnabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>physicsThreadEnabled</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsGravity</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>gravityForce</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gravityForce</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyCircle</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>newBody</name> <init>= <expr><call><name>CreatePhysicsBodyPolygon</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>radius</name></expr></argument>, <argument><expr><name>PHYSAC_CIRCLE_VERTICES</name></expr></argument>, <argument><expr><name>density</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>newBody</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyRectangle</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>height</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>newBody</name> <init>= <expr><operator>(</operator><name>PhysicsBody</name><operator>)</operator><call><name>PHYSAC_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newId</name> <init>= <expr><call><name>FindAvailableBodyIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>newId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>velocity</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><literal type="number">0.0f</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><literal type="number">0.0f</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>torque</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>orient</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PHYSICS_POLYGON</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name>newBody</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name> <operator>=</operator> <call><name>Mat2Radians</name><argument_list>(<argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name> <operator>=</operator> <macro><name>CreateRectanglePolygon</name><argument_list>(<argument>pos</argument>, <argument>(Vector2){ width</argument>, <argument>height }</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>center</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>area</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inertia</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>p1</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>p2</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>D</name> <init>= <expr><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>triangleArea</name> <init>= <expr><name>D</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>area</name> <operator>+=</operator> <name>triangleArea</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>intx2</name> <init>= <expr><name><name>p1</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p2</name><operator>.</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inty2</name> <init>= <expr><name><name>p1</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p2</name><operator>.</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>inertia</name> <operator>+=</operator> <operator>(</operator><literal type="number">0.25f</literal><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><name>D</name><operator>)</operator><operator>*</operator><operator>(</operator><name>intx2</name> <operator>+</operator> <name>inty2</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>-=</operator> <name><name>center</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>-=</operator> <name><name>center</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>=</operator> <name>density</name><operator>*</operator><name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>=</operator> <name>density</name><operator>*</operator><name>inertia</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseInertia</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>staticFriction</name></name> <operator>=</operator> <literal type="number">0.4f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>dynamicFriction</name></name> <operator>=</operator> <literal type="number">0.2f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>useGravity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>isGrounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>freezeOrient</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>bodies</name><index>[<expr><name>physicsBodiesCount</name></expr>]</index></name> <operator>=</operator> <name>newBody</name></expr>;</expr_stmt>
<expr_stmt><expr><name>physicsBodiesCount</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] created polygon physics body id %i\n"</literal></expr></argument>, <argument><expr><name><name>newBody</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] new physics body creation failed because there is any available id to use\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>newBody</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>CreatePhysicsBodyPolygon</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sides</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>density</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>newBody</name> <init>= <expr><operator>(</operator><name>PhysicsBody</name><operator>)</operator><call><name>PHYSAC_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newId</name> <init>= <expr><call><name>FindAvailableBodyIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>newId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>velocity</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>torque</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>orient</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PHYSICS_POLYGON</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name>newBody</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name> <operator>=</operator> <call><name>Mat2Radians</name><argument_list>(<argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name> <operator>=</operator> <call><name>CreateRandomPolygon</name><argument_list>(<argument><expr><name>radius</name></expr></argument>, <argument><expr><name>sides</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>center</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>area</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inertia</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>position1</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>position2</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>cross</name> <init>= <expr><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>position1</name></expr></argument>, <argument><expr><name>position2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>triangleArea</name> <init>= <expr><name>cross</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>area</name> <operator>+=</operator> <name>triangleArea</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>position1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>position1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>intx2</name> <init>= <expr><name><name>position1</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>position1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>position1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>position2</name><operator>.</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inty2</name> <init>= <expr><name><name>position1</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>position1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>position1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>position2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>position2</name><operator>.</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>inertia</name> <operator>+=</operator> <operator>(</operator><literal type="number">0.25f</literal><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><name>cross</name><operator>)</operator><operator>*</operator><operator>(</operator><name>intx2</name> <operator>+</operator> <name>inty2</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>-=</operator> <name><name>center</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>-=</operator> <name><name>center</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>=</operator> <name>density</name><operator>*</operator><name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>=</operator> <name>density</name><operator>*</operator><name>inertia</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseInertia</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>staticFriction</name></name> <operator>=</operator> <literal type="number">0.4f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>dynamicFriction</name></name> <operator>=</operator> <literal type="number">0.2f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>useGravity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>isGrounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>freezeOrient</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>bodies</name><index>[<expr><name>physicsBodiesCount</name></expr>]</index></name> <operator>=</operator> <name>newBody</name></expr>;</expr_stmt>
<expr_stmt><expr><name>physicsBodiesCount</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] created polygon physics body id %i\n"</literal></expr></argument>, <argument><expr><name><name>newBody</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] new physics body creation failed because there is any available id to use\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>newBody</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsAddForce</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>force</name></name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsAddTorque</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>torque</name></name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>PhysicsShatter</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>position</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PHYSICS_POLYGON</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>vertexData</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>collision</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>positionA</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>positionB</name> <init>= <expr><call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>vertexData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>positionC</name> <init>= <expr><call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>alpha</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>positionB</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>position</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>positionC</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionB</name><operator>.</operator><name>x</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>position</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>)</operator><operator>/</operator>
<operator>(</operator><operator>(</operator><name><name>positionB</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>positionA</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>positionC</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionB</name><operator>.</operator><name>x</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>positionA</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>beta</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>positionC</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionA</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>position</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>positionA</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>x</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>position</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>)</operator><operator>/</operator>
<operator>(</operator><operator>(</operator><name><name>positionB</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>positionA</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>positionC</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>positionB</name><operator>.</operator><name>x</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>positionA</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>positionC</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>gamma</name> <init>= <expr><literal type="number">1.0f</literal> <operator>-</operator> <name>alpha</name> <operator>-</operator> <name>beta</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>alpha</name> <operator>&gt;</operator> <literal type="number">0.0f</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>beta</name> <operator>&gt;</operator> <literal type="number">0.0f</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>gamma</name> <operator>&gt;</operator> <literal type="number">0.0f</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>collision</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>collision</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>bodyPos</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>vertices</name> <init>= <expr><operator>(</operator><name>Vector2</name> <operator>*</operator><operator>)</operator><call><name>PHYSAC_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Vector2</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Matrix2x2</name></type> <name>trans</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><call><name>DestroyPhysicsBody</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>center</name> <init>= <expr><call><name>TriangleBarycenter</name><argument_list>(<argument><expr><name><name>vertices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>vertices</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>PHYSAC_VECTOR_ZERO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>center</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>bodyPos</name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>offset</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>bodyPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>newBody</name> <init>= <expr><call><name>CreatePhysicsBodyPolygon</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>PolygonData</name></type> <name>newData</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>vertexCount</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>vertices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>vertices</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>y</name> <operator>*=</operator> <literal type="number">0.95f</literal></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>newData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nextVertex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>newData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>face</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextVertex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>newData</name><operator>.</operator><name>normals</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>face</name><operator>.</operator><name>y</name></name></expr>, <expr><operator>-</operator><name><name>face</name><operator>.</operator><name>x</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newData</name><operator>.</operator><name>normals</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name> <operator>=</operator> <name>newData</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name> <operator>=</operator> <name>trans</name></expr>;</expr_stmt>


<expr_stmt><expr><name>center</name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>area</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inertia</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>p1</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextVertex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>p2</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextVertex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>D</name> <init>= <expr><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>triangleArea</name> <init>= <expr><name>D</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>area</name> <operator>+=</operator> <name>triangleArea</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name>triangleArea</name><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><operator>(</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>intx2</name> <init>= <expr><name><name>p1</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>p2</name><operator>.</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>inty2</name> <init>= <expr><name><name>p1</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>p2</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>p2</name><operator>.</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>inertia</name> <operator>+=</operator> <operator>(</operator><literal type="number">0.25f</literal><operator>*</operator><name>PHYSAC_K</name><operator>*</operator><name>D</name><operator>)</operator><operator>*</operator><operator>(</operator><name>intx2</name> <operator>+</operator> <name>inty2</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>center</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>center</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>area</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>mass</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>=</operator> <name>inertia</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newBody</name><operator>-&gt;</operator><name>inverseInertia</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name> <operator>!=</operator> <literal type="number">0.0f</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0f</literal><operator>/</operator><name><name>newBody</name><operator>-&gt;</operator><name>inertia</name></name></expr> </then><else>: <expr><literal type="number">0.0f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>pointA</name> <init>= <expr><name><name>newBody</name><operator>-&gt;</operator><name>position</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>pointB</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pointB</name><operator>.</operator><name>x</name></name> <operator>/=</operator> <literal type="number">2.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pointB</name><operator>.</operator><name>y</name></name> <operator>/=</operator> <literal type="number">2.0f</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>forceDirection</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><call><name>Vector2Add</name><argument_list>(<argument><expr><name>pointA</name></expr></argument>, <argument><expr><call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>newData</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pointB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>newBody</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>forceDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>forceDirection</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <name>force</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>forceDirection</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <name>force</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>PhysicsAddForce</name><argument_list>(<argument><expr><name>newBody</name></expr></argument>, <argument><expr><name>forceDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>PHYSAC_FREE</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error when trying to shatter a null reference physics body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsBodiesCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>physicsBodiesCount</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>PhysicsBody</name></type> <name>GetPhysicsBody</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>body</name> <operator>=</operator> <name><name>bodies</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error when trying to get a null reference physics body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics body index is out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>body</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsShapeType</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error when trying to get a null reference physics body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics body index is out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>int</name></type> <name>GetPhysicsShapeVerticesCount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>PHYSICS_CIRCLE</name></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <name>PHYSAC_CIRCLE_VERTICES</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>PHYSICS_POLYGON</name></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error when trying to get a null reference physics body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics body index is out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>Vector2</name></type> <name>GetPhysicsShapeVertex</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>position</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>PHYSICS_CIRCLE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name><name>position</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name> <operator>+</operator> <call><name>cosf</name><argument_list>(<argument><expr><literal type="number">360.0f</literal><operator>/</operator><name>PHYSAC_CIRCLE_VERTICES</name><operator>*</operator><name>vertex</name><operator>*</operator><name>PHYSAC_DEG2RAD</name></expr></argument>)</argument_list></call><operator>*</operator><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>position</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name> <operator>+</operator> <call><name>sinf</name><argument_list>(<argument><expr><literal type="number">360.0f</literal><operator>/</operator><name>PHYSAC_CIRCLE_VERTICES</name><operator>*</operator><name>vertex</name><operator>*</operator><name>PHYSAC_DEG2RAD</name></expr></argument>)</argument_list></call><operator>*</operator><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>PHYSICS_POLYGON</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>vertexData</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>vertex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error when trying to get a null reference physics body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>position</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsBodyRotation</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>orient</name></name> <operator>=</operator> <name>radians</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PHYSICS_POLYGON</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name> <operator>=</operator> <call><name>Mat2Radians</name><argument_list>(<argument><expr><name>radians</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>DestroyPhysicsBody</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>id</name> <operator>==</operator> <name>id</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] Not possible to find body id %i in pointers array\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return;</return> 
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>PHYSAC_FREE</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodies</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>bodies</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>physicsBodiesCount</name><operator>--</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] destroyed physics body id %i\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error trying to destroy a null referenced body\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>ResetPhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>physicsBodiesCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>PHYSAC_FREE</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsBodyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>physicsBodiesCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>physicsManifoldsCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>PHYSAC_FREE</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsManifoldData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>physicsManifoldsCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics module reset successfully\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>ClosePhysics</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>physicsThreadEnabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_NO_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>physicsThreadId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>physicsManifoldsCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DestroyPhysicsManifold</name><argument_list>(<argument><expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>physicsBodiesCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DestroyPhysicsBody</name><argument_list>(<argument><expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>physicsBodiesCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>usedMemory</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics module closed with %i still allocated bodies [MEMORY: %i bytes]\n"</literal></expr></argument>, <argument><expr><name>physicsBodiesCount</name></expr></argument>, <argument><expr><name>usedMemory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>physicsManifoldsCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>usedMemory</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics module closed with %i still allocated manifolds [MEMORY: %i bytes]\n"</literal></expr></argument>, <argument><expr><name>physicsManifoldsCount</name></expr></argument>, <argument><expr><name>usedMemory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics module closed successfully\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>FindAvailableBodyIndex</name><parameter_list>()</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PHYSAC_MAX_BODIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>currentId</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bodies</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>id</name> <operator>==</operator> <name>currentId</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>currentId</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>currentId</name> <operator>==</operator> <name>i</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PolygonData</name></type> <name>CreateRandomPolygon</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>data</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>vertexCount</name></name> <operator>=</operator> <name>sides</name></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name> <operator>=</operator> <call><name>cosf</name><argument_list>(<argument><expr><literal type="number">360.0f</literal><operator>/</operator><name>sides</name><operator>*</operator><name>i</name><operator>*</operator><name>PHYSAC_DEG2RAD</name></expr></argument>)</argument_list></call><operator>*</operator><name>radius</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name> <operator>=</operator> <call><name>sinf</name><argument_list>(<argument><expr><literal type="number">360.0f</literal><operator>/</operator><name>sides</name><operator>*</operator><name>i</name><operator>*</operator><name>PHYSAC_DEG2RAD</name></expr></argument>)</argument_list></call><operator>*</operator><name>radius</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>sides</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>face</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>face</name><operator>.</operator><name>y</name></name></expr>, <expr><operator>-</operator><name><name>face</name><operator>.</operator><name>x</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PolygonData</name></type> <name>CreateRectanglePolygon</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>data</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>vertexCount</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>pos</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>size</name><operator>.</operator><name>x</name></name><operator>/</operator><literal type="number">2</literal></expr>, <expr><name><name>pos</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>size</name><operator>.</operator><name>y</name></name><operator>/</operator><literal type="number">2</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>pos</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>size</name><operator>.</operator><name>x</name></name><operator>/</operator><literal type="number">2</literal></expr>, <expr><name><name>pos</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>size</name><operator>.</operator><name>y</name></name><operator>/</operator><literal type="number">2</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>pos</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>size</name><operator>.</operator><name>x</name></name><operator>/</operator><literal type="number">2</literal></expr>, <expr><name><name>pos</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>size</name><operator>.</operator><name>y</name></name><operator>/</operator><literal type="number">2</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>pos</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>size</name><operator>.</operator><name>x</name></name><operator>/</operator><literal type="number">2</literal></expr>, <expr><name><name>pos</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>size</name><operator>.</operator><name>y</name></name><operator>/</operator><literal type="number">2</literal></expr> }</block></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>face</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>face</name><operator>.</operator><name>y</name></name></expr>, <expr><operator>-</operator><name><name>face</name><operator>.</operator><name>x</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>PhysicsLoop</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_NO_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] physics thread created successfully\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>physicsThreadEnabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>physicsThreadEnabled</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>RunPhysicsStep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>PhysicsStep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>stepsCount</name><operator>++</operator></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>physicsManifoldsCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DestroyPhysicsManifold</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>isGrounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bodyA</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bodyB</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><call><name>CreatePhysicsManifold</name><argument_list>(<argument><expr><name>bodyA</name></expr></argument>, <argument><expr><name>bodyB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SolvePhysicsManifold</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>newManifold</name> <init>= <expr><call><name>CreatePhysicsManifold</name><argument_list>(<argument><expr><name>bodyA</name></expr></argument>, <argument><expr><name>bodyB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>restitution</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>staticFriction</name></name> <operator>=</operator> <name><name>manifold</name><operator>-&gt;</operator><name>staticFriction</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>IntegratePhysicsForces</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>InitializePhysicsManifolds</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PHYSAC_COLLISION_ITERATIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>IntegratePhysicsImpulses</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>IntegratePhysicsVelocity</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>manifold</name> <init>= <expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CorrectPhysicsPositions</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsBodiesCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>body</name> <init>= <expr><name><name>bodies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>body</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>torque</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>RunPhysicsStep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>currentTime</name> <operator>=</operator> <call><name>GetCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>delta</name> <init>= <expr><name>currentTime</name> <operator>-</operator> <name>startTime</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>accumulator</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>accumulator</name> <operator>&gt;=</operator> <name>deltaTime</name></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PhysicsStep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accumulator</name> <operator>-=</operator> <name>deltaTime</name></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><name>startTime</name> <operator>=</operator> <name>currentTime</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PHYSACDEF</name> <name>void</name></type> <name>SetPhysicsTimeStep</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>delta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>deltaTime</name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>FindAvailableManifoldIndex</name><parameter_list>()</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PHYSAC_MAX_MANIFOLDS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>currentId</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>contacts</name><index>[<expr><name>k</name></expr>]</index></name><operator>-&gt;</operator><name>id</name> <operator>==</operator> <name>currentId</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>currentId</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>currentId</name> <operator>==</operator> <name>i</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PhysicsManifold</name></type> <name>CreatePhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>PhysicsBody</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsManifold</name></type> <name>newManifold</name> <init>= <expr><operator>(</operator><name>PhysicsManifold</name><operator>)</operator><call><name>PHYSAC_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsManifoldData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsManifoldData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newId</name> <init>= <expr><call><name>FindAvailableManifoldIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>newId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>bodyA</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>bodyB</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newManifold</name><operator>-&gt;</operator><name>staticFriction</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>contacts</name><index>[<expr><name>physicsManifoldsCount</name></expr>]</index></name> <operator>=</operator> <name>newManifold</name></expr>;</expr_stmt>
<expr_stmt><expr><name>physicsManifoldsCount</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] new physics manifold creation failed because there is any available id to use\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>newManifold</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>DestroyPhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>manifold</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>id</name> <operator>==</operator> <name>id</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] Not possible to manifold id %i in pointers array\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return;</return> 
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>PHYSAC_FREE</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>usedMemory</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PhysicsManifoldData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>contacts</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>physicsManifoldsCount</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>contacts</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>physicsManifoldsCount</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>TRACELOG</name><argument_list>(<argument><expr><literal type="string">"[PHYSAC] error trying to destroy a null referenced manifold\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SolvePhysicsManifold</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>PHYSICS_CIRCLE</name></expr>:</case>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>PHYSICS_CIRCLE</name></expr>:</case> <expr_stmt><expr><call><name>SolveCircleToCircle</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>PHYSICS_POLYGON</name></expr>:</case> <expr_stmt><expr><call><name>SolveCircleToPolygon</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>PHYSICS_POLYGON</name></expr>:</case>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>type</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>PHYSICS_CIRCLE</name></expr>:</case> <expr_stmt><expr><call><name>SolvePolygonToCircle</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>PHYSICS_POLYGON</name></expr>:</case> <expr_stmt><expr><call><name>SolvePolygonToPolygon</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name><operator>-&gt;</operator><name>isGrounded</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name><operator>-&gt;</operator><name>isGrounded</name></name> <operator>=</operator> <operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SolveCircleToCircle</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>distSqr</name> <init>= <expr><call><name>MathLenSqr</name><argument_list>(<argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>radius</name> <init>= <expr><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>distSqr</name> <operator>&gt;=</operator> <name>radius</name><operator>*</operator><name>radius</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>distance</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><name>distSqr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>distance</name> <operator>==</operator> <literal type="number">0.0f</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><literal type="number">1.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <name>radius</name> <operator>-</operator> <name>distance</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>normal</name><operator>.</operator><name>x</name></name><operator>/</operator><name>distance</name></expr>, <expr><name><name>normal</name><operator>.</operator><name>y</name></name><operator>/</operator><name>distance</name></expr> }</block></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name></expr>, <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bodyA</name><operator>-&gt;</operator><name>isGrounded</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>isGrounded</name></name> <operator>=</operator> <operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SolveCircleToPolygon</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>center</name> <init>= <expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>center</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><call><name>Mat2Transpose</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>float</name></type> <name>separation</name> <init>= <expr><operator>-</operator><name>PHYSAC_FLT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>faceNormal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>vertexData</name> <init>= <expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vertexData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>currentSeparation</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name><name>vertexData</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>currentSeparation</name> <operator>&gt;</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>currentSeparation</name> <operator>&gt;</operator> <name>separation</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>separation</name> <operator>=</operator> <name>currentSeparation</name></expr>;</expr_stmt>
<expr_stmt><expr><name>faceNormal</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<decl_stmt><decl><type><name>Vector2</name></type> <name>v1</name> <init>= <expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>faceNormal</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextIndex</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>faceNormal</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>vertexData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>faceNormal</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>v2</name> <init>= <expr><name><name>vertexData</name><operator>.</operator><name>positions</name><index>[<expr><name>nextIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>separation</name> <operator>&lt;</operator> <name>PHYSAC_EPSILON</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name><name>vertexData</name><operator>.</operator><name>normals</name><index>[<expr><name>faceNormal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><operator>-</operator><name><name>normal</name><operator>.</operator><name>x</name></name></expr>, <expr><operator>-</operator><name><name>normal</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name></expr>, <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>dot1</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>dot2</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>-</operator> <name>separation</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dot1</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>DistSqr</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>normal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <name>normal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>dot2</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>DistSqr</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>normal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <name>normal</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><name><name>vertexData</name><operator>.</operator><name>normals</name><index>[<expr><name>faceNormal</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MathDot</name><argument_list>(<argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>normal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><operator>-</operator><name><name>normal</name><operator>.</operator><name>x</name></name></expr>, <expr><operator>-</operator><name><name>normal</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name></expr>, <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>radius</name></name> <operator>+</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SolvePolygonToCircle</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name> <operator>=</operator> <name>bodyB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name> <operator>=</operator> <name>bodyA</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SolveCircleToPolygon</name><argument_list>(<argument><expr><name>manifold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <operator>-</operator><literal type="number">1.0f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <operator>-</operator><literal type="number">1.0f</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SolvePolygonToPolygon</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PhysicsShape</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name><operator>-&gt;</operator><name>shape</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsShape</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name><operator>-&gt;</operator><name>shape</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>faceA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>penetrationA</name> <init>= <expr><call><name>FindAxisLeastPenetration</name><argument_list>(<argument><expr><operator>&amp;</operator><name>faceA</name></expr></argument>, <argument><expr><name>bodyA</name></expr></argument>, <argument><expr><name>bodyB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>penetrationA</name> <operator>&gt;=</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>faceB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>penetrationB</name> <init>= <expr><call><name>FindAxisLeastPenetration</name><argument_list>(<argument><expr><operator>&amp;</operator><name>faceB</name></expr></argument>, <argument><expr><name>bodyB</name></expr></argument>, <argument><expr><name>bodyA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>penetrationB</name> <operator>&gt;=</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>referenceIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>flip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>PhysicsShape</name></type> <name>refPoly</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PhysicsShape</name></type> <name>incPoly</name></decl>;</decl_stmt> 


<if_stmt><if>if <condition>(<expr><call><name>BiasGreaterThan</name><argument_list>(<argument><expr><name>penetrationA</name></expr></argument>, <argument><expr><name>penetrationB</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>refPoly</name> <operator>=</operator> <name>bodyA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incPoly</name> <operator>=</operator> <name>bodyB</name></expr>;</expr_stmt>
<expr_stmt><expr><name>referenceIndex</name> <operator>=</operator> <name>faceA</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>refPoly</name> <operator>=</operator> <name>bodyB</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incPoly</name> <operator>=</operator> <name>bodyA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>referenceIndex</name> <operator>=</operator> <name>faceB</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name><name>incidentFace</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FindIncidentFace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>incidentFace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>incidentFace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>refPoly</name></expr></argument>, <argument><expr><name>incPoly</name></expr></argument>, <argument><expr><name>referenceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>PolygonData</name></type> <name>refData</name> <init>= <expr><name><name>refPoly</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>v1</name> <init>= <expr><name><name>refData</name><operator>.</operator><name>positions</name><index>[<expr><name>referenceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>referenceIndex</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>referenceIndex</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>refData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>referenceIndex</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>v2</name> <init>= <expr><name><name>refData</name><operator>.</operator><name>positions</name><index>[<expr><name>referenceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>refPoly</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name><name>refPoly</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>refPoly</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name><name>refPoly</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>sidePlaneNormal</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sidePlaneNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>refFaceNormal</name> <init>= <expr><block>{ <expr><name><name>sidePlaneNormal</name><operator>.</operator><name>y</name></name></expr>, <expr><operator>-</operator><name><name>sidePlaneNormal</name><operator>.</operator><name>x</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>refC</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>refFaceNormal</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>negSide</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>sidePlaneNormal</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call><operator>*</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>posSide</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>sidePlaneNormal</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><macro><name>Clip</name><argument_list>(<argument>(Vector2){ -sidePlaneNormal.x</argument>, <argument>-sidePlaneNormal.y }</argument>, <argument>negSide</argument>, <argument>&amp;incidentFace[<literal type="number">0</literal>]</argument>, <argument>&amp;incidentFace[<literal type="number">1</literal>]</argument>)</argument_list></macro> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Clip</name><argument_list>(<argument><expr><name>sidePlaneNormal</name></expr></argument>, <argument><expr><name>posSide</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>incidentFace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>incidentFace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>flip</name></expr> ?</condition><then> <expr><operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><operator>-</operator><name><name>refFaceNormal</name><operator>.</operator><name>x</name></name></expr>, <expr><operator>-</operator><name><name>refFaceNormal</name><operator>.</operator><name>y</name></name></expr> }</block></expr> </then><else>: <expr><name>refFaceNormal</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>currentPoint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float</name></type> <name>separation</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>refFaceNormal</name></expr></argument>, <argument><expr><name><name>incidentFace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>refC</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>separation</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>currentPoint</name></expr>]</index></name> <operator>=</operator> <name><name>incidentFace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <operator>-</operator><name>separation</name></expr>;</expr_stmt>
<expr_stmt><expr><name>currentPoint</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>separation</name> <operator>=</operator> <call><name>MathDot</name><argument_list>(<argument><expr><name>refFaceNormal</name></expr></argument>, <argument><expr><name><name>incidentFace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>refC</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>separation</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>currentPoint</name></expr>]</index></name> <operator>=</operator> <name><name>incidentFace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>+=</operator> <operator>-</operator><name>separation</name></expr>;</expr_stmt>
<expr_stmt><expr><name>currentPoint</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>/=</operator> <name>currentPoint</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name> <operator>=</operator> <name>currentPoint</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsForces</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>body</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>==</operator> <literal type="number">0.0f</literal><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>force</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>body</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name>deltaTime</name><operator>/</operator><literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>force</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>body</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name>deltaTime</name><operator>/</operator><literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>useGravity</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>gravityForce</name><operator>.</operator><name>x</name></name><operator>*</operator><operator>(</operator><name>deltaTime</name><operator>/</operator><literal type="number">1000</literal><operator>/</operator><literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>gravityForce</name><operator>.</operator><name>y</name></name><operator>*</operator><operator>(</operator><name>deltaTime</name><operator>/</operator><literal type="number">1000</literal><operator>/</operator><literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>torque</name></name><operator>*</operator><name><name>body</name><operator>-&gt;</operator><name>inverseInertia</name></name><operator>*</operator><operator>(</operator><name>deltaTime</name><operator>/</operator><literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>InitializePhysicsManifolds</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>restitution</name></name><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>restitution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>staticFriction</name></name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>staticFriction</name></name><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>staticFriction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>dynamicFriction</name></name><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>dynamicFriction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusA</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusB</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>crossA</name> <init>= <expr><call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>crossB</name> <init>= <expr><call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusV</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>crossB</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>crossA</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>crossB</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>crossA</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>MathLenSqr</name><argument_list>(<argument><expr><name>radiusV</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><macro><name>MathLenSqr</name><argument_list>(<argument>(Vector2){ gravityForce.x*deltaTime/<literal type="number">1000</literal></argument>, <argument>gravityForce.y*deltaTime/<literal type="number">1000</literal> }</argument>)</argument_list></macro> <operator>+</operator> <name>PHYSAC_EPSILON</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>manifold</name><operator>-&gt;</operator><name>restitution</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsImpulses</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>+</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>PHYSAC_EPSILON</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name></name> <operator>=</operator> <name>PHYSAC_VECTOR_ZERO</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusA</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusB</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>contacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>radiusV</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusB</name></expr></argument>)</argument_list></call><operator>.</operator><name>x</name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>-</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusA</name></expr></argument>)</argument_list></call><operator>.</operator><name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusB</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>-</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusA</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>contactVelocity</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>radiusV</name></expr></argument>, <argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>contactVelocity</name> <operator>&gt;</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>raCrossN</name> <init>= <expr><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>radiusA</name></expr></argument>, <argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>rbCrossN</name> <init>= <expr><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>radiusB</name></expr></argument>, <argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>inverseMassSum</name> <init>= <expr><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>+</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>+</operator> <operator>(</operator><name>raCrossN</name><operator>*</operator><name>raCrossN</name><operator>)</operator><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseInertia</name></name> <operator>+</operator> <operator>(</operator><name>rbCrossN</name><operator>*</operator><name>rbCrossN</name><operator>)</operator><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>inverseInertia</name></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>impulse</name> <init>= <expr><operator>-</operator><operator>(</operator><literal type="number">1.0f</literal> <operator>+</operator> <name><name>manifold</name><operator>-&gt;</operator><name>restitution</name></name><operator>)</operator><operator>*</operator><name>contactVelocity</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>impulse</name> <operator>/=</operator> <name>inverseMassSum</name></expr>;</expr_stmt>
<expr_stmt><expr><name>impulse</name> <operator>/=</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>impulseV</name> <init>= <expr><block>{ <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><name>impulse</name></expr>, <expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><name>impulse</name></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bodyA</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><operator>-</operator><name><name>impulseV</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><operator>-</operator><name><name>impulseV</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bodyA</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseInertia</name></name><operator>*</operator><macro><name>MathCrossVector2</name><argument_list>(<argument>radiusA</argument>, <argument>(Vector2){ -impulseV.x</argument>, <argument>-impulseV.y }</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bodyB</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><name><name>impulseV</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><name><name>impulseV</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bodyB</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseInertia</name></name><operator>*</operator><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>radiusB</name></expr></argument>, <argument><expr><name>impulseV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusB</name></expr></argument>)</argument_list></call><operator>.</operator><name>x</name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>-</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusA</name></expr></argument>)</argument_list></call><operator>.</operator><name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>radiusV</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusB</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name> <operator>-</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>-</operator> <call><name>MathCross</name><argument_list>(<argument><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name></expr></argument>, <argument><expr><name>radiusA</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>tangent</name> <init>= <expr><block>{ <expr><name><name>radiusV</name><operator>.</operator><name>x</name></name> <operator>-</operator> <operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><call><name>MathDot</name><argument_list>(<argument><expr><name>radiusV</name></expr></argument>, <argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>, <expr><name><name>radiusV</name><operator>.</operator><name>y</name></name> <operator>-</operator> <operator>(</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><call><name>MathDot</name><argument_list>(<argument><expr><name>radiusV</name></expr></argument>, <argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MathNormalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tangent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>impulseTangent</name> <init>= <expr><operator>-</operator><call><name>MathDot</name><argument_list>(<argument><expr><name>radiusV</name></expr></argument>, <argument><expr><name>tangent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>impulseTangent</name> <operator>/=</operator> <name>inverseMassSum</name></expr>;</expr_stmt>
<expr_stmt><expr><name>impulseTangent</name> <operator>/=</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>manifold</name><operator>-&gt;</operator><name>contactsCount</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>absImpulseTangent</name> <init>= <expr><call><name>fabs</name><argument_list>(<argument><expr><name>impulseTangent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>absImpulseTangent</name> <operator>&lt;=</operator> <name>PHYSAC_EPSILON</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>tangentImpulse</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>absImpulseTangent</name> <operator>&lt;</operator> <name>impulse</name><operator>*</operator><name><name>manifold</name><operator>-&gt;</operator><name>staticFriction</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tangentImpulse</name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>tangent</name><operator>.</operator><name>x</name></name><operator>*</operator><name>impulseTangent</name></expr>, <expr><name><name>tangent</name><operator>.</operator><name>y</name></name><operator>*</operator><name>impulseTangent</name></expr> }</block></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>tangentImpulse</name> <operator>=</operator> <operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>tangent</name><operator>.</operator><name>x</name></name><operator>*</operator><operator>-</operator><name>impulse</name><operator>*</operator><name><name>manifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name></expr>, <expr><name><name>tangent</name><operator>.</operator><name>y</name></name><operator>*</operator><operator>-</operator><name>impulse</name><operator>*</operator><name><name>manifold</name><operator>-&gt;</operator><name>dynamicFriction</name></name></expr> }</block></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>bodyA</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><operator>-</operator><name><name>tangentImpulse</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><operator>-</operator><name><name>tangentImpulse</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bodyA</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>+=</operator> <name><name>bodyA</name><operator>-&gt;</operator><name>inverseInertia</name></name><operator>*</operator><macro><name>MathCrossVector2</name><argument_list>(<argument>radiusA</argument>, <argument>(Vector2){ -tangentImpulse.x</argument>, <argument>-tangentImpulse.y }</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bodyB</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><name><name>tangentImpulse</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>*</operator><operator>(</operator><name><name>tangentImpulse</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bodyB</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>angularVelocity</name></name> <operator>+=</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseInertia</name></name><operator>*</operator><call><name>MathCrossVector2</name><argument_list>(<argument><expr><name>radiusB</name></expr></argument>, <argument><expr><name>tangentImpulse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>IntegratePhysicsVelocity</name><parameter_list>(<parameter><decl><type><name>PhysicsBody</name></type> <name>body</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>body</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator><operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>x</name></name><operator>*</operator><name>deltaTime</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>velocity</name><operator>.</operator><name>y</name></name><operator>*</operator><name>deltaTime</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>freezeOrient</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>orient</name></name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>angularVelocity</name></name><operator>*</operator><name>deltaTime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Mat2Set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>shape</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>orient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IntegratePhysicsForces</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>CorrectPhysicsPositions</name><parameter_list>(<parameter><decl><type><name>PhysicsManifold</name></type> <name>manifold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyA</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyA</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PhysicsBody</name></type> <name>bodyB</name> <init>= <expr><name><name>manifold</name><operator>-&gt;</operator><name>bodyB</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bodyA</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bodyB</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>correction</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>correction</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><call><name>max</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>-</operator> <name>PHYSAC_PENETRATION_ALLOWANCE</name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call><operator>/</operator><operator>(</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>+</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>)</operator><operator>)</operator><operator>*</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>x</name></name><operator>*</operator><name>PHYSAC_PENETRATION_CORRECTION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>correction</name><operator>.</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><call><name>max</name><argument_list>(<argument><expr><name><name>manifold</name><operator>-&gt;</operator><name>penetration</name></name> <operator>-</operator> <name>PHYSAC_PENETRATION_ALLOWANCE</name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call><operator>/</operator><operator>(</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name> <operator>+</operator> <name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name><operator>)</operator><operator>)</operator><operator>*</operator><name><name>manifold</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>y</name></name><operator>*</operator><name>PHYSAC_PENETRATION_CORRECTION</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bodyA</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name> <operator>-=</operator> <name><name>correction</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyA</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name> <operator>-=</operator> <name><name>correction</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>bodyA</name><operator>-&gt;</operator><name>inverseMass</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bodyB</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>x</name></name> <operator>+=</operator> <name><name>correction</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bodyB</name><operator>-&gt;</operator><name>position</name><operator>.</operator><name>y</name></name> <operator>+=</operator> <name><name>correction</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>bodyB</name><operator>-&gt;</operator><name>inverseMass</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Vector2</name></type> <name>GetSupport</name><parameter_list>(<parameter><decl><type><name>PhysicsShape</name></type> <name>shape</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>bestProjection</name> <init>= <expr><operator>-</operator><name>PHYSAC_FLT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>bestVertex</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>data</name> <init>= <expr><name><name>shape</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>vertex</name> <init>= <expr><name><name>data</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>projection</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>projection</name> <operator>&gt;</operator> <name>bestProjection</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>bestVertex</name> <operator>=</operator> <name>vertex</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bestProjection</name> <operator>=</operator> <name>projection</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>bestVertex</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>float</name></type> <name>FindAxisLeastPenetration</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>faceIndex</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>shapeA</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>shapeB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>bestDistance</name> <init>= <expr><operator>-</operator><name>PHYSAC_FLT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bestIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PolygonData</name></type> <name>dataA</name> <init>= <expr><name><name>shapeA</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dataA</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>

<decl_stmt><decl><type><name>Vector2</name></type> <name>normal</name> <init>= <expr><name><name>dataA</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>transNormal</name> <init>= <expr><call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>shapeA</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Matrix2x2</name></type> <name>buT</name> <init>= <expr><call><name>Mat2Transpose</name><argument_list>(<argument><expr><name><name>shapeB</name><operator>.</operator><name>transform</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>normal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name>buT</name></expr></argument>, <argument><expr><name>transNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>support</name> <init>= <macro><name>GetSupport</name><argument_list>(<argument>shapeB</argument>, <argument>(Vector2){ -normal.x</argument>, <argument>-normal.y }</argument>)</argument_list></macro></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Vector2</name></type> <name>vertex</name> <init>= <expr><name><name>dataA</name><operator>.</operator><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>shapeA</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name><name>shapeA</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name><name>shapeB</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name>buT</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>distance</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>normal</name></expr></argument>, <argument><expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>support</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&gt;</operator> <name>bestDistance</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>bestDistance</name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bestIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>faceIndex</name> <operator>=</operator> <name>bestIndex</name></expr>;</expr_stmt>
<return>return <expr><name>bestDistance</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>FindIncidentFace</name><parameter_list>(<parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>v0</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>PhysicsShape</name></type> <name>inc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>refData</name> <init>= <expr><name><name>ref</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PolygonData</name></type> <name>incData</name> <init>= <expr><name><name>inc</name><operator>.</operator><name>vertexData</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>referenceNormal</name> <init>= <expr><name><name>refData</name><operator>.</operator><name>normals</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>referenceNormal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>ref</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name>referenceNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>referenceNormal</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><call><name>Mat2Transpose</name><argument_list>(<argument><expr><name><name>inc</name><operator>.</operator><name>transform</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>referenceNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>incidentFace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minDot</name> <init>= <expr><name>PHYSAC_FLT_MAX</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>incData</name><operator>.</operator><name>vertexCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>dot</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>referenceNormal</name></expr></argument>, <argument><expr><name><name>incData</name><operator>.</operator><name>normals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dot</name> <operator>&lt;</operator> <name>minDot</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>minDot</name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incidentFace</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>*</operator><name>v0</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>inc</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name><name>incData</name><operator>.</operator><name>positions</name><index>[<expr><name>incidentFace</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v0</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><operator>*</operator><name>v0</name></expr></argument>, <argument><expr><name><name>inc</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>incidentFace</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>incidentFace</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>incData</name><operator>.</operator><name>vertexCount</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>incidentFace</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v1</name> <operator>=</operator> <call><name>Mat2MultiplyVector2</name><argument_list>(<argument><expr><name><name>inc</name><operator>.</operator><name>transform</name></name></expr></argument>, <argument><expr><name><name>incData</name><operator>.</operator><name>positions</name><index>[<expr><name>incidentFace</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v1</name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><operator>*</operator><name>v1</name></expr></argument>, <argument><expr><name><name>inc</name><operator>.</operator><name>body</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>Clip</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>normal</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>clip</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>faceA</name></decl></parameter>, <parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>faceB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name><name>out</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><operator>*</operator><name>faceA</name></expr>, <expr><operator>*</operator><name>faceB</name></expr> }</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>float</name></type> <name>distanceA</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>normal</name></expr></argument>, <argument><expr><operator>*</operator><name>faceA</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>clip</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>distanceB</name> <init>= <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>normal</name></expr></argument>, <argument><expr><operator>*</operator><name>faceB</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>clip</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>distanceA</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>out</name><index>[<expr><name>sp</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>faceA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>distanceB</name> <operator>&lt;=</operator> <literal type="number">0.0f</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>out</name><index>[<expr><name>sp</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>faceB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>distanceA</name><operator>*</operator><name>distanceB</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0.0f</literal></expr>)</condition>
<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>alpha</name> <init>= <expr><name>distanceA</name><operator>/</operator><operator>(</operator><name>distanceA</name> <operator>-</operator> <name>distanceB</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>sp</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>faceA</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vector2</name></type> <name>delta</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><operator>*</operator><name>faceB</name></expr></argument>, <argument><expr><operator>*</operator><name>faceA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>delta</name><operator>.</operator><name>x</name></name> <operator>*=</operator> <name>alpha</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>delta</name><operator>.</operator><name>y</name></name> <operator>*=</operator> <name>alpha</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>sp</name></expr>]</index></name> <operator>=</operator> <call><name>Vector2Add</name><argument_list>(<argument><expr><name><name>out</name><index>[<expr><name>sp</name></expr>]</index></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>faceA</name> <operator>=</operator> <name><name>out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>faceB</name> <operator>=</operator> <name><name>out</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name>sp</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>BiasGreaterThan</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>valueA</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>valueB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>valueA</name> <operator>&gt;=</operator> <operator>(</operator><name>valueB</name><operator>*</operator><literal type="number">0.95f</literal> <operator>+</operator> <name>valueA</name><operator>*</operator><literal type="number">0.01f</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Vector2</name></type> <name>TriangleBarycenter</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>result</name> <init>= <expr><block>{ <expr><literal type="number">0.0f</literal></expr>, <expr><literal type="number">0.0f</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>result</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>v1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>v2</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>v3</name><operator>.</operator><name>x</name></name><operator>)</operator><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>.</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name><name>v1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>v2</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>v3</name><operator>.</operator><name>y</name></name><operator>)</operator><operator>/</operator><literal type="number">3</literal></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>InitTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>frequency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>now</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>frequency</name> <operator>=</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>mach_timebase_info_data_t</name></type> <name>timebase</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>mach_timebase_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timebase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>frequency</name> <operator>=</operator> <operator>(</operator><name><name>timebase</name><operator>.</operator><name>denom</name></name><operator>*</operator><literal type="number">1e9</literal><operator>)</operator><operator>/</operator><name><name>timebase</name><operator>.</operator><name>numer</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>baseTime</name> <operator>=</operator> <call><name>GetTimeCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>startTime</name> <operator>=</operator> <call><name>GetCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>long</name> <name>int</name></type> <name>GetTimeCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>now</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name><operator>)</operator><name><name>now</name><operator>.</operator><name>tv_sec</name></name><operator>*</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name><operator>)</operator><literal type="number">1000000000</literal> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <name>int</name><operator>)</operator><name><name>now</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>mach_absolute_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>double</name></type> <name>GetCurrentTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><call><name>GetTimeCount</name><argument_list>()</argument_list></call> <operator>-</operator> <name>baseTime</name><operator>)</operator><operator>/</operator><name>frequency</name><operator>*</operator><literal type="number">1000</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Vector2</name></type> <name>MathCross</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><operator>-</operator><name>value</name><operator>*</operator><name><name>vector</name><operator>.</operator><name>y</name></name></expr>, <expr><name>value</name><operator>*</operator><name><name>vector</name><operator>.</operator><name>x</name></name></expr> }</block></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>MathCrossVector2</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>v1</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>v2</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>v1</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>v2</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>MathLenSqr</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>vector</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>vector</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>MathDot</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>v1</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>v2</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>v1</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>v2</name><operator>.</operator><name>y</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>DistSqr</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector2</name></type> <name>dir</name> <init>= <expr><call><name>Vector2Subtract</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>MathDot</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>MathNormalize</name><parameter_list>(<parameter><decl><type><name>Vector2</name> <modifier>*</modifier></type><name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>ilength</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vector2</name></type> <name>aux</name> <init>= <expr><operator>*</operator><name>vector</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name><name>aux</name><operator>.</operator><name>x</name></name><operator>*</operator><name><name>aux</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>aux</name><operator>.</operator><name>y</name></name><operator>*</operator><name><name>aux</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ilength</name> <operator>=</operator> <literal type="number">1.0f</literal><operator>/</operator><name>length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vector</name><operator>-&gt;</operator><name>x</name></name> <operator>*=</operator> <name>ilength</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vector</name><operator>-&gt;</operator><name>y</name></name> <operator>*=</operator> <name>ilength</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHYSAC_STANDALONE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Vector2</name></type> <name>Vector2Add</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>v1</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>v2</name><operator>.</operator><name>x</name></name></expr>, <expr><name><name>v1</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>v2</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Vector2</name></type> <name>Vector2Subtract</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>v1</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>v2</name><operator>.</operator><name>x</name></name></expr>, <expr><name><name>v1</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>v2</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>Matrix2x2</name></type> <name>Mat2Radians</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>c</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>radians</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>s</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>radians</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>Matrix2x2</name><operator>)</operator><block>{ <expr><name>c</name></expr>, <expr><operator>-</operator><name>s</name></expr>, <expr><name>s</name></expr>, <expr><name>c</name></expr> }</block></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>Mat2Set</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name> <modifier>*</modifier></type><name>matrix</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>radians</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>cos</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>radians</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>sin</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>radians</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>matrix</name><operator>-&gt;</operator><name>m00</name></name> <operator>=</operator> <name>cos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matrix</name><operator>-&gt;</operator><name>m01</name></name> <operator>=</operator> <operator>-</operator><name>sin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matrix</name><operator>-&gt;</operator><name>m10</name></name> <operator>=</operator> <name>sin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matrix</name><operator>-&gt;</operator><name>m11</name></name> <operator>=</operator> <name>cos</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Matrix2x2</name></type> <name>Mat2Transpose</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name></type> <name>matrix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>Matrix2x2</name><operator>)</operator><block>{ <expr><name><name>matrix</name><operator>.</operator><name>m00</name></name></expr>, <expr><name><name>matrix</name><operator>.</operator><name>m10</name></name></expr>, <expr><name><name>matrix</name><operator>.</operator><name>m01</name></name></expr>, <expr><name><name>matrix</name><operator>.</operator><name>m11</name></name></expr> }</block></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Vector2</name></type> <name>Mat2MultiplyVector2</name><parameter_list>(<parameter><decl><type><name>Matrix2x2</name></type> <name>matrix</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>Vector2</name><operator>)</operator><block>{ <expr><name><name>matrix</name><operator>.</operator><name>m00</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>matrix</name><operator>.</operator><name>m01</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>y</name></name></expr>, <expr><name><name>matrix</name><operator>.</operator><name>m10</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>matrix</name><operator>.</operator><name>m11</name></name><operator>*</operator><name><name>vector</name><operator>.</operator><name>y</name></name></expr> }</block></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
