<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\libtomcrypt-analysis\_cppstats\libtomcrypt\src\headers\tomcrypt_macros.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENDIAN_NEUTRAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[3] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[0] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = ((ulong32)((y)[3] &amp; 255)&lt;&lt;24) | ((ulong32)((y)[2] &amp; 255)&lt;&lt;16) | ((ulong32)((y)[1] &amp; 255)&lt;&lt;8) | ((ulong32)((y)[0] &amp; 255)); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[7] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[0] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[7] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[6] &amp; 255))&lt;&lt;48)| (((ulong64)((y)[5] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[4] &amp; 255))&lt;&lt;32)| (((ulong64)((y)[3] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[2] &amp; 255))&lt;&lt;16)| (((ulong64)((y)[1] &amp; 255))&lt;&lt;8)|(((ulong64)((y)[0] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[0] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[3] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = ((ulong32)((y)[0] &amp; 255)&lt;&lt;24) | ((ulong32)((y)[1] &amp; 255)&lt;&lt;16) | ((ulong32)((y)[2] &amp; 255)&lt;&lt;8) | ((ulong32)((y)[3] &amp; 255)); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[0] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[7] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[0] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[1] &amp; 255))&lt;&lt;48) | (((ulong64)((y)[2] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[3] &amp; 255))&lt;&lt;32) | (((ulong64)((y)[4] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[5] &amp; 255))&lt;&lt;16) | (((ulong64)((y)[6] &amp; 255))&lt;&lt;8)|(((ulong64)((y)[7] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENDIAN_LITTLE</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_HAVE_BSWAP_BUILTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong32 __t = __builtin_bswap32 ((x)); XMEMCPY ((y), &amp;__t, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY (&amp;(x), (y), 4); (x) = __builtin_bswap32 ((x)); } while(0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_BSWAP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>INTEL_CC</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__DJGPP__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>asm __volatile__ ( "bswapl %0 \n\t" "movl %0,(%1)\n\t" "bswapl %0 \n\t" ::"r"(x), "r"(y));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>asm __volatile__ ( "movl (%1),%0\n\t" "bswapl %0\n\t" :"=r"(x): "r"(y));</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[0] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[3] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = ((ulong32)((y)[0] &amp; 255)&lt;&lt;24) | ((ulong32)((y)[1] &amp; 255)&lt;&lt;16) | ((ulong32)((y)[2] &amp; 255)&lt;&lt;8) | ((ulong32)((y)[3] &amp; 255)); } while(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_HAVE_BSWAP_BUILTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong64 __t = __builtin_bswap64 ((x)); XMEMCPY ((y), &amp;__t, 8); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY (&amp;(x), (y), 8); (x) = __builtin_bswap64 ((x)); } while(0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_BSWAP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>asm __volatile__ ( "bswapq %0 \n\t" "movq %0,(%1)\n\t" "bswapq %0 \n\t" ::"r"(x), "r"(y): "memory");</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>asm __volatile__ ( "movq (%1),%0\n\t" "bswapq %0\n\t" :"=r"(x): "r"(y): "memory");</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[0] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[7] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[0] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[1] &amp; 255))&lt;&lt;48) | (((ulong64)((y)[2] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[3] &amp; 255))&lt;&lt;32) | (((ulong64)((y)[4] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[5] &amp; 255))&lt;&lt;16) | (((ulong64)((y)[6] &amp; 255))&lt;&lt;8)|(((ulong64)((y)[7] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENDIAN_32BITWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong32 __t = (x); XMEMCPY(y, &amp;__t, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[7] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[0] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[7] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[6] &amp; 255))&lt;&lt;48)| (((ulong64)((y)[5] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[4] &amp; 255))&lt;&lt;32)| (((ulong64)((y)[3] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[2] &amp; 255))&lt;&lt;16)| (((ulong64)((y)[1] &amp; 255))&lt;&lt;8)|(((ulong64)((y)[0] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong32 __t = (x); XMEMCPY(y, &amp;__t, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 4); x &amp;= 0xFFFFFFFF; } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong64 __t = (x); XMEMCPY(y, &amp;__t, 8); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 8); } while(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENDIAN_BIG</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[3] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[0] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = ((ulong32)((y)[3] &amp; 255)&lt;&lt;24) | ((ulong32)((y)[2] &amp; 255)&lt;&lt;16) | ((ulong32)((y)[1] &amp; 255)&lt;&lt;8) | ((ulong32)((y)[0] &amp; 255)); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[7] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[0] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[7] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[6] &amp; 255))&lt;&lt;48) | (((ulong64)((y)[5] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[4] &amp; 255))&lt;&lt;32) | (((ulong64)((y)[3] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[2] &amp; 255))&lt;&lt;16) | (((ulong64)((y)[1] &amp; 255))&lt;&lt;8)|(((ulong64)((y)[0] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENDIAN_32BITWORD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong32 __t = (x); XMEMCPY(y, &amp;__t, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (y)[0] = (unsigned char)(((x)&gt;&gt;56)&amp;255); (y)[1] = (unsigned char)(((x)&gt;&gt;48)&amp;255); (y)[2] = (unsigned char)(((x)&gt;&gt;40)&amp;255); (y)[3] = (unsigned char)(((x)&gt;&gt;32)&amp;255); (y)[4] = (unsigned char)(((x)&gt;&gt;24)&amp;255); (y)[5] = (unsigned char)(((x)&gt;&gt;16)&amp;255); (y)[6] = (unsigned char)(((x)&gt;&gt;8)&amp;255); (y)[7] = (unsigned char)((x)&amp;255); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { x = (((ulong64)((y)[0] &amp; 255))&lt;&lt;56)|(((ulong64)((y)[1] &amp; 255))&lt;&lt;48)| (((ulong64)((y)[2] &amp; 255))&lt;&lt;40)|(((ulong64)((y)[3] &amp; 255))&lt;&lt;32)| (((ulong64)((y)[4] &amp; 255))&lt;&lt;24)|(((ulong64)((y)[5] &amp; 255))&lt;&lt;16)| (((ulong64)((y)[6] &amp; 255))&lt;&lt;8)| (((ulong64)((y)[7] &amp; 255))); } while(0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong32 __t = (x); XMEMCPY(y, &amp;__t, 4); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD32H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 4); x &amp;= 0xFFFFFFFF; } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ulong64 __t = (x); XMEMCPY(y, &amp;__t, 8); } while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD64H</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { XMEMCPY(&amp;(x), y, 8); } while(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BSWAP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((x&gt;&gt;24)&amp;0x000000FFUL) | ((x&lt;&lt;24)&amp;0xFF000000UL) | ((x&gt;&gt;8)&amp;0x0000FF00UL) | ((x&lt;&lt;8)&amp;0x00FF0000UL) )</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTC_ROx_BUILTIN</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_rotr</name><name>,</name><name>_rotl</name><name>)</name></cpp:pragma>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_rotr(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_rotl(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROR(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROL(x,n)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_HAVE_ROTATE_BUILTIN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTC_ROx_BUILTIN</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_rotateright32(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_rotateleft32(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROL(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROR(x,n)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STRICT_ANSI__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INTEL_CC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_ASM</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTC_ROx_ASM</name></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>ROL</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("roll %%cl,%0"

:"=r" (word)

:"0" (word),"c" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>ROR</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("rorl %%cl,%0"

:"=r" (word)

:"0" (word),"c" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_ROLC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>({ ulong32 __ROLc_tmp = (word); __asm__ ("roll %2, %0" : "=r" (__ROLc_tmp) : "0" (__ROLc_tmp), "I" (i)); __ROLc_tmp; })</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>({ ulong32 __RORc_tmp = (word); __asm__ ("rorl %2, %0" : "=r" (__RORc_tmp) : "0" (__RORc_tmp), "I" (i)); __RORc_tmp; })</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name></cpp:macro> <cpp:value>ROL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name></cpp:macro> <cpp:value>ROR</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STRICT_ANSI__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LTC_PPC32</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTC_ROx_ASM</name></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>ROL</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("rotlw %0,%0,%2"

:"=r" (word)

:"0" (word),"r" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>ROR</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("rotlw %0,%0,%2"

:"=r" (word)

:"0" (word),"r" (32-i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_ROLC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>ROLc</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("rotlwi %0,%0,%2"

:"=r" (word)

:"0" (word),"I" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong32</name></type> <name>RORc</name><parameter_list>(<parameter><decl><type><name>ulong32</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm ("rotrwi %0,%0,%2"

:"=r" (word)

:"0" (word),"I" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name></cpp:macro> <cpp:value>ROL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name></cpp:macro> <cpp:value>ROR</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (((ulong32)(x)&lt;&lt;(ulong32)((y)&amp;31)) | (((ulong32)(x)&amp;0xFFFFFFFFUL)&gt;&gt;(ulong32)((32-((y)&amp;31))&amp;31))) &amp; 0xFFFFFFFFUL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((((ulong32)(x)&amp;0xFFFFFFFFUL)&gt;&gt;(ulong32)((y)&amp;31)) | ((ulong32)(x)&lt;&lt;(ulong32)((32-((y)&amp;31))&amp;31))) &amp; 0xFFFFFFFFUL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (((ulong32)(x)&lt;&lt;(ulong32)((y)&amp;31)) | (((ulong32)(x)&amp;0xFFFFFFFFUL)&gt;&gt;(ulong32)((32-((y)&amp;31))&amp;31))) &amp; 0xFFFFFFFFUL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RORc</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((((ulong32)(x)&amp;0xFFFFFFFFUL)&gt;&gt;(ulong32)((y)&amp;31)) | ((ulong32)(x)&lt;&lt;(ulong32)((32-((y)&amp;31))&amp;31))) &amp; 0xFFFFFFFFUL)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_rotr64</name><name>,</name><name>_rotr64</name><name>)</name></cpp:pragma>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_rotr64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_rotl64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROR64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROL64(x,n)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_HAVE_ROTATE_BUILTIN</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_rotateright64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_rotateleft64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROR64(x,n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ROL64(x,n)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STRICT_ANSI__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INTEL_CC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_ASM</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong64</name></type> <name>ROL64</name><parameter_list>(<parameter><decl><type><name>ulong64</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm("rolq %%cl,%0"

:"=r" (word)

:"0" (word),"c" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ulong64</name></type> <name>ROR64</name><parameter_list>(<parameter><decl><type><name>ulong64</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<asm>asm("rorq %%cl,%0"

:"=r" (word)

:"0" (word),"c" (i));</asm>

<return>return <expr><name>word</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_NO_ROLC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64c</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>({ ulong64 __ROL64c_tmp = word; __asm__ ("rolq %2, %0" : "=r" (__ROL64c_tmp) : "0" (__ROL64c_tmp), "J" (i)); __ROL64c_tmp; })</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64c</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>({ ulong64 __ROR64c_tmp = word; __asm__ ("rorq %2, %0" : "=r" (__ROR64c_tmp) : "0" (__ROR64c_tmp), "J" (i)); __ROR64c_tmp; })</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64c</name></cpp:macro> <cpp:value>ROL64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64c</name></cpp:macro> <cpp:value>ROR64</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (((x)&lt;&lt;((ulong64)(y)&amp;63)) | (((x)&amp;CONST64(0xFFFFFFFFFFFFFFFF))&gt;&gt;(((ulong64)64-((y)&amp;63))&amp;63))) &amp; CONST64(0xFFFFFFFFFFFFFFFF))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((((x)&amp;CONST64(0xFFFFFFFFFFFFFFFF))&gt;&gt;((ulong64)(y)&amp;CONST64(63))) | ((x)&lt;&lt;(((ulong64)64-((y)&amp;63))&amp;63))) &amp; CONST64(0xFFFFFFFFFFFFFFFF))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (((x)&lt;&lt;((ulong64)(y)&amp;63)) | (((x)&amp;CONST64(0xFFFFFFFFFFFFFFFF))&gt;&gt;(((ulong64)64-((y)&amp;63))&amp;63))) &amp; CONST64(0xFFFFFFFFFFFFFFFF))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROR64c</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((((x)&amp;CONST64(0xFFFFFFFFFFFFFFFF))&gt;&gt;((ulong64)(y)&amp;CONST64(63))) | ((x)&lt;&lt;(((ulong64)64-((y)&amp;63))&amp;63))) &amp; CONST64(0xFFFFFFFFFFFFFFFF))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((x)&gt;(y))?(x):(y) )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((x)&lt;(y))?(x):(y) )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LTC_UNUSED_PARAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LTC_UNUSED_PARAM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1900</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
