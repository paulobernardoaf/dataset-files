<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\libtomcrypt-analysis\_cppstats\libtomcrypt\demos\tv_gen.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tomcrypt_private.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>md</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>outlen</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"hash_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"can't open hash_tv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Hash Test Vectors:\n\nThese are the hashes of nn bytes '00 01 02 03 .. (nn-1)'\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>XMALLOC</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>blocksize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"can't alloc mem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Hash: %s\n"</literal></expr></argument>, <argument><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;=</operator> <operator>(</operator><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>blocksize</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>outlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>md</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>hash_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"hash_memory error: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3lu: "</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>outlen</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>md</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cipher_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"/><name><name>pt</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>lastkl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>symmetric_key</name></type> <name>skey</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"cipher_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,

<argument><expr><literal type="string">"Cipher Test Vectors\n\nThese are test encryptions with key of nn bytes '00 01 02 03 .. (nn-1)' and original PT of the same style.\n"</literal>

<literal type="string">"The output of step N is used as the key and plaintext for step N+1 (key bytes repeated as required to fill the key)\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Cipher: %s\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lastkl</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name>y</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>min_key_length</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>kl</name> <operator>=</operator> <operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>min_key_length</name> <operator>+</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"keysize error: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>==</operator> <name>lastkl</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lastkl</name> <operator>=</operator> <name>kl</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Key Size: %d bytes\n"</literal></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>XMALLOC</name><argument_list>(<argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"can't malloc memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>z</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>setup</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"setup error: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>z</name> <operator>&lt;</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>pt</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>z</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>w</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>w</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>ecb_encrypt</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%2lu: "</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>z</name> <operator>&lt;</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>pt</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>pt</name><index>[<expr><name>z</name> <operator>%</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>setup</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"cipher setup2 error: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hmac_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>output</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>input</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"hmac_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,

<argument><expr><literal type="string">"HMAC Tests. In these tests messages of N bytes long (00,01,02,...,NN-1) are HMACed. The initial key is\n"</literal>

<literal type="string">"of the same format (the same length as the HASH output size). The HMAC key in step N+1 is the HMAC output of\n"</literal>

<literal type="string">"step N.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"HMAC-%s\n"</literal></expr></argument>, <argument><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>hashsize</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name><operator>&amp;</operator><literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>XMALLOC</name><argument_list>(<argument><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>blocksize</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"Can't malloc memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>blocksize</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>input</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>hmac_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>hashsize</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error hmacing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator> <name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name><name>hash_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>hashsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>XFREE</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OMAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>omac_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>output</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>input</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"omac_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,

<argument><expr><literal type="string">"OMAC Tests. In these tests messages of N bytes long (00,01,02,...,NN-1) are OMAC'ed. The initial key is\n"</literal>

<literal type="string">"of the same format (length specified per cipher). The OMAC key in step N+1 is the OMAC output of\n"</literal>

<literal type="string">"step N (repeated as required to fill the array).\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"OMAC-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>input</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>omac_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OMAC'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OMAC'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>output</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_PMAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pmac_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>output</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>input</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"pmac_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,

<argument><expr><literal type="string">"PMAC Tests. In these tests messages of N bytes long (00,01,02,...,NN-1) are PMAC'ed. The initial key is\n"</literal>

<literal type="string">"of the same format (length specified per cipher). The PMAC key in step N+1 is the PMAC output of\n"</literal>

<literal type="string">"step N (repeated as required to fill the array).\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"PMAC-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>input</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>pmac_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error PMACing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error PMAC'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>output</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_EAX_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>eax_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>nonce</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>header</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>,

<decl><type ref="prev"/><name><name>plaintext</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tag</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"eax_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"EAX Test Vectors. Uses the 00010203...NN-1 pattern for header/nonce/plaintext/key. The outputs\n"</literal>

<literal type="string">"are of the form ciphertext,tag for a given NN. The key for step N&gt;1 is the tag of the previous\n"</literal>

<literal type="string">"step repeated sufficiently.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"EAX-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y1</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nonce</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>header</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>eax_encrypt_authenticate_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error EAX'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error EAX'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>tag</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>tag</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OCB_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ocb_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>nonce</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>,

<decl><type ref="prev"/><name><name>plaintext</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tag</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"ocb_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"OCB Test Vectors. Uses the 00010203...NN-1 pattern for nonce/plaintext/key. The outputs\n"</literal>

<literal type="string">"are of the form ciphertext,tag for a given NN. The key for step N&gt;1 is the tag of the previous\n"</literal>

<literal type="string">"step repeated sufficiently. The nonce is fixed throughout.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"OCB-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>nonce</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y1</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>ocb_encrypt_authenticate_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OCB'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OCB'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>tag</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>tag</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OCB3_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ocb3_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>z</name></decl>, <decl><type ref="prev"/><name>noncelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>nonce</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>,

<decl><type ref="prev"/><name><name>plaintext</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tag</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"ocb3_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"OCB3 Test Vectors. Uses the 00010203...NN-1 pattern for nonce/plaintext/key. The outputs\n"</literal>

<literal type="string">"are of the form ciphertext,tag for a given NN. The key for step N&gt;1 is the tag of the previous\n"</literal>

<literal type="string">"step repeated sufficiently. The nonce is fixed throughout. AAD is fixed to 3 bytes (ASCII) 'AAD'.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"OCB3-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>noncelen</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>noncelen</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>nonce</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y1</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>ocb3_encrypt_authenticate_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><name>noncelen</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"AAD"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OCB3'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error OCB3'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>tag</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>tag</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_CCM_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ccm_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>nonce</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>,

<decl><type ref="prev"/><name><name>plaintext</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tag</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name><name>taglen</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">16</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"ccm_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"CCM Test Vectors. Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key. The outputs\n"</literal>

<literal type="string">"are of the form ciphertext,tag for a given NN. The key for step N&gt;1 is the tag of the previous\n"</literal>

<literal type="string">"step repeated sufficiently. The nonce is fixed throughout at 13 bytes 000102...\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"CCM-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>nonce</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>taglen</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>taglen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><operator>++</operator><name>t</name></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>y1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y1</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>taglen</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>ccm_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nonce</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>CCM_ENCRYPT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error CCM'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error CCM'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>tag</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>tag</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_GCM_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gcm_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>kl</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>plaintext</name><index>[<expr><name>MAXBLOCKSIZE</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tag</name><index>[<expr><name>MAXBLOCKSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"gcm_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"GCM Test Vectors. Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key. The outputs\n"</literal>

<literal type="string">"are of the form ciphertext,tag for a given NN. The key for step N&gt;1 is the tag of the previous\n"</literal>

<literal type="string">"step repeated sufficiently. The nonce is fixed throughout at 13 bytes 000102...\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kl</name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><call><name>keysize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>kl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kl</name> <operator>=</operator> <name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>max_key_length</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"GCM-%s (%d byte key)\n"</literal></expr></argument>, <argument><expr><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>y1</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y1</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cipher_descriptor</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>block_length</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition> <incr><expr><name>y1</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>gcm_memory</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>kl</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>plaintext</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>GCM_ENCRYPT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error GCM'ing: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error GCM'ing: zero length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>y1</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>plaintext</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02X"</literal></expr></argument>, <argument><expr><name><name>tag</name><index>[<expr><name>z</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>kl</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <name><name>tag</name><index>[<expr><name>z</name> <operator>%</operator> <name>len</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>base64_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>src</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>dst</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"base64_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Base64 vectors. These are the base64 encodings of the strings 00,01,02...NN-1\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;</operator> <name>x</name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>src</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>base64_encode</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%2lu: %s\n"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>math_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ecc_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>k</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>order</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>modulus</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ecc_point</name> <modifier>*</modifier></type><name>G</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>R</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"ecc_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ecc vectors. These are for kG for k=1,3,9,27,...,3**n until k &gt; order of the curve outputs are &lt;k,x,y&gt; triplets\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>G</name> <operator>=</operator> <call><name>ltc_ecc_new_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>R</name> <operator>=</operator> <call><name>ltc_ecc_new_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>prime</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_set</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_read_radix</name><argument_list>(<argument><expr><name>order</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>order</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_read_radix</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>prime</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_read_radix</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>A</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_read_radix</name><argument_list>(<argument><expr><name><name>G</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>Gx</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_read_radix</name><argument_list>(<argument><expr><name><name>G</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ltc_ecc_curves</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name>Gy</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_set</name><argument_list>(<argument><expr><name><name>G</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>mp_cmp</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LTC_MP_LT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>ltc_mp</name><operator>.</operator><name>ecc_ptmul</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>modulus</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_tohex</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_tohex</name><argument_list>(<argument><expr><name><name>R</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_tohex</name><argument_list>(<argument><expr><name><name>R</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mp_mul_d</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></for>

<expr_stmt><expr><call><name>mp_clear_multi</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>modulus</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ltc_ecc_del_point</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ltc_ecc_del_point</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_LRW_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lrw_gen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>tweak</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>key</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>iv</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>symmetric_LRW</name></type> <name>lrw</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>tweak</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name><name>iv</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"lrw_tv.txt"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">16</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>x</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>lrw_start</name><argument_list>(<argument><expr><call><name>find_cipher</name><argument_list>(<argument><expr><literal type="string">"aes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iv</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>tweak</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lrw</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error starting LRW-AES: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>x</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <name>y</name> <operator>&amp;</operator> <literal type="number">255</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>lrw_encrypt</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lrw</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error encrypting with LRW-AES: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%d:"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>x</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>lrw_setiv</name><argument_list>(<argument><expr><name>iv</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lrw</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error setting IV: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>key</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iv</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><operator>(</operator><name>y</name><operator>+</operator><literal type="number">16</literal><operator>)</operator><operator>%</operator><name>x</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tweak</name><index>[<expr><name>y</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><operator>(</operator><name>y</name><operator>+</operator><literal type="number">32</literal><operator>)</operator><operator>%</operator><name>x</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>lrw_decrypt</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lrw</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CRYPT_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error decrypting with LRW-AES: %s\n"</literal></expr></argument>, <argument><expr><call><name>error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%d:"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>x</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lrw_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lrw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>register_all_ciphers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>register_all_hashes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>register_all_prngs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LTM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>ltc_mp</name> <operator>=</operator> <name>ltm_desc</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TFM</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>ltc_mp</name> <operator>=</operator> <name>tfm_desc</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GMP</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>ltc_mp</name> <operator>=</operator> <name>gmp_desc</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXT_MATH_LIB</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><specifier>extern</specifier> <name>ltc_math_descriptor</name></type> <name>EXT_MATH_LIB</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ltc_mp</name> <operator>=</operator> <name>EXT_MATH_LIB</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating hash vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>hash_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating cipher vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>cipher_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating HMAC vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>hmac_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OMAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating OMAC vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>omac_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_PMAC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating PMAC vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>pmac_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_EAX_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating EAX vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>eax_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OCB_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating OCB vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>ocb_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_OCB3_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating OCB3 vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>ocb3_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_CCM_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating CCM vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>ccm_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_GCM_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating GCM vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>gcm_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating BASE64 vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>base64_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ltc_mp</name><operator>.</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating MATH vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>math_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating ECC vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>ecc_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LTC_LRW_MODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Generating LRW vectors..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lrw_gen</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
