<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\os\shell.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uv.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/log.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/event/loop.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/event/libuv_process.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/event/rstream.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_cmds.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/shell.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/signal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/main.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ui.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/screen.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option_defs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/strings.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYNAMIC_BUFFER_INIT</name></cpp:macro> <cpp:value>{ NULL, 0, 0 }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_1_SECOND</name></cpp:macro> <cpp:value>1000000000U</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT_DATA_THRESHOLD</name></cpp:macro> <cpp:value>1024 * 10U</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_SPECIAL</name></cpp:macro> <cpp:value>(char_u *)"\t \"&amp;'$;&lt;&gt;()\\|"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cap</name></decl>, <name>len</name>;</decl_stmt>

}</block></struct></type> <name>DynamicBuffer</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os/shell.c.generated.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>save_patterns</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_pat</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>num_pat</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>backslash_halve</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>file</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name>num_pat</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>have_wildcard</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>path_has_wildcard</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>have_dollars</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>os_expand_wildcards</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_pat</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>3</function>)

<macro><name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>dir</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>extra_shell_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ShellOpts</name></type> <name>shellopts</name> <init>= <expr><name>kShellOptExpand</name> <operator>|</operator> <name>kShellOptSilent</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tempname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STYLE_ECHO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STYLE_GLOB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STYLE_VIMGLOB</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STYLE_PRINT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STYLE_BT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>int</name></type> <name>shell_style</name> <init>= <expr><name>STYLE_ECHO</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>check_spaces</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>did_find_nul</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ampersent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sh_vimglob_func</name> <init>=

<expr><literal type="string">"vimglob() { while [ $#-ge 1 ]; do echo \"$1\"; shift; done }; vimglob &gt;"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_fish_shell</name> <init>=

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><call><name>invocation_path_tail</name><argument_list>(<argument><expr><name>p_sh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"fish"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>false</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>have_wildcard</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>save_patterns</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sandbox</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>check_secure</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>secure</name> <operator>||</operator> <name>restricted</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><call><name>check_restricted</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>check_secure</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tempname</name> <operator>=</operator> <call><name>vim_tempname</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num_pat</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>pat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'`'</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">2</literal>

<operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>pat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shell_style</name> <operator>=</operator> <name>STYLE_BT</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p_sh</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p_sh</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"csh"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shell_style</name> <operator>=</operator> <name>STYLE_GLOB</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p_sh</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"zsh"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shell_style</name> <operator>=</operator> <name>STYLE_PRINT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shell_style</name> <operator>==</operator> <name>STYLE_ECHO</name>

<operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>path_tail</name><argument_list>(<argument><expr><name>p_sh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"sh"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shell_style</name> <operator>=</operator> <name>STYLE_VIMGLOB</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">29</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shell_style</name> <operator>==</operator> <name>STYLE_VIMGLOB</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>sh_vimglob_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>SHELL_SPECIAL</name></expr></argument>, <argument><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>is_fish_shell</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> sizeof<operator>(</operator><literal type="string">"egin;""</literal> <name>end</name><literal type="string">") - 1;

}

command = xmalloc(len);

// Build the shell command:

// - Set $nonomatch depending on EW_NOTFOUND (hopefully the shell

// recognizes this).

// - Add the shell command to print the expanded names.

// - Add the temp file name.

// - Add the file name patterns.

if (shell_style == STYLE_BT) {

// change `command; command&amp; ` to (command; command )

if (is_fish_shell) {

STRCPY(command, "</literal><name>begin</name>;</expr></expr_stmt> <expr_stmt><expr><literal type="string">");

} else {

STRCPY(command, "</literal><operator>(</operator><literal type="string">");

}

STRCAT(command, pat[0] + 1); // exclude first backtick

p = command + STRLEN(command) - 1;

if (is_fish_shell) {

*p-- = ';';

STRCAT(command, "</literal> <name>end</name><literal type="string">");

} else {

*p-- = ')'; // remove last backtick

}

while (p &gt; command &amp;&amp; ascii_iswhite(*p)) {

p--;

}

if (*p == '&amp;') { // remove trailing '&amp;'

ampersent = true;

*p = ' ';

}

STRCAT(command, "</literal><operator>&gt;</operator><literal type="string">");

} else {

if (flags &amp; EW_NOTFOUND) {

STRCPY(command, "</literal><name>set</name> <name>nonomatch</name>;</expr></expr_stmt> <expr_stmt><expr><literal type="string">");

} else {

STRCPY(command, "</literal><name>unset</name> <name>nonomatch</name></expr>;</expr_stmt> <expr_stmt><expr><literal type="string">");

}

if (shell_style == STYLE_GLOB) {

STRCAT(command, "</literal><name>glob</name> <operator>&gt;</operator><literal type="string">");

} else if (shell_style == STYLE_PRINT) {

STRCAT(command, "</literal><name>print</name> <operator>-</operator><name>N</name> <operator>&gt;</operator><literal type="string">");

} else if (shell_style == STYLE_VIMGLOB) {

STRCAT(command, sh_vimglob_func);

} else {

STRCAT(command, "</literal><name>echo</name> <operator>&gt;</operator><literal type="string">");

}

}

STRCAT(command, tempname);

if (shell_style != STYLE_BT) {

for (i = 0; i &lt; num_pat; i++) {

// Put a backslash before special

// characters, except inside ``.

bool intick = false;

p = command + STRLEN(command);

*p++ = ' ';

for (j = 0; pat[i][j] != NUL; j++) {

if (pat[i][j] == '`') {

intick = !intick;

} else if (pat[i][j] == '\\' &amp;&amp; pat[i][j + 1] != NUL) {

// Remove a backslash, take char literally. But keep

// backslash inside backticks, before a special character

// and before a backtick.

if (intick

|| vim_strchr(SHELL_SPECIAL, pat[i][j + 1]) != NULL

|| pat[i][j + 1] == '`') {

*p++ = '\\';

}

j++;

} else if (!intick

&amp;&amp; ((flags &amp; EW_KEEPDOLLAR) == 0 || pat[i][j] != '$')

&amp;&amp; vim_strchr(SHELL_SPECIAL, pat[i][j]) != NULL) {

// Put a backslash before a special character, but not

// when inside ``. And not for $var when EW_KEEPDOLLAR is

// set.

*p++ = '\\';

}

// Copy one character.

*p++ = pat[i][j];

}

*p = NUL;

}

}

if (flags &amp; EW_SILENT) {

shellopts |= kShellOptHideMess;

}

if (ampersent) {

STRCAT(command, "</literal><operator>&amp;</operator><literal type="string">"); // put the '&amp;' after the redirection

}

// Using zsh -G: If a pattern has no matches, it is just deleted from

// the argument list, otherwise zsh gives an error message and doesn't

// expand any other pattern.

if (shell_style == STYLE_PRINT) {

extra_shell_arg = (char_u *)"</literal><operator>-</operator><name>G</name><literal type="string">"; // Use zsh NULL_GLOB option

// If we use -f then shell variables set in .cshrc won't get expanded.

// vi can do it, so we will too, but it is only necessary if there is a "</literal><name>$</name><literal type="string">"

// in one of the patterns, otherwise we can still use the fast option.

} else if (shell_style == STYLE_GLOB &amp;&amp; !have_dollars(num_pat, pat)) {

extra_shell_arg = (char_u *)"</literal><operator>-</operator><name>f</name><literal type="string">"; // Use csh fast option

}

// execute the shell command

i = call_shell(command, shellopts, extra_shell_arg);

// When running in the background, give it some time to create the temp

// file, but don't wait for it to finish.

if (ampersent) {

os_delay(10L, true);

}

xfree(command);

if (i) { // os_call_shell() failed

os_remove((char *)tempname);

xfree(tempname);

// With interactive completion, the error message is not printed.

if (!(flags &amp; EW_SILENT)) {

msg_putchar('\n'); // clear bottom line quickly

cmdline_row = Rows - 1; // continue on last line

MSG(_(e_wildexpand));

msg_start(); // don't overwrite this message

}

// If a `cmd` expansion failed, don't list `cmd` as a match, even when

// EW_NOTFOUND is given

if (shell_style == STYLE_BT) {

return FAIL;

}

goto notfound;

}

// read the names from the file into memory

fd = fopen((char *)tempname, READBIN);

if (fd == NULL) {

// Something went wrong, perhaps a file name with a special char.

if (!(flags &amp; EW_SILENT)) {

MSG(_(e_wildexpand));

msg_start(); // don't overwrite this message

}

xfree(tempname);

goto notfound;

}

int fseek_res = fseek(fd, 0L, SEEK_END);

if (fseek_res &lt; 0) {

xfree(tempname);

fclose(fd);

return FAIL;

}

int64_t templen = ftell(fd); // get size of temp file

if (templen &lt; 0) {

xfree(tempname);

fclose(fd);

return FAIL;

}

#if SIZEOF_LONG_LONG &gt; SIZEOF_SIZE_T

assert(templen &lt;= (long long)SIZE_MAX); // NOLINT(runtime/int)

#endif

len = (size_t)templen;

fseek(fd, 0L, SEEK_SET);

buffer = xmalloc(len + 1);

// fread() doesn't terminate buffer with NUL;

// appropriate termination (not always NUL) is done below.

size_t readlen = fread((char *)buffer, 1, len, fd);

fclose(fd);

os_remove((char *)tempname);

if (readlen != len) {

// unexpected read error

EMSG2(_(e_notread), tempname);

xfree(tempname);

xfree(buffer);

return FAIL;

}

xfree(tempname);

// file names are separated with Space

if (shell_style == STYLE_ECHO) {

buffer[len] = '\n'; // make sure the buffer ends in NL

p = buffer;

for (i = 0; *p != '\n'; i++) { // count number of entries

while (*p != ' ' &amp;&amp; *p != '\n') {

p++;

}

p = skipwhite(p); // skip to next entry

}

// file names are separated with NL

} else if (shell_style == STYLE_BT || shell_style == STYLE_VIMGLOB) {

buffer[len] = NUL; // make sure the buffer ends in NUL

p = buffer;

for (i = 0; *p != NUL; i++) { // count number of entries

while (*p != '\n' &amp;&amp; *p != NUL) {

p++;

}

if (*p != NUL) {

p++;

}

p = skipwhite(p); // skip leading white space

}

// file names are separated with NUL

} else {

// Some versions of zsh use spaces instead of NULs to separate

// results. Only do this when there is no NUL before the end of the

// buffer, otherwise we would never be able to use file names with

// embedded spaces when zsh does use NULs.

// When we found a NUL once, we know zsh is OK, set did_find_nul and

// don't check for spaces again.

check_spaces = false;

if (shell_style == STYLE_PRINT &amp;&amp; !did_find_nul) {

// If there is a NUL, set did_find_nul, else set check_spaces

buffer[len] = NUL;

if (len &amp;&amp; (int)STRLEN(buffer) &lt; (int)len) {

did_find_nul = true;

} else {

check_spaces = true;

}

}

// Make sure the buffer ends with a NUL. For STYLE_PRINT there

// already is one, for STYLE_GLOB it needs to be added.

if (len &amp;&amp; buffer[len - 1] == NUL) {

len--;

} else {

buffer[len] = NUL;

}

for (p = buffer; p &lt; buffer + len; p++) {

if (*p == NUL || (*p == ' ' &amp;&amp; check_spaces)) { // count entry

i++;

*p = NUL;

}

}

if (len) {

i++; // count last entry

}

}

assert(buffer[len] == NUL || buffer[len] == '\n');

if (i == 0) {

// Can happen when using /bin/sh and typing "</literal><operator>:</operator><name>e</name> <name>$NO_SUCH_VAR</name><operator>^</operator><name>I</name><literal type="string">".

// /bin/sh will happily expand it to nothing rather than returning an

// error; and hey, it's good to check anyway -- webb.

xfree(buffer);

goto notfound;

}

*num_file = i;

*file = xmalloc(sizeof(char_u *) * (size_t)i);

// Isolate the individual file names.

p = buffer;

for (i = 0; i &lt; *num_file; i++) {

(*file)[i] = p;

// Space or NL separates

if (shell_style == STYLE_ECHO || shell_style == STYLE_BT

|| shell_style == STYLE_VIMGLOB) {

while (!(shell_style == STYLE_ECHO &amp;&amp; *p == ' ')

&amp;&amp; *p != '\n' &amp;&amp; *p != NUL) {

p++;

}

if (p == buffer + len) { // last entry

*p = NUL;

} else {

*p++ = NUL;

p = skipwhite(p); // skip to next entry

}

} else { // NUL separates

while (*p &amp;&amp; p &lt; buffer + len) { // skip entry

p++;

}

p++; // skip NUL

}

}

// Move the file names to allocated memory.

for (j = 0, i = 0; i &lt; *num_file; i++) {

// Require the files to exist. Helps when using /bin/sh

if (!(flags &amp; EW_NOTFOUND) &amp;&amp; !os_path_exists((*file)[i])) {

continue;

}

// check if this entry should be included

dir = (os_isdir((*file)[i]));

if ((dir &amp;&amp; !(flags &amp; EW_DIR)) || (!dir &amp;&amp; !(flags &amp; EW_FILE))) {

continue;

}

// Skip files that are not executable if we check for that.

if (!dir &amp;&amp; (flags &amp; EW_EXEC)

&amp;&amp; !os_can_exe((char *)(*file)[i], NULL, !(flags &amp; EW_SHELLCMD))) {

continue;

}

p = xmalloc(STRLEN((*file)[i]) + 1 + dir);

STRCPY(p, (*file)[i]);

if (dir) {

add_pathsep((char *)p); // add '/' to a directory name

}

(*file)[j++] = p;

}

xfree(buffer);

*num_file = j;

if (*num_file == 0) { // rejected all entries

XFREE_CLEAR(*file);

goto notfound;

}

return OK;

notfound:

if (flags &amp; EW_NOTFOUND) {

save_patterns(num_pat, pat, num_file, file);

return OK;

}

return FAIL;

}

/// Builds the argument vector for running the user-configured 'shell' (p_sh)

/// with an optional command prefixed by 'shellcmdflag' (p_shcf). E.g.:

///

/// ["</literal><name>shell</name><literal type="string">", "</literal><operator>-</operator><name>extra_args</name><literal type="string">", "</literal><operator>-</operator><name>shellcmdflag</name><literal type="string">", "</literal><name>command</name> <name>with</name> <name>spaces</name><literal type="string">"]

///

/// @param cmd Command string, or NULL to run an interactive shell.

/// @param extra_args Extra arguments to the shell, or NULL.

/// @return Newly allocated argument vector. Must be freed with shell_free_argv.

char **shell_build_argv(const char *cmd, const char *extra_args)

FUNC_ATTR_NONNULL_RET

{

size_t argc = tokenize(p_sh, NULL) + (cmd ? tokenize(p_shcf, NULL) : 0);

char **rv = xmalloc((argc + 4) * sizeof(*rv));

// Split 'shell'

size_t i = tokenize(p_sh, rv);

if (extra_args) {

rv[i++] = xstrdup(extra_args); // Push a copy of `extra_args`

}

if (cmd) {

i += tokenize(p_shcf, rv + i); // Split 'shellcmdflag'

rv[i++] = shell_xescape_xquote(cmd); // Copy (and escape) `cmd`.

}

rv[i] = NULL;

assert(rv[0]);

return rv;

}

/// Releases the memory allocated by `shell_build_argv`.

///

/// @param argv The argument vector.

void shell_free_argv(char **argv)

{

char **p = argv;

if (p == NULL) {

// Nothing was allocated, return

return;

}

while (*p != NULL) {

// Free each argument

xfree(*p);

p++;

}

xfree(argv);

}

/// Joins shell arguments from `argv` into a new string.

/// If the result is too long it is truncated with ellipsis ("</literal><operator>...</operator><literal type="string">").

///

/// @returns[allocated] `argv` joined to a string.

char *shell_argv_to_str(char **const argv)

FUNC_ATTR_NONNULL_ALL

{

size_t n = 0;

char **p = argv;

char *rv = xcalloc(256, sizeof(*rv));

const size_t maxsize = (256 * sizeof(*rv));

if (*p == NULL) {

return rv;

}

while (*p != NULL) {

xstrlcat(rv, "</literal><literal type="char">'", maxsize);

xstrlcat(rv, *p, maxsize);

n = xstrlcat(rv, "'</literal> <literal type="string">", maxsize);

if (n &gt;= maxsize) {

break;

}

p++;

}

if (n &lt; maxsize) {

rv[n - 1] = '\0';

} else {

// Command too long, show ellipsis: "</literal><operator>/</operator><name>bin</name><operator>/</operator><name>bash</name> <literal type="char">'foo'</literal> <literal type="char">'bar'</literal><operator>...</operator><literal type="string">"

rv[maxsize - 4] = '.';

rv[maxsize - 3] = '.';

rv[maxsize - 2] = '.';

rv[maxsize - 1] = '\0';

}

return rv;

}

/// Calls the user-configured 'shell' (p_sh) for running a command or wildcard

/// expansion.

///

/// @param cmd The command to execute, or NULL to run an interactive shell.

/// @param opts Options that control how the shell will work.

/// @param extra_args Extra arguments to the shell, or NULL.

///

/// @return shell command exit code

int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_args)

{

DynamicBuffer input = DYNAMIC_BUFFER_INIT;

char *output = NULL, **output_ptr = NULL;

int current_state = State;

bool forward_output = true;

// While the child is running, ignore terminating signals

signal_reject_deadly();

if (opts &amp; (kShellOptHideMess | kShellOptExpand)) {

forward_output = false;

} else {

State = EXTERNCMD;

if (opts &amp; kShellOptWrite) {

read_input(&amp;input);

}

if (opts &amp; kShellOptRead) {

output_ptr = &amp;output;

forward_output = false;

} else if (opts &amp; kShellOptDoOut) {

// Caller has already redirected output

forward_output = false;

}

}

size_t nread;

int exitcode = do_os_system(shell_build_argv((char *)cmd, (char *)extra_args),

input.data, input.len, output_ptr, &amp;nread,

emsg_silent, forward_output);

xfree(input.data);

if (output) {

(void)write_output(output, nread, true);

xfree(output);

}

if (!emsg_silent &amp;&amp; exitcode != 0 &amp;&amp; !(opts &amp; kShellOptSilent)) {

MSG_PUTS(_("</literal><operator>\</operator><name>nshell</name> <name>returned</name> <literal type="string">"));

msg_outnum(exitcode);

msg_putchar('\n');

}

State = current_state;

signal_accept_deadly();

return exitcode;

}

/// os_system - synchronously execute a command in the shell

///

/// example:

/// char *output = NULL;

/// size_t nread = 0;

/// char *argv[] = {"</literal><name>ls</name><literal type="string">", "</literal><operator>-</operator><name>la</name><literal type="string">", NULL};

/// int exitcode = os_sytem(argv, NULL, 0, &amp;output, &amp;nread);

///

/// @param argv The commandline arguments to be passed to the shell. `argv`

/// will be consumed.

/// @param input The input to the shell (NULL for no input), passed to the

/// stdin of the resulting process.

/// @param len The length of the input buffer (not used if `input` == NULL)

/// @param[out] output Pointer to a location where the output will be

/// allocated and stored. Will point to NULL if the shell

/// command did not output anything. If NULL is passed,

/// the shell output will be ignored.

/// @param[out] nread the number of bytes in the returned buffer (if the

/// returned buffer is not NULL)

/// @return the return code of the process, -1 if the process couldn't be

/// started properly

int os_system(char **argv,

const char *input,

size_t len,

char **output,

size_t *nread) FUNC_ATTR_NONNULL_ARG(1)

{

return do_os_system(argv, input, len, output, nread, true, false);

}

static int do_os_system(char **argv,

const char *input,

size_t len,

char **output,

size_t *nread,

bool silent,

bool forward_output)

{

out_data_decide_throttle(0); // Initialize throttle decider.

out_data_ring(NULL, 0); // Initialize output ring-buffer.

bool has_input = (input != NULL &amp;&amp; input[0] != '\0');

// the output buffer

DynamicBuffer buf = DYNAMIC_BUFFER_INIT;

stream_read_cb data_cb = system_data_cb;

if (nread) {

*nread = 0;

}

if (forward_output) {

data_cb = out_data_cb;

} else if (!output) {

data_cb = NULL;

}

// Copy the program name in case we need to report an error.

char prog[MAXPATHL];

xstrlcpy(prog, argv[0], MAXPATHL);

LibuvProcess uvproc = libuv_process_init(&amp;main_loop, &amp;buf);

Process *proc = &amp;uvproc.process;

MultiQueue *events = multiqueue_new_child(main_loop.events);

proc-&gt;events = events;

proc-&gt;argv = argv;

int status = process_spawn(proc, has_input, true, true);

if (status) {

loop_poll_events(&amp;main_loop, 0);

// Failed, probably 'shell' is not executable.

if (!silent) {

MSG_PUTS(_("</literal><operator>\</operator><name>nshell</name> <name>failed</name> <name>to</name> <name>start</name><operator>:</operator> <literal type="string">"));

msg_outtrans((char_u *)os_strerror(status));

MSG_PUTS("</literal><operator>:</operator> <literal type="string">");

msg_outtrans((char_u *)prog);

msg_putchar('\n');

}

multiqueue_free(events);

return -1;

}

// Note: unlike process events, stream events are not queued, as we want to

// deal with stream events as fast a possible. It prevents closing the

// streams while there's still data in the OS buffer (due to the process

// exiting before all data is read).

if (has_input) {

wstream_init(&amp;proc-&gt;in, 0);

}

rstream_init(&amp;proc-&gt;out, 0);

rstream_start(&amp;proc-&gt;out, data_cb, &amp;buf);

rstream_init(&amp;proc-&gt;err, 0);

rstream_start(&amp;proc-&gt;err, data_cb, &amp;buf);

// write the input, if any

if (has_input) {

WBuffer *input_buffer = wstream_new_buffer((char *)input, len, 1, NULL);

if (!wstream_write(&amp;proc-&gt;in, input_buffer)) {

// couldn't write, stop the process and tell the user about it

process_stop(proc);

return -1;

}

// close the input stream after everything is written

wstream_set_write_cb(&amp;proc-&gt;in, shell_write_cb, NULL);

}

// Invoke busy_start here so LOOP_PROCESS_EVENTS_UNTIL will not change the

// busy state.

ui_busy_start();

ui_flush();

if (forward_output) {

msg_sb_eol();

msg_start();

msg_no_more = true;

lines_left = -1;

}

int exitcode = process_wait(proc, -1, NULL);

if (!got_int &amp;&amp; out_data_decide_throttle(0)) {

// Last chunk of output was skipped; display it now.

out_data_ring(NULL, SIZE_MAX);

}

if (forward_output) {

// caller should decide if wait_return is invoked

no_wait_return++;

msg_end();

no_wait_return--;

msg_no_more = false;

}

ui_busy_stop();

// prepare the out parameters if requested

if (output) {

if (buf.len == 0) {

// no data received from the process, return NULL

*output = NULL;

xfree(buf.data);

} else {

// NUL-terminate to make the output directly usable as a C string

buf.data[buf.len] = NUL;

*output = buf.data;

}

if (nread) {

*nread = buf.len;

}

}

assert(multiqueue_empty(events));

multiqueue_free(events);

return exitcode;

}

/// - ensures at least `desired` bytes in buffer

///

/// TODO(aktau): fold with kvec/garray

static void dynamic_buffer_ensure(DynamicBuffer *buf, size_t desired)

{

if (buf-&gt;cap &gt;= desired) {

assert(buf-&gt;data);

return;

}

buf-&gt;cap = desired;

kv_roundup32(buf-&gt;cap);

buf-&gt;data = xrealloc(buf-&gt;data, buf-&gt;cap);

}

static void system_data_cb(Stream *stream, RBuffer *buf, size_t count,

void *data, bool eof)

{

DynamicBuffer *dbuf = data;

size_t nread = buf-&gt;size;

dynamic_buffer_ensure(dbuf, dbuf-&gt;len + nread + 1);

rbuffer_read(buf, dbuf-&gt;data + dbuf-&gt;len, nread);

dbuf-&gt;len += nread;

}

/// Tracks output received for the current executing shell command, and displays

/// a pulsing "</literal><operator>...</operator><literal type="string">" when output should be skipped. Tracking depends on the

/// synchronous/blocking nature of "</literal><operator>:</operator><operator>!</operator><literal type="string">".

///

/// Purpose:

/// 1. CTRL-C is more responsive. #1234 #5396

/// 2. Improves performance of :! (UI, esp. TUI, is the bottleneck).

/// 3. Avoids OOM during long-running, spammy :!.

///

/// Vim does not need this hack because:

/// 1. :! in terminal-Vim runs in cooked mode, so CTRL-C is caught by the

/// terminal and raises SIGINT out-of-band.

/// 2. :! in terminal-Vim uses a tty (Nvim uses pipes), so commands

/// (e.g. `git grep`) may page themselves.

///

/// @param size Length of data, used with internal state to decide whether

/// output should be skipped. size=0 resets the internal state and

/// returns the previous decision.

///

/// @returns true if output should be skipped and pulse was displayed.

/// Returns the previous decision if size=0.

static bool out_data_decide_throttle(size_t size)

{

static uint64_t started = 0; // Start time of the current throttle.

static size_t received = 0; // Bytes observed since last throttle.

static size_t visit = 0; // "</literal><name>Pulse</name><literal type="string">" count of the current throttle.

static char pulse_msg[] = { ' ', ' ', ' ', '\0' };

if (!size) {

bool previous_decision = (visit &gt; 0);

started = received = visit = 0;

return previous_decision;

}

received += size;

if (received &lt; OUT_DATA_THRESHOLD

// Display at least the first chunk of output even if it is big.

|| (!started &amp;&amp; received &lt; size + 1000)) {

return false;

} else if (!visit) {

started = os_hrtime();

} else {

uint64_t since = os_hrtime() - started;

if (since &lt; (visit * 0.1L * NS_1_SECOND)) {

return true;

}

if (since &gt; (3 * NS_1_SECOND)) {

received = visit = 0;

return false;

}

}

visit++;

// Pulse "</literal><operator>...</operator><literal type="string">" at the bottom of the screen.

size_t tick = visit % 4;

pulse_msg[0] = (tick &gt; 0) ? '.' : ' ';

pulse_msg[1] = (tick &gt; 1) ? '.' : ' ';

pulse_msg[2] = (tick &gt; 2) ? '.' : ' ';

if (visit == 1) {

msg_puts("</literal><operator>...</operator><operator>\</operator><name>n</name><literal type="string">");

}

msg_putchar('\r'); // put cursor at start of line

msg_puts(pulse_msg);

msg_putchar('\r');

ui_flush();

return true;

}

/// Saves output in a quasi-ringbuffer. Used to ensure the last ~page of

/// output for a shell-command is always displayed.

///

/// Init mode: Resets the internal state.

/// output = NULL

/// size = 0

/// Print mode: Displays the current saved data.

/// output = NULL

/// size = SIZE_MAX

///

/// @param output Data to save, or NULL to invoke a special mode.

/// @param size Length of `output`.

static void out_data_ring(char *output, size_t size)

{

#define MAX_CHUNK_SIZE (OUT_DATA_THRESHOLD / 2)

static char last_skipped[MAX_CHUNK_SIZE]; // Saved output.

static size_t last_skipped_len = 0;

assert(output != NULL || (size == 0 || size == SIZE_MAX));

if (output == NULL &amp;&amp; size == 0) { // Init mode

last_skipped_len = 0;

return;

}

if (output == NULL &amp;&amp; size == SIZE_MAX) { // Print mode

out_data_append_to_screen(last_skipped, &amp;last_skipped_len, true);

return;

}

// This is basically a ring-buffer...

if (size &gt;= MAX_CHUNK_SIZE) { // Save mode

size_t start = size - MAX_CHUNK_SIZE;

memcpy(last_skipped, output + start, MAX_CHUNK_SIZE);

last_skipped_len = MAX_CHUNK_SIZE;

} else if (size &gt; 0) {

// Length of the old data that can be kept.

size_t keep_len = MIN(last_skipped_len, MAX_CHUNK_SIZE - size);

size_t keep_start = last_skipped_len - keep_len;

// Shift the kept part of the old data to the start.

if (keep_start) {

memmove(last_skipped, last_skipped + keep_start, keep_len);

}

// Copy the entire new data to the remaining space.

memcpy(last_skipped + keep_len, output, size);

last_skipped_len = keep_len + size;

}

}

/// Continue to append data to last screen line.

///

/// @param output Data to append to screen lines.

/// @param remaining Size of data.

/// @param new_line If true, next data output will be on a new line.

static void out_data_append_to_screen(char *output, size_t *count, bool eof)

FUNC_ATTR_NONNULL_ALL

{

char *p = output, *end = output + *count;

while (p &lt; end) {

if (*p == '\n' || *p == '\r' || *p == TAB || *p == BELL) {

msg_putchar_attr((uint8_t)(*p), 0);

p++;

} else {

// Note: this is not 100% precise:

// 1. we don't check if received continuation bytes are already invalid

// and we thus do some buffering that could be avoided

// 2. we don't compose chars over buffer boundaries, even if we see an

// incomplete UTF-8 sequence that could be composing with the last

// complete sequence.

// This will be corrected when we switch to vterm based implementation

int i = *p ? utfc_ptr2len_len((char_u *)p, (int)(end-p)) : 1;

if (!eof &amp;&amp; i == 1 &amp;&amp; utf8len_tab_zero[*(uint8_t *)p] &gt; (end-p)) {

*count = (size_t)(p - output);

goto end;

}

(void)msg_outtrans_len_attr((char_u *)p, i, 0);

p += i;

}

}

end:

ui_flush();

}

static void out_data_cb(Stream *stream, RBuffer *buf, size_t count, void *data,

bool eof)

{

size_t cnt;

char *ptr = rbuffer_read_ptr(buf, &amp;cnt);

if (ptr != NULL &amp;&amp; cnt &gt; 0

&amp;&amp; out_data_decide_throttle(cnt)) { // Skip output above a threshold.

// Save the skipped output. If it is the final chunk, we display it later.

out_data_ring(ptr, cnt);

} else if (ptr != NULL) {

out_data_append_to_screen(ptr, &amp;cnt, eof);

}

if (cnt) {

rbuffer_consumed(buf, cnt);

}

// Move remaining data to start of buffer, so the buffer can never

// wrap around.

rbuffer_reset(buf);

}

/// Parses a command string into a sequence of words, taking quotes into

/// consideration.

///

/// @param str The command string to be parsed

/// @param argv The vector that will be filled with copies of the parsed

/// words. It can be NULL if the caller only needs to count words.

/// @return The number of words parsed.

static size_t tokenize(const char_u *const str, char **const argv)

FUNC_ATTR_NONNULL_ARG(1)

{

size_t argc = 0;

const char *p = (const char *) str;

while (*p != NUL) {

const size_t len = word_length((const char_u *) p);

if (argv != NULL) {

// Fill the slot

argv[argc] = vim_strnsave_unquoted(p, len);

}

argc++;

p = (const char *) skipwhite((char_u *) (p + len));

}

return argc;

}

/// Calculates the length of a shell word.

///

/// @param str A pointer to the first character of the word

/// @return The offset from `str` at which the word ends.

static size_t word_length(const char_u *str)

{

const char_u *p = str;

bool inquote = false;

size_t length = 0;

// Move `p` to the end of shell word by advancing the pointer while it's

// inside a quote or it's a non-whitespace character

while (*p &amp;&amp; (inquote || (*p != ' ' &amp;&amp; *p != TAB))) {

if (*p == '"</literal><literal type="char">') {

// Found a quote character, switch the `inquote` flag

inquote = !inquote;

} else if (*p == '</literal><operator>\</operator><operator>\</operator><literal type="char">' &amp;&amp; inquote) {

p++;

length++;

}

p++;

length++;

}

return length;

}

/// To remain compatible with the old implementation (which forked a process

/// for writing) the entire text is copied to a temporary buffer before the

/// event loop starts. If we don'</literal><macro><name>t</name> <argument_list>(<argument>by writing in chunks returned by `ml_get`</argument>)</argument_list></macro>

<specifier>static</specifier> <name>void</name> <macro><name>read_input</name><argument_list>(<argument>DynamicBuffer *buf</argument>)</argument_list></macro>

<block>{

<expr><name>size_t</name> <name>written</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<name>linenr_T</name> <name>lnum</name> <operator>=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_op_start</name><operator>.</operator><name>lnum</name></name></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>ml_get</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lp</name> <operator>+</operator> <name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lp</name><index>[<expr><name>written</name></expr>]</index></name> <operator>==</operator> <name>NL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dynamic_buffer_ensure</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>lp</name> <operator>+</operator> <name>written</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>s</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>s</name> <operator>-</operator> <operator>(</operator><name>lp</name> <operator>+</operator> <name>written</name><operator>)</operator><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dynamic_buffer_ensure</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>lp</name> <operator>+</operator> <name>written</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>!=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_op_end</name><operator>.</operator><name>lnum</name></name>

<operator>||</operator> <operator>(</operator><operator>!</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_bin</name></name> <operator>&amp;&amp;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_p_fixeol</name></name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>lnum</name> <operator>!=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_no_eol_lnum</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>lnum</name> <operator>!=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name> <operator>||</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_p_eol</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dynamic_buffer_ensure</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_op_end</name><operator>.</operator><name>lnum</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>write_output</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>remaining</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>eof</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>output</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>output</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>remaining</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>output</name><index>[<expr><name>off</name></expr>]</index></name> <operator>==</operator> <name>NL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>off</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name><operator>++</operator></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>skip</name> <init>= <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>output</name> <operator>+=</operator> <name>skip</name></expr>;</expr_stmt>

<expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>skip</name></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>output</name><index>[<expr><name>off</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>output</name><index>[<expr><name>off</name></expr>]</index></name> <operator>=</operator> <name>NL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>eof</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name><operator>++</operator></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_no_eol_lnum</name></name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>output</name> <operator>+=</operator> <name>remaining</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_no_eol_lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ui_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>output</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shell_write_cb</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>msg_schedule_emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E5677: Error writing input to shell-command: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>uv_err_name</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shell_xescape_xquote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sxq</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ecmd</name> <init>= <expr><name>cmd</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sxe</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>p_sxq</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecmd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strsave_escaped_ext</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr></argument>, <argument><expr><name>p_sxe</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ncmd_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>ecmd</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p_sxq</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ncmd</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>ncmd_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p_sxq</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>ncmd_size</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>ecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p_sxq</name></expr></argument>, <argument><expr><literal type="string">"\"("</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>ncmd_size</name></expr></argument>, <argument><expr><literal type="string">"\"(%s)\""</literal></expr></argument>, <argument><expr><name>ecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>ncmd_size</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>p_sxq</name></expr></argument>, <argument><expr><name>ecmd</name></expr></argument>, <argument><expr><name>p_sxq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecmd</name> <operator>!=</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ncmd</name></expr>;</return>

</block_content>}</block></function></block_content></block>

</unit>
