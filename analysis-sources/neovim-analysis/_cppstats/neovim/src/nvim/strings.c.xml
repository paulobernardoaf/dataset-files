<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\strings.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/assert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/strings.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/file_search.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/edit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_cmds.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_docmd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_getln.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/func_attr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fold.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/func_attr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/getchar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mark.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/math.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memfile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/move.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ops.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os_unix.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/quickfix.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/screen.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/search.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/spell.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/syntax.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/tag.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/window.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/shell.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/encode.h"</cpp:file></cpp:include>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strsave</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>xstrdup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strnsave</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>strncpy</name><argument_list>(<argument><expr><call><name>xmallocz</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strsave_escaped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>esc_chars</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<return>return <expr><call><name>vim_strsave_escaped_ext</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strsave_escaped_ext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>esc_chars</name></decl></parameter>,

<parameter><decl><type><name>char_u</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bsl</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>length</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>bsl</name> <operator>&amp;&amp;</operator> <call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

</block_content>}</block></for>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>escaped_string</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>escaped_string</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>bsl</name> <operator>&amp;&amp;</operator> <call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <name>cc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>escaped_string</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>vim_strnsave_unquoted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>

FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL

FUNC_ATTR_NONNULL_RET

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPE_COND</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>inquote</name></type></parameter>, <parameter><type><name>string_end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*p == '\\' &amp;&amp; inquote &amp;&amp; p + 1 &lt; string_end &amp;&amp; (p[1] == '\\' || p[1] == '"'))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>size_t</name></type> <name>ret_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>inquote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string_end</name> <init>= <expr><name>string</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>string_end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inquote</name> <operator>=</operator> <operator>!</operator><name>inquote</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ESCAPE_COND</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inquote</name></expr></argument>, <argument><expr><name>string_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret_length</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ret_length</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>xmallocz</name><argument_list>(<argument><expr><name>ret_length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>string_end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inquote</name> <operator>=</operator> <operator>!</operator><name>inquote</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ESCAPE_COND</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inquote</name></expr></argument>, <argument><expr><name>string_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ESCAPE_COND</name></cpp:undef>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strsave_shellescape</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,

<parameter><decl><type><name>bool</name></type> <name>do_special</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_newline</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>escaped_string</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>csh_like</name></decl>;</decl_stmt>

<expr_stmt><expr><name>csh_like</name> <operator>=</operator> <call><name>csh_like_shell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> 

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_newline</name><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_special</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>csh_like</name> <operator>&amp;&amp;</operator> <name>do_special</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_special</name> <operator>&amp;&amp;</operator> <call><name>find_cmdline_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>escaped_string</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>escaped_string</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_newline</name><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_special</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>csh_like</name> <operator>&amp;&amp;</operator> <name>do_special</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_special</name> <operator>&amp;&amp;</operator> <call><name>find_cmdline_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt> 

<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>!=</operator> <name>SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MB_COPY_CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>escaped_string</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strsave_up</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strup</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p1</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strnsave_up</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>vim_strnsave</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_strup</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p1</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>vim_strup</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name>c</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'a'</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="char">'z'</literal></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>c</name> <operator>-</operator> <literal type="number">0x20</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>strcase_save</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>upper</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>res</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>utf_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>uc</name> <init>= <expr><ternary><condition><expr><name>upper</name></expr> ?</condition><then> <expr><call><name>mb_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>mb_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newl</name> <init>= <expr><call><name>utf_char2len</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newl</name> <operator>!=</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>newl</name> <operator>-</operator> <name>l</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator> <operator>+</operator> <name>newl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>newl</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>del_trailing_spaces</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>--</operator><name>q</name> <operator>&gt;</operator> <name>ptr</name> <operator>&amp;&amp;</operator> <call><name>ascii_iswhite</name><argument_list>(<argument><expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>Ctrl_V</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRCASECMP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRICMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<function><type><name>int</name></type> <name>vim_stricmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>s1</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>s2</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNCASECMP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNICMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<function><type><name>int</name></type> <name>vim_strnicmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>s1</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>s2</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>vim_strchr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>strchr</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>u8char</name><index>[<expr><name>MB_MAXBYTES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>u8char</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>u8char</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>, <argument><expr><name>u8char</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strings.c.generated.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>sort_strings</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>files</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>files</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>bool</name></type> <name>has_non_ascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

FUNC_ATTR_PURE

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name></type> <name>has_non_ascii_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_PURE

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type><name>concat_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>str1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>str2</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>l</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>dest</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dest</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e_printf</name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E766: Insufficient arguments for printf()"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>varnumber_T</name></type> <name>tv_nr</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tvs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>idxp</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>idxp</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_printf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>idxp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_str</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tvs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>idxp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>tofree</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>idxp</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_printf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>idxp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_STRING</name> <operator>||</operator> <name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tofree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>tofree</name> <operator>=</operator> <call><name>encode_tv2echo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>tv_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tvs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>idxp</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(union typval_vval_union, attr)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(

<argument><expr><call><name>OFF</name><argument_list>(<argument><expr><name>v_string</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OFF</name><argument_list>(<argument><expr><name>v_list</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>OFF</name><argument_list>(<argument><expr><name>v_string</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OFF</name><argument_list>(<argument><expr><name>v_dict</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>OFF</name><argument_list>(<argument><expr><name>v_string</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>OFF</name><argument_list>(<argument><expr><name>v_partial</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></sizeof>

<operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>)</argument_list></sizeof>

<operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_partial</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><literal type="string">"Strings, dictionaries, lists and partials are expected to be pointers, "</literal>

<literal type="string">"so that all three of them can be accessed via v_string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFF</name></cpp:undef>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>idxp</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_printf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>idxp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float_T</name></type> <name>tv_float</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tvs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>idxp</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>idxp</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float_T</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_printf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>idxp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_float</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>float_T</name><operator>)</operator><name><name>tvs</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E807: Expected Float argument for printf()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>f</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>vim_snprintf_add</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_m</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

FUNC_ATTR_PRINTF<parameter_list>(</parameter_list>3<operator>,</operator> 4</function>)

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>space</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_m</name> <operator>&lt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>space</name> <operator>=</operator> <name>str_m</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>str_l</name> <init>= <expr><call><name>vim_vsnprintf</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>space</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str_l</name></expr>;</return>

</block_content>}</block>

<function><type><name>int</name></type> <name>vim_snprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

FUNC_ATTR_PRINTF<parameter_list>(</parameter_list>3<operator>,</operator> 4</function>)

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>str_l</name> <init>= <expr><call><name>vim_vsnprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_m</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str_l</name></expr>;</return>

</block_content>}</block>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>infinity_str</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>positive</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>fmt_spec</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>force_sign</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>space_for_positive</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>table</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"-inf"</literal></expr>, <expr><literal type="string">"inf"</literal></expr>, <expr><literal type="string">"+inf"</literal></expr>, <expr><literal type="string">" inf"</literal></expr>,

<expr><literal type="string">"-INF"</literal></expr>, <expr><literal type="string">"INF"</literal></expr>, <expr><literal type="string">"+INF"</literal></expr>, <expr><literal type="string">" INF"</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>positive</name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>force_sign</name> <operator>+</operator> <name>force_sign</name> <operator>*</operator> <name>space_for_positive</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ASCII_ISUPPER</name><argument_list>(<argument><expr><name>fmt_spec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>vim_vsnprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vim_vsnprintf_typval</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_m</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>vim_vsnprintf_typval</name><parameter_list>(

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tvs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>str_l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>str_avail</name> <init>= <expr><name>str_l</name> <operator>&lt;</operator> <name>str_m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>fmt</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_idx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><call><name>xstrchrnul</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>n</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>min_field_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>precision</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>zero_padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>precision_specified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>justify_left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>alternate_form</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>force_sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>space_for_positive</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>length_modifier</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP_LEN</name></cpp:macro> <cpp:value>350</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>TMP_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>str_arg_l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>uchar_arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>number_of_zeros_to_pad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>zero_padding_insertion_ind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>fmt_spec</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> 

<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> <expr_stmt><expr><name>zero_padding</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name>justify_left</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> <expr_stmt><expr><name>force_sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>space_for_positive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <expr_stmt><expr><name>force_sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<case>case <expr><literal type="char">'#'</literal></expr>:</case> <expr_stmt><expr><name>alternate_form</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<case>case <expr><literal type="char">'\''</literal></expr>:</case> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <continue>continue;</continue>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>min_field_width</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>j</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>min_field_width</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><name>j</name></expr>;</expr_stmt>

<expr_stmt><expr><name>justify_left</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>uj</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>uj</name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name>uj</name> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>min_field_width</name> <operator>=</operator> <name>uj</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>precision_specified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>j</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>precision_specified</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>uj</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>uj</name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name>uj</name> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>uj</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'h'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>length_modifier</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <literal type="char">'2'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>fmt_spec</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> <expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'U'</literal></expr>:</case> <expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'O'</literal></expr>:</case> <expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <literal type="char">'o'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>fmt_spec</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case> <case>case <expr><literal type="char">'o'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>tvs</name> <operator>&amp;&amp;</operator> <name>length_modifier</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>length_modifier</name> <operator>=</operator> <literal type="char">'2'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>fmt_spec</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'%'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <case>case <expr><literal type="char">'s'</literal></expr>:</case> <case>case <expr><literal type="char">'S'</literal></expr>:</case>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>fmt_spec</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'%'</literal></expr>:</case>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>uchar_arg</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>j</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>uchar_arg</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<case>case <expr><literal type="char">'S'</literal></expr>:</case>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><call><name>tv_str</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <literal type="string">"[NULL]"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>precision_specified</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>precision</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>xmemscan</name><argument_list>(<argument><expr><name>str_arg</name></expr></argument>,

<argument><expr><name>NUL</name></expr></argument>,

<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>precision</name></expr></argument>,

<argument><expr><literal type="number">0x7fffffff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>

<operator>-</operator> <name>str_arg</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>min_field_width</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>min_field_width</name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>str_arg</name></expr></argument>)</argument_list></call>

<operator>-</operator> <call><name>mb_string2cells</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>str_arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>precision</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>str_arg</name></expr>;</init> <condition><expr><operator>*</operator><name>p1</name></expr>;</condition>

<incr><expr><name>p1</name> <operator>+=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>utf_ptr2cells</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>precision</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <name>precision</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p1</name> <operator>-</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>str_arg</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>arg_sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>intmax_t</name></type> <name>arg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uintmax_t</name></type> <name>uarg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr_arg</name> <operator>=</operator> <ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><call><name>tv_ptr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg_sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>length_modifier</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'2'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator>

<ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> 

</then><else>: <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>long long</argument>)</argument_list></macro><expr/></else></ternary><operator>)</operator></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'z'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg_sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>arg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg_sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch <condition>(<expr><name>length_modifier</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>uarg</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro><expr/></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>uarg</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned int</argument>)</argument_list></macro><expr/></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>uarg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned long</argument>)</argument_list></macro><expr/></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'2'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>uarg</name> <operator>=</operator> <operator>(</operator><name>uintmax_t</name><operator>)</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><operator>(</operator> 

<ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> 

<call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>

</then><else>: <macro><name>va_arg</name><argument_list>(<argument>ap</argument>, <argument>unsigned long long</argument>)</argument_list></macro><expr/></else></ternary><operator>)</operator></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'z'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>uarg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>tvs</name></expr>

?</condition><then> <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>tv_nr</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><name>arg_sign</name> <operator>=</operator> <operator>(</operator><name>uarg</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>precision_specified</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zero_padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>force_sign</name> <operator>&amp;&amp;</operator> <name>arg_sign</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>str_arg_l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>space_for_positive</name></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>alternate_form</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg_sign</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>fmt_spec</name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'X'</literal>

<operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>str_arg_l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>str_arg_l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>fmt_spec</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>zero_padding_insertion_ind</name> <operator>=</operator> <name>str_arg_l</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>precision_specified</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>arg_sign</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch <condition>(<expr><name>fmt_spec</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> <block>{<block_content> 

<expr_stmt><expr><name>str_arg_l</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name> <operator>+</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>ptr_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content> 

<expr_stmt><expr><name>str_arg_l</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name> <operator>+</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><literal type="string">"%"</literal> <name>PRIdMAX</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>size_t</name></type> <name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>bits</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uarg</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><name>bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>str_arg_l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>uarg</name> <operator>&gt;&gt;</operator> <operator>--</operator><name>bits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'1'</literal></expr> </then><else>: <expr><literal type="char">'0'</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></while>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name></type> <name><name>f</name><index>[]</index></name> <init>= <expr><literal type="string">"%"</literal> <name>PRIuMAX</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>f</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PRIuMAX</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fmt_spec</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>PRIuMAX</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PRIuMAX</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name> <operator>+</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>str_arg_l</name></expr></argument>,

<argument><expr><name>f</name></expr></argument>, <argument><expr><name>uarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str_arg_l</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>zero_padding_insertion_ind</name> <operator>&lt;</operator> <name>str_arg_l</name>

<operator>&amp;&amp;</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zero_padding_insertion_ind</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>zero_padding_insertion_ind</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>str_arg_l</name>

<operator>&amp;&amp;</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal>

<operator>||</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal>

<operator>||</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal>

<operator>||</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zero_padding_insertion_ind</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>num_of_digits</name> <init>= <expr><name>str_arg_l</name> <operator>-</operator> <name>zero_padding_insertion_ind</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>alternate_form</name> <operator>&amp;&amp;</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'o'</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>zero_padding_insertion_ind</name> <operator>&lt;</operator> <name>str_arg_l</name>

<operator>&amp;&amp;</operator> <name><name>tmp</name><index>[<expr><name>zero_padding_insertion_ind</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>precision_specified</name>

<operator>||</operator> <name>precision</name> <operator>&lt;</operator> <name>num_of_digits</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>num_of_digits</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num_of_digits</name> <operator>&lt;</operator> <name>precision</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>number_of_zeros_to_pad</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>num_of_digits</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>justify_left</name> <operator>&amp;&amp;</operator> <name>zero_padding</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>min_field_width</name> <operator>-</operator> <operator>(</operator><name>str_arg_l</name>

<operator>+</operator> <name>number_of_zeros_to_pad</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>number_of_zeros_to_pad</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<case>case <expr><literal type="char">'F'</literal></expr>:</case>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<case>case <expr><literal type="char">'E'</literal></expr>:</case>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<case>case <expr><literal type="char">'G'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>format</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>remove_trailing_zeroes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>f</name> <init>= <expr><ternary><condition><expr><name>tvs</name></expr> ?</condition><then> <expr><call><name>tv_float</name><argument_list>(<argument><expr><name>tvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_idx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>abs_f</name> <init>= <expr><ternary><condition><expr><name>f</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>f</name></expr> </then><else>: <expr><name>f</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'g'</literal> <operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'G'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>abs_f</name> <operator>&gt;=</operator> <literal type="number">0.001</literal> <operator>&amp;&amp;</operator> <name>abs_f</name> <operator>&lt;</operator> <literal type="number">10000000.0</literal><operator>)</operator> <operator>||</operator> <name>abs_f</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <ternary><condition><expr><call><name>ASCII_ISUPPER</name><argument_list>(<argument><expr><name>fmt_spec</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'F'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fmt_spec</name> <operator>=</operator> <ternary><condition><expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'g'</literal></expr> ?</condition><then> <expr><literal type="char">'e'</literal></expr> </then><else>: <expr><literal type="char">'E'</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>remove_trailing_zeroes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>xisinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"fF"</literal></expr></argument>, <argument><expr><name>fmt_spec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>abs_f</name> <operator>&gt;</operator> <literal type="number">1.0e307</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>infinity_str</name><argument_list>(<argument><expr><name>f</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr></argument>, <argument><expr><name>fmt_spec</name></expr></argument>,

<argument><expr><name>force_sign</name></expr></argument>, <argument><expr><name>space_for_positive</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zero_padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>xisnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>ASCII_ISUPPER</name><argument_list>(<argument><expr><name>fmt_spec</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"NAN"</literal></expr> </then><else>: <expr><literal type="string">"nan"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>zero_padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>format</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>force_sign</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>format</name><index>[<expr><name>l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>space_for_positive</name></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'+'</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>precision_specified</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>max_prec</name> <init>= <expr><name>TMP_LEN</name> <operator>-</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmt_spec</name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'F'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>abs_f</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_prec</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>log10</name><argument_list>(<argument><expr><name>abs_f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&gt;</operator> <name>max_prec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>max_prec</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>format</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>l</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>format</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'F'</literal></expr> ?</condition><then> <expr><literal type="char">'f'</literal></expr> </then><else>: <expr><name>fmt_spec</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>format</name><index>[<expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str_arg_l</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>remove_trailing_zeroes</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name>fmt_spec</name> <operator>==</operator> <literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tp</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <name>str_arg_l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'e'</literal></expr> ?</condition><then> <expr><literal type="char">'e'</literal></expr> </then><else>: <expr><literal type="char">'E'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>tp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>tp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>tp</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>tp</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>precision_specified</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>tp</name> <operator>&gt;</operator> <name>tmp</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tp</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tp</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>fmt_spec</name> <operator>==</operator> <literal type="char">'e'</literal></expr> ?</condition><then> <expr><literal type="char">'e'</literal></expr> </then><else>: <expr><literal type="char">'E'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal>

<operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>tp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>tp</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>zero_padding</name> <operator>&amp;&amp;</operator> <name>min_field_width</name> <operator>&gt;</operator> <name>str_arg_l</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>force_sign</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>number_of_zeros_to_pad</name> <operator>=</operator> <name>min_field_width</name> <operator>-</operator> <name>str_arg_l</name></expr>;</expr_stmt>

<expr_stmt><expr><name>zero_padding_insertion_ind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><name>zero_padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>justify_left</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>min_field_width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str_arg_l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_arg_l</name><operator>++</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>justify_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str_arg_l</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>number_of_zeros_to_pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_field_width</name> <operator>&gt;</operator> <name>str_arg_l</name> <operator>+</operator> <name>number_of_zeros_to_pad</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>pn</name> <init>= <expr><name>min_field_width</name> <operator>-</operator> <operator>(</operator><name>str_arg_l</name> <operator>+</operator> <name>number_of_zeros_to_pad</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zero_padding</name></expr> ?</condition><then> <expr><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>pn</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pn</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>pn</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>number_of_zeros_to_pad</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zero_padding_insertion_ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>zero_padding_insertion_ind</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name> <init>= <expr><name>zero_padding_insertion_ind</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>, <argument><expr><name>str_arg</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>zn</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zn</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>zn</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>zn</name> <init>= <expr><name>number_of_zeros_to_pad</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>zn</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>zn</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zn</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>zn</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_arg_l</name> <operator>&gt;</operator> <name>zero_padding_insertion_ind</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sn</name> <init>= <expr><name>str_arg_l</name> <operator>-</operator> <name>zero_padding_insertion_ind</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>,

<argument><expr><name>str_arg</name> <operator>+</operator> <name>zero_padding_insertion_ind</name></expr></argument>,

<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>sn</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sn</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>sn</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>justify_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str_arg_l</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>number_of_zeros_to_pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_field_width</name> <operator>&gt;</operator> <name>str_arg_l</name> <operator>+</operator> <name>number_of_zeros_to_pad</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>pn</name> <init>= <expr><name>min_field_width</name> <operator>-</operator> <operator>(</operator><name>str_arg_l</name> <operator>+</operator> <name>number_of_zeros_to_pad</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_avail</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>avail</name> <init>= <expr><name>str_m</name> <operator>-</operator> <name>str_l</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>str_l</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_avail</name> <operator>=</operator> <name>pn</name> <operator>&lt;</operator> <name>avail</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pn</name> <operator>&lt;=</operator> <name>SIZE_MAX</name> <operator>-</operator> <name>str_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_l</name> <operator>+=</operator> <name>pn</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>str_m</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>str</name><index>[<expr><ternary><condition><expr><name>str_l</name> <operator>&lt;=</operator> <name>str_m</name> <operator>-</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>str_l</name></expr> </then><else>: <expr><name>str_m</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tvs</name> <operator>&amp;&amp;</operator> <name><name>tvs</name><index>[<expr><name>arg_idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E767: Too many arguments to printf()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>str_l</name></expr>;</return>

</block_content>}</block></function>

</unit>
