<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\viml\parser\expressions.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/viml/parser/parser.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kCCStrategyUseOption</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 

<decl><name>kCCStrategyMatchCase</name> <init>= <expr><literal type="char">'#'</literal></expr></init></decl>,

<decl><name>kCCStrategyIgnoreCase</name> <init>= <expr><literal type="char">'?'</literal></expr></init></decl>,

}</block></enum></type> <name>ExprCaseCompareStrategy</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprLexInvalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 

<decl><name>kExprLexMissing</name></decl>, 

<decl><name>kExprLexSpacing</name></decl>, 

<decl><name>kExprLexEOC</name></decl>, 

<decl><name>kExprLexQuestion</name></decl>, 

<decl><name>kExprLexColon</name></decl>, 

<decl><name>kExprLexOr</name></decl>, 

<decl><name>kExprLexAnd</name></decl>, 

<decl><name>kExprLexComparison</name></decl>, 

<decl><name>kExprLexPlus</name></decl>, 

<decl><name>kExprLexMinus</name></decl>, 

<decl><name>kExprLexDot</name></decl>, 

<decl><name>kExprLexMultiplication</name></decl>, 

<decl><name>kExprLexNot</name></decl>, 

<decl><name>kExprLexNumber</name></decl>, 

<decl><name>kExprLexSingleQuotedString</name></decl>, 

<decl><name>kExprLexDoubleQuotedString</name></decl>, 

<decl><name>kExprLexOption</name></decl>, 

<decl><name>kExprLexRegister</name></decl>, 

<decl><name>kExprLexEnv</name></decl>, 

<decl><name>kExprLexPlainIdentifier</name></decl>, 

<decl><name>kExprLexBracket</name></decl>, 

<decl><name>kExprLexFigureBrace</name></decl>, 

<decl><name>kExprLexParenthesis</name></decl>, 

<decl><name>kExprLexComma</name></decl>, 

<decl><name>kExprLexArrow</name></decl>, 

<decl><name>kExprLexAssignment</name></decl>, 

}</block></enum></type> <name>LexExprTokenType</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprCmpEqual</name></decl>, 

<decl><name>kExprCmpMatches</name></decl>, 

<decl><name>kExprCmpGreater</name></decl>, 

<decl><name>kExprCmpGreaterOrEqual</name></decl>, 

<decl><name>kExprCmpIdentical</name></decl>, 

}</block></enum></type> <name>ExprComparisonType</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprOptScopeUnspecified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>kExprOptScopeGlobal</name> <init>= <expr><literal type="char">'g'</literal></expr></init></decl>,

<decl><name>kExprOptScopeLocal</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>,

}</block></enum></type> <name>ExprOptScope</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprAsgnPlain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 

<decl><name>kExprAsgnAdd</name></decl>, 

<decl><name>kExprAsgnSubtract</name></decl>, 

<decl><name>kExprAsgnConcat</name></decl>, 

}</block></enum></type> <name>ExprAssignmentType</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR_OPT_SCOPE_LIST</name></cpp:macro> <cpp:value>((char[]){ kExprOptScopeGlobal, kExprOptScopeLocal })</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprVarScopeMissing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>kExprVarScopeScript</name> <init>= <expr><literal type="char">'s'</literal></expr></init></decl>,

<decl><name>kExprVarScopeGlobal</name> <init>= <expr><literal type="char">'g'</literal></expr></init></decl>,

<decl><name>kExprVarScopeVim</name> <init>= <expr><literal type="char">'v'</literal></expr></init></decl>,

<decl><name>kExprVarScopeBuffer</name> <init>= <expr><literal type="char">'b'</literal></expr></init></decl>,

<decl><name>kExprVarScopeWindow</name> <init>= <expr><literal type="char">'w'</literal></expr></init></decl>,

<decl><name>kExprVarScopeTabpage</name> <init>= <expr><literal type="char">'t'</literal></expr></init></decl>,

<decl><name>kExprVarScopeLocal</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>,

<decl><name>kExprVarScopeArguments</name> <init>= <expr><literal type="char">'a'</literal></expr></init></decl>,

}</block></enum></type> <name>ExprVarScope</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR_VAR_SCOPE_LIST</name></cpp:macro> <cpp:value>((char[]) { kExprVarScopeScript, kExprVarScopeGlobal, kExprVarScopeVim, kExprVarScopeBuffer, kExprVarScopeWindow, kExprVarScopeTabpage, kExprVarScopeLocal, kExprVarScopeBuffer, kExprVarScopeArguments, })</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ParserPosition</name></type> <name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LexExprTokenType</name></type> <name>type</name></decl>;</decl_stmt>

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprComparisonType</name></type> <name>type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ExprCaseCompareStrategy</name></type> <name>ccs</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>inv</name></decl>;</decl_stmt> 

}</block> <decl><name>cmp</name></decl>;</struct> 

<struct>struct <block>{

<enum>enum <block>{

<decl><name>kExprLexMulMul</name></decl>, 

<decl><name>kExprLexMulDiv</name></decl>, 

<decl><name>kExprLexMulMod</name></decl>, 

}</block> <decl><name>type</name></decl>;</enum> 

}</block> <decl><name>mul</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>closing</name></decl>;</decl_stmt> 

}</block> <decl><name>brc</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt> 

}</block> <decl><name>reg</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>closed</name></decl>;</decl_stmt> 

}</block> <decl><name>str</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ExprOptScope</name></type> <name>scope</name></decl>;</decl_stmt> 

}</block> <decl><name>opt</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprVarScope</name></type> <name>scope</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>autoload</name></decl>;</decl_stmt> 

}</block> <decl><name>var</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>LexExprTokenType</name></type> <name>type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt> 

}</block> <decl><name>err</name></decl>;</struct> 

<struct>struct <block>{

<union>union <block>{

<decl_stmt><decl><type><name>float_T</name></type> <name>floating</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>integer</name></decl>;</decl_stmt>

}</block> <decl><name>val</name></decl>;</union> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>base</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>is_float</name></decl>;</decl_stmt> 

}</block> <decl><name>num</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprAssignmentType</name></type> <name>type</name></decl>;</decl_stmt>

}</block> <decl><name>ass</name></decl>;</struct> 

}</block> <decl><name>data</name></decl>;</union> 

}</block></struct></type> <name>LexExprToken</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kELFlagPeek</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>,

<decl><name>kELFlagForbidScope</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,

<decl><name>kELFlagAllowFloat</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>,

<decl><name>kELFlagIsNotCmp</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>,

<decl><name>kELFlagForbidEOC</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>,

}</block></enum></type> <name>LexExprFlags</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>kExprNodeMissing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>kExprNodeOpMissing</name></decl>,

<decl><name>kExprNodeTernary</name></decl>, 

<decl><name>kExprNodeTernaryValue</name></decl>, 

<decl><name>kExprNodeRegister</name></decl>, 

<decl><name>kExprNodeSubscript</name></decl>, 

<decl><name>kExprNodeListLiteral</name></decl>, 

<decl><name>kExprNodeUnaryPlus</name></decl>,

<decl><name>kExprNodeBinaryPlus</name></decl>,

<decl><name>kExprNodeNested</name></decl>, 

<decl><name>kExprNodeCall</name></decl>, 

<decl><name>kExprNodePlainIdentifier</name></decl>,

<decl><name>kExprNodePlainKey</name></decl>,

<decl><name>kExprNodeComplexIdentifier</name></decl>,

<decl><name>kExprNodeUnknownFigure</name></decl>,

<decl><name>kExprNodeLambda</name></decl>, 

<decl><name>kExprNodeDictLiteral</name></decl>, 

<decl><name>kExprNodeCurlyBracesIdentifier</name></decl>, 

<decl><name>kExprNodeComma</name></decl>, 

<decl><name>kExprNodeColon</name></decl>, 

<decl><name>kExprNodeArrow</name></decl>, 

<decl><name>kExprNodeComparison</name></decl>, 

<decl><name>kExprNodeConcat</name></decl>,

<decl><name>kExprNodeConcatOrSubscript</name></decl>,

<decl><name>kExprNodeInteger</name></decl>, 

<decl><name>kExprNodeFloat</name></decl>, 

<decl><name>kExprNodeSingleQuotedString</name></decl>,

<decl><name>kExprNodeDoubleQuotedString</name></decl>,

<decl><name>kExprNodeOr</name></decl>,

<decl><name>kExprNodeAnd</name></decl>,

<decl><name>kExprNodeUnaryMinus</name></decl>,

<decl><name>kExprNodeBinaryMinus</name></decl>,

<decl><name>kExprNodeNot</name></decl>,

<decl><name>kExprNodeMultiplication</name></decl>,

<decl><name>kExprNodeDivision</name></decl>,

<decl><name>kExprNodeMod</name></decl>,

<decl><name>kExprNodeOption</name></decl>,

<decl><name>kExprNodeEnvironment</name></decl>,

<decl><name>kExprNodeAssignment</name></decl>,

}</block></enum></type> <name>ExprASTNodeType</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>expr_ast_node</name></name></type> <name>ExprASTNode</name>;</typedef>

<struct>struct <name>expr_ast_node</name> <block>{

<decl_stmt><decl><type><name>ExprASTNodeType</name></type> <name>type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ParserPosition</name></type> <name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>name</name></decl>;</decl_stmt> 

}</block> <decl><name>reg</name></decl>;</struct> 

<struct>struct <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>allow_dict</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>allow_lambda</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>allow_ident</name></decl>;</decl_stmt>

}</block> <decl><name>type_guesses</name></decl>;</struct>

<decl_stmt><decl><type><name>size_t</name></type> <name>opening_hl_idx</name></decl>;</decl_stmt>

}</block> <decl><name>fig</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprVarScope</name></type> <name>scope</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ident_len</name></decl>;</decl_stmt> 

}</block> <decl><name>var</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>got_colon</name></decl>;</decl_stmt> 

}</block> <decl><name>ter</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprComparisonType</name></type> <name>type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ExprCaseCompareStrategy</name></type> <name>ccs</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>inv</name></decl>;</decl_stmt> 

}</block> <decl><name>cmp</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>value</name></decl>;</decl_stmt>

}</block> <decl><name>num</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>float_T</name></type> <name>value</name></decl>;</decl_stmt>

}</block> <decl><name>flt</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

}</block> <decl><name>str</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>ident_len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ExprOptScope</name></type> <name>scope</name></decl>;</decl_stmt> 

}</block> <decl><name>opt</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>ident_len</name></decl>;</decl_stmt> 

}</block> <decl><name>env</name></decl>;</struct> 

<struct>struct <block>{

<decl_stmt><decl><type><name>ExprAssignmentType</name></type> <name>type</name></decl>;</decl_stmt>

}</block> <decl><name>ass</name></decl>;</struct> 

}</block> <decl><name>data</name></decl>;</union>

}</block>;</struct>

<enum>enum <name>ExprParserFlags</name> <block>{

<decl><name>kExprFlagsMulti</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>,

<decl><name>kExprFlagsDisallowEOC</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,

<decl><name>kExprFlagsParseLet</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>,

}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_len</name></decl>;</decl_stmt>

}</block></struct></type> <name>ExprASTError</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ExprASTError</name></type> <name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

}</block></struct></type> <name>ExprAST</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>node_maxchildren</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>east_node_type_tab</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>eltkn_cmp_type_tab</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ccs_tab</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>expr_asgn_type_tab</name><index>[]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"viml/parser/expressions.h.generated.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
