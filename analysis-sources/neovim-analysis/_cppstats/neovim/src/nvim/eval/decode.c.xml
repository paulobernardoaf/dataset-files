<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\eval\decode.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;msgpack.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/decode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/encode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/macros.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/globals.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include> 

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>stack_index</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>special_val</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>typval_T</name></type> <name>container</name></decl>;</decl_stmt> 

}</block></struct></type> <name>ContainerStackItem</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>is_special_string</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>didcomma</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>didcolon</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>typval_T</name></type> <name>val</name></decl>;</decl_stmt> 

}</block></struct></type> <name>ValuesStackItem</name>;</typedef>

<typedef>typedef <macro><name>kvec_t</name><argument_list>(<argument>ValuesStackItem</argument>)</argument_list></macro> <expr_stmt><expr><name>ValuesStack</name></expr>;</expr_stmt></typedef>

<typedef>typedef <macro><name>kvec_t</name><argument_list>(<argument>ContainerStackItem</argument>)</argument_list></macro> <expr_stmt><expr><name>ContainerStack</name></expr>;</expr_stmt></typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval/decode.c.generated.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>create_special_dict</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rettv</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>MessagePackType</name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name></type> <name>val</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>type_di</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"_TYPE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <operator>(</operator><name>list_T</name> <operator>*</operator><operator>)</operator><name><name>eval_msgpack_type_lists</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>type_di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>val_di</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"_VAL"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>val_di</name><operator>-&gt;</operator><name>di_tv</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>val_di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_DICT</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_dict</name> <operator>=</operator> <name>dict</name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_LEN</name><parameter_list>(<parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(dict)-&gt;dv_hashtab.ht_used</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>json_decoder_pop</name><parameter_list>(<parameter><decl><type><name>ValuesStackItem</name></type> <name>obj</name></decl></parameter>,

<parameter><decl><type><name>ValuesStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stack</name></decl></parameter>,

<parameter><decl><type><name>ContainerStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>container_stack</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>pp</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>next_map_special</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcomma</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcolon</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>kv_push</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ContainerStackItem</name></type> <name>last_container</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><operator>*</operator><name>container_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val_location</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name>

<operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><operator>*</operator><name>container_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val_location</name> <operator>=</operator> <name><name>last_container</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>last_container</name> <operator>=</operator> <call><name>kv_last</name><argument_list>(<argument><expr><operator>*</operator><name>container_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><name><name>obj</name><operator>.</operator><name>didcomma</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected comma before list item: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>stack_index</name></name> <operator>==</operator> <call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>.</operator><name>didcolon</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected colon before dictionary value: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>val_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ValuesStackItem</name></type> <name>key</name> <init>= <expr><call><name>kv_pop</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>key</name><operator>.</operator><name>is_special_string</name></name>

<operator>||</operator> <name><name>key</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>*</operator><name><name>key</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NUL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>obj_di</name> <init>= <expr><call><name>tv_dict_item_alloc</name><argument_list>(

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>key</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>, <argument><expr><name>obj_di</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>obj_di</name><operator>-&gt;</operator><name>di_tv</name></name> <operator>=</operator> <name><name>obj</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>kv_pair</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_append_list</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name></expr></argument>, <argument><expr><name>kv_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name>kv_pair</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name>kv_pair</name></expr></argument>, <argument><expr><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>.</operator><name>is_special_string</name></name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected string key: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>.</operator><name>didcomma</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>last_container</name><operator>.</operator><name>special_val</name></name> <operator>==</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><call><name>DICT_LEN</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected comma before dictionary key: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name> <operator>==</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>obj</name><operator>.</operator><name>is_special_string</name></name>

<operator>||</operator> <name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>*</operator><name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <call><name>tv_dict_find</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><operator>*</operator><name>container_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ValuesStackItem</name></type> <name>last_container_val</name> <init>=

<expr><call><name>kv_A</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>, <argument><expr><name><name>last_container</name><operator>.</operator><name>stack_index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>last_container</name><operator>.</operator><name>stack_index</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>kv_pop</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>)</argument_list></call><operator>.</operator><name>val</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>last_container</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>didcomma</name> <operator>=</operator> <name><name>last_container_val</name><operator>.</operator><name>didcomma</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>didcolon</name> <operator>=</operator> <name><name>last_container_val</name><operator>.</operator><name>didcolon</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>next_map_special</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>kv_push</name><argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LENP</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int) ((e) - (p))), (p)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJ</name><parameter_list>(<parameter><type><name>obj_tv</name></type></parameter>, <parameter><type><name>is_sp_string</name></type></parameter>, <parameter><type><name>didcomma_</name></type></parameter>, <parameter><type><name>didcolon_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ValuesStackItem) { .is_special_string = (is_sp_string), .val = (obj_tv), .didcomma = (didcomma_), .didcolon = (didcolon_), })</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>(<parameter><type><name>obj_tv</name></type></parameter>, <parameter><type><name>is_sp_string</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (json_decoder_pop(OBJ(obj_tv, is_sp_string, *didcomma, *didcolon), stack, container_stack, &amp;p, next_map_special, didcomma, didcolon) == FAIL) { goto parse_json_string_fail; } if (*next_map_special) { goto parse_json_string_ret; } } while (0)</cpp:value></cpp:define>

<function><type><name>list_T</name> <modifier>*</modifier></type><name>decode_create_map_special_dict</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_tv</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>create_special_dict</name><argument_list>(<argument>ret_tv</argument>, <argument>kMPMap</argument>, <argument>((typval_T) {

.v_type = VAR_LIST,

.v_lock = VAR_UNLOCKED,

.vval = { .v_list = list },

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>typval_T</name></type> <name>decode_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>TriState</name></type> <name>hasnul</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>binary</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>s_allocated</name></decl></parameter>)</parameter_list>

FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>really_hasnul</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>hasnul</name> <operator>==</operator> <name>kNone</name></expr>

?</condition><then> <expr><operator>(</operator><operator>(</operator><name>s</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>

</then><else>: <expr><operator>(</operator><name>bool</name><operator>)</operator><name>hasnul</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>really_hasnul</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>kListLenMayKnow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>

<macro><name>create_special_dict</name><argument_list>(<argument>&amp;tv</argument>, <argument>binary ? kMPBinary : kMPString</argument>, <argument>((typval_T) {

.v_type = VAR_LIST,

.v_lock = VAR_UNLOCKED,

.vval = { .v_list = list },

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>elw_ret</name> <init>= <expr><call><name>encode_list_write</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>list</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s_allocated</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>elw_ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>typval_T</name><operator>)</operator> <block>{ <expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>, <expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr> }</block></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>tv</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_STRING</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_string</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator>

<operator>(</operator><name>s</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>s_allocated</name><operator>)</operator> <operator>?</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>:</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr> }</block></expr>,

}</block></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_json_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buf_len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>pp</name></decl></parameter>,

<parameter><decl><type><name>ValuesStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stack</name></decl></parameter>,

<parameter><decl><type><name>ContainerStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>container_stack</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>next_map_special</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcomma</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcolon</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>buf_len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name> <init>= <expr><operator>++</operator><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unfinished escape sequence: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">4</literal> <operator>&gt;=</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unfinished unicode escape sequence: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>!</operator><call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>!</operator><call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>!</operator><call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected four hex digits after \\u: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unknown escape sequence: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>p_byte</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p_byte</name> <operator>&lt;</operator> <literal type="number">0x20</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: ASCII control characters cannot be present "</literal>

<literal type="string">"inside string: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ch</name> <init>= <expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>p_byte</name> <operator>==</operator> <name>ch</name>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>ch</name> <operator>==</operator> <literal type="number">0xC3</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x83</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Only UTF-8 strings allowed: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <literal type="number">0x10FFFF</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Only UTF-8 code points up to U+10FFFF "</literal>

<literal type="string">"are allowed to appear unescaped: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ch_len</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <call><name>utf_char2len</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ch_len</name> <operator>==</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>ch</name></expr> ?</condition><then> <expr><call><name>utf_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>ch_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>ch_len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected string end: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<macro><name>POP</name><argument_list>(<argument>((typval_T) {

.v_type = VAR_STRING,

.vval = { .v_string = NULL },

})</argument>, <argument>false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<goto>goto <name>parse_json_string_ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fst_in_pair</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_end</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>hasnul</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUT_FST_IN_PAIR</name><parameter_list>(<parameter><type><name>fst_in_pair</name></type></parameter>, <parameter><type><name>str_end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (fst_in_pair != 0) { str_end += utf_char2bytes(fst_in_pair, (char_u *) str_end); fst_in_pair = 0; } } while (0)</cpp:value></cpp:define>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>s</name></expr></init></decl>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>p</name></expr>;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PUT_FST_IN_PAIR</name><argument_list>(<argument><expr><name>fst_in_pair</name></expr></argument>, <argument><expr><name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>t</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>t</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>ubuf</name><index>[]</index></name> <init>= <expr><block>{ <expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>, <expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>, <expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>ch</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>ubuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>STR2NR_HEX</name> <operator>|</operator> <name>STR2NR_FORCE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hasnul</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>SURROGATE_HI_START</name> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <name>SURROGATE_HI_END</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PUT_FST_IN_PAIR</name><argument_list>(<argument><expr><name>fst_in_pair</name></expr></argument>, <argument><expr><name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fst_in_pair</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ch</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>SURROGATE_LO_START</name> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <name>SURROGATE_LO_END</name>

<operator>&amp;&amp;</operator> <name>fst_in_pair</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>full_char</name> <init>= <expr><operator>(</operator>

<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ch</name> <operator>-</operator> <name>SURROGATE_LO_START</name><operator>)</operator>

<operator>+</operator> <operator>(</operator><operator>(</operator><name>fst_in_pair</name> <operator>-</operator> <name>SURROGATE_HI_START</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator>

<operator>+</operator> <name>SURROGATE_FIRST_CHAR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str_end</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>full_char</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fst_in_pair</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>PUT_FST_IN_PAIR</name><argument_list>(<argument><expr><name>fst_in_pair</name></expr></argument>, <argument><expr><name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_end</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ch</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>escapes</name><index>[]</index></name> <init>= <expr><block>{

<expr><index>[<expr><literal type="char">'\\'</literal></expr>]</index> <operator>=</operator> <literal type="char">'\\'</literal></expr>,

<expr><index>[<expr><literal type="char">'/'</literal></expr>]</index> <operator>=</operator> <literal type="char">'/'</literal></expr>,

<expr><index>[<expr><literal type="char">'"'</literal></expr>]</index> <operator>=</operator> <literal type="char">'"'</literal></expr>,

<expr><index>[<expr><literal type="char">'t'</literal></expr>]</index> <operator>=</operator> <name>TAB</name></expr>,

<expr><index>[<expr><literal type="char">'b'</literal></expr>]</index> <operator>=</operator> <name>BS</name></expr>,

<expr><index>[<expr><literal type="char">'n'</literal></expr>]</index> <operator>=</operator> <name>NL</name></expr>,

<expr><index>[<expr><literal type="char">'r'</literal></expr>]</index> <operator>=</operator> <name>CAR</name></expr>,

<expr><index>[<expr><literal type="char">'f'</literal></expr>]</index> <operator>=</operator> <name>FF</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>str_end</name><operator>++</operator> <operator>=</operator> <name><name>escapes</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>t</name></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>str_end</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>t</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>PUT_FST_IN_PAIR</name><argument_list>(<argument><expr><name>fst_in_pair</name></expr></argument>, <argument><expr><name>str_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PUT_FST_IN_PAIR</name></cpp:undef>

<expr_stmt><expr><operator>*</operator><name>str_end</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>obj</name> <init>= <expr><call><name>decode_string</name><argument_list>(

<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>str_end</name> <operator>-</operator> <name>str</name><operator>)</operator></expr></argument>, <argument><expr><ternary><condition><expr><name>hasnul</name></expr> ?</condition><then> <expr><name>kTrue</name></expr> </then><else>: <expr><name>kFalse</name></expr></else></ternary></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>POP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>obj</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_string_ret</name>;</goto>

<label><name>parse_json_string_fail</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

<label><name>parse_json_string_ret</name>:</label>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>POP</name></cpp:undef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>parse_json_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buf_len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>pp</name></decl></parameter>,

<parameter><decl><type><name>ValuesStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stack</name></decl></parameter>,

<parameter><decl><type><name>ContainerStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>container_stack</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>next_map_special</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcomma</name></decl></parameter>,

<parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>didcolon</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>buf_len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ints</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fracs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exps</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exps_s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ints</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_number_check</name>;</goto>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>ints</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ints</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Leading zeroes are not allowed: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_number_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>e</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>ints</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_number_check</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>fracs</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>e</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>fracs</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_number_check</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>exps_s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>exps</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<label><name>parse_json_number_check</name>:</label>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>ints</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Missing number after minus sign: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_number_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name>fracs</name> <operator>||</operator> <name>exps_s</name> <operator>==</operator> <name>fracs</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Missing number after decimal dot: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_number_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name>exps</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Missing exponent: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>parse_json_number_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name> <init>= <expr><block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_NUMBER</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>exp_num_len</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fracs</name> <operator>||</operator> <name>exps</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_len</name> <init>= <expr><call><name>string2float</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exp_num_len</name> <operator>!=</operator> <name>num_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E685: internal error: while converting number \"%.*s\" "</literal>

<literal type="string">"to float string2float consumed %zu bytes in place of %zu"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>exp_num_len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>num_len</name></expr></argument>, <argument><expr><name>exp_num_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_FLOAT</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>exp_num_len</name> <operator>!=</operator> <name>num_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E685: internal error: while converting number \"%.*s\" "</literal>

<literal type="string">"to integer vim_str2nr consumed %i bytes in place of %zu"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>exp_num_len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>num_len</name></expr></argument>, <argument><expr><name>exp_num_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>json_decoder_pop</name><argument_list>(<argument><expr><call><name>OBJ</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>*</operator><name>didcomma</name></expr></argument>, <argument><expr><operator>*</operator><name>didcolon</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>container_stack</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>next_map_special</name></expr></argument>, <argument><expr><name>didcomma</name></expr></argument>, <argument><expr><name>didcolon</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_number_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_map_special</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>parse_json_number_ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>

<goto>goto <name>parse_json_number_ret</name>;</goto>

<label><name>parse_json_number_fail</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

<label><name>parse_json_number_ret</name>:</label>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP</name><parameter_list>(<parameter><type><name>obj_tv</name></type></parameter>, <parameter><type><name>is_sp_string</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (json_decoder_pop(OBJ(obj_tv, is_sp_string, didcomma, didcolon), &amp;stack, &amp;container_stack, &amp;p, &amp;next_map_special, &amp;didcomma, &amp;didcolon) == FAIL) { goto json_decode_string_fail; } if (next_map_special) { goto json_decode_string_cycle_start; } } while (0)</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>json_decode_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buf_len</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rettv</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>buf_len</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>TAB</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NL</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>CAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Attempt to decode a blank string"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ValuesStack</name></type> <name>stack</name> <init>= <expr><name>KV_INITIAL_VALUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ContainerStack</name></type> <name>container_stack</name> <init>= <expr><name>KV_INITIAL_VALUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>didcomma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>didcolon</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>next_map_special</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<label><name>json_decode_string_cycle_start</name>:</label>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name>next_map_special</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'}'</literal></expr>:</case>

<case>case <expr><literal type="char">']'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: No container to close: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ContainerStackItem</name></type> <name>last_container</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_DICT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Closing list with curly bracket: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Closing dictionary with square bracket: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>didcomma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Trailing comma: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>didcolon</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected value after colon: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>stack_index</name></name> <operator>!=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>stack_index</name></name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected value: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_after_cycle</name>;</goto>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>json_decoder_pop</name><argument_list>(<argument><expr><call><name>kv_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>container_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>next_map_special</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcomma</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcolon</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>next_map_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<case>case <expr><literal type="char">','</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Comma not inside container: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ContainerStackItem</name></type> <name>last_container</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>didcomma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Duplicate comma: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>didcolon</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Comma after colon: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name>

<operator>&amp;&amp;</operator> <name><name>last_container</name><operator>.</operator><name>stack_index</name></name> <operator>!=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Using comma in place of colon: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><ternary><condition><expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name> <operator>==</operator> <name>NULL</name></expr>

?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>

?</condition><then> <expr><operator>(</operator><call><name>DICT_LEN</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>

</then><else>: <expr><operator>(</operator><call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call>

<operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>

</then><else>: <expr><operator>(</operator><call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>last_container</name><operator>.</operator><name>special_val</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Leading comma: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>didcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block>

<case>case <expr><literal type="char">':'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Colon not inside container: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ContainerStackItem</name></type> <name>last_container</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>container</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_DICT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Using colon not in dictionary: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>last_container</name><operator>.</operator><name>stack_index</name></name> <operator>!=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unexpected colon: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>didcomma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Colon after comma: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>didcolon</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Duplicate colon: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>didcolon</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<case>case <expr><name>TAB</name></expr>:</case>

<case>case <expr><name>NL</name></expr>:</case>

<case>case <expr><name>CAR</name></expr>:</case> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&gt;=</operator> <name>e</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"ull"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected null: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<macro><name>POP</name><argument_list>(<argument>((typval_T) {

.v_type = VAR_SPECIAL,

.v_lock = VAR_UNLOCKED,

.vval = { .v_special = kSpecialVarNull },

})</argument>, <argument>false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&gt;=</operator> <name>e</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"rue"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected true: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<macro><name>POP</name><argument_list>(<argument>((typval_T) {

.v_type = VAR_SPECIAL,

.v_lock = VAR_UNLOCKED,

.vval = { .v_special = kSpecialVarTrue },

})</argument>, <argument>false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <operator>&gt;=</operator> <name>e</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"alse"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Expected false: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<macro><name>POP</name><argument_list>(<argument>((typval_T) {

.v_type = VAR_SPECIAL,

.v_lock = VAR_UNLOCKED,

.vval = { .v_special = kSpecialVarFalse },

})</argument>, <argument>false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'"'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>parse_json_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>container_stack</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>next_map_special</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcomma</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcolon</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>next_map_special</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>json_decode_string_cycle_start</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<case>case <expr><literal type="char">'3'</literal></expr>:</case>

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<case>case <expr><literal type="char">'5'</literal></expr>:</case>

<case>case <expr><literal type="char">'6'</literal></expr>:</case>

<case>case <expr><literal type="char">'7'</literal></expr>:</case>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>parse_json_number</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>container_stack</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>next_map_special</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcomma</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>didcolon</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>next_map_special</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>json_decode_string_cycle_start</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>kListLenMayKnow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name> <init>= <expr><block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_LIST</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_list</name> <operator>=</operator> <name>list</name></expr> }</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<macro><name>kv_push</name><argument_list>(<argument>container_stack</argument>, <argument>((ContainerStackItem) {

.stack_index = kv_size(stack),

.s = p,

.container = tv,

.special_val = NULL,

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>kv_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>OBJ</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>didcomma</name></expr></argument>, <argument><expr><name>didcolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>val_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>next_map_special</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next_map_special</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>val_list</name> <operator>=</operator> <call><name>decode_create_map_special_dict</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>kListLenMayKnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dict</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>tv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_DICT</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_dict</name> <operator>=</operator> <name>dict</name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<macro><name>kv_push</name><argument_list>(<argument>container_stack</argument>, <argument>((ContainerStackItem) {

.stack_index = kv_size(stack),

.s = p,

.container = tv,

.special_val = val_list,

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>kv_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>OBJ</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>didcomma</name></expr></argument>, <argument><expr><name>didcolon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unidentified byte: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><name>didcomma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>didcolon</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<label><name>json_decode_string_after_cycle</name>:</label>

<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NL</name></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<case>case <expr><name>TAB</name></expr>:</case>

<case>case <expr><name>CAR</name></expr>:</case> <block>{<block_content>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Trailing characters: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LENP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_fail</name>;</goto>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call><operator>.</operator><name>val</name></expr>;</expr_stmt>

<goto>goto <name>json_decode_string_ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: Unexpected end of input: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>json_decode_string_fail</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>kv_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call><operator>.</operator><name>val</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<label><name>json_decode_string_ret</name>:</label>

<expr_stmt><expr><call><name>kv_destroy</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>kv_destroy</name><argument_list>(<argument><expr><name>container_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LENP</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>POP</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OBJ</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DICT_LEN</name></cpp:undef>

<function><type><name>int</name></type> <name>msgpack_to_vim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>msgpack_object</name></type> <name>mobj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rettv</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>mobj</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MSGPACK_OBJECT_NIL</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_special</name> <operator>=</operator> <name>kSpecialVarNull</name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_BOOLEAN</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{

<expr><operator>.</operator><name>v_special</name> <operator>=</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>boolean</name></name> <operator>?</operator> <name>kSpecialVarTrue</name> <operator>:</operator> <name>kSpecialVarFalse</name></expr>

}</block></expr>,

}</block></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_POSITIVE_INTEGER</name></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>u64</name></name> <operator>&lt;=</operator> <name>VARNUMBER_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_NUMBER</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_number</name> <operator>=</operator> <operator>(</operator><name>varnumber_T</name><operator>)</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>u64</name></name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>create_special_dict</name><argument_list>(<argument>rettv</argument>, <argument>kMPInteger</argument>, <argument>((typval_T) {

.v_type = VAR_LIST,

.v_lock = VAR_UNLOCKED,

.vval = { .v_list = list },

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>n</name> <init>= <expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>u64</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">62</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_NEGATIVE_INTEGER</name></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>i64</name></name> <operator>&gt;=</operator> <name>VARNUMBER_MIN</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_NUMBER</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_number</name> <operator>=</operator> <operator>(</operator><name>varnumber_T</name><operator>)</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>i64</name></name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>create_special_dict</name><argument_list>(<argument>rettv</argument>, <argument>kMPInteger</argument>, <argument>((typval_T) {

.v_type = VAR_LIST,

.v_lock = VAR_UNLOCKED,

.vval = { .v_list = list },

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>n</name> <init>= <expr><operator>-</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>i64</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">62</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>varnumber_T</name><operator>)</operator><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NVIM_MSGPACK_HAS_FLOAT32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>MSGPACK_OBJECT_FLOAT32</name></expr>:</case>

<case>case <expr><name>MSGPACK_OBJECT_FLOAT64</name></expr>:</case>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<case>case <expr><name>MSGPACK_OBJECT_FLOAT</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_FLOAT</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_float</name> <operator>=</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>f64</name></name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_STR</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <call><name>decode_string</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>kTrue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,

<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_BIN</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <call><name>decode_string</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>kNone</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,

<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_ARRAY</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_LIST</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_list</name> <operator>=</operator> <name>list</name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>list</argument>, <argument>(typval_T) { .v_type = VAR_UNKNOWN }</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<if_stmt><if>if <condition>(<expr><call><name>msgpack_to_vim</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><call><name>tv_list_last</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_MAP</name></expr>:</case> <block>{<block_content>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_STR</name>

<operator>||</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>memchr</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>,

<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>msgpack_to_vim_generic_map</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>rettv</name> <operator>=</operator> <operator>(</operator><name>typval_T</name><operator>)</operator> <block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_DICT</name></expr>,

<expr><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_dict</name> <operator>=</operator> <name>dict</name></expr> }</block></expr>,

}</block></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>xmallocz</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>dictitem_T</name></expr></argument>, <argument><expr><name>di_key</name></expr></argument>)</argument_list></call>

<operator>+</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>ptr</name></name></expr></argument>,

<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>key</name><operator>.</operator><name>via</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>msgpack_to_vim_generic_map</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>msgpack_to_vim</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<break>break;</break>

<label><name>msgpack_to_vim_generic_map</name>:</label> <block>{<block_content/>}</block>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>decode_create_map_special_dict</name><argument_list>(

<argument><expr><name>rettv</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>kv_pair</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_append_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>kv_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>key_tv</name> <init>= <expr><block>{ <expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>msgpack_to_vim</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name>kv_pair</name></expr></argument>, <argument><expr><name>key_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>val_tv</name> <init>= <expr><block>{ <expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>msgpack_to_vim</name><argument_list>(<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name>kv_pair</name></expr></argument>, <argument><expr><name>val_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>MSGPACK_OBJECT_EXT</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_list_append_number</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>ext</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ext_val_list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>kListLenMayKnow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_list_append_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>ext_val_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>create_special_dict</name><argument_list>(<argument>rettv</argument>, <argument>kMPExt</argument>, <argument>((typval_T) {

.v_type = VAR_LIST,

.v_lock = VAR_UNLOCKED,

.vval = { .v_list = list },

})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encode_list_write</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ext_val_list</name></expr></argument>, <argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>ext</name><operator>.</operator><name>ptr</name></name></expr></argument>,

<argument><expr><name><name>mobj</name><operator>.</operator><name>via</name><operator>.</operator><name>ext</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

</unit>
