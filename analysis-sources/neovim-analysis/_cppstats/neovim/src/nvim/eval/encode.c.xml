<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\eval\encode.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;msgpack.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/encode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer_defs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/math.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/macros.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ga_concat</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(a, (char_u *)b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf_ptr2char</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>utf_ptr2char((char_u *)b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf_ptr2len</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t)utf_ptr2len((char_u *)b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf_char2len</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t)utf_char2len(b))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encode_special_var_names</name><index>[]</index></name> <init>= <expr><block>{

<expr><index>[<expr><name>kSpecialVarNull</name></expr>]</index> <operator>=</operator> <literal type="string">"null"</literal></expr>,

<expr><index>[<expr><name>kSpecialVarTrue</name></expr>]</index> <operator>=</operator> <literal type="string">"true"</literal></expr>,

<expr><index>[<expr><name>kSpecialVarFalse</name></expr>]</index> <operator>=</operator> <literal type="string">"false"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval/encode.c.generated.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>encode_list_write</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><operator>(</operator><name>list_T</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>end</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_end</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><call><name>tv_list_last</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>li</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>line_end</name> <operator>=</operator> <call><name>xmemscan</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line_end</name> <operator>!=</operator> <name>buf</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>line_length</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>line_end</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>li_len</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>str</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(

<argument><expr><name>str</name></expr></argument>, <argument><expr><name>li_len</name> <operator>+</operator> <name>line_length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>+</operator> <name>li_len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>line_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>line_length</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memchrsub</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><name>line_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line_end</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>line_end</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_start</name> <init>= <expr><name>line_end</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>line_end</name> <operator>=</operator> <call><name>xmemscan</name><argument_list>(<argument><expr><name>line_start</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>line_start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line_end</name> <operator>!=</operator> <name>line_start</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>line_length</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>line_end</name> <operator>-</operator> <name>line_start</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>line_start</name></expr></argument>, <argument><expr><name>line_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memchrsub</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><name>line_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_list_append_allocated_string</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line_end</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>line_end</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_list_append_allocated_string</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>did_echo_string_emsg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>conv_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MPConvStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>mpstack</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>objname</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>msg_ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"key %s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key_pair_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"key %s at index %i from special map"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>idx_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"index %i"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>partial_arg_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"partial"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>partial_arg_i_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"argument %i"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>partial_self_msg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"partial self dictionary"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>mpstack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>MPConvStackVal</name></type> <name>v</name> <init>= <expr><call><name>kv_A</name><argument_list>(<argument><expr><operator>*</operator><name>mpstack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>kMPConvDict</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>key_tv</name> <init>= <expr><block>{

<expr><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_STRING</name></expr>,

<expr><operator>.</operator><name>vval</name> <operator>=</operator> <block>{ <expr><operator>.</operator><name>v_string</name> <operator>=</operator> <operator>(</operator><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>d</name><operator>.</operator><name>hi</name></name> <operator>==</operator> <name>NULL</name>

<operator>?</operator> <name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>d</name><operator>.</operator><name>dict</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_array</name></name>

<operator>:</operator> <operator>(</operator><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>d</name><operator>.</operator><name>hi</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>hi_key</name></expr> }</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>encode_tv2string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name>key_msg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>kMPConvPairs</name></expr>:</case>

<case>case <expr><name>kMPConvList</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name> <operator>==</operator> <call><name>tv_list_first</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>

?</condition><then> <expr><literal type="number">0</literal></expr>

</then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name> <operator>==</operator> <name>NULL</name></expr>

?</condition><then> <expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>

</then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tv_list_idx_of_item</name><argument_list>(

<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>,

<argument><expr><call><name>TV_LIST_ITEM_PREV</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>,

<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name> <operator>==</operator> <name>NULL</name></expr>

?</condition><then> <expr><call><name>tv_list_last</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>TV_LIST_ITEM_PREV</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>list</name></name></expr></argument>,

<argument><expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kMPConvList</name>

<operator>||</operator> <name>li</name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>(</operator><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v_type</name> <operator>!=</operator> <name>VAR_LIST</name>

<operator>&amp;&amp;</operator> <call><name>tv_list_len</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name>idx_msg</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>key_tv</name> <init>= <expr><operator>*</operator><call><name>TV_LIST_ITEM_TV</name><argument_list>(

<argument><expr><call><name>tv_list_first</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>encode_tv2echo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name>key_pair_msg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>kMPConvPartial</name></expr>:</case> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>p</name><operator>.</operator><name>stage</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>kMPConvPartialArgs</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>kMPConvPartialSelf</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>partial_arg_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>kMPConvPartialEnd</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>partial_self_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>kMPConvPartialList</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>a</name><operator>.</operator><name>arg</name></name> <operator>-</operator> <name><name>v</name><operator>.</operator><name>data</name><operator>.</operator><name>a</name><operator>.</operator><name>argv</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name>partial_arg_i_msg</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>mpstack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>

?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"itself"</literal></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>msg_ga</name><operator>.</operator><name>ga_data</name></name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name></type> <name>encode_vim_list_to_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_len</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>ret_buf</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2<operator>,</operator> 3</function>) <macro><name>FUNC_ATTR_WARN_UNUSED_RESULT</name></macro>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>TV_LIST_ITER_CONST</name><argument_list>(<argument>list</argument>, <argument>li</argument>, <argument>{

if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {

return false;

}

len++;

if (TV_LIST_ITEM_TV(li)-&gt;vval.v_string != NULL) {

len += STRLEN(TV_LIST_ITEM_TV(li)-&gt;vval.v_string);

}

}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ret_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ret_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ListReaderState</name></type> <name>lrstate</name> <init>= <expr><call><name>encode_init_lrstate</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>read_bytes</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encode_read_from_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lrstate</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_bytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <name>read_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ret_buf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block>

<function><type><name>int</name></type> <name>encode_read_from_list</name><parameter_list>(<parameter><decl><type><name>ListReaderState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read_bytes</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf_end</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>nbuf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>buf_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li_length</name></name> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>li_length</name></name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>buf_end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>ch</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><operator>(</operator>

<call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name><operator>++</operator></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>char</name><operator>)</operator><name>ch</name> <operator>==</operator> <operator>(</operator><name>char</name><operator>)</operator><name>NL</name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>)</operator><name>NUL</name></expr> </then><else>: <expr><operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>buf_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name> <operator>=</operator> <call><name>TV_LIST_ITEM_NEXT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>read_bytes</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v_type</name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>read_bytes</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>li_length</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name></expr>

?</condition><then> <expr><literal type="number">0</literal></expr>

</then><else>: <expr><call><name>STRLEN</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>read_bytes</name> <operator>=</operator> <name>nbuf</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>li_length</name></name>

<operator>||</operator> <call><name>TV_LIST_ITEM_NEXT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>li</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>

?</condition><then> <expr><name>NOTDONE</name></expr>

</then><else>: <expr><name>OK</name></expr></else></ternary><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const char *const buf_ = (const char *) buf; if (buf == NULL) { ga_concat(gap, "''"); } else { const size_t len_ = (len); ga_grow(gap, (int) (2 + len_ + memcnt(buf_, '\'', len_))); ga_append(gap, '\''); for (size_t i_ = 0; i_ &lt; len_; i_++) { if (buf_[i_] == '\'') { ga_append(gap, '\''); } ga_append(gap, buf_[i_]); } ga_append(gap, '\''); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STR_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_STRING(tv, buf, len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EXT_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char numbuf[NUMBUFLEN]; vim_snprintf(numbuf, ARRAY_SIZE(numbuf), "%" PRId64, (int64_t) (num)); ga_concat(gap, numbuf); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FLOAT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>flt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const float_T flt_ = (flt); switch (xfpclassify(flt_)) { case FP_NAN: { ga_concat(gap, (char_u *) "str2float('nan')"); break; } case FP_INFINITE: { if (flt_ &lt; 0) { ga_append(gap, '-'); } ga_concat(gap, (char_u *) "str2float('inf')"); break; } default: { char numbuf[NUMBUFLEN]; vim_snprintf(numbuf, ARRAY_SIZE(numbuf), "%g", flt_); ga_concat(gap, (char_u *) numbuf); } } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>fun</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const char *const fun_ = (const char *)(fun); if (fun_ == NULL) { internal_error("string(): NULL function name"); ga_concat(gap, "function(NULL"); } else { ga_concat(gap, "function("); TYPVAL_ENCODE_CONV_STRING(tv, fun_, strlen(fun_)); }} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (len != 0) { ga_concat(gap, ", "); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((ptrdiff_t)len != -1) { ga_concat(gap, ", "); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_append(gap, ')')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, "[]")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_append(gap, '[')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, "{}")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NIL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, "v:null")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_BOOL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, ((num)? "v:true": "v:false"))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_append(gap, '{')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_append(gap, '}')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, ": ")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, ", ")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name><parameter_list>(<parameter><type><name>label</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_append(gap, ']')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(tv, NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!did_echo_string_emsg) { did_echo_string_emsg = true; EMSG(_("E724: unable to correctly dump variable " "with self-referencing container")); } char ebuf[NUMBUFLEN + 7]; size_t backref = 0; for (; backref &lt; kv_size(*mpstack); backref++) { const MPConvStackVal mpval = kv_A(*mpstack, backref); if (mpval.type == conv_type) { if (conv_type == kMPConvDict) { if ((void *) mpval.data.d.dict == (void *) (val)) { break; } } else if (conv_type == kMPConvList) { if ((void *) mpval.data.l.list == (void *) (val)) { break; } } } } vim_snprintf(ebuf, ARRAY_SIZE(ebuf), "{E724@%zu}", backref); ga_concat(gap, &amp;ebuf[0]); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:macro> <cpp:value>false</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>garray_T *const</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>gap</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char ebuf[NUMBUFLEN + 7]; size_t backref = 0; for (; backref &lt; kv_size(*mpstack); backref++) { const MPConvStackVal mpval = kv_A(*mpstack, backref); if (mpval.type == conv_type) { if (conv_type == kMPConvDict) { if ((void *) mpval.data.d.dict == (void *) val) { break; } } else if (conv_type == kMPConvList) { if ((void *) mpval.data.l.list == (void *) val) { break; } } } } if (conv_type == kMPConvDict) { vim_snprintf(ebuf, ARRAY_SIZE(ebuf), "{...@%zu}", backref); } else { vim_snprintf(ebuf, ARRAY_SIZE(ebuf), "[...@%zu]", backref); } ga_concat(gap, &amp;ebuf[0]); return OK; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>echo</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>garray_T *const</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>gap</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!did_echo_string_emsg) { did_echo_string_emsg = true; EMSG(_("E724: unable to correctly dump variable " "with self-referencing container")); } } while (0)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:macro> <cpp:value>true</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NIL</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NIL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, "null")</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_BOOL</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_BOOL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ga_concat(gap, ((num)? "true": "false"))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char numbuf[NUMBUFLEN]; vim_snprintf(numbuf, ARRAY_SIZE(numbuf), "%" PRIu64, (num)); ga_concat(gap, numbuf); } while (0)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FLOAT</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FLOAT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>flt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const float_T flt_ = (flt); switch (xfpclassify(flt_)) { case FP_NAN: { EMSG(_("E474: Unable to represent NaN value in JSON")); return FAIL; } case FP_INFINITE: { EMSG(_("E474: Unable to represent infinity in JSON")); return FAIL; } default: { char numbuf[NUMBUFLEN]; vim_snprintf(numbuf, ARRAY_SIZE(numbuf), "%g", flt_); ga_concat(gap, (char_u *) numbuf); break; } } } while (0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>escapes</name><index>[]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{

<expr><index>[<expr><name>BS</name></expr>]</index> <operator>=</operator> <literal type="string">"\\b"</literal></expr>,

<expr><index>[<expr><name>TAB</name></expr>]</index> <operator>=</operator> <literal type="string">"\\t"</literal></expr>,

<expr><index>[<expr><name>NL</name></expr>]</index> <operator>=</operator> <literal type="string">"\\n"</literal></expr>,

<expr><index>[<expr><name>CAR</name></expr>]</index> <operator>=</operator> <literal type="string">"\\r"</literal></expr>,

<expr><index>[<expr><literal type="char">'"'</literal></expr>]</index> <operator>=</operator> <literal type="string">"\\\""</literal></expr>,

<expr><index>[<expr><literal type="char">'\\'</literal></expr>]</index> <operator>=</operator> <literal type="string">"\\\\"</literal></expr>,

<expr><index>[<expr><name>FF</name></expr>]</index> <operator>=</operator> <literal type="string">"\\f"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>xdigits</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789ABCDEF"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>convert_to_json_string</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>gap</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>) <macro><name>FUNC_ATTR_ALWAYS_INLINE</name></macro>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>utf_buf</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>utf_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="string">"\"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>utf_len</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>str_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODE_RAW</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ch &gt;= 0x20 &amp;&amp; utf_printable(ch))</cpp:value></cpp:define>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf_len</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ch</name> <init>= <expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>shift</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><call><name>utf_ptr2len</name><argument_list>(<argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>shift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>shift</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BS</name></expr>:</case>

<case>case <expr><name>TAB</name></expr>:</case>

<case>case <expr><name>NL</name></expr>:</case>

<case>case <expr><name>FF</name></expr>:</case>

<case>case <expr><name>CAR</name></expr>:</case>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>str_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <literal type="number">0x7F</literal> <operator>&amp;&amp;</operator> <name>shift</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: String \"%.*s\" contains byte that does not start "</literal>

<literal type="string">"any UTF-8 character"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>utf_len</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>shift</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>SURROGATE_HI_START</name> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <name>SURROGATE_HI_END</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>SURROGATE_LO_START</name> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <name>SURROGATE_LO_END</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E474: UTF-8 string contains code point which belongs "</literal>

<literal type="string">"to a surrogate pair: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>utf_len</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>shift</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name> <operator>-</operator> <name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ENCODE_RAW</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_len</name> <operator>+=</operator> <name>shift</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>str_len</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"\\u1234"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>

<operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>ch</name> <operator>&gt;=</operator> <name>SURROGATE_FIRST_CHAR</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf_len</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ch</name> <init>= <expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>shift</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><call><name>utf_char2len</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>shift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>shift</name> <operator>==</operator> <call><name>utf_ptr2len</name><argument_list>(<argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BS</name></expr>:</case>

<case>case <expr><name>TAB</name></expr>:</case>

<case>case <expr><name>NL</name></expr>:</case>

<case>case <expr><name>FF</name></expr>:</case>

<case>case <expr><name>CAR</name></expr>:</case>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat_len</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name><name>escapes</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ENCODE_RAW</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat_len</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>utf_buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <name>SURROGATE_FIRST_CHAR</name></expr>)</condition> <block>{<block_content>

<macro><name>ga_concat_len</name><argument_list>(<argument>gap</argument>, <argument>((const char[]) {

<literal type="char">'\\'</literal>, <literal type="char">'u'</literal>,

xdigits[(ch &gt;&gt; (<literal type="number">4</literal> * <literal type="number">3</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(ch &gt;&gt; (<literal type="number">4</literal> * <literal type="number">2</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(ch &gt;&gt; (<literal type="number">4</literal> * <literal type="number">1</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(ch &gt;&gt; (<literal type="number">4</literal> * <literal type="number">0</literal>)) &amp; <literal type="number">0xF</literal>],

})</argument>, <argument>sizeof(<literal type="string">"\\u1234"</literal>) - <literal type="number">1</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>tmp</name> <init>= <expr><name>ch</name> <operator>-</operator> <name>SURROGATE_FIRST_CHAR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hi</name> <init>= <expr><name>SURROGATE_HI_START</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>tmp</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lo</name> <init>= <expr><name>SURROGATE_LO_END</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>tmp</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<macro><name>ga_concat_len</name><argument_list>(<argument>gap</argument>, <argument>((const char[]) {

<literal type="char">'\\'</literal>, <literal type="char">'u'</literal>,

xdigits[(hi &gt;&gt; (<literal type="number">4</literal> * <literal type="number">3</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(hi &gt;&gt; (<literal type="number">4</literal> * <literal type="number">2</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(hi &gt;&gt; (<literal type="number">4</literal> * <literal type="number">1</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(hi &gt;&gt; (<literal type="number">4</literal> * <literal type="number">0</literal>)) &amp; <literal type="number">0xF</literal>],

<literal type="char">'\\'</literal>, <literal type="char">'u'</literal>,

xdigits[(lo &gt;&gt; (<literal type="number">4</literal> * <literal type="number">3</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(lo &gt;&gt; (<literal type="number">4</literal> * <literal type="number">2</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(lo &gt;&gt; (<literal type="number">4</literal> * <literal type="number">1</literal>)) &amp; <literal type="number">0xF</literal>],

xdigits[(lo &gt;&gt; (<literal type="number">4</literal> * <literal type="number">0</literal>)) &amp; <literal type="number">0xF</literal>],

})</argument>, <argument>(sizeof(<literal type="string">"\\u1234"</literal>) - <literal type="number">1</literal>) * <literal type="number">2</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>shift</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STRING</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (convert_to_json_string(gap, (const char *) (buf), (len)) != OK) { return FAIL; } } while (0)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EXT_STRING</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EXT_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { xfree(buf); EMSG(_("E474: Unable to convert EXT string to JSON")); return FAIL; } while (0)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_START</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>fun</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return conv_error(_("E474: Error while dumping %s, %s: " "attempt to dump function reference"), mpstack, objname)</cpp:value></cpp:define>

<function><type><name>bool</name></type> <name>encode_check_json_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_DICT</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>spdict</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spdict</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>dictitem_T</name> <modifier>*</modifier></type><name>type_di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>dictitem_T</name> <modifier>*</modifier></type><name>val_di</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type_di</name> <operator>=</operator> <call><name>tv_dict_find</name><argument_list>(<argument><expr><name>spdict</name></expr></argument>, <argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"_TYPE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name>

<operator>||</operator> <operator>(</operator><name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>!=</operator> <name><name>eval_msgpack_type_lists</name><index>[<expr><name>kMPString</name></expr>]</index></name>

<operator>&amp;&amp;</operator> <name><name>type_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>!=</operator> <name><name>eval_msgpack_type_lists</name><index>[<expr><name>kMPBinary</name></expr>]</index></name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>val_di</name> <operator>=</operator> <call><name>tv_dict_find</name><argument_list>(<argument><expr><name>spdict</name></expr></argument>, <argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"_VAL"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <name><name>val_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>val_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>TV_LIST_ITER_CONST</name><argument_list>(<argument>val_di-&gt;di_tv.vval.v_list</argument>, <argument>li</argument>, <argument>{

if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {

return false;

}

}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name><parameter_list>(<parameter><type><name>label</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!encode_check_json_key(&amp;key)) { EMSG(_("E474: Invalid key in special dictionary")); goto label; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>json</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>garray_T *const</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>gap</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STR_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EXT_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NUMBER</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FLOAT</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NIL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_BOOL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:undef>

<function><type><name>char</name> <modifier>*</modifier></type><name>encode_tv2string</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>) <macro><name>FUNC_ATTR_MALLOC</name></macro>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>evs_ret</name> <init>= <expr><call><name>encode_vim_to_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"encode_tv2string() argument"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>evs_ret</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>evs_ret</name> <operator>==</operator> <name>OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>did_echo_string_emsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</return>

</block_content>}</block>

<function><type><name>char</name> <modifier>*</modifier></type><name>encode_tv2echo</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>) <macro><name>FUNC_ATTR_MALLOC</name></macro>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name> <operator>||</operator> <name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FUNC</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>eve_ret</name> <init>= <expr><call><name>encode_vim_to_echo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">":echo argument"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>eve_ret</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eve_ret</name> <operator>==</operator> <name>OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</return>

</block_content>}</block>

<function><type><name>char</name> <modifier>*</modifier></type><name>encode_tv2json</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>) <macro><name>FUNC_ATTR_MALLOC</name></macro>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>evj_ret</name> <init>= <expr><call><name>encode_vim_to_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>,

<argument><expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"encode_tv2json() argument"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>evj_ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>did_echo_string_emsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</return>

</block_content>}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (buf == NULL) { msgpack_pack_bin(packer, 0); } else { const size_t len_ = (len); msgpack_pack_bin(packer, len_); msgpack_pack_bin_body(packer, buf, len_); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STR_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (buf == NULL) { msgpack_pack_str(packer, 0); } else { const size_t len_ = (len); msgpack_pack_str(packer, len_); msgpack_pack_str_body(packer, buf, len_); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EXT_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (buf == NULL) { msgpack_pack_ext(packer, 0, (int8_t) type); } else { const size_t len_ = (len); msgpack_pack_ext(packer, len_, (int8_t) type); msgpack_pack_ext_body(packer, buf, len_); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_int64(packer, (int64_t)(num))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FLOAT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>flt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_double(packer, (double)(flt))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>fun</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return conv_error(_("E5004: Error while dumping %s, %s: " "attempt to dump function reference"), mpstack, objname)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_array(packer, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_array(packer, (size_t)(len))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_map(packer, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NIL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_nil(packer)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_BOOL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (num) { msgpack_pack_true(packer); } else { msgpack_pack_false(packer); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_uint64(packer, (num))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>msgpack_pack_map(packer, (size_t)(len))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name><parameter_list>(<parameter><type><name>label</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return conv_error(_("E5005: Unable to dump %s: " "container references itself in %s"), mpstack, objname)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:macro> <cpp:value>true</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>msgpack</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>msgpack_packer *const</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>packer</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STR_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EXT_STRING</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NUMBER</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FLOAT</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NIL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_BOOL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_END</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:undef>

</unit>
