






































#include <stdlib.h>
#include <string.h>

#include "nvim/memory.h"
#include "nvim/os/os_defs.h"

#define kv_roundup32(x) ((--(x)), ((x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16), (++(x)))




#define KV_INITIAL_VALUE { .size = 0, .capacity = 0, .items = NULL }

#define kvec_t(type) struct { size_t size; size_t capacity; type *items; }






#define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)
#define kv_destroy(v) do { xfree((v).items); kv_init(v); } while (0)




#define kv_A(v, i) ((v).items[(i)])
#define kv_pop(v) ((v).items[--(v).size])
#define kv_size(v) ((v).size)
#define kv_max(v) ((v).capacity)
#define kv_Z(v, i) kv_A(v, kv_size(v) - (i) - 1)
#define kv_last(v) kv_Z(v, 0)







#define kv_drop(v, n) ((v).size -= (n))

#define kv_resize(v, s) ((v).capacity = (s), (v).items = xrealloc((v).items, sizeof((v).items[0]) * (v).capacity))



#define kv_resize_full(v) kv_resize(v, (v).capacity ? (v).capacity << 1 : 8)


#define kv_copy(v1, v0) do { if ((v1).capacity < (v0).size) { kv_resize(v1, (v0).size); } (v1).size = (v0).size; memcpy((v1).items, (v0).items, sizeof((v1).items[0]) * (v0).size); } while (0)








#define kv_pushp(v) ((((v).size == (v).capacity) ? (kv_resize_full(v), 0) : 0), ((v).items + ((v).size++)))



#define kv_push(v, x) (*kv_pushp(v) = (x))


#define kv_a(v, i) (*(((v).capacity <= (size_t) (i) ? ((v).capacity = (v).size = (i) + 1, kv_roundup32((v).capacity), kv_resize((v), (v).capacity), 0UL) : ((v).size <= (size_t) (i) ? (v).size = (i) + 1 : 0UL)), &(v).items[(i)]))

















#define kvec_withinit_t(type, INIT_SIZE) struct { size_t size; size_t capacity; type *items; type init_array[INIT_SIZE]; }










#define kvi_init(v) ((v).capacity = ARRAY_SIZE((v).init_array), (v).size = 0, (v).items = (v).init_array)





static inline void *_memcpy_free(void *const restrict dest,
void *const restrict src,
const size_t size)
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_ALWAYS_INLINE
{
memcpy(dest, src, size);
XFREE_CLEAR(src);
return dest;
}










#define kvi_resize(v, s) ((v).capacity = ((s) > ARRAY_SIZE((v).init_array) ? (s) : ARRAY_SIZE((v).init_array)), (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) ? ((v).items == (v).init_array ? (v).items : _memcpy_free((v).init_array, (v).items, (v).size * sizeof((v).items[0]))) : ((v).items == (v).init_array ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), (v).items, (v).size * sizeof((v).items[0])) : xrealloc((v).items, (v).capacity * sizeof((v).items[0])))))


















#define kvi_resize_full(v) kvi_resize(v, (v).capacity << 1)













#define kvi_pushp(v) ((((v).size == (v).capacity) ? (kvi_resize_full(v), 0) : 0), ((v).items + ((v).size++)))







#define kvi_push(v, x) (*kvi_pushp(v) = (x))





#define kvi_destroy(v) do { if ((v).items != (v).init_array) { XFREE_CLEAR((v).items); } } while (0)







