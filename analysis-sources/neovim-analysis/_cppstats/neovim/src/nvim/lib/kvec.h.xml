<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\lib\kvec.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os_defs.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_roundup32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((--(x)), ((x)|=(x)&gt;&gt;1, (x)|=(x)&gt;&gt;2, (x)|=(x)&gt;&gt;4, (x)|=(x)&gt;&gt;8, (x)|=(x)&gt;&gt;16), (++(x)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KV_INITIAL_VALUE</name></cpp:macro> <cpp:value>{ .size = 0, .capacity = 0, .items = NULL }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvec_t</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { size_t size; size_t capacity; type *items; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_init</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).size = (v).capacity = 0, (v).items = 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_destroy</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { xfree((v).items); kv_init(v); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_A</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).items[(i)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_pop</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).items[--(v).size])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_size</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).size)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_max</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).capacity)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_Z</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_A(v, kv_size(v) - (i) - 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_last</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_Z(v, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_drop</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).size -= (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_resize</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).capacity = (s), (v).items = xrealloc((v).items, sizeof((v).items[0]) * (v).capacity))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_resize_full</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_resize(v, (v).capacity ? (v).capacity &lt;&lt; 1 : 8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_copy</name><parameter_list>(<parameter><type><name>v1</name></type></parameter>, <parameter><type><name>v0</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((v1).capacity &lt; (v0).size) { kv_resize(v1, (v0).size); } (v1).size = (v0).size; memcpy((v1).items, (v0).items, sizeof((v1).items[0]) * (v0).size); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_pushp</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((v).size == (v).capacity) ? (kv_resize_full(v), 0) : 0), ((v).items + ((v).size++)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_push</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*kv_pushp(v) = (x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kv_a</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(((v).capacity &lt;= (size_t) (i) ? ((v).capacity = (v).size = (i) + 1, kv_roundup32((v).capacity), kv_resize((v), (v).capacity), 0UL) : ((v).size &lt;= (size_t) (i) ? (v).size = (i) + 1 : 0UL)), &amp;(v).items[(i)]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvec_withinit_t</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>INIT_SIZE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { size_t size; size_t capacity; type *items; type init_array[INIT_SIZE]; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_init</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).capacity = ARRAY_SIZE((v).init_array), (v).size = 0, (v).items = (v).init_array)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>_memcpy_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier> <specifier>restrict</specifier></type> <name>dest</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier> <specifier>restrict</specifier></type> <name>src</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_ALWAYS_INLINE

<block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dest</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_resize</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((v).capacity = ((s) &gt; ARRAY_SIZE((v).init_array) ? (s) : ARRAY_SIZE((v).init_array)), (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) ? ((v).items == (v).init_array ? (v).items : _memcpy_free((v).init_array, (v).items, (v).size * sizeof((v).items[0]))) : ((v).items == (v).init_array ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), (v).items, (v).size * sizeof((v).items[0])) : xrealloc((v).items, (v).capacity * sizeof((v).items[0])))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_resize_full</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kvi_resize(v, (v).capacity &lt;&lt; 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_pushp</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((v).size == (v).capacity) ? (kvi_resize_full(v), 0) : 0), ((v).items + ((v).size++)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_push</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*kvi_pushp(v) = (x))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kvi_destroy</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((v).items != (v).init_array) { XFREE_CLEAR((v).items); } } while (0)</cpp:value></cpp:define>

</unit>
