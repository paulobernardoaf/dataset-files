<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\nvim\lib\kbtree.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB_MAX_DEPTH</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_KEY</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x-&gt;key)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_PTR</name><parameter_list>(<parameter><type><name>btr</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x-&gt;ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_TREE_T</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>key_t</name></type></parameter>,<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typedef struct kbnode_##name##_s kbnode_##name##_t; struct kbnode_##name##_s { int32_t n; bool is_internal; key_t key[2*T-1]; kbnode_##name##_t *ptr[]; } ; typedef struct { kbnode_##name##_t *root; int n_keys, n_nodes; } kbtree_##name##_t; typedef struct { kbnode_##name##_t *x; int i; } kbpos_##name##_t; typedef struct { kbpos_##name##_t stack[KB_MAX_DEPTH], *p; } kbitr_##name##_t;</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__kb_destroy</name><parameter_list>(<parameter><type><name>kbnode_t</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int i; unsigned int max = 8; kbnode_t *x, **top, **stack = 0; if (b-&gt;root) { top = stack = (kbnode_t**)xcalloc(max, sizeof(kbnode_t*)); *top++ = (b)-&gt;root; while (top != stack) { x = *--top; if (x-&gt;is_internal == 0) { XFREE_CLEAR(x); continue; } for (i = 0; i &lt;= x-&gt;n; ++i) if (__KB_PTR(b, x)[i]) { if (top - stack == (int)max) { max &lt;&lt;= 1; stack = (kbnode_t**)xrealloc(stack, max * sizeof(kbnode_t*)); top = stack + (max&gt;&gt;1); } *top++ = __KB_PTR(b, x)[i]; } XFREE_CLEAR(x); } } XFREE_CLEAR(stack); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_GET_AUX1</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>, <parameter><type><name>__cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, key_t * __restrict k, int *r) { int tr, *rr, begin = 0, end = x-&gt;n; if (x-&gt;n == 0) return -1; rr = r? r : &amp;tr; while (begin &lt; end) { int mid = (begin + end) &gt;&gt; 1; if (__cmp(__KB_KEY(key_t, x)[mid], *k) &lt; 0) begin = mid + 1; else end = mid; } if (begin == x-&gt;n) { *rr = 1; return x-&gt;n - 1; } if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) &lt; 0) --begin; return begin; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_GET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static key_t *kb_getp_##name(kbtree_##name##_t *b, key_t * __restrict k) { if (!b-&gt;root) { return 0; } int i, r = 0; kbnode_t *x = b-&gt;root; while (x) { i = __kb_getp_aux_##name(x, k, &amp;r); if (i &gt;= 0 &amp;&amp; r == 0) return &amp;__KB_KEY(key_t, x)[i]; if (x-&gt;is_internal == 0) return 0; x = __KB_PTR(b, x)[i + 1]; } return 0; } static inline key_t *kb_get_##name(kbtree_##name##_t *b, key_t k) { return kb_getp_##name(b, &amp;k); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_INTERVAL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline void kb_intervalp_##name(kbtree_##name##_t *b, key_t * __restrict k, key_t **lower, key_t **upper) { if (!b-&gt;root) { return; } int i, r = 0; kbnode_t *x = b-&gt;root; *lower = *upper = 0; while (x) { i = __kb_getp_aux_##name(x, k, &amp;r); if (i &gt;= 0 &amp;&amp; r == 0) { *lower = *upper = &amp;__KB_KEY(key_t, x)[i]; return; } if (i &gt;= 0) *lower = &amp;__KB_KEY(key_t, x)[i]; if (i &lt; x-&gt;n - 1) *upper = &amp;__KB_KEY(key_t, x)[i + 1]; if (x-&gt;is_internal == 0) return; x = __KB_PTR(b, x)[i + 1]; } } static inline void kb_interval_##name(kbtree_##name##_t *b, key_t k, key_t **lower, key_t **upper) { kb_intervalp_##name(b, &amp;k, lower, upper); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_PUT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>, <parameter><type><name>__cmp</name></type></parameter>, <parameter><type><name>T</name></type></parameter>, <parameter><type><name>ILEN</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) { kbnode_t *z; z = (kbnode_t*)xcalloc(1, y-&gt;is_internal? ILEN : sizeof(kbnode_##name##_t)); ++b-&gt;n_nodes; z-&gt;is_internal = y-&gt;is_internal; z-&gt;n = T - 1; memcpy(__KB_KEY(key_t, z), &amp;__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); if (y-&gt;is_internal) memcpy(__KB_PTR(b, z), &amp;__KB_PTR(b, y)[T], sizeof(void*) * T); y-&gt;n = T - 1; memmove(&amp;__KB_PTR(b, x)[i + 2], &amp;__KB_PTR(b, x)[i + 1], sizeof(void*) * (unsigned int)(x-&gt;n - i)); __KB_PTR(b, x)[i + 1] = z; memmove(&amp;__KB_KEY(key_t, x)[i + 1], &amp;__KB_KEY(key_t, x)[i], sizeof(key_t) * (unsigned int)(x-&gt;n - i)); __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1]; ++x-&gt;n; } static inline key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k) { int i = x-&gt;n - 1; key_t *ret; if (x-&gt;is_internal == 0) { i = __kb_getp_aux_##name(x, k, 0); if (i != x-&gt;n - 1) memmove(&amp;__KB_KEY(key_t, x)[i + 2], &amp;__KB_KEY(key_t, x)[i + 1], (unsigned int)(x-&gt;n - i - 1) * sizeof(key_t)); ret = &amp;__KB_KEY(key_t, x)[i + 1]; *ret = *k; ++x-&gt;n; } else { i = __kb_getp_aux_##name(x, k, 0) + 1; if (__KB_PTR(b, x)[i]-&gt;n == 2 * T - 1) { __kb_split_##name(b, x, i, __KB_PTR(b, x)[i]); if (__cmp(*k, __KB_KEY(key_t, x)[i]) &gt; 0) ++i; } ret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k); } return ret; } static inline key_t *kb_putp_##name(kbtree_##name##_t *b, key_t * __restrict k) { if (!b-&gt;root) { b-&gt;root = (kbnode_t*)xcalloc(1, ILEN); ++b-&gt;n_nodes; } kbnode_t *r, *s; ++b-&gt;n_keys; r = b-&gt;root; if (r-&gt;n == 2 * T - 1) { ++b-&gt;n_nodes; s = (kbnode_t*)xcalloc(1, ILEN); b-&gt;root = s; s-&gt;is_internal = 1; s-&gt;n = 0; __KB_PTR(b, s)[0] = r; __kb_split_##name(b, s, 0, r); r = s; } return __kb_putp_aux_##name(b, r, k); } static inline void kb_put_##name(kbtree_##name##_t *b, key_t k) { kb_putp_##name(b, &amp;k); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_DEL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>, <parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, key_t * __restrict k, int s) { int yn, zn, i, r = 0; kbnode_t *xp, *y, *z; key_t kp; if (x == 0) return *k; if (s) { r = x-&gt;is_internal == 0? 0 : s == 1? 1 : -1; i = s == 1? x-&gt;n - 1 : -1; } else i = __kb_getp_aux_##name(x, k, &amp;r); if (x-&gt;is_internal == 0) { if (s == 2) ++i; kp = __KB_KEY(key_t, x)[i]; memmove(&amp;__KB_KEY(key_t, x)[i], &amp;__KB_KEY(key_t, x)[i + 1], (unsigned int)(x-&gt;n - i - 1) * sizeof(key_t)); --x-&gt;n; return kp; } if (r == 0) { if ((yn = __KB_PTR(b, x)[i]-&gt;n) &gt;= T) { xp = __KB_PTR(b, x)[i]; kp = __KB_KEY(key_t, x)[i]; __KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); return kp; } else if ((zn = __KB_PTR(b, x)[i + 1]-&gt;n) &gt;= T) { xp = __KB_PTR(b, x)[i + 1]; kp = __KB_KEY(key_t, x)[i]; __KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); return kp; } else if (yn == T - 1 &amp;&amp; zn == T - 1) { y = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1]; __KB_KEY(key_t, y)[y-&gt;n++] = *k; memmove(&amp;__KB_KEY(key_t, y)[y-&gt;n], __KB_KEY(key_t, z), (unsigned int)z-&gt;n * sizeof(key_t)); if (y-&gt;is_internal) memmove(&amp;__KB_PTR(b, y)[y-&gt;n], __KB_PTR(b, z), (unsigned int)(z-&gt;n + 1) * sizeof(void*)); y-&gt;n += z-&gt;n; memmove(&amp;__KB_KEY(key_t, x)[i], &amp;__KB_KEY(key_t, x)[i + 1], (unsigned int)(x-&gt;n - i - 1) * sizeof(key_t)); memmove(&amp;__KB_PTR(b, x)[i + 1], &amp;__KB_PTR(b, x)[i + 2], (unsigned int)(x-&gt;n - i - 1) * sizeof(void*)); --x-&gt;n; XFREE_CLEAR(z); return __kb_delp_aux_##name(b, y, k, s); } } ++i; if ((xp = __KB_PTR(b, x)[i])-&gt;n == T - 1) { if (i &gt; 0 &amp;&amp; (y = __KB_PTR(b, x)[i - 1])-&gt;n &gt;= T) { memmove(&amp;__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp-&gt;n * sizeof(key_t)); if (xp-&gt;is_internal) memmove(&amp;__KB_PTR(b, xp)[1], __KB_PTR(b, xp), (unsigned int)(xp-&gt;n + 1) * sizeof(void*)); __KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1]; __KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y-&gt;n - 1]; if (xp-&gt;is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y-&gt;n]; --y-&gt;n; ++xp-&gt;n; } else if (i &lt; x-&gt;n &amp;&amp; (y = __KB_PTR(b, x)[i + 1])-&gt;n &gt;= T) { __KB_KEY(key_t, xp)[xp-&gt;n++] = __KB_KEY(key_t, x)[i]; __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0]; if (xp-&gt;is_internal) __KB_PTR(b, xp)[xp-&gt;n] = __KB_PTR(b, y)[0]; --y-&gt;n; memmove(__KB_KEY(key_t, y), &amp;__KB_KEY(key_t, y)[1], (unsigned int)y-&gt;n * sizeof(key_t)); if (y-&gt;is_internal) memmove(__KB_PTR(b, y), &amp;__KB_PTR(b, y)[1], (unsigned int)(y-&gt;n + 1) * sizeof(void*)); } else if (i &gt; 0 &amp;&amp; (y = __KB_PTR(b, x)[i - 1])-&gt;n == T - 1) { __KB_KEY(key_t, y)[y-&gt;n++] = __KB_KEY(key_t, x)[i - 1]; memmove(&amp;__KB_KEY(key_t, y)[y-&gt;n], __KB_KEY(key_t, xp), (unsigned int)xp-&gt;n * sizeof(key_t)); if (y-&gt;is_internal) memmove(&amp;__KB_PTR(b, y)[y-&gt;n], __KB_PTR(b, xp), (unsigned int)(xp-&gt;n + 1) * sizeof(void*)); y-&gt;n += xp-&gt;n; memmove(&amp;__KB_KEY(key_t, x)[i - 1], &amp;__KB_KEY(key_t, x)[i], (unsigned int)(x-&gt;n - i) * sizeof(key_t)); memmove(&amp;__KB_PTR(b, x)[i], &amp;__KB_PTR(b, x)[i + 1], (unsigned int)(x-&gt;n - i) * sizeof(void*)); --x-&gt;n; XFREE_CLEAR(xp); xp = y; } else if (i &lt; x-&gt;n &amp;&amp; (y = __KB_PTR(b, x)[i + 1])-&gt;n == T - 1) { __KB_KEY(key_t, xp)[xp-&gt;n++] = __KB_KEY(key_t, x)[i]; memmove(&amp;__KB_KEY(key_t, xp)[xp-&gt;n], __KB_KEY(key_t, y), (unsigned int)y-&gt;n * sizeof(key_t)); if (xp-&gt;is_internal) memmove(&amp;__KB_PTR(b, xp)[xp-&gt;n], __KB_PTR(b, y), (unsigned int)(y-&gt;n + 1) * sizeof(void*)); xp-&gt;n += y-&gt;n; memmove(&amp;__KB_KEY(key_t, x)[i], &amp;__KB_KEY(key_t, x)[i + 1], (unsigned int)(x-&gt;n - i - 1) * sizeof(key_t)); memmove(&amp;__KB_PTR(b, x)[i + 1], &amp;__KB_PTR(b, x)[i + 2], (unsigned int)(x-&gt;n - i - 1) * sizeof(void*)); --x-&gt;n; XFREE_CLEAR(y); } } return __kb_delp_aux_##name(b, xp, k, s); } static inline key_t kb_delp_##name(kbtree_##name##_t *b, key_t * __restrict k) { kbnode_t *x; key_t ret; ret = __kb_delp_aux_##name(b, b-&gt;root, k, 0); --b-&gt;n_keys; if (b-&gt;root-&gt;n == 0 &amp;&amp; b-&gt;root-&gt;is_internal) { --b-&gt;n_nodes; x = b-&gt;root; b-&gt;root = __KB_PTR(b, x)[0]; XFREE_CLEAR(x); } return ret; } static inline key_t kb_del_##name(kbtree_##name##_t *b, key_t k) { return kb_delp_##name(b, &amp;k); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__KB_ITR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) { itr-&gt;p = NULL; if (b-&gt;n_keys == 0) return; itr-&gt;p = itr-&gt;stack; itr-&gt;p-&gt;x = b-&gt;root; itr-&gt;p-&gt;i = 0; while (itr-&gt;p-&gt;x-&gt;is_internal &amp;&amp; __KB_PTR(b, itr-&gt;p-&gt;x)[0] != 0) { kbnode_t *x = itr-&gt;p-&gt;x; ++itr-&gt;p; itr-&gt;p-&gt;x = __KB_PTR(b, x)[0]; itr-&gt;p-&gt;i = 0; } } static inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) { if (itr-&gt;p == NULL) return 0; for (;;) { ++itr-&gt;p-&gt;i; assert(itr-&gt;p-&gt;i &lt;= 21); while (itr-&gt;p-&gt;x &amp;&amp; itr-&gt;p-&gt;i &lt;= itr-&gt;p-&gt;x-&gt;n) { itr-&gt;p[1].i = 0; itr-&gt;p[1].x = itr-&gt;p-&gt;x-&gt;is_internal? __KB_PTR(b, itr-&gt;p-&gt;x)[itr-&gt;p-&gt;i] : 0; ++itr-&gt;p; } if (itr-&gt;p == itr-&gt;stack) { itr-&gt;p = NULL; return 0; } --itr-&gt;p; if (itr-&gt;p-&gt;x &amp;&amp; itr-&gt;p-&gt;i &lt; itr-&gt;p-&gt;x-&gt;n) return 1; } } static inline int kb_itr_prev_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) { if (itr-&gt;p == NULL) return 0; for (;;) { while (itr-&gt;p-&gt;x &amp;&amp; itr-&gt;p-&gt;i &gt;= 0) { itr-&gt;p[1].x = itr-&gt;p-&gt;x-&gt;is_internal? __KB_PTR(b, itr-&gt;p-&gt;x)[itr-&gt;p-&gt;i] : 0; itr-&gt;p[1].i = itr-&gt;p[1].x ? itr-&gt;p[1].x-&gt;n : -1; ++itr-&gt;p; } if (itr-&gt;p == itr-&gt;stack) { itr-&gt;p = NULL; return 0; } --itr-&gt;p; --itr-&gt;p-&gt;i; if (itr-&gt;p-&gt;x &amp;&amp; itr-&gt;p-&gt;i &gt;= 0) return 1; } } static inline int kb_itr_getp_##name(kbtree_##name##_t *b, key_t * __restrict k, kbitr_##name##_t *itr) { if (b-&gt;n_keys == 0) { itr-&gt;p = NULL; return 0; } int i, r = 0; itr-&gt;p = itr-&gt;stack; itr-&gt;p-&gt;x = b-&gt;root; while (itr-&gt;p-&gt;x) { i = __kb_getp_aux_##name(itr-&gt;p-&gt;x, k, &amp;r); itr-&gt;p-&gt;i = i; if (i &gt;= 0 &amp;&amp; r == 0) return 1; ++itr-&gt;p-&gt;i; assert(itr-&gt;p-&gt;i &lt;= 21); itr-&gt;p[1].x = itr-&gt;p-&gt;x-&gt;is_internal? __KB_PTR(b, itr-&gt;p-&gt;x)[i + 1] : 0; ++itr-&gt;p; } itr-&gt;p-&gt;i = 0; return 0; } static inline int kb_itr_get_##name(kbtree_##name##_t *b, key_t k, kbitr_##name##_t *itr) { return kb_itr_getp_##name(b,&amp;k,itr); } static inline void kb_del_itr_##name(kbtree_##name##_t *b, kbitr_##name##_t *itr) { key_t k = kb_itr_key(itr); kb_delp_##name(b, &amp;k); kb_itr_getp_##name(b, &amp;k, itr); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KBTREE_INIT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>__cmp</name></type></parameter>, <parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, (sizeof(kbnode_##name##_t)+(2*T)*sizeof(void *)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KBTREE_INIT_IMPL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>key_t</name></type></parameter>, <parameter><type><name>kbnode_t</name></type></parameter>, <parameter><type><name>__cmp</name></type></parameter>, <parameter><type><name>T</name></type></parameter>, <parameter><type><name>ILEN</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__KB_TREE_T(name, key_t, T) __KB_GET_AUX1(name, key_t, kbnode_t, __cmp) __KB_GET(name, key_t, kbnode_t) __KB_INTERVAL(name, key_t, kbnode_t) __KB_PUT(name, key_t, kbnode_t, __cmp, T, ILEN) __KB_DEL(name, key_t, kbnode_t, T) __KB_ITR(name, key_t, kbnode_t)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB_DEFAULT_SIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kbtree_t</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kbtree_##name##_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kbitr_t</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kbitr_##name##_t</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_init</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b)-&gt;n_keys = (b)-&gt;n_nodes = 0, (b)-&gt;root = 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_destroy</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__kb_destroy(kbnode_##name##_t, b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_get</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_get_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_put</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_put_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_del</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_del_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_interval</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_interval_##name(b, k, l, u)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_getp</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_getp_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_putp</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_putp_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_delp</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_delp_##name(b, k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_intervalp</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_intervalp_##name(b, k, l, u)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_first</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_itr_first_##name(b, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_get</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_itr_get_##name(b, k, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_getp</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_itr_getp_##name(b, k, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_next</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_itr_next_##name(b, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_prev</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_itr_prev_##name(b, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_del_itr</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kb_del_itr_##name(b, i)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_key</name><parameter_list>(<parameter><type><name>itr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__KB_KEY(dummy, (itr)-&gt;p-&gt;x)[(itr)-&gt;p-&gt;i]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_itr_valid</name><parameter_list>(<parameter><type><name>itr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((itr)-&gt;p &gt;= (itr)-&gt;stack)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_size</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((b)-&gt;n_keys)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_generic_cmp</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((b) &lt; (a)) - ((a) &lt; (b)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb_str_cmp</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strcmp(a, b)</cpp:value></cpp:define>

</unit>
