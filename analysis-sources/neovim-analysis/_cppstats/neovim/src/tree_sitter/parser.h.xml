<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats\neovim\src\tree_sitter\parser.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ts_builtin_sym_error</name></cpp:macro> <cpp:value>((TSSymbol)-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ts_builtin_sym_end</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_SITTER_SERIALIZATION_BUFFER_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TREE_SITTER_API_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>uint16_t</name></type> <name>TSSymbol</name>;</typedef>

<typedef>typedef <type><name>uint16_t</name></type> <name>TSFieldId</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>TSLanguage</name></name></type> <name>TSLanguage</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>TSFieldId</name></type> <name>field_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>child_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>inherited</name></decl>;</decl_stmt>

}</block></struct></type> <name>TSFieldMapEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>uint16_t</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>length</name></decl>;</decl_stmt>

}</block></struct></type> <name>TSFieldMapSlice</name>;</typedef>

<typedef>typedef <type><name>uint16_t</name></type> <name>TSStateId</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>visible</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>named</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block></struct></type> <name>TSSymbolMetadata</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>TSLexer</name></name></type> <name>TSLexer</name>;</typedef>

<struct>struct <name>TSLexer</name> <block>{

<decl_stmt><decl><type><name>int32_t</name></type> <name>lookahead</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TSSymbol</name></type> <name>result_symbol</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>advance</name>)<parameter_list>(<parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>mark_end</name>)<parameter_list>(<parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>uint32_t</name></type> (<modifier>*</modifier><name>get_column</name>)<parameter_list>(<parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>is_at_included_range_start</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>eof</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

}</block>;</struct>

<typedef>typedef <type><enum>enum <block>{

<decl><name>TSParseActionTypeShift</name></decl>,

<decl><name>TSParseActionTypeReduce</name></decl>,

<decl><name>TSParseActionTypeAccept</name></decl>,

<decl><name>TSParseActionTypeRecover</name></decl>,

}</block></enum></type> <name>TSParseActionType</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>TSStateId</name></type> <name>state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>extra</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>repetition</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>TSSymbol</name></type> <name>symbol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int16_t</name></type> <name>dynamic_precedence</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>child_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>production_id</name></decl>;</decl_stmt>

}</block>;</struct>

}</block> <decl><name>params</name></decl>;</union>

<decl_stmt><decl><type><name>TSParseActionType</name></type> <name>type</name> <range>: <expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>

}</block></struct></type> <name>TSParseAction</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>uint16_t</name></type> <name>lex_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>external_lex_state</name></decl>;</decl_stmt>

}</block></struct></type> <name>TSLexMode</name>;</typedef>

<typedef>typedef <type><union>union <block>{

<decl_stmt><decl><type><name>TSParseAction</name></type> <name>action</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>reusable</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block>;</struct>

}</block></union></type> <name>TSParseActionEntry</name>;</typedef>

<struct>struct <name>TSLanguage</name> <block>{

<decl_stmt><decl><type><name>uint32_t</name></type> <name>version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>symbol_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>alias_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>token_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>external_token_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symbol_names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSSymbolMetadata</name> <modifier>*</modifier></type><name>symbol_metadata</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>parse_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSParseActionEntry</name> <modifier>*</modifier></type><name>parse_actions</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSLexMode</name> <modifier>*</modifier></type><name>lex_modes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSSymbol</name> <modifier>*</modifier></type><name>alias_sequences</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>max_alias_sequence_length</name></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>lex_fn</name>)<parameter_list>(<parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>TSStateId</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>keyword_lex_fn</name>)<parameter_list>(<parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>TSStateId</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>TSSymbol</name></type> <name>keyword_capture_token</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>states</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSSymbol</name> <modifier>*</modifier></type><name>symbol_map</name></decl>;</decl_stmt>

<function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>create</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>destroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>scan</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>TSLexer</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>symbol_whitelist</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>unsigned</name></type> (<modifier>*</modifier><name>serialize</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>deserialize</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type></decl></parameter>)</parameter_list>;</function_decl>

}</block> <decl><name>external_scanner</name></decl>;</struct>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>field_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSFieldMapSlice</name> <modifier>*</modifier></type><name>field_map_slices</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSFieldMapEntry</name> <modifier>*</modifier></type><name>field_map_entries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field_names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>large_state_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>small_parse_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>small_parse_table_map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>TSSymbol</name> <modifier>*</modifier></type><name>public_symbol_map</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>START_LEXER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>bool result = false; bool skip = false; bool eof = false; int32_t lookahead; goto start; next_state: lexer-&gt;advance(lexer, skip); start: skip = false; lookahead = lexer-&gt;lookahead;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADVANCE</name><parameter_list>(<parameter><type><name>state_value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ state = state_value; goto next_state; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP</name><parameter_list>(<parameter><type><name>state_value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ skip = true; state = state_value; goto next_state; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCEPT_TOKEN</name><parameter_list>(<parameter><type><name>symbol_value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>result = true; lexer-&gt;result_symbol = symbol_value; lexer-&gt;mark_end(lexer);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_STATE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>return result;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_STATE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>id - LARGE_STATE_COUNT</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>id</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTIONS</name><parameter_list>(<parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>id</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT</name><parameter_list>(<parameter><type><name>state_value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeShift, .params = {.state = state_value}, } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT_REPEAT</name><parameter_list>(<parameter><type><name>state_value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeShift, .params = { .state = state_value, .repetition = true }, } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeRecover } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT_EXTRA</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeShift, .params = {.extra = true} } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDUCE</name><parameter_list>(<parameter><type><name>symbol_val</name></type></parameter>, <parameter><type><name>child_count_val</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeReduce, .params = { .symbol = symbol_val, .child_count = child_count_val, __VA_ARGS__ } } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCEPT_INPUT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ { .type = TSParseActionTypeAccept } }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
