<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\viml\parser\expressions.c">



















































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/viml/parser/expressions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/viml/parser/parser.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vim_str2nr</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vim_str2nr((const char_u *)(s), __VA_ARGS__)</cpp:value></cpp:define>

<typedef>typedef <macro><name>kvec_withinit_t</name><argument_list>(<argument>ExprASTNode **</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro> <expr_stmt><expr><name>ExprASTStack</name></expr>;</expr_stmt></typedef>


<typedef>typedef <type><enum>enum <block>{



<decl><name>kENodeOperator</name></decl>,




<decl><name>kENodeValue</name></decl>,
}</block></enum></type> <name>ExprASTWantedNode</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{

<decl><name>kEPTExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,




<decl><name>kEPTLambdaArguments</name></decl>,

<decl><name>kEPTAssignment</name></decl>,

<decl><name>kEPTSingleAssignment</name></decl>,
}</block></enum></type> <name>ExprASTParseType</name>;</typedef>

<typedef>typedef <macro><name>kvec_withinit_t</name><argument_list>(<argument>ExprASTParseType</argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro> <expr_stmt><expr><name>ExprASTParseTypeStack</name></expr>;</expr_stmt></typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>kEOpLvlInvalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>kEOpLvlComplexIdentifier</name></decl>,
<decl><name>kEOpLvlParens</name></decl>,
<decl><name>kEOpLvlAssignment</name></decl>,
<decl><name>kEOpLvlArrow</name></decl>,
<decl><name>kEOpLvlComma</name></decl>,
<decl><name>kEOpLvlColon</name></decl>,
<decl><name>kEOpLvlTernaryValue</name></decl>,
<decl><name>kEOpLvlTernary</name></decl>,
<decl><name>kEOpLvlOr</name></decl>,
<decl><name>kEOpLvlAnd</name></decl>,
<decl><name>kEOpLvlComparison</name></decl>,
<decl><name>kEOpLvlAddition</name></decl>, 
<decl><name>kEOpLvlMultiplication</name></decl>, 
<decl><name>kEOpLvlUnary</name></decl>, 
<decl><name>kEOpLvlSubscript</name></decl>, 
<decl><name>kEOpLvlValue</name></decl>, 
}</block></enum></type> <name>ExprOpLvl</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>kEOpAssNo</name><init>= <expr><literal type="char">'n'</literal></expr></init></decl>, 
<decl><name>kEOpAssLeft</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>, 
<decl><name>kEOpAssRight</name> <init>= <expr><literal type="char">'r'</literal></expr></init></decl>, 
}</block></enum></type> <name>ExprOpAssociativity</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"viml/parser/expressions.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOLOAD_CHAR</name></cpp:macro> <cpp:value>'#'</cpp:value></cpp:define>











<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float_T</name></type> <name>scale_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float_T</name></type> <name>num</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uvarnumber_T</name></type> <name>exponent</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>exponent_negative</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_CONST
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>exponent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>exp</name> <init>= <expr><name>exponent</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float_T</name></type> <name>p_base</name> <init>= <expr><operator>(</operator><name>float_T</name><operator>)</operator><name>base</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float_T</name></type> <name>ret</name> <init>= <expr><name>num</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>exp</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exponent_negative</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>/=</operator> <name>p_base</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>*=</operator> <name>p_base</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>exp</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p_base</name> <operator>*=</operator> <name>p_base</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>LexExprToken</name></type> <name>viml_pexpr_next_token</name><parameter_list>(<parameter><decl><type><name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>LexExprToken</name></type> <name>ret</name> <init>= <expr><block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kExprLexInvalid</name></expr>,
<expr><operator>.</operator><name>start</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>pos</name></name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParserLine</name></type> <name>pline</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>viml_parser_get_remaining_line</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pline</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexEOC</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexEOC</name></expr>;</expr_stmt>
<goto>goto <name>viml_pexpr_next_token_adv_return</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>schar</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CCS</name><parameter_list>(<parameter><type><name>ret</name></type></parameter>, <parameter><type><name>pline</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ret.len &lt; pline.size &amp;&amp; strchr("?#", pline.data[ret.len]) != NULL) { ret.data.cmp.ccs = (ExprCaseCompareStrategy)pline.data[ret.len]; ret.len++; } else { ret.data.cmp.ccs = kCCStrategyUseOption; } } while (0)</cpp:value></cpp:define>










<switch>switch <condition>(<expr><name>schar</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BRACKET</name><parameter_list>(<parameter><type><name>typ</name></type></parameter>, <parameter><type><name>opning</name></type></parameter>, <parameter><type><name>clsing</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case opning: case clsing: { ret.type = typ; ret.data.brc.closing = (schar == clsing); break; }</cpp:value></cpp:define>






<macro><name>BRACKET</name><argument_list>(<argument>kExprLexParenthesis</argument>, <argument><literal type="char">'('</literal></argument>, <argument><literal type="char">')'</literal></argument>)</argument_list></macro>
<macro><name>BRACKET</name><argument_list>(<argument>kExprLexBracket</argument>, <argument><literal type="char">'['</literal></argument>, <argument><literal type="char">']'</literal></argument>)</argument_list></macro>
<macro><name>BRACKET</name><argument_list>(<argument>kExprLexFigureBrace</argument>, <argument><literal type="char">'{'</literal></argument>, <argument><literal type="char">'}'</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BRACKET</name></cpp:undef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR</name><parameter_list>(<parameter><type><name>typ</name></type></parameter>, <parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ch: { ret.type = typ; break; }</cpp:value></cpp:define>




<macro><name>CHAR</name><argument_list>(<argument>kExprLexQuestion</argument>, <argument><literal type="char">'?'</literal></argument>)</argument_list></macro>
<macro><name>CHAR</name><argument_list>(<argument>kExprLexColon</argument>, <argument><literal type="char">':'</literal></argument>)</argument_list></macro>
<macro><name>CHAR</name><argument_list>(<argument>kExprLexComma</argument>, <argument><literal type="char">','</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR</name></cpp:undef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL</name><parameter_list>(<parameter><type><name>mul_type</name></type></parameter>, <parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ch: { ret.type = kExprLexMultiplication; ret.data.mul.type = mul_type; break; }</cpp:value></cpp:define>





<macro><name>MUL</name><argument_list>(<argument>kExprLexMulMul</argument>, <argument><literal type="char">'*'</literal></argument>)</argument_list></macro>
<macro><name>MUL</name><argument_list>(<argument>kExprLexMulDiv</argument>, <argument><literal type="char">'/'</literal></argument>)</argument_list></macro>
<macro><name>MUL</name><argument_list>(<argument>kExprLexMulMod</argument>, <argument><literal type="char">'%'</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MUL</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARREG</name><parameter_list>(<parameter><type><name>typ</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ret.type = typ; for (; (ret.len &lt; pline.size &amp;&amp; cond(pline.data[ret.len])) ; ret.len++) { } } while (0)</cpp:value></cpp:define>









<case>case <expr><literal type="char">' '</literal></expr>:</case>
<case>case <expr><name>TAB</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexSpacing</name></expr></argument>, <argument><expr><name>ascii_iswhite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><name>Ctrl_A</name></expr>:</case> <case>case <expr><name>Ctrl_B</name></expr>:</case> <case>case <expr><name>Ctrl_C</name></expr>:</case> <case>case <expr><name>Ctrl_D</name></expr>:</case> <case>case <expr><name>Ctrl_E</name></expr>:</case>
<case>case <expr><name>Ctrl_F</name></expr>:</case> <case>case <expr><name>Ctrl_G</name></expr>:</case> <case>case <expr><name>Ctrl_H</name></expr>:</case>

<case>case <expr><name>Ctrl_K</name></expr>:</case> <case>case <expr><name>Ctrl_L</name></expr>:</case> <case>case <expr><name>Ctrl_M</name></expr>:</case> <case>case <expr><name>Ctrl_N</name></expr>:</case> <case>case <expr><name>Ctrl_O</name></expr>:</case>
<case>case <expr><name>Ctrl_P</name></expr>:</case> <case>case <expr><name>Ctrl_Q</name></expr>:</case> <case>case <expr><name>Ctrl_R</name></expr>:</case> <case>case <expr><name>Ctrl_S</name></expr>:</case> <case>case <expr><name>Ctrl_T</name></expr>:</case>
<case>case <expr><name>Ctrl_U</name></expr>:</case> <case>case <expr><name>Ctrl_V</name></expr>:</case> <case>case <expr><name>Ctrl_W</name></expr>:</case> <case>case <expr><name>Ctrl_X</name></expr>:</case> <case>case <expr><name>Ctrl_Y</name></expr>:</case>
<case>case <expr><name>Ctrl_Z</name></expr>:</case> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISCTRL</name><parameter_list>(<parameter><type><name>schar</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(schar &lt; ' ')</cpp:value></cpp:define>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexInvalid</name></expr></argument>, <argument><expr><name>ISCTRL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexSpacing</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name> <operator>=</operator>
<call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Invalid control character present in input: %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISCTRL</name></cpp:undef>
</block_content>}</block>


<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>is_float</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>base</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>frac_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>exp_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>frac_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>exp_negative</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexNumber</name></expr></argument>, <argument><expr><name>ascii_isdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>kELFlagAllowFloat</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>LexExprToken</name></type> <name>non_float_ret</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal>
<operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>frac_start</name> <operator>=</operator> <name><name>ret</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac_end</name> <operator>=</operator> <name><name>ret</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>is_float</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>
;</condition> <incr><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>frac_end</name> <operator>=</operator> <name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal>
<operator>||</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal>
<operator>||</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal>
<operator>||</operator> <operator>(</operator><name>exp_negative</name> <operator>=</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>exp_start</name> <operator>=</operator> <name><name>ret</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexNumber</name></expr></argument>, <argument><expr><name>ascii_isdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>ret</name><operator>.</operator><name>len</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal>
<operator>||</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>non_float_ret</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>is_float</name></name></expr>)</condition> <block>{<block_content>











<decl_stmt><decl><type><name>float_T</name></type> <name>significand_part</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>exp_part</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>frac_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>frac_end</name> <operator>-</operator> <name>frac_start</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>frac_end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>frac_start</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>significand_part</name> <operator>=</operator> <name>significand_part</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>exp_start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>exp_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exp_part</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>exp_start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exp_negative</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exp_part</name> <operator>+=</operator> <name>frac_size</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exp_part</name> <operator>&lt;</operator> <name>frac_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exp_negative</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>exp_part</name> <operator>=</operator> <name>frac_size</name> <operator>-</operator> <name>exp_part</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>exp_part</name> <operator>-=</operator> <name>frac_size</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>val</name><operator>.</operator><name>floating</name></name> <operator>=</operator> <call><name>scale_number</name><argument_list>(<argument><expr><name>significand_part</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>exp_part</name></expr></argument>,
<argument><expr><name>exp_negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prep</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>STR2NR_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>val</name><operator>.</operator><name>integer</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>bases</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="number">10</literal></expr>,
<expr><index>[<expr><literal type="char">'0'</literal></expr>]</index> <operator>=</operator> <literal type="number">8</literal></expr>,
<expr><index>[<expr><literal type="char">'x'</literal></expr>]</index> <operator>=</operator> <literal type="number">16</literal></expr>, <expr><index>[<expr><literal type="char">'X'</literal></expr>]</index> <operator>=</operator> <literal type="number">16</literal></expr>,
<expr><index>[<expr><literal type="char">'b'</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>, <expr><index>[<expr><literal type="char">'B'</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name><name>bases</name><index>[<expr><name>prep</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISWORD_OR_AUTOLOAD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ascii_isident(x) || (x) == AUTOLOAD_CHAR)</cpp:value></cpp:define>



<case>case <expr><literal type="char">'$'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexEnv</name></expr></argument>, <argument><expr><name>ascii_isident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'e'</literal></expr>:</case> <case>case <expr><literal type="char">'f'</literal></expr>:</case> <case>case <expr><literal type="char">'g'</literal></expr>:</case>
<case>case <expr><literal type="char">'h'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case> <case>case <expr><literal type="char">'j'</literal></expr>:</case> <case>case <expr><literal type="char">'k'</literal></expr>:</case> <case>case <expr><literal type="char">'l'</literal></expr>:</case> <case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'n'</literal></expr>:</case>
<case>case <expr><literal type="char">'o'</literal></expr>:</case> <case>case <expr><literal type="char">'p'</literal></expr>:</case> <case>case <expr><literal type="char">'q'</literal></expr>:</case> <case>case <expr><literal type="char">'r'</literal></expr>:</case> <case>case <expr><literal type="char">'s'</literal></expr>:</case> <case>case <expr><literal type="char">'t'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case>
<case>case <expr><literal type="char">'v'</literal></expr>:</case> <case>case <expr><literal type="char">'w'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'y'</literal></expr>:</case> <case>case <expr><literal type="char">'z'</literal></expr>:</case>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <case>case <expr><literal type="char">'C'</literal></expr>:</case> <case>case <expr><literal type="char">'D'</literal></expr>:</case> <case>case <expr><literal type="char">'E'</literal></expr>:</case> <case>case <expr><literal type="char">'F'</literal></expr>:</case> <case>case <expr><literal type="char">'G'</literal></expr>:</case>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> <case>case <expr><literal type="char">'I'</literal></expr>:</case> <case>case <expr><literal type="char">'J'</literal></expr>:</case> <case>case <expr><literal type="char">'K'</literal></expr>:</case> <case>case <expr><literal type="char">'L'</literal></expr>:</case> <case>case <expr><literal type="char">'M'</literal></expr>:</case> <case>case <expr><literal type="char">'N'</literal></expr>:</case>
<case>case <expr><literal type="char">'O'</literal></expr>:</case> <case>case <expr><literal type="char">'P'</literal></expr>:</case> <case>case <expr><literal type="char">'Q'</literal></expr>:</case> <case>case <expr><literal type="char">'R'</literal></expr>:</case> <case>case <expr><literal type="char">'S'</literal></expr>:</case> <case>case <expr><literal type="char">'T'</literal></expr>:</case> <case>case <expr><literal type="char">'U'</literal></expr>:</case>
<case>case <expr><literal type="char">'V'</literal></expr>:</case> <case>case <expr><literal type="char">'W'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case> <case>case <expr><literal type="char">'Y'</literal></expr>:</case> <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
<case>case <expr><literal type="char">'_'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>autoload</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexPlainIdentifier</name></expr></argument>, <argument><expr><name>ascii_isident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kELFlagIsNotCmp</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"is"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"isnot"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexComparison</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprCmpIdentical</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>=</operator> <operator>(</operator><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_CCS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>pline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>EXPR_VAR_SCOPE_LIST</name></expr></argument>, <argument><expr><name>schar</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EXPR_VAR_SCOPE_LIST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kELFlagForbidScope</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <operator>(</operator><name>ExprVarScope</name><operator>)</operator><name>schar</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexPlainIdentifier</name></expr></argument>, <argument><expr><name>ISWORD_OR_AUTOLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>autoload</name></name> <operator>=</operator> <operator>(</operator>
<call><name>memchr</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>AUTOLOAD_CHAR</name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>







</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>ret</name><operator>.</operator><name>len</name></name>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <name>AUTOLOAD_CHAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>autoload</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHARREG</name><argument_list>(<argument><expr><name>kExprLexPlainIdentifier</name></expr></argument>, <argument><expr><name>ISWORD_OR_AUTOLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ISWORD_OR_AUTOLOAD</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHARREG</name></cpp:undef>


<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTNAMEMISS</name><parameter_list>(<parameter><type><name>ret</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ret.type = kExprLexInvalid; ret.data.err.type = kExprLexOption; ret.data.err.msg = _("E112: Option name missing: %.*s"); } while (0)</cpp:value></cpp:define>





<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexAnd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>OPTNAMEMISS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexOption</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal>
<operator>&amp;&amp;</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>EXPR_OPT_SCOPE_LIST</name></expr></argument>, <argument><expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EXPR_OPT_SCOPE_LIST</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <operator>(</operator><name>ExprOptScope</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name>kExprOptScopeUnspecified</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>pline</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>-</operator> <name>p</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>name</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>OPTNAMEMISS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPTNAMEMISS</name></cpp:undef>
</block_content>}</block>


<case>case <expr><literal type="char">'@'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexRegister</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'\''</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexSingleQuotedString</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr>;</condition> <incr><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'"'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexDoubleQuotedString</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr>;</condition> <incr><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>pline</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<case>case <expr><literal type="char">'='</literal></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>schar</name> <operator>==</operator> <literal type="char">'!'</literal></expr> ?</condition><then> <expr><name>kExprLexNot</name></expr> </then><else>: <expr><name>kExprLexAssignment</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprAsgnPlain</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexComparison</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>=</operator> <operator>(</operator><name>schar</name> <operator>==</operator> <literal type="char">'!'</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprCmpEqual</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprCmpMatches</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>schar</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexNot</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexAssignment</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprAsgnPlain</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>GET_CCS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>pline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexComparison</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>haseqsign</name> <init>= <expr><operator>(</operator><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>haseqsign</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>GET_CCS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>pline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>=</operator> <operator>(</operator><name>schar</name> <operator>==</operator> <literal type="char">'&lt;'</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>^</operator> <name>haseqsign</name><operator>)</operator></expr>
?</condition><then> <expr><name>kExprCmpGreaterOrEqual</name></expr>
</then><else>: <expr><name>kExprCmpGreater</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexArrow</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexAssignment</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprAsgnSubtract</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexMinus</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_OR_ASSIGN</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>, <parameter><type><name>ch_type</name></type></parameter>, <parameter><type><name>ass_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ch: { if (pline.size &gt; 1 &amp;&amp; pline.data[1] == '=') { ret.len++; ret.type = kExprLexAssignment; ret.data.ass.type = ass_type; } else { ret.type = ch_type; } break; }</cpp:value></cpp:define>










<macro><name>CHAR_OR_ASSIGN</name><argument_list>(<argument><literal type="char">'+'</literal></argument>, <argument>kExprLexPlus</argument>, <argument>kExprAsgnAdd</argument>)</argument_list></macro>
<macro><name>CHAR_OR_ASSIGN</name><argument_list>(<argument><literal type="char">'.'</literal></argument>, <argument>kExprLexDot</argument>, <argument>kExprAsgnConcat</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_OR_ASSIGN</name></cpp:undef>


<case>case <expr><name>NUL</name></expr>:</case>
<case>case <expr><name>NL</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>kELFlagForbidEOC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected EOC character: %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexSpacing</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexEOC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="char">'|'</literal></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexOr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>kELFlagForbidEOC</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected EOC character: %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexOr</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexEOC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>


<default>default:</default> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>utfc_ptr2len_len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name><name>pline</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprLexPlainIdentifier</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unidentified character: %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_CCS</name></cpp:undef>
<label><name>viml_pexpr_next_token_adv_return</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kELFlagPeek</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_advance</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>eltkn_type_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprLexInvalid</name></expr>]</index> <operator>=</operator> <literal type="string">"Invalid"</literal></expr>,
<expr><index>[<expr><name>kExprLexMissing</name></expr>]</index> <operator>=</operator> <literal type="string">"Missing"</literal></expr>,
<expr><index>[<expr><name>kExprLexSpacing</name></expr>]</index> <operator>=</operator> <literal type="string">"Spacing"</literal></expr>,
<expr><index>[<expr><name>kExprLexEOC</name></expr>]</index> <operator>=</operator> <literal type="string">"EOC"</literal></expr>,

<expr><index>[<expr><name>kExprLexQuestion</name></expr>]</index> <operator>=</operator> <literal type="string">"Question"</literal></expr>,
<expr><index>[<expr><name>kExprLexColon</name></expr>]</index> <operator>=</operator> <literal type="string">"Colon"</literal></expr>,
<expr><index>[<expr><name>kExprLexOr</name></expr>]</index> <operator>=</operator> <literal type="string">"Or"</literal></expr>,
<expr><index>[<expr><name>kExprLexAnd</name></expr>]</index> <operator>=</operator> <literal type="string">"And"</literal></expr>,
<expr><index>[<expr><name>kExprLexComparison</name></expr>]</index> <operator>=</operator> <literal type="string">"Comparison"</literal></expr>,
<expr><index>[<expr><name>kExprLexPlus</name></expr>]</index> <operator>=</operator> <literal type="string">"Plus"</literal></expr>,
<expr><index>[<expr><name>kExprLexMinus</name></expr>]</index> <operator>=</operator> <literal type="string">"Minus"</literal></expr>,
<expr><index>[<expr><name>kExprLexDot</name></expr>]</index> <operator>=</operator> <literal type="string">"Dot"</literal></expr>,
<expr><index>[<expr><name>kExprLexMultiplication</name></expr>]</index> <operator>=</operator> <literal type="string">"Multiplication"</literal></expr>,

<expr><index>[<expr><name>kExprLexNot</name></expr>]</index> <operator>=</operator> <literal type="string">"Not"</literal></expr>,

<expr><index>[<expr><name>kExprLexNumber</name></expr>]</index> <operator>=</operator> <literal type="string">"Number"</literal></expr>,
<expr><index>[<expr><name>kExprLexSingleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="string">"SingleQuotedString"</literal></expr>,
<expr><index>[<expr><name>kExprLexDoubleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="string">"DoubleQuotedString"</literal></expr>,
<expr><index>[<expr><name>kExprLexOption</name></expr>]</index> <operator>=</operator> <literal type="string">"Option"</literal></expr>,
<expr><index>[<expr><name>kExprLexRegister</name></expr>]</index> <operator>=</operator> <literal type="string">"Register"</literal></expr>,
<expr><index>[<expr><name>kExprLexEnv</name></expr>]</index> <operator>=</operator> <literal type="string">"Env"</literal></expr>,
<expr><index>[<expr><name>kExprLexPlainIdentifier</name></expr>]</index> <operator>=</operator> <literal type="string">"PlainIdentifier"</literal></expr>,

<expr><index>[<expr><name>kExprLexBracket</name></expr>]</index> <operator>=</operator> <literal type="string">"Bracket"</literal></expr>,
<expr><index>[<expr><name>kExprLexFigureBrace</name></expr>]</index> <operator>=</operator> <literal type="string">"FigureBrace"</literal></expr>,
<expr><index>[<expr><name>kExprLexParenthesis</name></expr>]</index> <operator>=</operator> <literal type="string">"Parenthesis"</literal></expr>,
<expr><index>[<expr><name>kExprLexComma</name></expr>]</index> <operator>=</operator> <literal type="string">"Comma"</literal></expr>,
<expr><index>[<expr><name>kExprLexArrow</name></expr>]</index> <operator>=</operator> <literal type="string">"Arrow"</literal></expr>,
<expr><index>[<expr><name>kExprLexAssignment</name></expr>]</index> <operator>=</operator> <literal type="string">"Assignment"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>eltkn_cmp_type_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprCmpEqual</name></expr>]</index> <operator>=</operator> <literal type="string">"Equal"</literal></expr>,
<expr><index>[<expr><name>kExprCmpMatches</name></expr>]</index> <operator>=</operator> <literal type="string">"Matches"</literal></expr>,
<expr><index>[<expr><name>kExprCmpGreater</name></expr>]</index> <operator>=</operator> <literal type="string">"Greater"</literal></expr>,
<expr><index>[<expr><name>kExprCmpGreaterOrEqual</name></expr>]</index> <operator>=</operator> <literal type="string">"GreaterOrEqual"</literal></expr>,
<expr><index>[<expr><name>kExprCmpIdentical</name></expr>]</index> <operator>=</operator> <literal type="string">"Identical"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>expr_asgn_type_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprAsgnPlain</name></expr>]</index> <operator>=</operator> <literal type="string">"Plain"</literal></expr>,
<expr><index>[<expr><name>kExprAsgnAdd</name></expr>]</index> <operator>=</operator> <literal type="string">"Add"</literal></expr>,
<expr><index>[<expr><name>kExprAsgnSubtract</name></expr>]</index> <operator>=</operator> <literal type="string">"Subtract"</literal></expr>,
<expr><index>[<expr><name>kExprAsgnConcat</name></expr>]</index> <operator>=</operator> <literal type="string">"Concat"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ccs_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kCCStrategyUseOption</name></expr>]</index> <operator>=</operator> <literal type="string">"UseOption"</literal></expr>,
<expr><index>[<expr><name>kCCStrategyMatchCase</name></expr>]</index> <operator>=</operator> <literal type="string">"MatchCase"</literal></expr>,
<expr><index>[<expr><name>kCCStrategyIgnoreCase</name></expr>]</index> <operator>=</operator> <literal type="string">"IgnoreCase"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>eltkn_mul_type_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprLexMulMul</name></expr>]</index> <operator>=</operator> <literal type="string">"Mul"</literal></expr>,
<expr><index>[<expr><name>kExprLexMulDiv</name></expr>]</index> <operator>=</operator> <literal type="string">"Div"</literal></expr>,
<expr><index>[<expr><name>kExprLexMulMod</name></expr>]</index> <operator>=</operator> <literal type="string">"Mod"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>eltkn_opt_scope_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprOptScopeUnspecified</name></expr>]</index> <operator>=</operator> <literal type="string">"Unspecified"</literal></expr>,
<expr><index>[<expr><name>kExprOptScopeGlobal</name></expr>]</index> <operator>=</operator> <literal type="string">"Global"</literal></expr>,
<expr><index>[<expr><name>kExprOptScopeLocal</name></expr>]</index> <operator>=</operator> <literal type="string">"Local"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>















<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>viml_pexpr_repr_token</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LexExprToken</name></type> <name>token</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ret</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDSTR</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { p += snprintf(p, (size_t)(sizeof(ret) - (size_t)(p - ret)), __VA_ARGS__); if (p &gt;= e) { goto viml_pexpr_repr_token_end; } } while (0)</cpp:value></cpp:define>






<expr_stmt><expr><call><name>ADDSTR</name><argument_list>(<argument><expr><literal type="string">"%zu:%zu:%s"</literal></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name></expr></argument>,
<argument><expr><name><name>eltkn_type_tab</name><index>[<expr><name><name>token</name><operator>.</operator><name>type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>token</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TKNARGS</name><parameter_list>(<parameter><type><name>tkn_type</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case tkn_type: { ADDSTR(__VA_ARGS__); break; }</cpp:value></cpp:define>




<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexComparison</argument>, <argument><literal type="string">"(type=%s,ccs=%s,inv=%i)"</literal></argument>,
<argument>eltkn_cmp_type_tab[token.data.cmp.type]</argument>,
<argument>ccs_tab[token.data.cmp.ccs]</argument>,
<argument>(int)token.data.cmp.inv</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexMultiplication</argument>, <argument><literal type="string">"(type=%s)"</literal></argument>,
<argument>eltkn_mul_type_tab[token.data.mul.type]</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexAssignment</argument>, <argument><literal type="string">"(type=%s)"</literal></argument>,
<argument>expr_asgn_type_tab[token.data.ass.type]</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexRegister</argument>, <argument><literal type="string">"(name=%s)"</literal></argument>, <argument>intchar2str(token.data.reg.name)</argument>)</argument_list></macro>
<case>case <expr><name>kExprLexDoubleQuotedString</name></expr>:</case>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexSingleQuotedString</argument>, <argument><literal type="string">"(closed=%i)"</literal></argument>,
<argument>(int)token.data.str.closed</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexOption</argument>, <argument><literal type="string">"(scope=%s,name=%.*s)"</literal></argument>,
<argument>eltkn_opt_scope_tab[token.data.opt.scope]</argument>,
<argument>(int)token.data.opt.len</argument>, <argument>token.data.opt.name</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexPlainIdentifier</argument>, <argument><literal type="string">"(scope=%s,autoload=%i)"</literal></argument>,
<argument>intchar2str((int)token.data.var.scope)</argument>,
<argument>(int)token.data.var.autoload</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexNumber</argument>, <argument><literal type="string">"(is_float=%i,base=%i,val=%lg)"</literal></argument>,
<argument>(int)token.data.num.is_float</argument>,
<argument>(int)token.data.num.base</argument>,
<argument>(double)(token.data.num.is_float
? (double)token.data.num.val.floating
: (double)token.data.num.val.integer)</argument>)</argument_list></macro>
<macro><name>TKNARGS</name><argument_list>(<argument>kExprLexInvalid</argument>, <argument><literal type="string">"(msg=%s)"</literal></argument>, <argument>token.data.err.msg</argument>)</argument_list></macro>
<default>default:</default> <block>{<block_content>

<break>break;</break>
</block_content>}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TKNARGS</name></cpp:undef>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADDSTR</name><argument_list>(<argument><expr><literal type="string">"::%zu"</literal></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(
<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>reader</name><operator>.</operator><name>lines</name><operator>.</operator><name>items</name><index>[<expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>line</name></name></expr>]</index></name><operator>.</operator><name><name>data</name><index>[<expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>token</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>token</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADDSTR</name></cpp:undef>
<label><name>viml_pexpr_repr_token_end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ret_size</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>ret</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>east_node_type_tab</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprNodeMissing</name></expr>]</index> <operator>=</operator> <literal type="string">"Missing"</literal></expr>,
<expr><index>[<expr><name>kExprNodeOpMissing</name></expr>]</index> <operator>=</operator> <literal type="string">"OpMissing"</literal></expr>,
<expr><index>[<expr><name>kExprNodeTernary</name></expr>]</index> <operator>=</operator> <literal type="string">"Ternary"</literal></expr>,
<expr><index>[<expr><name>kExprNodeTernaryValue</name></expr>]</index> <operator>=</operator> <literal type="string">"TernaryValue"</literal></expr>,
<expr><index>[<expr><name>kExprNodeRegister</name></expr>]</index> <operator>=</operator> <literal type="string">"Register"</literal></expr>,
<expr><index>[<expr><name>kExprNodeSubscript</name></expr>]</index> <operator>=</operator> <literal type="string">"Subscript"</literal></expr>,
<expr><index>[<expr><name>kExprNodeListLiteral</name></expr>]</index> <operator>=</operator> <literal type="string">"ListLiteral"</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnaryPlus</name></expr>]</index> <operator>=</operator> <literal type="string">"UnaryPlus"</literal></expr>,
<expr><index>[<expr><name>kExprNodeBinaryPlus</name></expr>]</index> <operator>=</operator> <literal type="string">"BinaryPlus"</literal></expr>,
<expr><index>[<expr><name>kExprNodeNested</name></expr>]</index> <operator>=</operator> <literal type="string">"Nested"</literal></expr>,
<expr><index>[<expr><name>kExprNodeCall</name></expr>]</index> <operator>=</operator> <literal type="string">"Call"</literal></expr>,
<expr><index>[<expr><name>kExprNodePlainIdentifier</name></expr>]</index> <operator>=</operator> <literal type="string">"PlainIdentifier"</literal></expr>,
<expr><index>[<expr><name>kExprNodePlainKey</name></expr>]</index> <operator>=</operator> <literal type="string">"PlainKey"</literal></expr>,
<expr><index>[<expr><name>kExprNodeComplexIdentifier</name></expr>]</index> <operator>=</operator> <literal type="string">"ComplexIdentifier"</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnknownFigure</name></expr>]</index> <operator>=</operator> <literal type="string">"UnknownFigure"</literal></expr>,
<expr><index>[<expr><name>kExprNodeLambda</name></expr>]</index> <operator>=</operator> <literal type="string">"Lambda"</literal></expr>,
<expr><index>[<expr><name>kExprNodeDictLiteral</name></expr>]</index> <operator>=</operator> <literal type="string">"DictLiteral"</literal></expr>,
<expr><index>[<expr><name>kExprNodeCurlyBracesIdentifier</name></expr>]</index> <operator>=</operator> <literal type="string">"CurlyBracesIdentifier"</literal></expr>,
<expr><index>[<expr><name>kExprNodeComma</name></expr>]</index> <operator>=</operator> <literal type="string">"Comma"</literal></expr>,
<expr><index>[<expr><name>kExprNodeColon</name></expr>]</index> <operator>=</operator> <literal type="string">"Colon"</literal></expr>,
<expr><index>[<expr><name>kExprNodeArrow</name></expr>]</index> <operator>=</operator> <literal type="string">"Arrow"</literal></expr>,
<expr><index>[<expr><name>kExprNodeComparison</name></expr>]</index> <operator>=</operator> <literal type="string">"Comparison"</literal></expr>,
<expr><index>[<expr><name>kExprNodeConcat</name></expr>]</index> <operator>=</operator> <literal type="string">"Concat"</literal></expr>,
<expr><index>[<expr><name>kExprNodeConcatOrSubscript</name></expr>]</index> <operator>=</operator> <literal type="string">"ConcatOrSubscript"</literal></expr>,
<expr><index>[<expr><name>kExprNodeInteger</name></expr>]</index> <operator>=</operator> <literal type="string">"Integer"</literal></expr>,
<expr><index>[<expr><name>kExprNodeFloat</name></expr>]</index> <operator>=</operator> <literal type="string">"Float"</literal></expr>,
<expr><index>[<expr><name>kExprNodeSingleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="string">"SingleQuotedString"</literal></expr>,
<expr><index>[<expr><name>kExprNodeDoubleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="string">"DoubleQuotedString"</literal></expr>,
<expr><index>[<expr><name>kExprNodeOr</name></expr>]</index> <operator>=</operator> <literal type="string">"Or"</literal></expr>,
<expr><index>[<expr><name>kExprNodeAnd</name></expr>]</index> <operator>=</operator> <literal type="string">"And"</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnaryMinus</name></expr>]</index> <operator>=</operator> <literal type="string">"UnaryMinus"</literal></expr>,
<expr><index>[<expr><name>kExprNodeBinaryMinus</name></expr>]</index> <operator>=</operator> <literal type="string">"BinaryMinus"</literal></expr>,
<expr><index>[<expr><name>kExprNodeNot</name></expr>]</index> <operator>=</operator> <literal type="string">"Not"</literal></expr>,
<expr><index>[<expr><name>kExprNodeMultiplication</name></expr>]</index> <operator>=</operator> <literal type="string">"Multiplication"</literal></expr>,
<expr><index>[<expr><name>kExprNodeDivision</name></expr>]</index> <operator>=</operator> <literal type="string">"Division"</literal></expr>,
<expr><index>[<expr><name>kExprNodeMod</name></expr>]</index> <operator>=</operator> <literal type="string">"Mod"</literal></expr>,
<expr><index>[<expr><name>kExprNodeOption</name></expr>]</index> <operator>=</operator> <literal type="string">"Option"</literal></expr>,
<expr><index>[<expr><name>kExprNodeEnvironment</name></expr>]</index> <operator>=</operator> <literal type="string">"Environment"</literal></expr>,
<expr><index>[<expr><name>kExprNodeAssignment</name></expr>]</index> <operator>=</operator> <literal type="string">"Assignment"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>












<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>intchar2str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><literal type="char">' '</literal> <operator>&lt;=</operator> <name>ch</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;</operator> <literal type="number">0x7f</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%i"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIT_TESTING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<function><type><name>REAL_FATTR_UNUSED</name>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>viml_pexpr_debug_print_ast_node</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>eastnode_p</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eastnode_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %p : NULL\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>eastnode_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %p : %p : %s : %zu:%zu:%zu\n"</literal></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>eastnode_p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator></expr></argument>,
<argument><expr><name><name>east_node_type_tab</name><index>[<expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>start</name><operator>.</operator><name>line</name></name></name></expr></argument>,
<argument><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>start</name><operator>.</operator><name>col</name></name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>REAL_FATTR_UNUSED</name>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>viml_pexpr_debug_print_ast_stack</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ExprASTStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ast_stack</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>msg</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n%sstack: %zu:\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>viml_pexpr_debug_print_ast_node</name><argument_list>(
<argument><expr><operator>(</operator><specifier>const</specifier> <name>ExprASTNode</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><call><name>kv_A</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>REAL_FATTR_UNUSED</name>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>viml_pexpr_debug_print_token</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LexExprToken</name></type> <name>token</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\ntkn: %s\n"</literal></expr></argument>, <argument><expr><call><name>viml_pexpr_repr_token</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSTACK</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_pexpr_debug_print_ast_stack(&amp;ast_stack, #msg)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSTACK_P</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_pexpr_debug_print_ast_stack(ast_stack, #msg)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNODE_P</name><parameter_list>(<parameter><type><name>eastnode_p</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_pexpr_debug_print_ast_node((const ExprASTNode *const *)eastnode_p, (#msg))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTOKEN</name><parameter_list>(<parameter><type><name>tkn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_pexpr_debug_print_token(pstate, tkn)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name><name>node_maxchildren</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprNodeMissing</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeOpMissing</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeTernary</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeTernaryValue</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeRegister</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeSubscript</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeListLiteral</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnaryPlus</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeBinaryPlus</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeNested</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeCall</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodePlainIdentifier</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodePlainKey</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeComplexIdentifier</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnknownFigure</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeLambda</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeDictLiteral</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeCurlyBracesIdentifier</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeComma</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeColon</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeArrow</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeComparison</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeConcat</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeConcatOrSubscript</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeInteger</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeFloat</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeSingleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeDoubleQuotedString</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeOr</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeAnd</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeUnaryMinus</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeBinaryMinus</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeNot</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><name>kExprNodeMultiplication</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeDivision</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeMod</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><name>kExprNodeOption</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeEnvironment</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><name>kExprNodeAssignment</name></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>




<function><type><name>void</name></type> <name>viml_pexpr_free_ast</name><parameter_list>(<parameter><decl><type><name>ExprAST</name></type> <name>ast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ExprASTStack</name></type> <name>ast_stack</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>kvi_init</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>cur_node</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>*</operator><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>maxchildren</name> <init>= <expr><name><name>node_maxchildren</name><index>[<expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxchildren</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>maxchildren</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>maxchildren</name> <operator>==</operator> <literal type="number">1</literal></expr>
?</condition><then> <expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name></name> <operator>==</operator> <name>NULL</name></expr>
</then><else>: <expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cur_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kExprNodeDoubleQuotedString</name></expr>:</case>
<case>case <expr><name>kExprNodeSingleQuotedString</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>cur_node</name><operator>)</operator><operator>-&gt;</operator><name><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeMissing</name></expr>:</case>
<case>case <expr><name>kExprNodeOpMissing</name></expr>:</case>
<case>case <expr><name>kExprNodeTernary</name></expr>:</case>
<case>case <expr><name>kExprNodeTernaryValue</name></expr>:</case>
<case>case <expr><name>kExprNodeRegister</name></expr>:</case>
<case>case <expr><name>kExprNodeSubscript</name></expr>:</case>
<case>case <expr><name>kExprNodeListLiteral</name></expr>:</case>
<case>case <expr><name>kExprNodeUnaryPlus</name></expr>:</case>
<case>case <expr><name>kExprNodeBinaryPlus</name></expr>:</case>
<case>case <expr><name>kExprNodeNested</name></expr>:</case>
<case>case <expr><name>kExprNodeCall</name></expr>:</case>
<case>case <expr><name>kExprNodePlainIdentifier</name></expr>:</case>
<case>case <expr><name>kExprNodePlainKey</name></expr>:</case>
<case>case <expr><name>kExprNodeComplexIdentifier</name></expr>:</case>
<case>case <expr><name>kExprNodeUnknownFigure</name></expr>:</case>
<case>case <expr><name>kExprNodeLambda</name></expr>:</case>
<case>case <expr><name>kExprNodeDictLiteral</name></expr>:</case>
<case>case <expr><name>kExprNodeCurlyBracesIdentifier</name></expr>:</case>
<case>case <expr><name>kExprNodeAssignment</name></expr>:</case>
<case>case <expr><name>kExprNodeComma</name></expr>:</case>
<case>case <expr><name>kExprNodeColon</name></expr>:</case>
<case>case <expr><name>kExprNodeArrow</name></expr>:</case>
<case>case <expr><name>kExprNodeComparison</name></expr>:</case>
<case>case <expr><name>kExprNodeConcat</name></expr>:</case>
<case>case <expr><name>kExprNodeConcatOrSubscript</name></expr>:</case>
<case>case <expr><name>kExprNodeInteger</name></expr>:</case>
<case>case <expr><name>kExprNodeFloat</name></expr>:</case>
<case>case <expr><name>kExprNodeOr</name></expr>:</case>
<case>case <expr><name>kExprNodeAnd</name></expr>:</case>
<case>case <expr><name>kExprNodeUnaryMinus</name></expr>:</case>
<case>case <expr><name>kExprNodeBinaryMinus</name></expr>:</case>
<case>case <expr><name>kExprNodeNot</name></expr>:</case>
<case>case <expr><name>kExprNodeMultiplication</name></expr>:</case>
<case>case <expr><name>kExprNodeDivision</name></expr>:</case>
<case>case <expr><name>kExprNodeMod</name></expr>:</case>
<case>case <expr><name>kExprNodeOption</name></expr>:</case>
<case>case <expr><name>kExprNodeEnvironment</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>*</operator><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cur_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>kvi_destroy</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ExprASTNode</name> <modifier>*</modifier></type><name>viml_pexpr_new_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprASTNodeType</name></type> <name>type</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC
<block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>ExprOpLvl</name></type> <name>lvl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprOpAssociativity</name></type> <name>ass</name></decl>;</decl_stmt>
}</block> <decl><name><name>node_type_to_node_props</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kExprNodeMissing</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlInvalid</name></expr>, <expr><name>kEOpAssNo</name></expr>, }</block></expr>,
<expr><index>[<expr><name>kExprNodeOpMissing</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlMultiplication</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeNested</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,


<expr><index>[<expr><name>kExprNodeCall</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeSubscript</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeUnknownFigure</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeLambda</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeDictLiteral</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeListLiteral</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlParens</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeArrow</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlArrow</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,








<expr><index>[<expr><name>kExprNodeComma</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlComma</name></expr>, <expr><name>kEOpAssRight</name></expr> }</block></expr>,


<expr><index>[<expr><name>kExprNodeColon</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlColon</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeTernary</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlTernary</name></expr>, <expr><name>kEOpAssRight</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeOr</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlOr</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeAnd</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlAnd</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeTernaryValue</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlTernaryValue</name></expr>, <expr><name>kEOpAssRight</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeComparison</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlComparison</name></expr>, <expr><name>kEOpAssRight</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeBinaryPlus</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlAddition</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeBinaryMinus</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlAddition</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeConcat</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlAddition</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeMultiplication</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlMultiplication</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeDivision</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlMultiplication</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeMod</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlMultiplication</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeUnaryPlus</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlUnary</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeUnaryMinus</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlUnary</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeNot</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlUnary</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeConcatOrSubscript</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlSubscript</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeCurlyBracesIdentifier</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlComplexIdentifier</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeAssignment</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlAssignment</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodeComplexIdentifier</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssLeft</name></expr> }</block></expr>,

<expr><index>[<expr><name>kExprNodePlainIdentifier</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodePlainKey</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeRegister</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeInteger</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeFloat</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeDoubleQuotedString</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeSingleQuotedString</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeOption</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
<expr><index>[<expr><name>kExprNodeEnvironment</name></expr>]</index> <operator>=</operator> <block>{ <expr><name>kEOpLvlValue</name></expr>, <expr><name>kEOpAssNo</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ExprOpLvl</name></type> <name>node_lvl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprASTNode</name></type> <name>node</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><name><name>node_type_to_node_props</name><index>[<expr><name><name>node</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>lvl</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ExprOpAssociativity</name></type> <name>node_ass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprASTNode</name></type> <name>node</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><name><name>node_type_to_node_props</name><index>[<expr><name><name>node</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>ass</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>bool</name></type> <name>viml_pexpr_handle_bop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>,
<parameter><decl><type><name>ExprASTStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ast_stack</name></decl></parameter>,
<parameter><decl><type><name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier></type> <name>bop_node</name></decl></parameter>,
<parameter><decl><type><name>ExprASTWantedNode</name> <modifier>*</modifier><specifier>const</specifier></type> <name>want_node_p</name></decl></parameter>,
<parameter><decl><type><name>ExprASTError</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ast_err</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>top_node_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>top_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprOpLvl</name></type> <name>top_node_lvl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprOpAssociativity</name></type> <name>top_node_ass</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpLvl</name></type> <name>bop_node_lvl</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>bop_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeCall</name>
<operator>||</operator> <name><name>bop_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeSubscript</name><operator>)</operator></expr>
?</condition><then> <expr><name>kEOpLvlSubscript</name></expr>
</then><else>: <expr><call><name>node_lvl</name><argument_list>(<argument><expr><operator>*</operator><name>bop_node</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpAssociativity</name></type> <name>bop_node_ass</name> <init>= <expr><operator>(</operator>
<ternary><condition><expr><operator>(</operator><name><name>bop_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeCall</name>
<operator>||</operator> <name><name>bop_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeSubscript</name><operator>)</operator></expr>
?</condition><then> <expr><name>kEOpAssLeft</name></expr>
</then><else>: <expr><call><name>node_ass</name><argument_list>(<argument><expr><operator>*</operator><name>bop_node</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_top_node_p</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>new_top_node</name> <init>= <expr><operator>*</operator><name>new_top_node_p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new_top_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpLvl</name></type> <name>new_top_node_lvl</name> <init>= <expr><call><name>node_lvl</name><argument_list>(<argument><expr><operator>*</operator><name>new_top_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpAssociativity</name></type> <name>new_top_node_ass</name> <init>= <expr><call><name>node_ass</name><argument_list>(<argument><expr><operator>*</operator><name>new_top_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bop_node_lvl</name> <operator>!=</operator> <name>new_top_node_lvl</name>
<operator>||</operator> <name>bop_node_ass</name> <operator>==</operator> <name>new_top_node_ass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>top_node_p</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>bop_node_lvl</name> <operator>&gt;</operator> <name>new_top_node_lvl</name>
<operator>||</operator> <operator>(</operator><name>bop_node_lvl</name> <operator>==</operator> <name>new_top_node_lvl</name>
<operator>&amp;&amp;</operator> <name>new_top_node_ass</name> <operator>==</operator> <name>kEOpAssNo</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>top_node_p</name> <operator>=</operator> <name>new_top_node_p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>top_node</name> <operator>=</operator> <name>new_top_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>top_node_lvl</name> <operator>=</operator> <name>new_top_node_lvl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>top_node_ass</name> <operator>=</operator> <name>new_top_node_ass</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bop_node_lvl</name> <operator>==</operator> <name>top_node_lvl</name> <operator>&amp;&amp;</operator> <name>top_node_ass</name> <operator>==</operator> <name>kEOpAssRight</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>top_node_ass</name> <operator>==</operator> <name>kEOpAssLeft</name> <operator>||</operator> <name>top_node_lvl</name> <operator>!=</operator> <name>bop_node_lvl</name></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>bop_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bop_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name>top_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bop_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><name>top_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bop_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>top_node_lvl</name> <operator>==</operator> <name>bop_node_lvl</name> <operator>&amp;&amp;</operator> <name>top_node_ass</name> <operator>==</operator> <name>kEOpAssRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>top_node</name><operator>-&gt;</operator><name>children</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>top_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name><name>bop_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name><name>top_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>bop_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bop_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><name>top_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>top_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><operator>*</operator><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bop_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bop_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeComparison</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>ast_err</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Operator is not associative: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>bop_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>want_node_p</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ParserPosition</name></type> <name>shifted_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParserPosition</name></type> <name>pos</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>shift</name></decl></parameter>)</parameter_list>
FUNC_ATTR_CONST FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><operator>(</operator><name>ParserPosition</name><operator>)</operator> <block>{ <expr><operator>.</operator><name>line</name> <operator>=</operator> <name><name>pos</name><operator>.</operator><name>line</name></name></expr>, <expr><operator>.</operator><name>col</name> <operator>=</operator> <name><name>pos</name><operator>.</operator><name>col</name></name> <operator>+</operator> <name>shift</name></expr> }</block></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ParserPosition</name></type> <name>recol_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParserPosition</name></type> <name>pos</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>new_col</name></decl></parameter>)</parameter_list>
FUNC_ATTR_CONST FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><operator>(</operator><name>ParserPosition</name><operator>)</operator> <block>{ <expr><operator>.</operator><name>line</name> <operator>=</operator> <name><name>pos</name><operator>.</operator><name>line</name></name></expr>, <expr><operator>.</operator><name>col</name> <operator>=</operator> <name>new_col</name></expr> }</block></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HL</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(is_invalid ? "NvimInvalid" #g : "Nvim" #g)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HL_CUR_TOKEN</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_parser_highlight(pstate, cur_token.start, cur_token.len, HL(g))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_NODE</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>viml_pexpr_new_node(type)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POS_FROM_TOKEN</name><parameter_list>(<parameter><type><name>cur_node</name></type></parameter>, <parameter><type><name>cur_token</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (cur_node)-&gt;start = cur_token.start; (cur_node)-&gt;len = cur_token.len; } while (0)</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW_NODE_WITH_CUR_POS</name><parameter_list>(<parameter><type><name>cur_node</name></type></parameter>, <parameter><type><name>typ</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (cur_node) = NEW_NODE(typ); POS_FROM_TOKEN((cur_node), cur_token); if (prev_token.type == kExprLexSpacing) { (cur_node)-&gt;start = prev_token.start; (cur_node)-&gt;len += prev_token.len; } } while (0)</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAY_HAVE_NEXT_EXPR</name></cpp:macro> <cpp:value>(kv_size(ast_stack) == 1)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_OP_NODE</name><parameter_list>(<parameter><type><name>cur_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>is_invalid |= !viml_pexpr_handle_bop(pstate, &amp;ast_stack, cur_node, &amp;want_node, &amp;ast.err)</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_MISSING</name></cpp:macro> <cpp:value>do { if (flags &amp; kExprFlagsMulti &amp;&amp; MAY_HAVE_NEXT_EXPR) { goto viml_pexpr_parse_end; } else { assert(*top_node_p != NULL); ERROR_FROM_TOKEN_AND_MSG(cur_token, _("E15: Missing operator: %.*s")); NEW_NODE_WITH_CUR_POS(cur_node, kExprNodeOpMissing); cur_node-&gt;len = 0; ADD_OP_NODE(cur_node); goto viml_pexpr_parse_process_token; } } while (0)</cpp:value></cpp:define>


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_VALUE_IF_MISSING</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (want_node == kENodeValue) { ERROR_FROM_TOKEN_AND_MSG(cur_token, (msg)); NEW_NODE_WITH_CUR_POS((*top_node_p), kExprNodeMissing); (*top_node_p)-&gt;len = 0; want_node = kENodeOperator; } } while (0)</cpp:value></cpp:define>
















<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>east_set_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>,
<parameter><decl><type><name>ExprASTError</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_ast_err</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>msg</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParserPosition</name></type> <name>start</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ret_ast_err</name><operator>-&gt;</operator><name>msg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParserLine</name></type> <name>pline</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>reader</name><operator>.</operator><name>lines</name><operator>.</operator><name>items</name><index>[<expr><name><name>start</name><operator>.</operator><name>line</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret_ast_err</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>msg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret_ast_err</name><operator>-&gt;</operator><name>arg_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pline</name><operator>.</operator><name>size</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>col</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret_ast_err</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>start</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_FROM_TOKEN_AND_MSG</name><parameter_list>(<parameter><type><name>cur_token</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { is_invalid = true; east_set_error(pstate, &amp;ast.err, msg, cur_token.start); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_FROM_NODE_AND_MSG</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { is_invalid = true; east_set_error(pstate, &amp;ast.err, msg, node-&gt;start); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_FROM_TOKEN</name><parameter_list>(<parameter><type><name>cur_token</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ERROR_FROM_TOKEN_AND_MSG(cur_token, cur_token.data.err.msg)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SELECT_FIGURE_BRACE_TYPE</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>new_type</name></type></parameter>, <parameter><type><name>hl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ExprASTNode *const node_ = (node); assert(node_-&gt;type == kExprNodeUnknownFigure || node_-&gt;type == kExprNode##new_type); node_-&gt;type = kExprNode##new_type; if (pstate-&gt;colors) { kv_A(*pstate-&gt;colors, node_-&gt;data.fig.opening_hl_idx).group = HL(hl); } } while (0)</cpp:value></cpp:define>



















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_IDENT</name><parameter_list>(<parameter><type><name>new_ident_node_code</name></type></parameter>, <parameter><type><name>hl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(want_node == kENodeOperator); if (prev_token.type == kExprLexSpacing) { OP_MISSING; } switch ((*top_node_p)-&gt;type) { case kExprNodeComplexIdentifier: case kExprNodePlainIdentifier: case kExprNodeCurlyBracesIdentifier: { NEW_NODE_WITH_CUR_POS(cur_node, kExprNodeComplexIdentifier); cur_node-&gt;len = 0; cur_node-&gt;children = *top_node_p; *top_node_p = cur_node; kvi_push(ast_stack, &amp;cur_node-&gt;children-&gt;next); ExprASTNode **const new_top_node_p = kv_last(ast_stack); assert(*new_top_node_p == NULL); new_ident_node_code; *new_top_node_p = cur_node; HL_CUR_TOKEN(hl); break; } default: { OP_MISSING; break; } } } while (0)</cpp:value></cpp:define>













































<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>pt_is_assignment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprASTParseType</name></type> <name>pt</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><operator>(</operator><name>pt</name> <operator>==</operator> <name>kEPTAssignment</name> <operator>||</operator> <name>pt</name> <operator>==</operator> <name>kEPTSingleAssignment</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>orig_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>act_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>escape_not_known</name></decl>;</decl_stmt> 
}</block></struct></type> <name>StringShift</name>;</typedef>













<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_quoted_string</name><parameter_list>(<parameter><decl><type><name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>,
<parameter><decl><type><name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier></type> <name>node</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LexExprToken</name></type> <name>token</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExprASTStack</name></type> <name>ast_stack</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_invalid</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParserLine</name></type> <name>pline</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>reader</name><operator>.</operator><name>lines</name><operator>.</operator><name>items</name><index>[<expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>line</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name> <init>= <expr><name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>e</name> <init>= <expr><name>s</name> <operator>+</operator> <name><name>token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_double</name> <init>= <expr><operator>(</operator><name><name>token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexDoubleQuotedString</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<macro><name>kvec_withinit_t</name><argument_list>(<argument>StringShift</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro> <expr_stmt><expr><name>shifts</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_init</name><argument_list>(<argument><expr><name>shifts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_double</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>SingleQuote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_e</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk_e</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>chunk_e</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr>)</condition> <block>{<block_content>
<macro><name>kvi_push</name><argument_list>(<argument>shifts</argument>, <argument>((StringShift) {
.start = token.start.col + (size_t)(chunk_e - s),
.orig_len = <literal type="number">2</literal>,
.act_len = <literal type="number">1</literal>,
.escape_not_known = false,
})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v_p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v_p</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>xmallocz</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_e</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk_e</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v_p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v_p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>chunk_e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v_p</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>chunk_e</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v_p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>chunk_e</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>DoubleQuote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>



<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>










<case>case <expr><literal type="char">'u'</literal></expr>:</case> <case>case <expr><literal type="char">'U'</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>esc_start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'u'</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <name>n</name><operator>--</operator> <operator>&amp;&amp;</operator> <call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>nr</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>hex2nr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>




<expr_stmt><expr><name>size</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>p</name> <operator>-</operator> <operator>(</operator><name>esc_start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <call><name>utf_char2len</name><argument_list>(<argument><expr><name>nr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v_p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v_p</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>chunk_e</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk_e</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v_p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v_p</name> <operator>+=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v_p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>chunk_e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v_p</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>chunk_e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>chunk_e</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>v_p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_unknown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>v_p_start</name> <init>= <expr><name>v_p</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLE_CHAR_ESC</name><parameter_list>(<parameter><type><name>ch</name></type></parameter>, <parameter><type><name>real_ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ch: { *v_p++ = real_ch; p++; break; }</cpp:value></cpp:define>





<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'b'</literal></argument>, <argument>BS</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'e'</literal></argument>, <argument>ESC</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'f'</literal></argument>, <argument>FF</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'n'</literal></argument>, <argument>NL</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'r'</literal></argument>, <argument>CAR</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'t'</literal></argument>, <argument>TAB</argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'"'</literal></argument>, <argument><literal type="char">'"'</literal></argument>)</argument_list></macro>
<macro><name>SINGLE_CHAR_ESC</name><argument_list>(<argument><literal type="char">'\\'</literal></argument>, <argument><literal type="char">'\\'</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SINGLE_CHAR_ESC</name></cpp:undef>


<case>case <expr><literal type="char">'X'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case> <case>case <expr><literal type="char">'U'</literal></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_hex</name> <init>= <expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_hex</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <name>n</name><operator>--</operator> <operator>&amp;&amp;</operator> <call><name>ascii_isxdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>nr</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>hex2nr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_hex</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>v_p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>nr</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>v_p</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>nr</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>v_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>is_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v_p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ch</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ch</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>v_p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>special_len</name> <init>= <expr><operator>(</operator>
<call><name>trans_special</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>v_p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>special_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v_p</name> <operator>+=</operator> <name>special_len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>is_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_copy_char</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>v_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<expr_stmt><expr><name>is_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_copy_char</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>v_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr>)</condition> <block>{<block_content>
<macro><name>kvi_push</name><argument_list>(<argument>shifts</argument>, <argument>((StringShift) {
.start = token.start.col + (size_t)(chunk_e - s),
.orig_len = (size_t)(p - chunk_e),
.act_len = (size_t)(v_p - (char *)v_p_start),
.escape_not_known = is_unknown,
})</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>v_p</name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>value</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>size_t</name></type> <name>next_col</name> <init>= <expr><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>body_str</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>is_double</name></expr>
?</condition><then> <expr><call><name>HL</name><argument_list>(<argument><expr><name>DoubleQuotedBody</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>HL</name><argument_list>(<argument><expr><name>SingleQuotedBody</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>esc_str</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>is_double</name></expr>
?</condition><then> <expr><call><name>HL</name><argument_list>(<argument><expr><name>DoubleQuotedEscape</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>HL</name><argument_list>(<argument><expr><name>SingleQuotedQuote</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ukn_esc_str</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>is_double</name></expr>
?</condition><then> <expr><call><name>HL</name><argument_list>(<argument><expr><name>DoubleQuotedUnknownEscape</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>HL</name><argument_list>(<argument><expr><name>SingleQuotedUnknownEscape</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>shifts</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>StringShift</name></type> <name>cur_shift</name> <init>= <expr><call><name>kv_A</name><argument_list>(<argument><expr><name>shifts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_shift</name><operator>.</operator><name>start</name></name> <operator>&gt;</operator> <name>next_col</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>recol_pos</name><argument_list>(<argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>next_col</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_shift</name><operator>.</operator><name>start</name></name> <operator>-</operator> <name>next_col</name></expr></argument>,
<argument><expr><name>body_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>recol_pos</name><argument_list>(<argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>cur_shift</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_shift</name><operator>.</operator><name>orig_len</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name><name>cur_shift</name><operator>.</operator><name>escape_not_known</name></name></expr>
?</condition><then> <expr><name>ukn_esc_str</name></expr>
</then><else>: <expr><name>esc_str</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next_col</name> <operator>=</operator> <name><name>cur_shift</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name><name>cur_shift</name><operator>.</operator><name>orig_len</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>next_col</name> <operator>-</operator> <name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>&lt;</operator> <name><name>token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>recol_pos</name><argument_list>(<argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>next_col</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name><name>token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name>
<operator>+</operator> <name><name>token</name><operator>.</operator><name>len</name></name>
<operator>-</operator> <name><name>token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name>
<operator>-</operator> <name>next_col</name><operator>)</operator></expr></argument>,
<argument><expr><name>body_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_double</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>DoubleQuote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>SingleQuote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>kvi_destroy</name><argument_list>(<argument><expr><name>shifts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>want_node_to_lexer_flags</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kENodeValue</name></expr>]</index> <operator>=</operator> <name>kELFlagIsNotCmp</name></expr>,
<expr><index>[<expr><name>kENodeOperator</name></expr>]</index> <operator>=</operator> <name>kELFlagForbidScope</name></expr>,
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>base_to_prefix_length</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><index>[<expr><literal type="number">8</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><index>[<expr><literal type="number">10</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><index>[<expr><literal type="number">16</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>







<function><type><name>ExprAST</name></type> <name>viml_pexpr_parse</name><parameter_list>(<parameter><decl><type><name>ParserState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>ExprAST</name></type> <name>ast</name> <init>= <expr><block>{
<expr><operator>.</operator><name>err</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>msg</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>arg_len</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>arg</name> <operator>=</operator> <name>NULL</name></expr>,
}</block></expr>,
<expr><operator>.</operator><name>root</name> <operator>=</operator> <name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>








<decl_stmt><decl><type><name>ExprASTStack</name></type> <name>ast_stack</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>kvi_init</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprASTWantedNode</name></type> <name>want_node</name> <init>= <expr><name>kENodeValue</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprASTParseTypeStack</name></type> <name>pt_stack</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>kvi_init</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>kExprFlagsParseLet</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTAssignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>LexExprToken</name></type> <name>prev_token</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kExprLexMissing</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>highlighted_prev_spacing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>lambda_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>asgn_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_concat_or_subscript</name> <init>= <expr><operator>(</operator>
<name>want_node</name> <operator>==</operator> <name>kENodeValue</name>
<operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>kExprNodeConcatOrSubscript</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lexer_additional_flags</name> <init>= <expr><operator>(</operator>
<name>kELFlagPeek</name>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kExprFlagsDisallowEOC</name><operator>)</operator></expr> ?</condition><then> <expr><name>kELFlagForbidEOC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>want_node</name> <operator>==</operator> <name>kENodeValue</name>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
<operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeConcat</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name>
<operator>!=</operator> <name>kExprNodeConcatOrSubscript</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr>
?</condition><then> <expr><name>kELFlagAllowFloat</name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LexExprToken</name></type> <name>cur_token</name> <init>= <expr><call><name>viml_pexpr_next_token</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>want_node_to_lexer_flags</name><index>[<expr><name>want_node</name></expr>]</index></name> <operator>|</operator> <name>lexer_additional_flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexEOC</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>LexExprTokenType</name></type> <name>tok_type</name> <init>= <expr><name><name>cur_token</name><operator>.</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>token_invalid</name> <init>= <expr><operator>(</operator><name>tok_type</name> <operator>==</operator> <name>kExprLexInvalid</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_invalid</name> <init>= <expr><name>token_invalid</name></expr></init></decl>;</decl_stmt>
<label><name>viml_pexpr_parse_process_token</name>:</label>

<expr_stmt><expr><name>cur_token</name> <operator>=</operator> <call><name>viml_pexpr_next_token</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>want_node_to_lexer_flags</name><index>[<expr><name>want_node</name></expr>]</index></name> <operator>|</operator> <name>lexer_additional_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok_type</name> <operator>==</operator> <name>kExprLexSpacing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_invalid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Spacing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


</block_content>}</block></else></if_stmt>
<goto>goto <name>viml_pexpr_parse_cycle_end</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_invalid</name> <operator>&amp;&amp;</operator> <name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexSpacing</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name>highlighted_prev_spacing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>prev_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>prev_token</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>Spacing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is_invalid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>highlighted_prev_spacing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParserLine</name></type> <name>pline</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>reader</name><operator>.</operator><name>lines</name><operator>.</operator><name>items</name><index>[<expr><name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>line</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>top_node_p</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>cur_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>want_value</name> <init>= <expr><operator>(</operator><name>want_node</name> <operator>==</operator> <name>kENodeValue</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>want_value</name> <operator>==</operator> <operator>(</operator><operator>*</operator><name>top_node_p</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>item_null</name> <init>= <expr><operator>(</operator><name>want_value</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal> <operator>==</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>&amp;</operator><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>children</name> <operator>==</operator> <call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>item_null</name></expr>
?</condition><then> <expr><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>children</name> <operator>==</operator> <name>NULL</name></expr>
</then><else>: <expr><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></else></ternary><operator>)</operator><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name>
<operator>==</operator> <call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>item_null</name></expr>
?</condition><then> <expr><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>
</then><else>: <expr><operator>(</operator><operator>*</operator><call><name>kv_A</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>













<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>node_is_key</name> <init>= <expr><operator>(</operator>
<name>is_concat_or_subscript</name>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexPlainIdentifier</name></expr>
?</condition><then> <expr><operator>(</operator><operator>!</operator><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>autoload</name></name>
<operator>&amp;&amp;</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name> <operator>==</operator> <name>kExprVarScopeMissing</name><operator>)</operator></expr>
</then><else>: <expr><operator>(</operator><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexNumber</name><operator>)</operator></expr></else></ternary><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kExprLexSpacing</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_concat_or_subscript</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>node_is_key</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><operator>(</operator><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>=</operator> <name>kExprNodeConcat</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_single_assignment</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>kEPTSingleAssignment</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kEPTExpr</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kEPTLambdaArguments</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexComma</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexArrow</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>want_node</name> <operator>==</operator> <name>kENodeValue</name>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexPlainIdentifier</name>
<operator>&amp;&amp;</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name> <operator>==</operator> <name>kExprVarScopeMissing</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>autoload</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexArrow</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lambda_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_lambda</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>lambda_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeComma</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected lambda arguments list or arrow: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>lambda_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kEPTSingleAssignment</name></expr>:</case>
<case>case <expr><name>kEPTAssignment</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexBracket</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexPlainIdentifier</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>tok_type</name> <operator>!=</operator> <name>kExprLexFigureBrace</name> <operator>||</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>node_is_key</name> <operator>&amp;&amp;</operator> <name>tok_type</name> <operator>==</operator> <name>kExprLexNumber</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexEnv</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexOption</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexRegister</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value part of assignment lvalue: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexBracket</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>tok_type</name> <operator>!=</operator> <name>kExprLexFigureBrace</name>
<operator>||</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexDot</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>tok_type</name> <operator>!=</operator> <name>kExprLexComma</name> <operator>||</operator> <operator>!</operator><name>is_single_assignment</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>tok_type</name> <operator>!=</operator> <name>kExprLexAssignment</name>


<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>tok_type</name> <operator>==</operator> <name>kExprLexPlainIdentifier</name>
<operator>||</operator> <operator>(</operator><name>tok_type</name> <operator>==</operator> <name>kExprLexFigureBrace</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kExprLexSpacing</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>kExprFlagsMulti</name> <operator>&amp;&amp;</operator> <name>MAY_HAVE_NEXT_EXPR</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_end</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected assignment operator or subscript: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprASTParseType</name></type> <name>cur_pt</name> <init>= <expr><call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lambda_node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cur_pt</name> <operator>==</operator> <name>kEPTLambdaArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kExprLexMissing</name></expr>:</case>
<case>case <expr><name>kExprLexSpacing</name></expr>:</case>
<case>case <expr><name>kExprLexEOC</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kExprLexInvalid</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN</name><argument_list>(<argument><expr><name>cur_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok_type</name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>err</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
<goto>goto <name>viml_pexpr_parse_process_token</name>;</goto>
</block_content>}</block>
<case>case <expr><name>kExprLexRegister</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeRegister</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Register</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLE_UB_OP</name><parameter_list>(<parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case kExprLex##op: { if (want_node == kENodeValue) { NEW_NODE_WITH_CUR_POS(cur_node, kExprNodeUnary##op); *top_node_p = cur_node; kvi_push(ast_stack, &amp;cur_node-&gt;children); HL_CUR_TOKEN(Unary##op); } else { NEW_NODE_WITH_CUR_POS(cur_node, kExprNodeBinary##op); ADD_OP_NODE(cur_node); HL_CUR_TOKEN(Binary##op); } want_node = kENodeValue; break; }</cpp:value></cpp:define>















<macro><name>SIMPLE_UB_OP</name><argument_list>(<argument>Plus</argument>)</argument_list></macro>
<macro><name>SIMPLE_UB_OP</name><argument_list>(<argument>Minus</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIMPLE_UB_OP</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLE_B_OP</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case kExprLex##op: { ADD_VALUE_IF_MISSING(_("E15: Unexpected " msg ": %.*s")); NEW_NODE_WITH_CUR_POS(cur_node, kExprNode##op); HL_CUR_TOKEN(op); ADD_OP_NODE(cur_node); break; }</cpp:value></cpp:define>







<macro><name>SIMPLE_B_OP</name><argument_list>(<argument>Or</argument>, <argument><literal type="string">"or operator"</literal></argument>)</argument_list></macro>
<macro><name>SIMPLE_B_OP</name><argument_list>(<argument>And</argument>, <argument><literal type="string">"and operator"</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SIMPLE_B_OP</name></cpp:undef>
<case>case <expr><name>kExprLexMultiplication</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected multiplication-like operator: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>mul</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_OP</name><parameter_list>(<parameter><type><name>lex_op_tail</name></type></parameter>, <parameter><type><name>node_op_tail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case kExprLexMul##lex_op_tail: { NEW_NODE_WITH_CUR_POS(cur_node, kExprNode##node_op_tail); HL_CUR_TOKEN(node_op_tail); break; }</cpp:value></cpp:define>





<macro><name>MUL_OP</name><argument_list>(<argument>Mul</argument>, <argument>Multiplication</argument>)</argument_list></macro>
<macro><name>MUL_OP</name><argument_list>(<argument>Div</argument>, <argument>Division</argument>)</argument_list></macro>
<macro><name>MUL_OP</name><argument_list>(<argument>Mod</argument>, <argument>Mod</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MUL_OP</name></cpp:undef>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexOption</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexInvalid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal>
<operator>||</operator> <operator>(</operator><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">3</literal>
<operator>&amp;&amp;</operator> <name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>ident</name></name> <operator>=</operator> <operator>(</operator>
<name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>+</operator> <name><name>cur_token</name><operator>.</operator><name>len</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>ident_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <operator>(</operator>
<ternary><condition><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">3</literal></expr>
?</condition><then> <expr><operator>(</operator><name>ExprOptScope</name><operator>)</operator><name><name>pline</name><operator>.</operator><name>data</name><index>[<expr><name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>
</then><else>: <expr><name>kExprOptScopeUnspecified</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>ident</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>ident_len</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>OptionSigil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>scope_shift</name> <init>= <expr><operator>(</operator>
<ternary><condition><expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>opt</name><operator>.</operator><name>scope</name></name> <operator>==</operator> <name>kExprOptScopeUnspecified</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>scope_shift</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>OptionScope</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>OptionScopeDelimiter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>scope_shift</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name>scope_shift</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>OptionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexEnv</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>env</name><operator>.</operator><name>ident</name></name> <operator>=</operator> <name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>env</name><operator>.</operator><name>ident_len</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>env</name><operator>.</operator><name>ident_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Environment variable name missing"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>EnvironmentSigil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>EnvironmentName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexNot</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeNot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Not</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexComparison</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got comparison operator: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexInvalid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>ccs</name></name> <operator>=</operator> <name>kCCStrategyUseOption</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kExprCmpEqual</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>ccs</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>ccs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>inv</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>cmp</name><operator>.</operator><name>ccs</name></name> <operator>!=</operator> <name>kCCStrategyUseOption</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>Comparison</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>ComparisonModifier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Comparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexComma</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>want_node</name> <operator>==</operator> <name>kENodeValue</name> <operator>&amp;&amp;</operator> <name>cur_pt</name> <operator>==</operator> <name>kEPTLambdaArguments</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got comma: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeMissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTLambdaArguments</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lambda_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lambda_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_lambda</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SELECT_FIGURE_BRACE_TYPE</name><argument_list>(<argument><expr><name>lambda_node</name></expr></argument>, <argument><expr><name>Lambda</name></expr></argument>, <argument><expr><name>Lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_comma</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>eastnode_p</name> <init>=
<expr><operator>(</operator><name>ExprASTNode</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprASTNodeType</name></type> <name>eastnode_type</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpLvl</name></type> <name>eastnode_lvl</name> <init>= <expr><call><name>node_lvl</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>eastnode_p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeLambda</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur_pt</name> <operator>==</operator> <name>kEPTLambdaArguments</name>
<operator>&amp;&amp;</operator> <name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeDictLiteral</name>
<operator>||</operator> <name>eastnode_type</name> <operator>==</operator> <name>kExprNodeListLiteral</name>
<operator>||</operator> <name>eastnode_type</name> <operator>==</operator> <name>kExprNodeCall</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeComma</name>
<operator>||</operator> <name>eastnode_type</name> <operator>==</operator> <name>kExprNodeColon</name>
<operator>||</operator> <name>eastnode_lvl</name> <operator>&gt;</operator> <name>kEOpLvlComma</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<label><name>viml_pexpr_parse_invalid_comma</name>:</label>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Comma outside of call, lambda or literal: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_comma</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP_VAL_COLON</name></cpp:macro> <cpp:value>"E15: Expected value, got colon: %.*s"</cpp:value></cpp:define>
<case>case <expr><name>kExprLexColon</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>is_ternary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_colon</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>can_be_ternary</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_subscript</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>eastnode_p</name> <init>=
<expr><operator>(</operator><name>ExprASTNode</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprASTNodeType</name></type> <name>eastnode_type</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprOpLvl</name></type> <name>eastnode_lvl</name> <init>= <expr><call><name>node_lvl</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>eastnode_p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>kEOpLvlTernary</name> <operator>&gt;</operator> <name>kEOpLvlComma</name></expr></argument>,
<argument><expr><literal type="string">"Unexpected operator priorities"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>can_be_ternary</name> <operator>&amp;&amp;</operator> <name>eastnode_type</name> <operator>==</operator> <name>kExprNodeTernaryValue</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>data</name><operator>.</operator><name>ter</name><operator>.</operator><name>got_colon</name></name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexSpacing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>prev_token</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name><name>prev_token</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>is_ternary</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>data</name><operator>.</operator><name>ter</name><operator>.</operator><name>got_colon</name></name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>EXP_VAL_COLON</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>eastnode_p</name><operator>)</operator><operator>-&gt;</operator><name><name>children</name><operator>-&gt;</operator><name>next</name></name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeUnknownFigure</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SELECT_FIGURE_BRACE_TYPE</name><argument_list>(<argument><expr><operator>*</operator><name>eastnode_p</name></expr></argument>, <argument><expr><name>DictLiteral</name></expr></argument>, <argument><expr><name>Dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeDictLiteral</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeSubscript</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_subscript</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_ternary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_type</name> <operator>==</operator> <name>kExprNodeColon</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_colon</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_lvl</name> <operator>&gt;=</operator> <name>kEOpLvlTernaryValue</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eastnode_lvl</name> <operator>&gt;=</operator> <name>kEOpLvlComma</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>can_be_ternary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_colon</name>;</goto>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_invalid_colon</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>is_subscript</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>kExprNodeSubscript</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><operator>*</operator><name>top_node_p</name></expr></argument>, <argument><expr><name>kExprNodeMissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>EXP_VAL_COLON</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>SubscriptColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<goto>goto <name>viml_pexpr_parse_valid_colon</name>;</goto>
<label><name>viml_pexpr_parse_invalid_colon</name>:</label>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Colon outside of dictionary or ternary operator: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>viml_pexpr_parse_valid_colon</name>:</label>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>EXP_VAL_COLON</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_ternary</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>TernaryColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Colon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EXP_VAL_COLON</name></cpp:undef>
<case>case <expr><name>kExprLexBracket</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_top_node_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeListLiteral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>!=</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <operator>*</operator><name>top_node_p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<goto>goto <name>viml_pexpr_parse_bracket_closing_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>








<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeListLiteral</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeComma</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeColon</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got closing bracket: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>new_top_node_p</name> <operator>=</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><name>new_top_node_p</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeListLiteral</name>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeSubscript</name><operator>)</operator><operator>)</operator></expr>)</condition>;</do>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>new_top_node</name> <init>= <expr><operator>*</operator><name>new_top_node_p</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>new_top_node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kExprNodeListLiteral</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pt_is_assignment</name><argument_list>(<argument><expr><name>cur_pt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>new_top_node</name><operator>-&gt;</operator><name>children</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E475: Unable to assign to empty list: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeSubscript</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>SubscriptBracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<label><name>viml_pexpr_parse_bracket_closing_error</name>:</label>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected closing figure brace: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>new_top_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>asgn_level</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>asgn_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>asgn_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTAssignment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ast</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTExpr</name>
<operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <call><name>pt_is_assignment</name><argument_list>(<argument><expr><call><name>kv_Z</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTSingleAssignment</name> <operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeListLiteral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTAssignment</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTSingleAssignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTSingleAssignment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E475: Nested lists not allowed when assigning: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexSpacing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeSubscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>SubscriptBracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pt_is_assignment</name><argument_list>(<argument><expr><name>cur_pt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>asgn_level</name> <operator>=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexFigureBrace</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_top_node_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeUnknownFigure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_lambda</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_dict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_ident</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>!=</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <operator>*</operator><name>top_node_p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_top_node_p</name> <operator>=</operator> <name>top_node_p</name></expr>;</expr_stmt>
<goto>goto <name>viml_pexpr_parse_figure_brace_closing_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeUnknownFigure</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeComma</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got closing figure brace: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>new_top_node_p</name> <operator>=</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><name>new_top_node_p</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeUnknownFigure</name>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeDictLiteral</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name>
<operator>!=</operator> <name>kExprNodeCurlyBracesIdentifier</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeLambda</name><operator>)</operator><operator>)</operator></expr>)</condition>;</do>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>new_top_node</name> <init>= <expr><operator>*</operator><name>new_top_node_p</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>new_top_node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kExprNodeUnknownFigure</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>new_top_node</name><operator>-&gt;</operator><name>children</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>new_top_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SELECT_FIGURE_BRACE_TYPE</name><argument_list>(<argument><expr><name>new_top_node</name></expr></argument>, <argument><expr><name>DictLiteral</name></expr></argument>, <argument><expr><name>Dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>new_top_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_ident</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SELECT_FIGURE_BRACE_TYPE</name><argument_list>(<argument><expr><name>new_top_node</name></expr></argument>, <argument><expr><name>CurlyBracesIdentifier</name></expr></argument>,
<argument><expr><name>Curly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Curly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><call><name>ERROR_FROM_NODE_AND_MSG</name><argument_list>(
<argument><expr><name>new_top_node</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Don't know what figure brace means: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>kv_A</name><argument_list>(<argument><expr><operator>*</operator><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr></argument>,
<argument><expr><name><name>new_top_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>opening_hl_idx</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>group</name> <operator>=</operator> <operator>(</operator>
<call><name>HL</name><argument_list>(<argument><expr><name>FigureBrace</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>FigureBrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeDictLiteral</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeCurlyBracesIdentifier</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Curly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeLambda</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<label><name>viml_pexpr_parse_figure_brace_closing_error</name>:</label>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected closing figure brace: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>FigureBrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>new_top_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>asgn_level</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>asgn_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTExpr</name>
<operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <call><name>pt_is_assignment</name><argument_list>(<argument><expr><call><name>kv_Z</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>asgn_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>FigureBrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>pt_is_assignment</name><argument_list>(<argument><expr><name>cur_pt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeCurlyBracesIdentifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_lambda</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_dict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_ident</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeUnknownFigure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_lambda</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_dict</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>type_guesses</name><operator>.</operator><name>allow_ident</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>fig</name><operator>.</operator><name>opening_hl_idx</name></name> <operator>=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name><name>pstate</name><operator>-&gt;</operator><name>colors</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><name>kEPTLambdaArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lambda_node</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>ADD_IDENT</name><argument_list>(
<argument>do {
NEW_NODE_WITH_CUR_POS(cur_node,
kExprNodeCurlyBracesIdentifier);
cur_node-&gt;data.fig.opening_hl_idx = kv_size(*pstate-&gt;colors);
cur_node-&gt;data.fig.type_guesses.allow_lambda = false;
cur_node-&gt;data.fig.type_guesses.allow_dict = false;
cur_node-&gt;data.fig.type_guesses.allow_ident = true;
kvi_push(ast_stack, &amp;cur_node-&gt;children);
if (pt_is_assignment(cur_pt)) {
kvi_push(pt_stack, kEPTExpr);
}
want_node = kENodeValue;
} while (<literal type="number">0</literal>)</argument>,
<argument>Curly</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pt_is_assignment</name><argument_list>(<argument><expr><name>cur_pt</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>pt_is_assignment</name><argument_list>(<argument><expr><call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>asgn_level</name> <operator>=</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexArrow</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTLambdaArguments</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeLambda</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>kExprNodeUnknownFigure</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>lambda_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SELECT_FIGURE_BRACE_TYPE</name><argument_list>(<argument><expr><name>lambda_node</name></expr></argument>, <argument><expr><name>Lambda</name></expr></argument>, <argument><expr><name>Lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeArrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lambda_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lambda_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected arrow: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Arrow outside of lambda: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeArrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Arrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexPlainIdentifier</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprVarScope</name></type> <name>scope</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cur_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexInvalid</name></expr>
?</condition><then> <expr><name>kExprVarScopeMissing</name></expr>
</then><else>: <expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>node_is_key</name></expr>
?</condition><then> <expr><name>kExprNodePlainKey</name></expr>
</then><else>: <expr><name>kExprNodePlainIdentifier</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name>scope</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>scope_shift</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>scope</name> <operator>==</operator> <name>kExprVarScopeMissing</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>ident</name></name> <operator>=</operator> <operator>(</operator><name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name>
<operator>+</operator> <name>scope_shift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>ident_len</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>scope_shift</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scope_shift</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>node_is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>IdentifierScope</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>IdentifierScopeDelimiter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>,
<argument><expr><name>scope_shift</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>scope_shift</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>node_is_key</name></expr>
?</condition><then> <expr><call><name>HL</name><argument_list>(<argument><expr><name>IdentifierKey</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>HL</name><argument_list>(<argument><expr><name>IdentifierName</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>kExprVarScopeMissing</name></expr>)</condition> <block>{<block_content>
<macro><name>ADD_IDENT</name><argument_list>(
<argument>do {
NEW_NODE_WITH_CUR_POS(cur_node, kExprNodePlainIdentifier);
cur_node-&gt;data.var.scope = scope;
cur_node-&gt;data.var.ident = pline.data + cur_token.start.col;
cur_node-&gt;data.var.ident_len = cur_token.len;
want_node = kENodeOperator;
} while (<literal type="number">0</literal>)</argument>,
<argument>IdentifierName</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexNumber</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>!=</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>node_is_key</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodePlainKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>ident</name></name> <operator>=</operator> <name><name>pline</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>cur_token</name><operator>.</operator><name>start</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>var</name><operator>.</operator><name>ident_len</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>IdentifierKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>is_float</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeFloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>flt</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>val</name><operator>.</operator><name>floating</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeInteger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>val</name><operator>.</operator><name>integer</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>prefix_length</name> <init>= <expr><name><name>base_to_prefix_length</name><index>[
<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>num</name><operator>.</operator><name>base</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>prefix_length</name></expr></argument>,
<argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>NumberPrefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_highlight</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>shifted_pos</name><argument_list>(<argument><expr><name><name>cur_token</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>prefix_length</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>prefix_length</name></expr></argument>, <argument><expr><call><name>HL</name><argument_list>(<argument><expr><name>Number</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexDot</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected dot: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexSpacing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTAssignment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Cannot concatenate in assignments: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeConcat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeConcatOrSubscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>ConcatOrSubscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexParenthesis</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>brc</name><operator>.</operator><name>closing</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier></type> <name>prev_top_node</name> <init>= <expr><operator>*</operator><call><name>kv_Z</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prev_top_node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeCall</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>viml_pexpr_parse_no_paren_closing_error</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got parenthesis: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeMissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>viml_pexpr_parse_no_paren_closing_error</name>:</label> <block>{<block_content/>}</block>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_top_node_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><name>new_top_node_p</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeNested</name>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeCall</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_top_node_p</name> <operator>=</operator> <call><name>kv_pop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>new_top_node_p</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeNested</name>
<operator>||</operator> <name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeCall</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>new_top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kExprNodeNested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>NestingParenthesis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>CallingParenthesis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>new_top_node_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_top_node_p</name> <operator>=</operator> <name>top_node_p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected closing parenthesis: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>NestingParenthesis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cur_node</name> <operator>=</operator> <call><name>NEW_NODE</name><argument_list>(<argument><expr><name>kExprNodeNested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <operator>*</operator><name>new_top_node_p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>new_top_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name>want_node</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kENodeValue</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeNested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>NestingParenthesis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kENodeOperator</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev_token</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kExprLexSpacing</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodePlainIdentifier</name>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeComplexIdentifier</name>
<operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>top_node_p</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>kExprNodeCurlyBracesIdentifier</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>CallingParenthesis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeValue</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexQuestion</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got question mark: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeTernary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HL_CUR_TOKEN</name><argument_list>(<argument><expr><name>Ternary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprASTNode</name> <modifier>*</modifier></type><name>ter_val_node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>ter_val_node</name></expr></argument>, <argument><expr><name>kExprNodeTernaryValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ter_val_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ter</name><operator>.</operator><name>got_colon</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>children</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name><name>cur_node</name><operator>-&gt;</operator><name>children</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><call><name>kv_last</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ter_val_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kvi_push</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ter_val_node</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexDoubleQuotedString</name></expr>:</case>
<case>case <expr><name>kExprLexSingleQuotedString</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_double</name> <init>= <expr><operator>(</operator><name>tok_type</name> <operator>==</operator> <name>kExprLexDoubleQuotedString</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>str</name><operator>.</operator><name>closed</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>is_double</name></expr>
?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E114: Missing double quote: %.*s"</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E115: Missing single quote: %.*s"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeOperator</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OP_MISSING</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(
<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>is_double</name></expr>
?</condition><then> <expr><name>kExprNodeDoubleQuotedString</name></expr>
</then><else>: <expr><name>kExprNodeSingleQuotedString</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top_node_p</name> <operator>=</operator> <name>cur_node</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_quoted_string</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>cur_token</name></expr></argument>, <argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><name>is_invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_node</name> <operator>=</operator> <name>kENodeOperator</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprLexAssignment</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTAssignment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cur_pt</name> <operator>==</operator> <name>kEPTSingleAssignment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E475: Expected closing bracket to end list assignment "</literal>
<literal type="string">"lvalue: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERROR_FROM_TOKEN_AND_MSG</name><argument_list>(
<argument><expr><name>cur_token</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Misplaced assignment: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>kEPTExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_VALUE_IF_MISSING</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Unexpected assignment: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEW_NODE_WITH_CUR_POS</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>kExprNodeAssignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>cur_token</name><operator>.</operator><name>data</name><operator>.</operator><name>ass</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HL_ASGN</name><parameter_list>(<parameter><type><name>asgn</name></type></parameter>, <parameter><type><name>hl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case kExprAsgn##asgn: { HL_CUR_TOKEN(hl); break; }</cpp:value></cpp:define>

<macro><name>HL_ASGN</name><argument_list>(<argument>Plain</argument>, <argument>PlainAssignment</argument>)</argument_list></macro>
<macro><name>HL_ASGN</name><argument_list>(<argument>Add</argument>, <argument>AssignmentWithAddition</argument>)</argument_list></macro>
<macro><name>HL_ASGN</name><argument_list>(<argument>Subtract</argument>, <argument>AssignmentWithSubtraction</argument>)</argument_list></macro>
<macro><name>HL_ASGN</name><argument_list>(<argument>Concat</argument>, <argument>AssignmentWithConcatenation</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HL_ASGN</name></cpp:undef>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>ADD_OP_NODE</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<label><name>viml_pexpr_parse_cycle_end</name>:</label>
<expr_stmt><expr><name>prev_token</name> <operator>=</operator> <name>cur_token</name></expr>;</expr_stmt>
<expr_stmt><expr><name>highlighted_prev_spacing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>viml_parser_advance</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cur_token</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>true</name></expr>)</condition>;</do>
<label><name>viml_pexpr_parse_end</name>:</label>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>want_node</name> <operator>==</operator> <name>kENodeValue</name>


<operator>&amp;&amp;</operator> <call><name>kv_last</name><argument_list>(<argument><expr><name>pt_stack</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>kEPTLambdaArguments</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Expected value, got EOC: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>kv_drop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>ast</name><operator>.</operator><name>err</name><operator>.</operator><name>msg</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>kv_size</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExprASTNode</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cur_node</name> <init>= <expr><operator>(</operator><operator>*</operator><call><name>kv_pop</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cur_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>cur_node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kExprNodeOpMissing</name></expr>:</case>
<case>case <expr><name>kExprNodeMissing</name></expr>:</case> <block>{<block_content>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeCall</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E116: Missing closing parenthesis for function call: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeNested</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E110: Missing closing parenthesis for nested expression"</literal>
<literal type="string">": %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeListLiteral</name></expr>:</case> <block>{<block_content>


<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E697: Missing end of List ']': %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeDictLiteral</name></expr>:</case> <block>{<block_content>


<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E723: Missing end of Dictionary '}': %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeUnknownFigure</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Missing closing figure brace: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeLambda</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E15: Missing closing figure brace for lambda: %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeCurlyBracesIdentifier</name></expr>:</case> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kExprNodeInteger</name></expr>:</case>
<case>case <expr><name>kExprNodeFloat</name></expr>:</case>
<case>case <expr><name>kExprNodeSingleQuotedString</name></expr>:</case>
<case>case <expr><name>kExprNodeDoubleQuotedString</name></expr>:</case>
<case>case <expr><name>kExprNodeOption</name></expr>:</case>
<case>case <expr><name>kExprNodeEnvironment</name></expr>:</case>
<case>case <expr><name>kExprNodeRegister</name></expr>:</case>
<case>case <expr><name>kExprNodePlainIdentifier</name></expr>:</case>
<case>case <expr><name>kExprNodePlainKey</name></expr>:</case> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kExprNodeComma</name></expr>:</case>
<case>case <expr><name>kExprNodeColon</name></expr>:</case>
<case>case <expr><name>kExprNodeArrow</name></expr>:</case> <block>{<block_content>



<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeSubscript</name></expr>:</case>
<case>case <expr><name>kExprNodeConcatOrSubscript</name></expr>:</case>
<case>case <expr><name>kExprNodeComplexIdentifier</name></expr>:</case>
<case>case <expr><name>kExprNodeAssignment</name></expr>:</case>
<case>case <expr><name>kExprNodeMod</name></expr>:</case>
<case>case <expr><name>kExprNodeDivision</name></expr>:</case>
<case>case <expr><name>kExprNodeMultiplication</name></expr>:</case>
<case>case <expr><name>kExprNodeNot</name></expr>:</case>
<case>case <expr><name>kExprNodeAnd</name></expr>:</case>
<case>case <expr><name>kExprNodeOr</name></expr>:</case>
<case>case <expr><name>kExprNodeConcat</name></expr>:</case>
<case>case <expr><name>kExprNodeComparison</name></expr>:</case>
<case>case <expr><name>kExprNodeUnaryMinus</name></expr>:</case>
<case>case <expr><name>kExprNodeUnaryPlus</name></expr>:</case>
<case>case <expr><name>kExprNodeBinaryMinus</name></expr>:</case>
<case>case <expr><name>kExprNodeTernary</name></expr>:</case>
<case>case <expr><name>kExprNodeBinaryPlus</name></expr>:</case> <block>{<block_content>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kExprNodeTernaryValue</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_node</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ter</name><operator>.</operator><name>got_colon</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>east_set_error</name><argument_list>(
<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ast</name><operator>.</operator><name>err</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E109: Missing ':' after '?': %.*s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cur_node</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>kvi_destroy</name><argument_list>(<argument><expr><name>ast_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ast</name></expr>;</return>
</block_content>}</block></function> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NEW_NODE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HL</name></cpp:undef>
</unit>
