<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\memory.c">




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/context.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/highlight.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ui.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/sign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIT_TESTING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mem_malloc(size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name><parameter_list>(<parameter><type><name>count</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mem_calloc(count, size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mem_realloc(ptr, size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mem_free(ptr)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>MemMalloc</name></type> <name>mem_malloc</name> <init>= <expr><operator>&amp;</operator><name>malloc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemFree</name></type> <name>mem_free</name> <init>= <expr><operator>&amp;</operator><name>free</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemCalloc</name></type> <name>mem_calloc</name> <init>= <expr><operator>&amp;</operator><name>calloc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemRealloc</name></type> <name>mem_realloc</name> <init>= <expr><operator>&amp;</operator><name>realloc</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>bool</name></type> <name>entered_free_all_mem</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function><type><name>void</name></type> <name>try_to_free_memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>trying_to_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>trying_to_free</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>trying_to_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>clear_sb_text</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mf_release_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>trying_to_free</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>









<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>try_malloc</name><argument_list>(<argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list> <name>FUNC_ATTR_MALLOC</name> <name>FUNC_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name> <init>= <expr><ternary><condition><expr><name>size</name></expr> ?</condition><then> <expr><name>size</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>try_to_free_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>verbose_try_malloc</name><argument_list>(<argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list> <name>FUNC_ATTR_MALLOC</name> <name>FUNC_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>try_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>do_outofmem_msg</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>









<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>xmalloc</name><argument_list>(<argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_MALLOC</name> <name>FUNC_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list> <name>FUNC_ATTR_NONNULL_RET</name>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>try_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><name>e_outofmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preserve_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name>void</name></type> <name>xfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>xcalloc</name><argument_list>(<argument><expr><name>size_t</name> <name>count</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_MALLOC</name> <name>FUNC_ATTR_ALLOC_SIZE_PROD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list> <name>FUNC_ATTR_NONNULL_RET</name>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_count</name> <init>= <expr><ternary><condition><expr><name>count</name> <operator>&amp;&amp;</operator> <name>size</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name> <init>= <expr><ternary><condition><expr><name>count</name> <operator>&amp;&amp;</operator> <name>size</name></expr> ?</condition><then> <expr><name>size</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><name>allocated_count</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>try_to_free_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>allocated_count</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><name>e_outofmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preserve_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>xrealloc</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list> <name>FUNC_ATTR_NONNULL_RET</name>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name> <init>= <expr><ternary><condition><expr><name>size</name></expr> ?</condition><then> <expr><name>size</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>try_to_free_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><name>e_outofmem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preserve_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<function><type><name>void</name> <modifier>*</modifier></type><name>xmallocz</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>total_size</name> <init>= <expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mch_errmsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Vim: Data too large to fit into virtual memory space\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preserve_exit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ret</name><operator>)</operator><index>[<expr><name>size</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name> <modifier>*</modifier></type><name>xmemdupz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>xmallocz</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><name>char</name> <modifier>*</modifier></type><name>xstrchrnul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>p</name></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>str</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name> <modifier>*</modifier></type><name>xmemscan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>p</name></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>addr</name> <operator>+</operator> <name>size</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>strchrsub</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>x</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>memchrsub</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>








<function><type><name>size_t</name></type> <name>strcnt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt> 
</block_content>}</block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>size_t</name></type> <name>memcnt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>data</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt> 
</block_content>}</block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>char</name> <modifier>*</modifier></type><name>xstpcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>src</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name></expr>;</return>
</block_content>}</block></function>

















<function><type><name>char</name> <modifier>*</modifier></type><name>xstpncpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>srclen</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>src</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>srclen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxlen</name> <operator>-</operator> <name>srclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dst</name> <operator>+</operator> <name>srclen</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dst</name> <operator>+</operator> <name>maxlen</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>













<function><type><name>size_t</name></type> <name>xstrlcpy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dsize</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dsize</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>slen</name></expr></argument>, <argument><expr><name>dsize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>slen</name></expr>;</return> 
</block_content>}</block></function>















<function><type><name>size_t</name></type> <name>xstrlcat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>dsize</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>dlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dlen</name> <operator>&lt;</operator> <name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <name>dsize</name> <operator>-</operator> <name>dlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>dlen</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dsize</name> <operator>-</operator> <name>dlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dsize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>dlen</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>slen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>slen</name> <operator>+</operator> <name>dlen</name></expr>;</return> 
</block_content>}</block></function>






<function><type><name>char</name> <modifier>*</modifier></type><name>xstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>char</name> <modifier>*</modifier></type><name>xstrdupnul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>xmallocz</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>









<function><type><name>void</name> <modifier>*</modifier></type><name>xmemrchr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE
<block>{<block_content>
<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>src</name><operator>)</operator><index>[<expr><name>len</name></expr>]</index> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>src</name> <operator>+</operator> <name>len</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>char</name> <modifier>*</modifier></type><name>xstrndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>xmemdupz</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>str</name><operator>)</operator></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>xmemdup</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>data</name></expr></argument>, <argument><expr><name>size_t</name> <name>len</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_MALLOC</name> <name>FUNC_ATTR_ALLOC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list> <name>FUNC_ATTR_NONNULL_RET</name>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_NONNULL_ALL</name>
<block>{<block_content>
<return>return <expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>bool</name></type> <name>strequal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><operator>(</operator><name>a</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>striequal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<return>return <expr><operator>(</operator><name>a</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <call><name>STRICMP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>do_outofmem_msg</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_outofmem_msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>did_outofmem_msg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EMSGU</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E342: Out of memory! (allocating %"</literal> <name>PRIu64</name> <literal type="string">" bytes)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>time_to_bytes</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>time_</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>


<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>, <decl><type ref="prev"/><name>bufi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bufi</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>bufi</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>bufi</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>time_</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/file_search.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/edit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_cmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_docmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_getln.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fold.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/getchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mark.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/move.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os_unix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/quickfix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/screen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/search.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/spell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/syntax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/window.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>








<function><type><name>void</name></type> <name>free_all_mem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextbuf</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>entered_free_all_mem</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>entered_free_all_mem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>block_autocmds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p_ea</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>first_tabpage</name><operator>-&gt;</operator><name>tp_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"tabonly!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ONE_WINDOW</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>firstwin</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"only!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>spell_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ex_comclear</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"aunmenu *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"menutranslate clear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"lmapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"xmapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"mapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"mapclear!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"abclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"breakdel *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"profdel *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"set keymap="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_titles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_findfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>free_all_autocmds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_all_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alist_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_homedir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_users</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_search_patterns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_old_sub</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_last_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_prev_shellcmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_regexp_stuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_tag_stuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_cd_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_signs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_expr_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>diff_clear</name><argument_list>(<argument><expr><name>curtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_sb_text</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>last_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>new_last_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_keep_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p_hi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tab</argument>, <argument>win</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><call><name>close_all_scripts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>win_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>free_all_options</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_arshape_buf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>clear_registers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>free_highlight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reset_last_sourcing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_tabpage</name><argument_list>(<argument><expr><name>first_tabpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first_tabpage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>delete_first_msg</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>eval_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_vim_free_all_mem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ctx_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>p_acd</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>buf</name> <operator>=</operator> <name>firstbuf</name></expr>;</init> <condition><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>bufref_T</name></type> <name>bufref</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nextbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_buffer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>DOBUF_WIPE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <ternary><condition><expr><call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>nextbuf</name></expr> </then><else>: <expr><name>firstbuf</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>screen_free_all_mem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_hl_tables</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_free_log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
