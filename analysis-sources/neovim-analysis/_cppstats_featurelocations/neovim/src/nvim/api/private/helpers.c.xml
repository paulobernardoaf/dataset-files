<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\api\private\helpers.c">


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/private/helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/private/defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/private/handle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/msgpack_rpc/helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lua/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/window.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/map_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/extmark.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/getchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ui.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <block>{
<macro><name>kvec_t</name><argument_list>(<argument>Object</argument>)</argument_list></macro> <expr_stmt><expr><name>stack</name></expr>;</expr_stmt> 
}</block></struct></type> <name>EncodedData</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/private/helpers.c.generated.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/private/funcs_metadata.generated.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/private/ui_events_metadata.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<function><type><name>void</name></type> <name>try_enter</name><parameter_list>(<parameter><decl><type><name>TryState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<expr_stmt><expr><operator>*</operator><name>tstate</name> <operator>=</operator> <operator>(</operator><name>TryState</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>current_exception</name> <operator>=</operator> <name>current_exception</name></expr>,
<expr><operator>.</operator><name>msg_list</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>msglist</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><name>msg_list</name></expr>,
<expr><operator>.</operator><name>private_msg_list</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>trylevel</name> <operator>=</operator> <name>trylevel</name></expr>,
<expr><operator>.</operator><name>got_int</name> <operator>=</operator> <name>got_int</name></expr>,
<expr><operator>.</operator><name>need_rethrow</name> <operator>=</operator> <name>need_rethrow</name></expr>,
<expr><operator>.</operator><name>did_emsg</name> <operator>=</operator> <name>did_emsg</name></expr>,
}</block></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_list</name> <operator>=</operator> <operator>&amp;</operator><name><name>tstate</name><operator>-&gt;</operator><name>private_msg_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>current_exception</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>trylevel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>need_rethrow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>did_emsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><name>bool</name></type> <name>try_leave</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TryState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tstate</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier><specifier>const</specifier></type> <name>err</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>ret</name> <init>= <expr><operator>!</operator><call><name>try_end</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>trylevel</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>need_rethrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>got_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>did_emsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>msg_list</name> <operator>==</operator> <operator>&amp;</operator><name><name>tstate</name><operator>-&gt;</operator><name>private_msg_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>msg_list</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>current_exception</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_list</name> <operator>=</operator> <operator>(</operator>struct <name>msglist</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>tstate</name><operator>-&gt;</operator><name>msg_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>current_exception</name> <operator>=</operator> <name><name>tstate</name><operator>-&gt;</operator><name>current_exception</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>trylevel</name> <operator>=</operator> <name><name>tstate</name><operator>-&gt;</operator><name>trylevel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name><name>tstate</name><operator>-&gt;</operator><name>got_int</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>need_rethrow</name> <operator>=</operator> <name><name>tstate</name><operator>-&gt;</operator><name>need_rethrow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>did_emsg</name> <operator>=</operator> <name><name>tstate</name><operator>-&gt;</operator><name>did_emsg</name></name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>try_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>trylevel</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>bool</name></type> <name>try_end</name><parameter_list>(<parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<expr_stmt><expr><name>trylevel</name><operator>--</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>did_emsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>force_abort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>current_exception</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>discard_current_exception</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Keyboard interrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>msg_list</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>msg_list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>should_free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>get_exception_string</name><argument_list>(<argument><expr><operator>*</operator><name>msg_list</name></expr></argument>,
<argument><expr><name>ET_ERROR</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_global_msglist</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>current_exception</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>current_exception</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discard_current_exception</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ERROR_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>Object</name></type> <name>dict_get_value</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>key</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Key not found: %s"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>Object</name><operator>)</operator><name>OBJECT_INIT</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vim_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><name>Object</name></type> <name>dict_set_var</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>del</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>retval</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>rv</name> <init>= <expr><name>OBJECT_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>key</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DI_FLAGS_RO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Key is read-only: %s"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DI_FLAGS_LOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Key is locked: %s"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>del</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>di</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DI_FLAGS_FIX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Key is fixed: %s"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>dv_lock</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Dictionary is locked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Key name is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>key</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Key name is too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>del</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Key not found: %s"</literal></expr></argument>,
<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vim_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_dict_item_remove</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_to_vim</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vim_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>Object</name></type> <name>get_option_from</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>rv</name> <init>= <expr><name>OBJECT_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Empty option name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>numval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stringval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>get_option_value_strict</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stringval</name></expr></argument>,
<argument><expr><name>type</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flags</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Invalid option name: '%s'"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SOPT_BOOL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kObjectTypeBoolean</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <ternary><condition><expr><name>numval</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SOPT_NUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kObjectTypeInteger</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <name>numval</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SOPT_STRING</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>stringval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kObjectTypeString</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>stringval</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rv</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>size</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>stringval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>,
<argument><expr><literal type="string">"Failed to get value for option '%s'"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
<argument><expr><name>kErrorTypeException</name></expr></argument>,
<argument><expr><literal type="string">"Unknown type for option '%s'"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>set_option_to</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>channel_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>name</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Empty option name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>get_option_value_strict</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Invalid option name '%s'"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeNil</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>SREQ_GLOBAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"Cannot unset option '%s'"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SOPT_GLOBAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
<argument><expr><name>kErrorTypeException</name></expr></argument>,
<argument><expr><literal type="string">"Cannot unset option '%s' "</literal>
<literal type="string">"because it doesn't have a global value"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>unset_global_local_option</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>numval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stringval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SOPT_BOOL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kObjectTypeBoolean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
<argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Option '%s' requires a Boolean value"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>numval</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SOPT_NUM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kObjectTypeInteger</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Option '%s' requires an integer value"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Value for option '%s' is out of range"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>numval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kObjectTypeString</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Option '%s' requires a string value"</literal></expr></argument>,
<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>stringval</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>sctx_T</name></type> <name>save_current_sctx</name> <init>= <expr><name>current_sctx</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name> <operator>=</operator>
<ternary><condition><expr><name>channel_id</name> <operator>==</operator> <name>LUA_INTERNAL_CALL</name></expr> ?</condition><then> <expr><name>SID_LUA</name></expr> </then><else>: <expr><name>SID_API_CLIENT</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current_sctx</name><operator>.</operator><name>sc_lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>current_channel_id</name> <operator>=</operator> <name>channel_id</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_flags</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>SREQ_WIN</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SOPT_GLOBAL</name><operator>)</operator><operator>)</operator></expr>
?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>SREQ_GLOBAL</name><operator>)</operator></expr>
?</condition><then> <expr><name>OPT_GLOBAL</name></expr> </then><else>: <expr><name>OPT_LOCAL</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_option_value_for</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>numval</name></expr></argument>, <argument><expr><name>stringval</name></expr></argument>,
<argument><expr><name>opt_flags</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current_sctx</name> <operator>=</operator> <name>save_current_sctx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:macro> <cpp:value>false</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NIL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, NIL)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_BOOL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, BOOLEAN_OBJ((Boolean)(num)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, INTEGER_OBJ((Integer)(num)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_NUMBER</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FLOAT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>flt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, FLOAT_OBJ((Float)(flt)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const size_t len_ = (size_t)(len); const char *const str_ = (const char *)(str); assert(len_ == 0 || str_ != NULL); kv_push(edata-&gt;stack, STRING_OBJ(((String) { .data = xmemdupz((len_?str_:""), len_), .size = len_ }))); } while (0)</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STR_STRING</name></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_STRING</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EXT_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_NIL(tv)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>fun</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { TYPVAL_ENCODE_CONV_NIL(tv); goto typval_encode_stop_converting_one_item; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, ARRAY_OBJ(((Array) { .capacity = 0, .size = 0 })))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kv_push(edata-&gt;stack, DICTIONARY_OBJ(((Dictionary) { .capacity = 0, .size = 0 })))</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_list_start</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<macro><name>kv_push</name><argument_list>(<argument>edata-&gt;stack</argument>, <argument>ARRAY_OBJ(((Array) {
.capacity = len,
.size = <literal type="number">0</literal>,
.items = xmalloc(len * sizeof(*((Object)OBJECT_INIT).data.array.items)),
}))</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_list_start(edata, (size_t)(len))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_between_list_items</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>item</name> <init>= <expr><call><name>kv_pop</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Object</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><operator>&amp;</operator><call><name>kv_last</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>items</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_between_list_items(edata)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_list_end</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>typval_encode_between_list_items</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>Object</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><operator>&amp;</operator><call><name>kv_last</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_list_end(edata)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_dict_start</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<macro><name>kv_push</name><argument_list>(<argument>edata-&gt;stack</argument>, <argument>DICTIONARY_OBJ(((Dictionary) {
.capacity = len,
.size = <literal type="number">0</literal>,
.items = xmalloc(len * sizeof(
*((Object)OBJECT_INIT).data.dictionary.items)),
}))</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_dict_start(edata, (size_t)(len))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name><parameter_list>(<parameter><type><name>label</name></type></parameter>, <parameter><type><name>kv_pair</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_after_key</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>key</name> <init>= <expr><call><name>kv_pop</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Object</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><call><name>kv_last</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeDictionary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeString</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>items</name><index>[<expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name></expr>]</index></name><operator>.</operator><name>key</name>
<operator>=</operator> <name><name>key</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>api_free_object</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>items</name><index>[<expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name></expr>]</index></name><operator>.</operator><name>key</name>
<operator>=</operator> <call><name>STATIC_CSTR_TO_STRING</name><argument_list>(<argument><expr><literal type="string">"__INVALID_KEY__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_after_key(edata)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_between_dict_items</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>val</name> <init>= <expr><call><name>kv_pop</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Object</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><call><name>kv_last</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeDictionary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>items</name><index>[<expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_between_dict_items(edata)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>typval_encode_dict_end</name><parameter_list>(<parameter><decl><type><name>EncodedData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>edata</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>typval_encode_between_dict_items</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>Object</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><operator>&amp;</operator><call><name>kv_last</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name><name>dict</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typval_encode_dict_end(edata)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_NIL(val)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>object</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>EncodedData *const</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>edata</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STR_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EXT_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NUMBER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FLOAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NIL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_BOOL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:undef>






<function><type><name>Object</name></type> <name>vim_to_object</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>EncodedData</name></type> <name>edata</name> <init>= <expr><block>{ <expr><operator>.</operator><name>stack</name> <operator>=</operator> <name>KV_INITIAL_VALUE</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>evo_ret</name> <init>= <expr><call><name>encode_vim_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
<argument><expr><literal type="string">"vim_to_object argument"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>evo_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>evo_ret</name> <operator>==</operator> <name>OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Object</name></type> <name>ret</name> <init>= <expr><call><name>kv_A</name><argument_list>(<argument><expr><name><name>edata</name><operator>.</operator><name>stack</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>kv_size</name><argument_list>(<argument><expr><name><name>edata</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_destroy</name><argument_list>(<argument><expr><name><name>edata</name><operator>.</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>buf_T</name> <modifier>*</modifier></type><name>find_buffer_by_handle</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>curbuf</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>handle_get_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Invalid buffer id: %d"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>win_T</name> <modifier>*</modifier></type><name>find_window_by_handle</name><parameter_list>(<parameter><decl><type><name>Window</name></type> <name>window</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>window</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>curwin</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>handle_get_window</name><argument_list>(<argument><expr><name>window</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Invalid window id: %d"</literal></expr></argument>, <argument><expr><name>window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>tabpage_T</name> <modifier>*</modifier></type><name>find_tab_by_handle</name><parameter_list>(<parameter><decl><type><name>Tabpage</name></type> <name>tabpage</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tabpage</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>curtab</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>handle_get_tabpage</name><argument_list>(<argument><expr><name>tabpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Invalid tabpage id: %d"</literal></expr></argument>, <argument><expr><name>tabpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>String</name></type> <name>cchar_to_string</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>c</name></expr>, <expr><name>NUL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><block>{
<expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>!=</operator> <name>NUL</name><operator>)</operator> <operator>?</operator> <literal type="number">1</literal> <operator>:</operator> <literal type="number">0</literal></expr>
}</block></expr>;</return>
</block_content>}</block></function>








<function><type><name>String</name></type> <name>cstr_to_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><name>STRING_INIT</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><block>{
<expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>len</name></expr>,
}</block></expr>;</return>
</block_content>}</block></function>









<function><type><name>String</name></type> <name>cbuf_to_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><block>{
<expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>size</name></expr>
}</block></expr>;</return>
</block_content>}</block></function>

<function><type><name>String</name></type> <name>cstrn_to_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>cbuf_to_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><name>String</name></type> <name>cstr_as_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> FUNC_ATTR_PURE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><name>STRING_INIT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>str</name></expr>, <expr><operator>.</operator><name>size</name> <operator>=</operator> <macro><name>strlen</name><argument_list>(<argument>str</argument>)</argument_list></macro></expr> }</block></expr>;</return>
</block_content>}</block></function>




<function><type><name>String</name></type> <name>ga_take_string</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>String</name></type> <name>str</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ga</name><operator>-&gt;</operator><name>ga_data</name></name></expr>, <expr><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>ga</name><operator>-&gt;</operator><name>ga_len</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>ga_maxlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>Array</name></type> <name>string_to_array</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>crlf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Array</name></type> <name>ret</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>input</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>line_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>line_len</name> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>size</name></name> <operator>-</operator> <name>i</name></expr>;</condition> <incr><expr><name>line_len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>line_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <name>NL</name> <operator>||</operator> <operator>(</operator><name>crlf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <name>CAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>line_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>crlf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <name>CAR</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>end</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>NL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><block>{
<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>line_len</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>line_len</name></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memchrsub</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><name>line_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>input</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>end</name> <operator>==</operator> <name>NL</name> <operator>||</operator> <operator>(</operator><name>crlf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <name>CAR</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><name>STRING_INIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>modify_keymap</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_unmap</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>lhs</name></decl></parameter>,
<parameter><decl><type><name>String</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name>Dictionary</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ErrorType</name></type> <name>err_type</name> <init>= <expr><name>kErrorTypeNone</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lhs_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rhs_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>global</name> <init>= <expr><operator>(</operator><name>buffer</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>global</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>target_buf</name> <init>= <expr><call><name>find_buffer_by_handle</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MapArguments</name></type> <name>parsed_args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>parsed_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_keymap_opts</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail_and_free</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parsed_args</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <operator>!</operator><name>global</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_maparg_lhs_rhs</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>lhs</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lhs</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>rhs</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>rhs</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name>CPO_TO_CPO_FLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>lhs_len</name></name> <operator>&gt;</operator> <name>MAXMAPLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"LHS exceeds maximum map length: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <name><name>lhs</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mode</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Shortname is too long: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <name><name>mode</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode_val</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>mode</name><operator>.</operator><name>size</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>mode</name><operator>.</operator><name>data</name></name></expr> </then><else>: <expr><literal type="string">"m"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"!"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mode_val</name> <operator>=</operator> <call><name>get_map_mode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>mode_val</name> <operator>=</operator> <call><name>get_map_mode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode_val</name> <operator>==</operator> <name>VISUAL</name> <operator>+</operator> <name>SELECTMODE</name> <operator>+</operator> <name>NORMAL</name> <operator>+</operator> <name>OP_PENDING</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>mode</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Invalid mode shortname: \"%s\""</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>lhs_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Invalid (empty) LHS"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_noremap</name> <init>= <expr><name><name>parsed_args</name><operator>.</operator><name>noremap</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>is_unmap</name> <operator>&amp;&amp;</operator> <name>is_noremap</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_unmap</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>parsed_args</name><operator>.</operator><name>rhs_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parsed_args</name><operator>.</operator><name>rhs_is_noop</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rhs</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>parsed_args</name><operator>.</operator><name>rhs_is_noop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Failed to parse nonempty RHS!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Parsing of nonempty RHS failed: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <name><name>rhs</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeException</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_unmap</name> <operator>&amp;&amp;</operator> <name><name>parsed_args</name><operator>.</operator><name>rhs_len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Gave nonempty RHS in unmap command: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>parsed_args</name><operator>.</operator><name>rhs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>maptype_val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_unmap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maptype_val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_noremap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maptype_val</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>buf_do_map</name><argument_list>(<argument><expr><name>maptype_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>, <argument><expr><name>mode_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target_buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e_invarg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e_nomap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>,
<argument><expr><literal type="string">"E227: mapping already exists for %s"</literal></expr></argument>, <argument><expr><name><name>parsed_args</name><operator>.</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Unrecognized return code!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail_and_free</name>;</goto>
</block_content>}</block></switch> 

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>lhs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>rhs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>parsed_args</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>parsed_args</name><operator>.</operator><name>orig_rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<label><name>fail_with_message</name>:</label>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>err_type</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>, <argument><expr><name>err_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail_and_free</name>:</label>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>lhs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>rhs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>parsed_args</name><operator>.</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>parsed_args</name><operator>.</operator><name>orig_rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></function>










<function><type><name>Integer</name></type> <name>parse_keymap_opts</name><parameter_list>(<parameter><decl><type><name>Dictionary</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>MapArguments</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ErrorType</name></type> <name>err_type</name> <init>= <expr><name>kErrorTypeNone</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nowait</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>silent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>script</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>opts</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>KeyValuePair</name> <modifier>*</modifier></type><name>key_and_val</name> <init>= <expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optname</name> <init>= <expr><name><name>key_and_val</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kObjectTypeBoolean</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Gave non-boolean value for an opt: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <name>optname</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>was_valid_opt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>optname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>






<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"noremap"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>noremap</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"nowait"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nowait</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"silent"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>silent</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"script"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>script</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"expr"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>optname</name></expr></argument>, <argument><expr><literal type="string">"unique"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>was_valid_opt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>key_and_val</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>was_valid_opt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"Invalid key: %s"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err_arg</name> <operator>=</operator> <name>optname</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err_type</name> <operator>=</operator> <name>kErrorTypeValidation</name></expr>;</expr_stmt>
<goto>goto <name>fail_with_message</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for> 

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail_with_message</name>:</label>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>err_type</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>, <argument><expr><name>err_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><name>bool</name></type> <name>buf_collect_lines</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace_nl</name></decl></parameter>,
<parameter><decl><type><name>Array</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lnum</name> <init>= <expr><name>start</name> <operator>+</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;=</operator> <name>MAXLNUM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Line index is too high"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bufstr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ml_get_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Object</name></type> <name>str</name> <init>= <expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><name>bufstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>replace_nl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strchrsub</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>bool</name></type> <name>object_to_vim</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>obj</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kObjectTypeNil</name></expr>:</case>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name> <operator>=</operator> <name>kSpecialVarNull</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeBoolean</name></expr>:</case>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name> <operator>=</operator> <ternary><condition><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>boolean</name></name></expr>?</condition><then> <expr><name>kSpecialVarTrue</name></expr></then><else>: <expr><name>kSpecialVarFalse</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeBuffer</name></expr>:</case>
<case>case <expr><name>kObjectTypeWindow</name></expr>:</case>
<case>case <expr><name>kObjectTypeTabpage</name></expr>:</case>
<case>case <expr><name>kObjectTypeInteger</name></expr>:</case>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varnumber_T</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Integer size must be &lt;= VimL number size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <operator>(</operator><name>varnumber_T</name><operator>)</operator><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeFloat</name></expr>:</case>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_FLOAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name> <operator>=</operator> <name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>floating</name></name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeString</name></expr>:</case>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeArray</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Object</name></type> <name>item</name> <init>= <expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typval_T</name></type> <name>li_tv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_to_vim</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li_tv</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_list_append_owned_tv</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>li_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>kObjectTypeDictionary</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>KeyValuePair</name></type> <name>item</name> <init>= <expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>dictionary</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><name><name>item</name><operator>.</operator><name>key</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Empty dictionary keys aren't allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tv_dict_free</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_item_alloc</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_to_vim</name><argument_list>(<argument><expr><name><name>item</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_free</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>api_free_string</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>value</name><operator>.</operator><name>data</name></name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>api_free_object</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>value</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kObjectTypeNil</name></expr>:</case>
<case>case <expr><name>kObjectTypeBoolean</name></expr>:</case>
<case>case <expr><name>kObjectTypeInteger</name></expr>:</case>
<case>case <expr><name>kObjectTypeFloat</name></expr>:</case>
<case>case <expr><name>kObjectTypeBuffer</name></expr>:</case>
<case>case <expr><name>kObjectTypeWindow</name></expr>:</case>
<case>case <expr><name>kObjectTypeTabpage</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>kObjectTypeString</name></expr>:</case>
<expr_stmt><expr><call><name>api_free_string</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeArray</name></expr>:</case>
<expr_stmt><expr><call><name>api_free_array</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeDictionary</name></expr>:</case>
<expr_stmt><expr><call><name>api_free_dictionary</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>kObjectTypeLuaRef</name></expr>:</case>
<expr_stmt><expr><call><name>executor_free_luaref</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>data</name><operator>.</operator><name>luaref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>api_free_array</name><parameter_list>(<parameter><decl><type><name>Array</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>api_free_object</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>api_free_dictionary</name><parameter_list>(<parameter><decl><type><name>Dictionary</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>api_free_string</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_free_object</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>api_clear_error</name><parameter_list>(<parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ERROR_SET</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kErrorTypeNone</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Dictionary</name></type> <name>api_metadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>Dictionary</name></type> <name>metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>metadata</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><call><name>version_dict</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_function_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_ui_event_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_error_type_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_type_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>copy_object</name><argument_list>(<argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name><name>data</name><operator>.</operator><name>dictionary</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_function_metadata</name><parameter_list>(<parameter><decl><type><name>Dictionary</name> <modifier>*</modifier></type><name>metadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>msgpack_unpacked</name></type> <name>unpacked</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_unpack_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>funcs_metadata</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>funcs_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MSGPACK_UNPACK_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>Object</name></type> <name>functions</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_rpc_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unpacked</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><operator>*</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"functions"</literal></expr></argument>, <argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_ui_event_metadata</name><parameter_list>(<parameter><decl><type><name>Dictionary</name> <modifier>*</modifier></type><name>metadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>msgpack_unpacked</name></type> <name>unpacked</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_unpack_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>ui_events_metadata</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ui_events_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MSGPACK_UNPACK_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>Object</name></type> <name>ui_events</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_rpc_to_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unpacked</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ui_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><operator>*</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"ui_events"</literal></expr></argument>, <argument><expr><name>ui_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Array</name></type> <name>ui_options</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>ui_options</name></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><literal type="string">"rgb"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>UIExtension</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>kUIExtCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ui_ext_names</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>ui_options</name></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><name><name>ui_ext_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><operator>*</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"ui_options"</literal></expr></argument>, <argument><expr><call><name>ARRAY_OBJ</name><argument_list>(<argument><expr><name>ui_options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_error_type_metadata</name><parameter_list>(<parameter><decl><type><name>Dictionary</name> <modifier>*</modifier></type><name>metadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dictionary</name></type> <name>types</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Dictionary</name></type> <name>exception_metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>exception_metadata</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><call><name>INTEGER_OBJ</name><argument_list>(<argument><expr><name>kErrorTypeException</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Dictionary</name></type> <name>validation_metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>validation_metadata</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><call><name>INTEGER_OBJ</name><argument_list>(<argument><expr><name>kErrorTypeValidation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"Exception"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>exception_metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"Validation"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>validation_metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><operator>*</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"error_types"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_type_metadata</name><parameter_list>(<parameter><decl><type><name>Dictionary</name> <modifier>*</modifier></type><name>metadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dictionary</name></type> <name>types</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Dictionary</name></type> <name>buffer_metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>buffer_metadata</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>,
<argument><expr><call><name>INTEGER_OBJ</name><argument_list>(<argument><expr><name>kObjectTypeBuffer</name> <operator>-</operator> <name>EXT_OBJECT_TYPE_SHIFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>buffer_metadata</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><literal type="string">"nvim_buf_"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Dictionary</name></type> <name>window_metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>window_metadata</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>,
<argument><expr><call><name>INTEGER_OBJ</name><argument_list>(<argument><expr><name>kObjectTypeWindow</name> <operator>-</operator> <name>EXT_OBJECT_TYPE_SHIFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>window_metadata</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><literal type="string">"nvim_win_"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Dictionary</name></type> <name>tabpage_metadata</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>tabpage_metadata</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>,
<argument><expr><call><name>INTEGER_OBJ</name><argument_list>(<argument><expr><name>kObjectTypeTabpage</name> <operator>-</operator> <name>EXT_OBJECT_TYPE_SHIFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>tabpage_metadata</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>cstr_to_string</name><argument_list>(<argument><expr><literal type="string">"nvim_tabpage_"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"Buffer"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>buffer_metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"Window"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>window_metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><literal type="string">"Tabpage"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>tabpage_metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><operator>*</operator><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"types"</literal></expr></argument>, <argument><expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>String</name></type> <name>copy_string</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>size</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>size</name></name></expr> }</block></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>(</operator><name>String</name><operator>)</operator><name>STRING_INIT</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Array</name></type> <name>copy_array</name><parameter_list>(<parameter><decl><type><name>Array</name></type> <name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Array</name></type> <name>rv</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>copy_object</name><argument_list>(<argument><expr><name><name>array</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Dictionary</name></type> <name>copy_dictionary</name><parameter_list>(<parameter><decl><type><name>Dictionary</name></type> <name>dict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dictionary</name></type> <name>rv</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dict</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>KeyValuePair</name></type> <name>item</name> <init>= <expr><name><name>dict</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>item</name><operator>.</operator><name>key</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>copy_object</name><argument_list>(<argument><expr><name><name>item</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Object</name></type> <name>copy_object</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>obj</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kObjectTypeBuffer</name></expr>:</case>
<case>case <expr><name>kObjectTypeTabpage</name></expr>:</case>
<case>case <expr><name>kObjectTypeWindow</name></expr>:</case>
<case>case <expr><name>kObjectTypeNil</name></expr>:</case>
<case>case <expr><name>kObjectTypeBoolean</name></expr>:</case>
<case>case <expr><name>kObjectTypeInteger</name></expr>:</case>
<case>case <expr><name>kObjectTypeFloat</name></expr>:</case>
<return>return <expr><name>obj</name></expr>;</return>

<case>case <expr><name>kObjectTypeString</name></expr>:</case>
<return>return <expr><call><name>STRING_OBJ</name><argument_list>(<argument><expr><call><name>copy_string</name><argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>kObjectTypeArray</name></expr>:</case>
<return>return <expr><call><name>ARRAY_OBJ</name><argument_list>(<argument><expr><call><name>copy_array</name><argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>kObjectTypeDictionary</name></expr>:</case> <block>{<block_content>
<return>return <expr><call><name>DICTIONARY_OBJ</name><argument_list>(<argument><expr><call><name>copy_dictionary</name><argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>dictionary</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_option_value_for</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>numval</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>stringval</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>opt_flags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>opt_type</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
<parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>save_curwin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>save_curtab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>aco_save_T</name></type> <name>aco</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>try_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>opt_type</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>SREQ_WIN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>switch_win</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_curwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_curtab</name></expr></argument>, <argument><expr><operator>(</operator><name>win_T</name> <operator>*</operator><operator>)</operator><name>from</name></expr></argument>,
<argument><expr><call><name>win_find_tabpage</name><argument_list>(<argument><expr><operator>(</operator><name>win_T</name> <operator>*</operator><operator>)</operator><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>try_end</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
<argument><expr><name>kErrorTypeException</name></expr></argument>,
<argument><expr><literal type="string">"Problem while switching windows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_option_value_err</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>numval</name></expr></argument>, <argument><expr><name>stringval</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>restore_win</name><argument_list>(<argument><expr><name>save_curwin</name></expr></argument>, <argument><expr><name>save_curtab</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SREQ_BUF</name></expr>:</case>
<expr_stmt><expr><call><name>aucmd_prepbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>, <argument><expr><operator>(</operator><name>buf_T</name> <operator>*</operator><operator>)</operator><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_option_value_err</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>numval</name></expr></argument>, <argument><expr><name>stringval</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>aucmd_restbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SREQ_GLOBAL</name></expr>:</case>
<expr_stmt><expr><call><name>set_option_value_err</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>numval</name></expr></argument>, <argument><expr><name>stringval</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>ERROR_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>try_end</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>set_option_value_err</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>numval</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>stringval</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>opt_flags</name></decl></parameter>,
<parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>errmsg</name> <operator>=</operator> <call><name>set_option_value</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>numval</name></expr></argument>, <argument><expr><name>stringval</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>try_end</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeException</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>api_set_error</name><argument_list>(<argument><expr><name>Error</name> <operator>*</operator><name>err</name></expr></argument>, <argument><expr><name>ErrorType</name> <name>errType</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>format</name></expr></argument>, <argument><expr><operator>...</operator></expr></argument>)</argument_list>
<name>FUNC_ATTR_NONNULL_ALL</name> <name>FUNC_ATTR_PRINTF</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kErrorTypeNone</name> <operator>!=</operator> <name>errType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args1</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_copy</name><argument_list>(<argument><expr><name>args2</name></expr></argument>, <argument><expr><name>args1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>bufsize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>err</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>err</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>errType</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>







<macro><name>ArrayOf</name><argument_list>(<argument>Dictionary</argument>)</argument_list></macro> <macro><name>keymap_array</name><argument_list>(<argument>String mode</argument>, <argument>buf_T *buf</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name>Array</name></type> <name>mappings</name> <init>= <expr><name>ARRAY_DICT_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>mode</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>int_mode</name> <init>= <expr><call><name>get_map_mode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>long</name></type> <name>buffer_value</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>buf</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>buf</name><operator>-&gt;</operator><name>handle</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_MAPHASH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>mapblock_T</name> <modifier>*</modifier></type><name>current_maphash</name> <init>= <expr><call><name>get_maphash</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
<condition><expr><name>current_maphash</name></expr>;</condition>
<incr><expr><name>current_maphash</name> <operator>=</operator> <name><name>current_maphash</name><operator>-&gt;</operator><name>m_next</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>int_mode</name> <operator>&amp;</operator> <name><name>current_maphash</name><operator>-&gt;</operator><name>m_mode</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mapblock_fill_dict</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>current_maphash</name></expr></argument>, <argument><expr><name>buffer_value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>ADD</name><argument_list>(<argument>mappings</argument>, <argument>vim_to_object(
(typval_T[]) { { .v_type = VAR_DICT, .vval.v_dict = dict } })</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>tv_dict_clear</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>tv_dict_free</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mappings</name></expr>;</return>
</block_content>}</block>


<function><type><name>bool</name></type> <name>ns_initialized</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ns</name> <operator>&lt;</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>next_namespace_id</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>bool</name></type> <name>extmark_get_index_from_obj</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Integer</name></type> <name>ns_id</name></decl></parameter>, <parameter><decl><type><name>Object</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name>
<modifier>*</modifier></type><name>row</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name> <modifier>*</modifier></type><name>col</name></decl></parameter>, <parameter><decl><type><name>Error</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeInteger</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Integer</name></type> <name>id</name> <init>= <expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>row</name> <operator>=</operator> <name>MAXLNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <name>MAXCOL</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"Mark id must be positive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ExtmarkInfo</name></type> <name>extmark</name> <init>= <expr><call><name>extmark_from_id</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>ns_id</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>extmark</name><operator>.</operator><name>row</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>row</name> <operator>=</operator> <name><name>extmark</name><operator>.</operator><name>row</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <name><name>extmark</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>, <argument><expr><literal type="string">"No mark with requested id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>


</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kObjectTypeArray</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Array</name></type> <name>pos</name> <init>= <expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>array</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">2</literal>
<operator>||</operator> <name><name>pos</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>kObjectTypeInteger</name>
<operator>||</operator> <name><name>pos</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>kObjectTypeInteger</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Position must have 2 integer elements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>Integer</name></type> <name>pos_row</name> <init>= <expr><name><name>pos</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>integer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Integer</name></type> <name>pos_col</name> <init>= <expr><name><name>pos</name><operator>.</operator><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>integer</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>row</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>pos_row</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>pos_row</name></expr> </then><else>: <expr><name>MAXLNUM</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>col</name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>pos_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>pos_col</name></expr> </then><else>: <expr><name>MAXCOL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>api_set_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>kErrorTypeValidation</name></expr></argument>,
<argument><expr><literal type="string">"Position must be a mark id Integer or position Array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
