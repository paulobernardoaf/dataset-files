<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\shada.c">


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;msgpack.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uv.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/pos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/shada.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/globals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mark.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/macros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/msgpack_rpc/helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/private/defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/api/private/helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_docmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_getln.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/search.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/quickfix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/encode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/decode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/khash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/kvec.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BE64TOH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BSD_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> ENDIAN_INCLUDE_FILE</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ARCH_32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>KHASH_SET_INIT_INT</name><argument_list>(<argument>bufset</argument>)</argument_list></macro>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ARCH_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<macro><name>KHASH_SET_INIT_INT64</name><argument_list>(<argument>bufset</argument>)</argument_list></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> Not a 64- or 32-bit architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>KHASH_MAP_INIT_STR</name><argument_list>(<argument>fnamebufs</argument>, <argument>buf_T *</argument>)</argument_list></macro>
<macro><name>KHASH_SET_INIT_STR</name><argument_list>(<argument>strset</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>copy_option_part</name><parameter_list>(<parameter><type><name>src</name></type></parameter>, <parameter><type><name>dest</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *) copy_option_part((char_u **) src, (char_u *) dest, __VA_ARGS__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>find_shada_parameter</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((const char *) find_shada_parameter(__VA_ARGS__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>home_replace_save</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)home_replace_save(a, (char_u *)b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>home_replace</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>home_replace(a, (char_u *)b, (char_u *)c, d, e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vim_rename</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vim_rename((char_u *)a, (char_u *)b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mb_strnicmp</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(mb_strnicmp((char_u *)a, (char_u *)b, c))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>path_try_shorten_fname</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)path_try_shorten_fname((char_u *)b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>buflist_new</name><parameter_list>(<parameter><type><name>ffname</name></type></parameter>, <parameter><type><name>sfname</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(buflist_new((char_u *)ffname, (char_u *)sfname, __VA_ARGS__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>os_isdir</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(os_isdir((char_u *) f))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>regtilde</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *) regtilde((char_u *) s, m))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>path_tail_with_sep</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *) path_tail_with_sep((char_u *)f))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_MAGIC</name></cpp:macro> <cpp:value>"sm"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_SMARTCASE</name></cpp:macro> <cpp:value>"sc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_HAS_LINE_OFFSET</name></cpp:macro> <cpp:value>"sl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_PLACE_CURSOR_AT_END</name></cpp:macro> <cpp:value>"se"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_IS_LAST_USED</name></cpp:macro> <cpp:value>"su"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_IS_SUBSTITUTE_PATTERN</name></cpp:macro> <cpp:value>"ss"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_HIGHLIGHTED</name></cpp:macro> <cpp:value>"sh"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_OFFSET</name></cpp:macro> <cpp:value>"so"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_PAT</name></cpp:macro> <cpp:value>"sp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEARCH_KEY_BACKWARD</name></cpp:macro> <cpp:value>"sb"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_KEY_TYPE</name></cpp:macro> <cpp:value>"rt"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_KEY_WIDTH</name></cpp:macro> <cpp:value>"rw"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_KEY_CONTENTS</name></cpp:macro> <cpp:value>"rc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_KEY_UNNAMED</name></cpp:macro> <cpp:value>"ru"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_LNUM</name></cpp:macro> <cpp:value>"l"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_COL</name></cpp:macro> <cpp:value>"c"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_FILE</name></cpp:macro> <cpp:value>"f"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_NAME_CHAR</name></cpp:macro> <cpp:value>"n"</cpp:value></cpp:define>


























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RERR</name></cpp:macro> <cpp:value>"E575: "</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RCERR</name></cpp:macro> <cpp:value>"E576: "</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERR</name></cpp:macro> <cpp:value>"E886: "</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RNERR</name></cpp:macro> <cpp:value>"E136: "</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WERR</name></cpp:macro> <cpp:value>"E574: "</cpp:value></cpp:define>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>SearchPatternGetter</name>)<parameter_list>(<parameter><decl><type><name>SearchPattern</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>






<typedef>typedef <type><enum>enum <block>{
<decl><name>kSDItemUnknown</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, 
<decl><name>kSDItemMissing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>kSDItemHeader</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>kSDItemSearchPattern</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, 


<decl><name>kSDItemSubString</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>, 
<decl><name>kSDItemHistoryEntry</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>, 
<decl><name>kSDItemRegister</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>, 
<decl><name>kSDItemVariable</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>, 
<decl><name>kSDItemGlobalMark</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>, 
<decl><name>kSDItemJump</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>, 
<decl><name>kSDItemBufferList</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>, 
<decl><name>kSDItemLocalMark</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>, 
<decl><name>kSDItemChange</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>, 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHADA_LAST_ENTRY</name></cpp:macro> <cpp:value>((uint64_t) kSDItemChange)</cpp:value></cpp:define>
}</block></enum></type> <name>ShadaEntryType</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>kSDReadStatusSuccess</name></decl>, 
<decl><name>kSDReadStatusFinished</name></decl>, 
<decl><name>kSDReadStatusReadError</name></decl>, 
<decl><name>kSDReadStatusNotShaDa</name></decl>, 
<decl><name>kSDReadStatusMalformed</name></decl>, 
}</block></enum></type> <name>ShaDaReadResult</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>kSDWriteSuccessfull</name></decl>, 
<decl><name>kSDWriteReadNotShada</name></decl>, 


<decl><name>kSDWriteFailed</name></decl>, 

<decl><name>kSDWriteIgnError</name></decl>, 


}</block></enum></type> <name>ShaDaWriteResult</name>;</typedef>


<enum>enum <name>SRNIFlags</name> <block>{
<decl><name>kSDReadHeader</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemHeader</name><operator>)</operator></expr></init></decl>, 

<decl><name>kSDReadUndisableableData</name> <init>= <expr><operator>(</operator>
<operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemSearchPattern</name><operator>)</operator>
<operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemSubString</name><operator>)</operator>
<operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemJump</name><operator>)</operator><operator>)</operator></expr></init></decl>, 


<decl><name>kSDReadRegisters</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemRegister</name><operator>)</operator></expr></init></decl>, 



<decl><name>kSDReadHistory</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemHistoryEntry</name><operator>)</operator></expr></init></decl>, 


<decl><name>kSDReadVariables</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemVariable</name><operator>)</operator></expr></init></decl>, 


<decl><name>kSDReadBufferList</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemBufferList</name><operator>)</operator></expr></init></decl>, 



<decl><name>kSDReadUnknown</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>SHADA_LAST_ENTRY</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>, 


<decl><name>kSDReadGlobalMarks</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemGlobalMark</name><operator>)</operator></expr></init></decl>, 




<decl><name>kSDReadLocalMarks</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemLocalMark</name><operator>)</operator></expr></init></decl>, 





<decl><name>kSDReadChanges</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>kSDItemChange</name><operator>)</operator></expr></init></decl>, 



}</block>;</enum>




<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ShadaEntryType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>Dictionary</name></type> <name>header</name></decl>;</decl_stmt>
<struct>struct <name>shada_filemark</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name></type> <name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>additional_data</name></decl>;</decl_stmt>
}</block> <decl><name>filemark</name></decl>;</struct>
<struct>struct <name>search_pattern</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>magic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>smartcase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>has_line_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>place_cursor_at_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_last_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_substitute_pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>highlighted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>search_backward</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>additional_data</name></decl>;</decl_stmt>
}</block> <decl><name>search_pattern</name></decl>;</struct>
<struct>struct <name>history_item</name> <block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name>histtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>additional_elements</name></decl>;</decl_stmt>
}</block> <decl><name>history_item</name></decl>;</struct>
<struct>struct <name>reg</name> <block>{ 
<decl_stmt><decl><type><name>char</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MotionType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_unnamed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>contents_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>additional_data</name></decl>;</decl_stmt>
}</block> <decl><name>reg</name></decl>;</struct>
<struct>struct <name>global_var</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>typval_T</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>additional_elements</name></decl>;</decl_stmt>
}</block> <decl><name>global_var</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block> <decl><name>unknown_item</name></decl>;</struct>
<struct>struct <name>sub_string</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>additional_elements</name></decl>;</decl_stmt>
}</block> <decl><name>sub_string</name></decl>;</struct>
<struct>struct <name>buffer_list</name> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<struct>struct <name>buffer_list_buffer</name> <block>{
<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>additional_data</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier><name>buffers</name></decl>;</struct>
}</block> <decl><name>buffer_list</name></decl>;</struct>
}</block> <decl><name>data</name></decl>;</union>
}</block></struct></type> <name>ShadaEntry</name>;</typedef>

<struct_decl>struct <name>hm_llist_entry</name>;</struct_decl>


<typedef>typedef <type><struct>struct <name>hm_llist_entry</name> <block>{
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>data</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>can_free_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>hm_llist_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>hm_llist_entry</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt> 
}</block></struct></type> <name>HMLListEntry</name>;</typedef>

<macro><name>KHASH_MAP_INIT_STR</name><argument_list>(<argument>hmll_entries</argument>, <argument>HMLListEntry *</argument>)</argument_list></macro>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>first</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>free_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>last_free_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>num_entries</name></decl>;</decl_stmt> 
<macro><name>khash_t</name><argument_list>(<argument>hmll_entries</argument>)</argument_list></macro> <expr_stmt><expr><name>contained_entries</name></expr>;</expr_stmt> 


}</block></struct></type> <name>HMLList</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>HMLList</name></type> <name>hmll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>do_merge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>reading</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>last_hist_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>history_type</name></decl>;</decl_stmt>
}</block></struct></type> <name>HistoryMergerState</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>data</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>can_free_entry</name></decl>;</decl_stmt> 
}</block></struct></type> <name>PossiblyFreedShadaEntry</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>marks</name><index>[<expr><name>NLOCALMARKS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>changes</name><index>[<expr><name>JUMPLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>changes_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ShadaEntry</name> <modifier>*</modifier></type><name>additional_marks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>additional_marks_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Timestamp</name></type> <name>greatest_timestamp</name></decl>;</decl_stmt> 
}</block></struct></type> <name>FileMarks</name>;</typedef>

<macro><name>KHASH_MAP_INIT_STR</name><argument_list>(<argument>file_marks</argument>, <argument>FileMarks</argument>)</argument_list></macro>




<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>HistoryMergerState</name></type> <name><name>hms</name><index>[<expr><name>HIST_COUNT</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>global_marks</name><index>[<expr><name>NMARKS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>numbered_marks</name><index>[<expr><name>EXTRA_MARKS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>registers</name><index>[<expr><name>NUM_SAVED_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>jumps</name><index>[<expr><name>JUMPLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>jumps_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name>search_pattern</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name>sub_search_pattern</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name>replacement</name></decl>;</decl_stmt> 
<macro><name>khash_t</name><argument_list>(<argument>strset</argument>)</argument_list></macro> <expr_stmt><expr><name>dumped_variables</name></expr>;</expr_stmt> 
<macro><name>khash_t</name><argument_list>(<argument>file_marks</argument>)</argument_list></macro> <expr_stmt><expr><name>file_marks</name></expr>;</expr_stmt> 
}</block></struct></type> <name>WriteMergerState</name>;</typedef>

<struct_decl>struct <name>sd_read_def</name>;</struct_decl>


<typedef>typedef <macro><name>void</name> <argument_list>(<argument>*ShaDaReadCloser</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <name>sd_read_def</name> <operator>*</operator><specifier>const</specifier> <name>sd_reader</name><operator>)</operator>
<name>REAL_FATTR_NONNULL_ALL</name></expr>;</expr_stmt></typedef>


<typedef>typedef <macro><name>ptrdiff_t</name> <argument_list>(<argument>*ShaDaFileReader</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <name>sd_read_def</name> <operator>*</operator><specifier>const</specifier> <name>sd_reader</name><operator>,</operator>
<name>void</name> <operator>*</operator><specifier>const</specifier> <name>dest</name><operator>,</operator>
<specifier>const</specifier> <name>size_t</name> <name>size</name><operator>)</operator>
<name>REAL_FATTR_NONNULL_ALL</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></expr>;</expr_stmt></typedef>


<typedef>typedef <macro><name>int</name> <argument_list>(<argument>*ShaDaFileSkipper</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <name>sd_read_def</name> <operator>*</operator><specifier>const</specifier> <name>sd_reader</name><operator>,</operator>
<specifier>const</specifier> <name>size_t</name> <name>offset</name><operator>)</operator>
<name>REAL_FATTR_NONNULL_ALL</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></expr>;</expr_stmt></typedef>


<typedef>typedef <type><struct>struct <name>sd_read_def</name> <block>{
<decl_stmt><decl><type><name>ShaDaFileReader</name></type> <name>read</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ShaDaReadCloser</name></type> <name>close</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ShaDaFileSkipper</name></type> <name>skip</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>eof</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>fpos</name></decl>;</decl_stmt> 

}</block></struct></type> <name>ShaDaReadDef</name>;</typedef>

<struct_decl>struct <name>sd_write_def</name>;</struct_decl>


<typedef>typedef <macro><name>void</name> <argument_list>(<argument>*ShaDaWriteCloser</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <name>sd_write_def</name> <operator>*</operator><specifier>const</specifier> <name>sd_writer</name><operator>)</operator>
<name>REAL_FATTR_NONNULL_ALL</name></expr>;</expr_stmt></typedef>


<typedef>typedef <macro><name>ptrdiff_t</name> <argument_list>(<argument>*ShaDaFileWriter</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <name>sd_write_def</name> <operator>*</operator><specifier>const</specifier> <name>sd_writer</name><operator>,</operator>
<specifier>const</specifier> <name>void</name> <operator>*</operator><specifier>const</specifier> <name>src</name><operator>,</operator>
<specifier>const</specifier> <name>size_t</name> <name>size</name><operator>)</operator>
<name>REAL_FATTR_NONNULL_ALL</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></expr>;</expr_stmt></typedef>


<typedef>typedef <type><struct>struct <name>sd_write_def</name> <block>{
<decl_stmt><decl><type><name>ShaDaFileWriter</name></type> <name>write</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ShaDaWriteCloser</name></type> <name>close</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt> 
}</block></struct></type> <name>ShaDaWriteDef</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shada.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_SDE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>[kSDItem##name] = { .timestamp = 0, .type = kSDItem##name, .data = { .attr = { __VA_ARGS__ } } }</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_POS</name></cpp:macro> <cpp:value>{ 1, 0, 0 }</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>pos_T</name></type> <name>default_pos</name> <init>= <expr><name>DEFAULT_POS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ShadaEntry</name></type> <name><name>sd_default_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>kSDItemMissing</name></expr>]</index> <operator>=</operator> <block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemMissing</name></expr>, <expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>Header</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>SearchPattern</name></expr></argument>, <argument><expr><name>search_pattern</name></expr></argument>,
<argument><expr><operator>.</operator><name>magic</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><operator>.</operator><name>smartcase</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>has_line_offset</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>place_cursor_at_end</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><operator>.</operator><name>is_last_used</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><operator>.</operator><name>is_substitute_pattern</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>highlighted</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>search_backward</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>pat</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>SubString</name></expr></argument>, <argument><expr><name>sub_string</name></expr></argument>, <argument><expr><operator>.</operator><name>sub</name> <operator>=</operator> <name>NULL</name></expr></argument>, <argument><expr><operator>.</operator><name>additional_elements</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>HistoryEntry</name></expr></argument>, <argument><expr><name>history_item</name></expr></argument>,
<argument><expr><operator>.</operator><name>histtype</name> <operator>=</operator> <name>HIST_CMD</name></expr></argument>,
<argument><expr><operator>.</operator><name>string</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>sep</name> <operator>=</operator> <name>NUL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_elements</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>Register</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>,
<argument><expr><operator>.</operator><name>name</name> <operator>=</operator> <name>NUL</name></expr></argument>,
<argument><expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kMTCharWise</name></expr></argument>,
<argument><expr><operator>.</operator><name>contents</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>contents_size</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><operator>.</operator><name>is_unnamed</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><operator>.</operator><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<macro><name>DEF_SDE</name><argument_list>(<argument>Variable</argument>, <argument>global_var</argument>,
<argument>.name = NULL</argument>,
<argument>.value = {
.v_type = VAR_UNKNOWN</argument>,
<argument>.vval = { .v_string = NULL }
}</argument>,
<argument>.additional_elements = NULL</argument>)</argument_list></macro>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>GlobalMark</name></expr></argument>, <argument><expr><name>filemark</name></expr></argument>,
<argument><expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="char">'"'</literal></expr></argument>,
<argument><expr><operator>.</operator><name>mark</name> <operator>=</operator> <name>DEFAULT_POS</name></expr></argument>,
<argument><expr><operator>.</operator><name>fname</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>Jump</name></expr></argument>, <argument><expr><name>filemark</name></expr></argument>,
<argument><expr><operator>.</operator><name>name</name> <operator>=</operator> <name>NUL</name></expr></argument>,
<argument><expr><operator>.</operator><name>mark</name> <operator>=</operator> <name>DEFAULT_POS</name></expr></argument>,
<argument><expr><operator>.</operator><name>fname</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>BufferList</name></expr></argument>, <argument><expr><name>buffer_list</name></expr></argument>,
<argument><expr><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><operator>.</operator><name>buffers</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>LocalMark</name></expr></argument>, <argument><expr><name>filemark</name></expr></argument>,
<argument><expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="char">'"'</literal></expr></argument>,
<argument><expr><operator>.</operator><name>mark</name> <operator>=</operator> <name>DEFAULT_POS</name></expr></argument>,
<argument><expr><operator>.</operator><name>fname</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DEF_SDE</name><argument_list>(<argument><expr><name>Change</name></expr></argument>, <argument><expr><name>filemark</name></expr></argument>,
<argument><expr><operator>.</operator><name>name</name> <operator>=</operator> <name>NUL</name></expr></argument>,
<argument><expr><operator>.</operator><name>mark</name> <operator>=</operator> <name>DEFAULT_POS</name></expr></argument>,
<argument><expr><operator>.</operator><name>fname</name> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFAULT_POS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_SDE</name></cpp:undef>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hmll_init</name><parameter_list>(<parameter><decl><type><name>HMLList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>hmll</name> <operator>=</operator> <operator>(</operator><name>HMLList</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>entries</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hmll</name><operator>-&gt;</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>first</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>last</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>free_entry</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>size</name></expr>,
<expr><operator>.</operator><name>num_entries</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>contained_entries</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>)</argument_list></call></expr>,
}</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name> <operator>=</operator> <name><name>hmll</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
</block_content>}</block></function>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HMLL_FORALL</name><parameter_list>(<parameter><type><name>hmll</name></type></parameter>, <parameter><type><name>cur_entry</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (HMLListEntry *cur_entry = (hmll)-&gt;first; cur_entry != NULL; cur_entry = cur_entry-&gt;next) { code }</cpp:value></cpp:define> 









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hmll_remove</name><parameter_list>(<parameter><decl><type><name>HMLList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll</name></decl></parameter>,
<parameter><decl><type><name>HMLListEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll_entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>hmll_entry</name> <operator>==</operator> <name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>hmll</name><operator>-&gt;</operator><name>free_entry</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>free_entry</name></name> <operator>=</operator> <name>hmll_entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>khiter_t</name></type> <name>k</name> <init>= <expr><call><name>kh_get</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>,
<argument><expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>k</name> <operator>!=</operator> <call><name>kh_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kh_del</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>hmll_entry</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>hmll_entry</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>num_entries</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>can_free_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll_entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hmll_insert</name><parameter_list>(<parameter><decl><type><name>HMLList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll</name></decl></parameter>,
<parameter><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>hmll_entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ShadaEntry</name></type> <name>data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>can_free_entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>hmll</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <name><name>hmll</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>hmll_entry</name> <operator>==</operator> <name><name>hmll</name><operator>-&gt;</operator><name>first</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hmll_entry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>hmll</name><operator>-&gt;</operator><name>first</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hmll_remove</name><argument_list>(<argument><expr><name>hmll</name></expr></argument>, <argument><expr><name><name>hmll</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>target_entry</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hmll</name><operator>-&gt;</operator><name>free_entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name> <operator>-</operator> <name><name>hmll</name><operator>-&gt;</operator><name>entries</name></name><operator>)</operator>
<operator>==</operator> <name><name>hmll</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>target_entry</name> <operator>=</operator> <name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>hmll</name><operator>-&gt;</operator><name>last_free_entry</name></name> <operator>-</operator> <name><name>hmll</name><operator>-&gt;</operator><name>entries</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal>
<operator>==</operator> <name><name>hmll</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>target_entry</name> <operator>=</operator> <name><name>hmll</name><operator>-&gt;</operator><name>free_entry</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>free_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>can_free_entry</name></name> <operator>=</operator> <name>can_free_entry</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>khiter_t</name></type> <name>k</name> <init>= <expr><call><name>kh_put</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kh_ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kh_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>target_entry</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>hmll_entry</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hmll_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hmll</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>target_entry</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hmll_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>target_entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>target_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hmll</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name>target_entry</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>target_entry</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>target_entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HMLL_ITER_BACK</name><parameter_list>(<parameter><type><name>hmll</name></type></parameter>, <parameter><type><name>cur_entry</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (cur_entry = (hmll)-&gt;last; cur_entry != NULL; cur_entry = cur_entry-&gt;prev) { code }</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hmll_dealloc</name><parameter_list>(<parameter><decl><type><name>HMLList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>hmll</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>read_file</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dest</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>ret</name> <init>= <expr><call><name>file_read</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <call><name>file_eof</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>os_strerror</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>ret</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_char</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>read_bytes</name> <init>= <expr><call><name><name>sd_reader</name><operator>-&gt;</operator><name>read</name></name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>read_bytes</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>ret</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>write_file</name><parameter_list>(<parameter><decl><type><name>ShaDaWriteDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_writer</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dest</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>ret</name> <init>= <expr><call><name>file_write</name><argument_list>(<argument><expr><name><name>sd_writer</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_writer</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>os_strerror</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>close_sd_reader</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>close_sd_writer</name><parameter_list>(<parameter><decl><type><name>ShaDaWriteDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_writer</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name><name>sd_writer</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>sd_reader_skip_read</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>skip_bytes</name> <init>= <expr><call><name>file_skip</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_bytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>os_strerror</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>skip_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>skip_bytes</name> <operator>!=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skip_bytes</name> <operator>&lt;</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <call><name>file_eof</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"too few bytes read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>skip_bytes</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>ShaDaReadResult</name></type> <name>sd_reader_skip</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>sd_reader</name><operator>-&gt;</operator><name>skip</name></name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while skipping in ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusReadError</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"last entry specified that it occupies %"</literal> <name>PRIu64</name> <literal type="string">" bytes, "</literal>
<literal type="string">"but file ended earlier"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>kSDReadStatusSuccess</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>open_shada_file_for_reading</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name></decl></parameter>,
<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier></type><name>sd_reader</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>sd_reader</name> <operator>=</operator> <operator>(</operator><name>ShaDaReadDef</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>read</name> <operator>=</operator> <operator>&amp;</operator><name>read_file</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <operator>&amp;</operator><name>close_sd_reader</name></expr>,
<expr><operator>.</operator><name>skip</name> <operator>=</operator> <operator>&amp;</operator><name>sd_reader_skip_read</name></expr>,
<expr><operator>.</operator><name>error</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>eof</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>fpos</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>cookie</name> <operator>=</operator> <call><name>file_open_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>kFileReadOnly</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p_enc</name></expr></argument>, <argument><expr><literal type="string">"utf-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>close_file</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>error</name> <init>= <expr><call><name>file_free</name><argument_list>(<argument><expr><name>cookie</name></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name>p_fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while closing ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>in_bufset</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>khash_t</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>set</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>buf_T</name> <operator>*</operator><name>buf</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_PURE</name>
<block>{<block_content>
<return>return <expr><call><name>kh_get</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>, <argument><expr><name>set</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>kh_end</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>in_strset</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>khash_t</name><argument_list>(<argument><expr><name>strset</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>set</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>str</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_PURE</name>
<block>{<block_content>
<return>return <expr><call><name>kh_get</name><argument_list>(<argument><expr><name>strset</name></expr></argument>, <argument><expr><name>set</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>kh_end</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type> <name>msgpack_sd_writer_write</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaWriteDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_writer</name> <init>= <expr><operator>(</operator><name>ShaDaWriteDef</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>written_bytes</name> <init>= <expr><call><name><name>sd_writer</name><operator>-&gt;</operator><name>write</name></name><argument_list>(<argument><expr><name>sd_writer</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>written_bytes</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while writing ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sd_writer</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>bool</name></type> <name>shada_disabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE
<block>{<block_content>
<return>return <expr><call><name>strequal</name><argument_list>(<argument><expr><name>p_shadafile</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>shada_read_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_disabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name> <init>= <expr><call><name>shada_filename</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ShaDaReadDef</name></type> <name>sd_reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>of_ret</name> <init>= <expr><call><name>open_shada_file_for_reading</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading ShaDa file \"%s\"%s%s%s%s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kShaDaWantInfo</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" info"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kShaDaWantMarks</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" marks"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kShaDaGetOldfiles</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" oldfiles"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>of_ret</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" FAILED"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>of_ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>of_ret</name> <operator>!=</operator> <name>UV_ENOENT</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kShaDaMissingError</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while opening ShaDa file %s for reading: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>of_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>shada_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>sd_reader</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>shada_hist_iter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>iter</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>history_type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>zero</name></decl></parameter>,
<parameter><decl><type><name>ShadaEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hist</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>4</function>) <macro><name>FUNC_ATTR_WARN_UNUSED_RESULT</name></macro>
<block>{<block_content>
<decl_stmt><decl><type><name>histentry_T</name></type> <name>hist_he</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>hist_iter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>history_type</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hist_he</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hist_he</name><operator>.</operator><name>hisstr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>hist</name> <operator>=</operator> <operator>(</operator><name>ShadaEntry</name><operator>)</operator> <block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemMissing</name></expr> }</block></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>hist</name> <operator>=</operator> <operator>(</operator><name>ShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemHistoryEntry</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>hist_he</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>history_item</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>histtype</name> <operator>=</operator> <name>history_type</name></expr>,
<expr><operator>.</operator><name>string</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>hist_he</name><operator>.</operator><name>hisstr</name></name></expr>,
<expr><operator>.</operator><name>sep</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>(</operator><name>history_type</name> <operator>==</operator> <name>HIST_SEARCH</name>
<operator>?</operator> <operator>(</operator><name>char</name><operator>)</operator> <name><name>hist_he</name><operator>.</operator><name>hisstr</name><index>[<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hist_he</name><operator>.</operator><name>hisstr</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name>
<operator>:</operator> <literal type="number">0</literal><operator>)</operator></expr>,
<expr><operator>.</operator><name>additional_elements</name> <operator>=</operator> <name><name>hist_he</name><operator>.</operator><name>additional_elements</name></name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>
















<function><type><specifier>static</specifier> <name>void</name></type> <name>hms_insert</name><parameter_list>(<parameter><decl><type><name>HistoryMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hms_p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ShadaEntry</name></type> <name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>do_iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>can_free_entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>do_iter</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kSDItemMissing</name>
<operator>&amp;&amp;</operator> <name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name><operator>.</operator><name>timestamp</name></name> <operator>&lt;</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hms_insert</name><argument_list>(<argument><expr><name>hms_p</name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>kSDItemMissing</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>shada_hist_iter</name><argument_list>(<argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>history_type</name></name></expr></argument>,
<argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HMLList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hmll</name> <init>= <expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>hmll</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>khiter_t</name></type> <name>k</name> <init>= <expr><call><name>kh_get</name><argument_list>(<argument><expr><name>hmll_entries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>hmll</name><operator>.</operator><name>contained_entries</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <call><name>kh_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>existing_entry</name> <init>= <expr><call><name>kh_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;</operator> <name><name>existing_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hmll_remove</name><argument_list>(<argument><expr><name>hmll</name></expr></argument>, <argument><expr><name>existing_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>do_iter</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name> <operator>==</operator> <name><name>existing_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>existing_entry</name><operator>-&gt;</operator><name>can_free_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>existing_entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>existing_entry</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>existing_entry</name><operator>-&gt;</operator><name>can_free_entry</name></name> <operator>=</operator> <name>can_free_entry</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>kh_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmll</name><operator>-&gt;</operator><name>contained_entries</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HMLListEntry</name> <modifier>*</modifier></type><name>insert_after</name></decl>;</decl_stmt>
<macro><name>HMLL_ITER_BACK</name><argument_list>(<argument>hmll</argument>, <argument>insert_after</argument>, <argument>{
if (insert_after-&gt;data.timestamp &lt;= entry.timestamp) {
break;
}
}</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>hmll_insert</name><argument_list>(<argument><expr><name>hmll</name></expr></argument>, <argument><expr><name>insert_after</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>can_free_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hms_init</name><parameter_list>(<parameter><decl><type><name>HistoryMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hms_p</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>history_type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_elements</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>do_merge</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>reading</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>hmll_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>hmll</name></name></expr></argument>, <argument><expr><name>num_elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>do_merge</name></name> <operator>=</operator> <name>do_merge</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name> <operator>=</operator> <name>reading</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>shada_hist_iter</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>history_type</name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>history_type</name></name> <operator>=</operator> <name>history_type</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hms_insert_whole_neovim_history</name><parameter_list>(
<parameter><decl><type><name>HistoryMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hms_p</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<while>while <condition>(<expr><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kSDItemMissing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hms_insert</name><argument_list>(<argument><expr><name>hms_p</name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>shada_hist_iter</name><argument_list>(<argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>history_type</name></name></expr></argument>,
<argument><expr><name><name>hms_p</name><operator>-&gt;</operator><name>reading</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>last_hist_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hms_to_he_array</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HistoryMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hms_p</name></decl></parameter>,
<parameter><decl><type><name>histentry_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hist_array</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>new_hisidx</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>new_hisnum</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>histentry_T</name> <modifier>*</modifier></type><name>hist</name> <init>= <expr><name>hist_array</name></expr></init></decl>;</decl_stmt>
<macro><name>HMLL_FORALL</name><argument_list>(<argument>&amp;hms_p-&gt;hmll</argument>, <argument>cur_entry</argument>, <argument>{
hist-&gt;timestamp = cur_entry-&gt;data.timestamp;
hist-&gt;hisnum = (int) (hist - hist_array) + <literal type="number">1</literal>;
hist-&gt;hisstr = (char_u *) cur_entry-&gt;data.data.history_item.string;
hist-&gt;additional_elements =
cur_entry-&gt;data.data.history_item.additional_elements;
hist++;
}</argument>)</argument_list></macro>
<expr_stmt><expr><operator>*</operator><name>new_hisnum</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>hist</name> <operator>-</operator> <name>hist_array</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_hisidx</name> <operator>=</operator> <operator>*</operator><name>new_hisnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>hms_dealloc</name><parameter_list>(<parameter><decl><type><name>HistoryMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hms_p</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>hmll_dealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms_p</name><operator>-&gt;</operator><name>hmll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HMS_ITER</name><parameter_list>(<parameter><type><name>hms_p</name></type></parameter>, <parameter><type><name>cur_entry</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HMLL_FORALL(&amp;((hms_p)-&gt;hmll), cur_entry, code)</cpp:value></cpp:define>








<decl_stmt><decl><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type><name>find_buffer</name><argument_list>(<argument><expr><call><name>khash_t</name><argument_list>(<argument><expr><name>fnamebufs</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>fname_bufs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <name>fname</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_NONNULL_ALL</name>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>khint_t</name></type> <name>k</name> <init>= <expr><call><name>kh_put</name><argument_list>(<argument><expr><name>fnamebufs</name></expr></argument>, <argument><expr><name>fname_bufs</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kh_ret</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>kh_val</name><argument_list>(<argument><expr><name>fname_bufs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>kh_key</name><argument_list>(<argument><expr><name>fname_bufs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fnamecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kh_val</name><argument_list>(<argument><expr><name>fname_bufs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>kh_val</name><argument_list>(<argument><expr><name>fname_bufs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>marks_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pos_T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pos_T</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>a</name><operator>.</operator><name>lnum</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>lnum</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>a</name><operator>.</operator><name>col</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>col</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE_JUMPS</name><parameter_list>(<parameter><type><name>jumps_size</name></type></parameter>, <parameter><type><name>jumps</name></type></parameter>, <parameter><type><name>jumps_type</name></type></parameter>, <parameter><type><name>timestamp_attr</name></type></parameter>, <parameter><type><name>mark_attr</name></type></parameter>, <parameter><type><name>entry</name></type></parameter>, <parameter><type><name>fname_cond</name></type></parameter>, <parameter><type><name>free_func</name></type></parameter>, <parameter><type><name>fin_func</name></type></parameter>, <parameter><type><name>idxadj_func</name></type></parameter>, <parameter><type><name>afterfree_func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const int jl_len = (int) jumps_size; int i; for (i = jl_len; i &gt; 0; i--) { const jumps_type jl_entry = jumps[i - 1]; if (jl_entry.timestamp_attr &lt;= entry.timestamp) { if (marks_equal(jl_entry.mark_attr, entry.data.filemark.mark) &amp;&amp; fname_cond) { i = -1; } break; } } if (i &gt; 0) { if (jl_len == JUMPLISTSIZE) { free_func(jumps[0]); i--; if (i &gt; 0) { memmove(&amp;jumps[0], &amp;jumps[1], sizeof(jumps[1]) * (size_t) i); } } else if (i != jl_len) { memmove(&amp;jumps[i + 1], &amp;jumps[i], sizeof(jumps[0]) * (size_t) (jl_len - i)); } } else if (i == 0) { if (jl_len == JUMPLISTSIZE) { i = -1; } else if (jl_len &gt; 0) { memmove(&amp;jumps[1], &amp;jumps[0], sizeof(jumps[0]) * (size_t) jl_len); } } if (i != -1) { jumps[i] = fin_func(entry); if (jl_len &lt; JUMPLISTSIZE) { jumps_size++; } idxadj_func(i); } else { shada_free_shada_entry(&amp;entry); afterfree_func(entry); } } while (0)</cpp:value></cpp:define>

















































<function><type><specifier>static</specifier> <name>void</name></type> <name>shada_read</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>oldfiles_list</name> <init>= <expr><call><name>get_vim_var_list</name><argument_list>(<argument><expr><name>VV_OLDFILES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>force</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>kShaDaForceit</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>get_old_files</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>kShaDaGetOldfiles</name> <operator>|</operator> <name>kShaDaForceit</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>force</name> <operator>||</operator> <call><name>tv_list_len</name><argument_list>(<argument><expr><name>oldfiles_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>want_marks</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>kShaDaWantMarks</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>srni_flags</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <operator>(</operator>
<operator>(</operator><ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>kShaDaWantInfo</name></expr>
?</condition><then> <expr><operator>(</operator><name>kSDReadUndisableableData</name>
<operator>|</operator> <name>kSDReadRegisters</name>
<operator>|</operator> <name>kSDReadGlobalMarks</name>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>p_hi</name></expr> ?</condition><then> <expr><name>kSDReadHistory</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'!'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>
?</condition><then> <expr><name>kSDReadVariables</name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name>ARGCOUNT</name> <operator>==</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name>kSDReadBufferList</name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>want_marks</name> <operator>&amp;&amp;</operator> <call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name>kSDReadLocalMarks</name> <operator>|</operator> <name>kSDReadChanges</name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>get_old_files</name></expr>
?</condition><then> <expr><name>kSDReadLocalMarks</name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>srni_flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HistoryMergerState</name></type> <name><name>hms</name><index>[<expr><name>HIST_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>srni_flags</name> <operator>&amp;</operator> <name>kSDReadHistory</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HIST_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>hms_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>p_hi</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>cur_entry</name></decl>;</decl_stmt>
<macro><name>khash_t</name><argument_list>(<argument>bufset</argument>)</argument_list></macro> <expr_stmt><expr><name>cl_bufs</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>khash_t</name><argument_list>(<argument>fnamebufs</argument>)</argument_list></macro> <expr_stmt><expr><name>fname_bufs</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>fnamebufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>khash_t</name><argument_list>(<argument>strset</argument>)</argument_list></macro> <expr_stmt><expr><name>oldfiles_set</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>strset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>get_old_files</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>oldfiles_list</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>force</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldfiles_list</name> <operator>=</operator> <call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>kListLenUnknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_vim_var_list</name><argument_list>(<argument><expr><name>VV_OLDFILES</name></expr></argument>, <argument><expr><name>oldfiles_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>srni_ret</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>srni_ret</name> <operator>=</operator> <call><name>shada_read_next_item</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>, <argument><expr><name>srni_flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusFinished</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>srni_ret</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDReadStatusSuccess</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusFinished</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusNotShaDa</name></expr>:</case>
<case>case <expr><name>kSDReadStatusReadError</name></expr>:</case> <block>{<block_content>
<goto>goto <name>shada_read_main_cycle_end</name>;</goto>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusMalformed</name></expr>:</case> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemMissing</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHeader</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SearchPattern</name></type> <name>pat</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><ternary><condition><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>is_substitute_pattern</name></name></expr>
?</condition><then> <expr><operator>&amp;</operator><name>get_substitute_pattern</name></expr>
</then><else>: <expr><operator>&amp;</operator><name>get_search_pattern</name></expr></else></ternary><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>pat</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pat</name><operator>.</operator><name>pat</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pat</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><ternary><condition><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>is_substitute_pattern</name></name></expr>
?</condition><then> <expr><operator>&amp;</operator><name>set_substitute_pattern</name></expr>
</then><else>: <expr><operator>&amp;</operator><name>set_search_pattern</name></expr></else></ternary><operator>)</operator><operator>(</operator><operator>(</operator><name>SearchPattern</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>magic</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>magic</name></name></expr>,
<expr><operator>.</operator><name>no_scs</name> <operator>=</operator> <operator>!</operator><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>smartcase</name></name></expr>,
<expr><operator>.</operator><name>off</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>dir</name> <operator>=</operator> <ternary><condition><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>search_backward</name></name></expr> ?</condition><then> <expr><literal type="char">'?'</literal></expr> </then><else>: <expr><literal type="char">'/'</literal></expr></else></ternary></expr>,
<expr><operator>.</operator><name>line</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>has_line_offset</name></name></expr>,
<expr><operator>.</operator><name>end</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>place_cursor_at_end</name></name></expr>,
<expr><operator>.</operator><name>off</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>offset</name></name></expr>,
}</block></expr>,
<expr><operator>.</operator><name>pat</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>pat</name></name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name></name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>,
}</block><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>is_last_used</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_last_used_pattern</name><argument_list>(
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>is_substitute_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_no_hlsearch</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>highlighted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SubReplacementString</name></type> <name>sub</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sub_get_replacement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sub</name><operator>.</operator><name>sub</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sub</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>sub_set_replacement</name><argument_list>(<argument>(SubReplacementString) {
.sub = cur_entry.data.sub_string.sub</argument>,
<argument>.timestamp = cur_entry.timestamp</argument>,
<argument>.additional_elements = cur_entry.data.sub_string.additional_elements</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>




<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>regtilde</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>sub</name></name></expr></argument>, <argument><expr><name>p_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name> <operator>&gt;=</operator> <name>HIST_COUNT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hms_insert</name><argument_list>(<argument><expr><name>hms</name> <operator>+</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name></expr></argument>, <argument><expr><name>cur_entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kMTCharWise</name>
<operator>&amp;&amp;</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kMTLineWise</name>
<operator>&amp;&amp;</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kMTBlockWise</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>yankreg_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>reg</name> <init>= <expr><call><name>op_reg_get</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>reg</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>&gt;=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><macro><name>op_reg_set</name><argument_list>(<argument>cur_entry.data.reg.name</argument>, <argument>(yankreg_T) {
.y_array = (char_u **)cur_entry.data.reg.contents</argument>,
<argument>.y_size = cur_entry.data.reg.contents_size</argument>,
<argument>.y_type = cur_entry.data.reg.type</argument>,
<argument>.y_width = (colnr_T) cur_entry.data.reg.width</argument>,
<argument>.timestamp = cur_entry.timestamp</argument>,
<argument>.additional_data = cur_entry.data.reg.additional_data</argument>,
<argument>}</argument>, <argument>cur_entry.data.reg.is_unnamed</argument>)</argument_list></macro></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>var_set_global</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>value</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemJump</name></expr>:</case>
<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>find_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fname_bufs</name></expr></argument>, <argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>xfmark_T</name></type> <name>fm</name> <init>= <expr><operator>(</operator><name>xfmark_T</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>buf</name> <operator>==</operator> <name>NULL</name>
<operator>?</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name>
<operator>:</operator> <name>NULL</name><operator>)</operator></expr>,
<expr><operator>.</operator><name>fmark</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>fnum</name> <operator>=</operator> <operator>(</operator><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_fnum</name></name><operator>)</operator></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name></expr>,
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemGlobalMark</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mark_set_global</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fm</name></expr></argument>, <argument><expr><operator>!</operator><name>force</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDE_TO_XFMARK</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fm</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADJUST_IDX</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (curwin-&gt;w_jumplistidx &gt;= i &amp;&amp; curwin-&gt;w_jumplistidx + 1 &lt;= curwin-&gt;w_jumplistlen) { curwin-&gt;w_jumplistidx++; }</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_AFTERFREE</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<expr_stmt><expr><call><name>MERGE_JUMPS</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_jumplistlen</name></name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_jumplist</name></name></expr></argument>, <argument><expr><name>xfmark_T</name></expr></argument>,
<argument><expr><name><name>fmark</name><operator>.</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>fmark</name><operator>.</operator><name>mark</name></name></expr></argument>, <argument><expr><name>cur_entry</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>
?</condition><then> <expr><operator>(</operator><name><name>jl_entry</name><operator>.</operator><name>fname</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>fm</name><operator>.</operator><name>fname</name></name></expr></argument>, <argument><expr><name><name>jl_entry</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>
</then><else>: <expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name> <operator>==</operator> <name><name>jl_entry</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name>free_xfmark</name></expr></argument>, <argument><expr><name>SDE_TO_XFMARK</name></expr></argument>, <argument><expr><name>ADJUST_IDX</name></expr></argument>, <argument><expr><name>DUMMY_AFTERFREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SDE_TO_XFMARK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADJUST_IDX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DUMMY_AFTERFREE</name></cpp:undef>
</block_content>}</block></else></if_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sfname</name> <init>= <expr><call><name>path_try_shorten_fname</name><argument_list>(
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name> <init>= <expr><call><name>buflist_new</name><argument_list>(
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fname</name></expr></argument>, <argument><expr><name>sfname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>BLN_LISTED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RESET_FMARK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>b_last_cursor</name></name></expr></argument>,
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>buflist_setfpos</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_last_cursor</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_last_cursor</name><operator>.</operator><name>mark</name><operator>.</operator><name>col</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>additional_data</name></name> <operator>=</operator>
<name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>get_old_files</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>in_strset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldfiles_set</name></expr></argument>,
<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>want_marks</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>kh_put</name><argument_list>(<argument><expr><name>strset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldfiles_set</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_append_allocated_string</name><argument_list>(<argument><expr><name>oldfiles_list</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>want_marks</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>want_marks</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>find_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fname_bufs</name></expr></argument>, <argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>fmark_T</name></type> <name>fm</name> <init>= <expr><operator>(</operator><name>fmark_T</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>fnum</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemLocalMark</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mark_set_local</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fm</name></expr></argument>, <argument><expr><operator>!</operator><name>force</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kh_put</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cl_bufs</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDE_TO_FMARK</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fm</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTERFREE</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(entry).data.filemark.fname = NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_IDX_ADJ</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<expr_stmt><expr><call><name>MERGE_JUMPS</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_changelistlen</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_changelist</name></name></expr></argument>, <argument><expr><name>fmark_T</name></expr></argument>,
<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name>cur_entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>free_fmark</name></expr></argument>, <argument><expr><name>SDE_TO_FMARK</name></expr></argument>, <argument><expr><name>DUMMY_IDX_ADJ</name></expr></argument>, <argument><expr><name>AFTERFREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SDE_TO_FMARK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>AFTERFREE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DUMMY_IDX_ADJ</name></cpp:undef>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>cur_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></while>
<label><name>shada_read_main_cycle_end</name>:</label>






<if_stmt><if>if <condition>(<expr><name>srni_flags</name> <operator>&amp;</operator> <name>kSDReadHistory</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HIST_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>hms_insert_whole_neovim_history</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clr_history</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>new_hisidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>new_hisnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>histentry_T</name> <modifier>*</modifier></type><name>hist</name> <init>= <expr><call><name>hist_get_array</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_hisidx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_hisnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>hist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hms_to_he_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>hist</name></expr></argument>, <argument><expr><name>new_hisidx</name></expr></argument>, <argument><expr><name>new_hisnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hms_dealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cl_bufs</name><operator>.</operator><name>n_occupied</name></name></expr>)</condition> <block>{<block_content>
<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tp</argument>, <argument>wp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>tp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>in_bufset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cl_bufs</name></expr></argument>, <argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_changelistidx</name></name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_changelistlen</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cl_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<macro><name>kh_foreach_key</name><argument_list>(<argument>&amp;fname_bufs</argument>, <argument>key</argument>, <argument>{
xfree((void *) key);
}</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>fnamebufs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>strset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldfiles_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>default_shada_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shada_get_default_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>default_shada_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shada_dir</name> <init>= <expr><call><name>stdpaths_user_data_subpath</name><argument_list>(<argument><expr><literal type="string">"shada"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>default_shada_file</name> <operator>=</operator> <call><name>concat_fnames_realloc</name><argument_list>(<argument><expr><name>shada_dir</name></expr></argument>, <argument><expr><literal type="string">"main.shada"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>default_shada_file</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shada_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>file</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p_shadafile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p_shadafile</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>p_shadafile</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>file</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>shada_get_default_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>expand_env</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>NameBuff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>NameBuff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_STATIC_STR</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { msgpack_pack_str(spacker, sizeof(s) - 1); msgpack_pack_str_body(spacker, s, sizeof(s) - 1); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_STRING</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const String s_ = (s); msgpack_pack_str(spacker, s_.size); if (s_.size) { msgpack_pack_str_body(spacker, s_.data, s_.size); } } while (0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_BIN</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const String s_ = (s); msgpack_pack_bin(spacker, s_.size); if (s_.size &gt; 0) { msgpack_pack_bin_body(spacker, s_.data, s_.size); } } while (0)</cpp:value></cpp:define>
















<function><type><specifier>static</specifier> <name>ShaDaWriteResult</name></type> <name>shada_pack_entry</name><parameter_list>(<parameter><decl><type><name>msgpack_packer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>packer</name></decl></parameter>,
<parameter><decl><type><name>ShadaEntry</name></type> <name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_kbyte</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>ret</name> <init>= <expr><name>kSDWriteFailed</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>msgpack_sbuffer</name></type> <name>sbuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_sbuffer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>msgpack_packer</name> <modifier>*</modifier></type><name>spacker</name> <init>= <expr><call><name>msgpack_packer_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgpack_sbuffer_write</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_ADDITIONAL_ELEMENTS</name><parameter_list>(<parameter><type><name>src</name></type></parameter>, <parameter><type><name>what</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((src) != NULL) { TV_LIST_ITER((src), li, { if (encode_vim_to_msgpack(spacker, TV_LIST_ITEM_TV(li), _("additional elements of ShaDa " what)) == FAIL) { goto shada_pack_entry_error; } }); } } while (0)</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_ADDITIONAL_DATA</name><parameter_list>(<parameter><type><name>src</name></type></parameter>, <parameter><type><name>what</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { dict_T *const d = (src); if (d != NULL) { size_t todo = d-&gt;dv_hashtab.ht_used; for (const hashitem_T *hi= d-&gt;dv_hashtab.ht_array; todo; hi++) { if (!HASHITEM_EMPTY(hi)) { todo--; dictitem_T *const di = TV_DICT_HI2DI(hi); const size_t key_len = strlen((const char *)hi-&gt;hi_key); msgpack_pack_str(spacker, key_len); msgpack_pack_str_body(spacker, (const char *)hi-&gt;hi_key, key_len); if (encode_vim_to_msgpack(spacker, &amp;di-&gt;di_tv, _("additional data of ShaDa " what)) == FAIL) { goto shada_pack_entry_error; } } } } } while (0)</cpp:value></cpp:define>




















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_DEFAULT</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sd_default_values[entry.type].data.attr == entry.data.attr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_IF_NOT_DEFAULT</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t) (!CHECK_DEFAULT(entry, attr)))</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name><name>entry</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemMissing</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>spacker</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name><name>spacker</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>contents</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_hist_search</name> <init>=
<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name> <operator>==</operator> <name>HIST_SEARCH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>arr_size</name> <init>= <expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>is_hist_search</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator>
<call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_array</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>arr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint8</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_hist_search</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_uint8</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"history entry item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>arr_size</name> <init>= <expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator>
<call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_array</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>arr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>String</name></type> <name>varname</name> <init>= <expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>vardesc</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><literal type="string">"variable g:"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vardesc</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"variable g:"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>varname</name><operator>.</operator><name>size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>encode_vim_to_msgpack</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>vardesc</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteIgnError</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>WERR</name> <literal type="string">"Failed to write variable %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"variable item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>arr_size</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator>
<call><name>tv_list_len</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_array</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>arr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>sub</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"sub string item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>map_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<literal type="number">1</literal> 
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>magic</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>is_last_used</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>smartcase</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>has_line_offset</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>place_cursor_at_end</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>is_substitute_pattern</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>highlighted</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>search_backward</name></name></expr></argument>)</argument_list></call>

<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<ternary><condition><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name></name></expr>
?</condition><then> <expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_map</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>SEARCH_KEY_PAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>pat</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_BOOL</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!CHECK_DEFAULT(entry, search_pattern.attr)) { PACK_STATIC_STR(name); if (sd_default_values[entry.type].data.search_pattern.attr) { msgpack_pack_false(spacker); } else { msgpack_pack_true(spacker); } } } while (0)</cpp:value></cpp:define>










<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_MAGIC</name></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_IS_LAST_USED</name></expr></argument>, <argument><expr><name>is_last_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_SMARTCASE</name></expr></argument>, <argument><expr><name>smartcase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_HAS_LINE_OFFSET</name></expr></argument>, <argument><expr><name>has_line_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_PLACE_CURSOR_AT_END</name></expr></argument>, <argument><expr><name>place_cursor_at_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_IS_SUBSTITUTE_PATTERN</name></expr></argument>, <argument><expr><name>is_substitute_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_HIGHLIGHTED</name></expr></argument>, <argument><expr><name>highlighted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BOOL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>SEARCH_KEY_BACKWARD</name></expr></argument>, <argument><expr><name>search_backward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>search_pattern</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>SEARCH_KEY_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_int64</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PACK_BOOL</name></cpp:undef>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name></name></expr></argument>,
<argument><expr><literal type="string">"search pattern item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case>
<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case>
<case>case <expr><name>kSDItemJump</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>map_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<literal type="number">1</literal> 
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call>

<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<ternary><condition><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name> <operator>==</operator> <name>NULL</name></expr>
?</condition><then> <expr><literal type="number">0</literal></expr>
</then><else>: <expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_map</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_LNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_long</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_COL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_long</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemJump</name> <operator>||</operator> <name><name>entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemChange</name></expr>
?</condition><then> <expr><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_NAME_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint8</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name></expr></argument>,
<argument><expr><literal type="string">"mark (change, jump, global or local) item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>map_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<literal type="number">2</literal> 
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>width</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>ONE_IF_NOT_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>is_unnamed</name></name></expr></argument>)</argument_list></call>

<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>additional_data</name></name> <operator>==</operator> <name>NULL</name></expr>
?</condition><then> <expr><literal type="number">0</literal></expr>
</then><else>: <expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>additional_data</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_map</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>REG_KEY_CONTENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_array</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_NAME_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_char</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>REG_KEY_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint8</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>REG_KEY_WIDTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint64</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_DEFAULT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>reg</name><operator>.</operator><name>is_unnamed</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>REG_KEY_UNNAMED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>is_unnamed</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_true</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_false</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>additional_data</name></name></expr></argument>, <argument><expr><literal type="string">"register item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_array</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>map_size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<literal type="number">1</literal> 
<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>lnum</name></name>
<operator>!=</operator> <name><name>default_pos</name><operator>.</operator><name>lnum</name></name><operator>)</operator>
<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>col</name></name>
<operator>!=</operator> <name><name>default_pos</name><operator>.</operator><name>col</name></name><operator>)</operator>

<operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator>
<ternary><condition><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name> <operator>==</operator> <name>NULL</name></expr>
?</condition><then> <expr><literal type="number">0</literal></expr>
</then><else>: <expr><operator>(</operator><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>additional_data</name>
<operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name><operator>)</operator></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_pack_map</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><call><name>cstr_as_string</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_LNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint64</name><argument_list>(
<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>col</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STATIC_STR</name><argument_list>(<argument><expr><name>KEY_COL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_pack_uint64</name><argument_list>(
<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DUMP_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name></expr></argument>,
<argument><expr><literal type="string">"buffer list subitem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHeader</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_map</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>header</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>header</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_STRING</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>header</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Object</name></type> <name>obj</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>header</name><operator>.</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>obj</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kObjectTypeString</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_BIN</name><argument_list>(<argument><expr><name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kObjectTypeInteger</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_pack_int64</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>obj</name><operator>.</operator><name>data</name><operator>.</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_DEFAULT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ONE_IF_NOT_DEFAULT</name></cpp:undef>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_kbyte</name> <operator>||</operator> <name><name>sbuf</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <name>max_kbyte</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemUnknown</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_pack_uint64</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_pack_uint64</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_pack_uint64</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sbuf</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>msgpack_pack_uint64</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>sbuf</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><call><name><name>packer</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name><name>packer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>sbuf</name><operator>.</operator><name>data</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name><name>sbuf</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_pack_entry_error</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>msgpack_packer_free</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_sbuffer_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDWriteSuccessfull</name></expr>;</return>
<label><name>shada_pack_entry_error</name>:</label>
<expr_stmt><expr><call><name>msgpack_packer_free</name><argument_list>(<argument><expr><name>spacker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_sbuffer_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PACK_STRING</name></cpp:undef>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ShaDaWriteResult</name></type> <name>shada_pack_pfreed_entry</name><parameter_list>(
<parameter><decl><type><name>msgpack_packer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>packer</name></decl></parameter>, <parameter><decl><type><name>PossiblyFreedShadaEntry</name></type> <name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_kbyte</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>ret</name> <init>= <expr><name>kSDWriteSuccessfull</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>max_kbyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>can_free_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_file_marks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FileMarks</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>a_fms</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>FileMarks</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier><specifier>const</specifier></type> <name>b_fms</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>a_fms</name><operator>)</operator><operator>-&gt;</operator><name>greatest_timestamp</name> <operator>==</operator> <name><operator>(</operator><operator>*</operator><name>b_fms</name><operator>)</operator><operator>-&gt;</operator><name>greatest_timestamp</name></name></expr>
?</condition><then> <expr><literal type="number">0</literal></expr>
</then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>a_fms</name><operator>)</operator><operator>-&gt;</operator><name>greatest_timestamp</name> <operator>&gt;</operator> <name><operator>(</operator><operator>*</operator><name>b_fms</name><operator>)</operator><operator>-&gt;</operator><name>greatest_timestamp</name></name></expr>
?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr>
</then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>












<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ShaDaReadResult</name></type> <name>shada_parse_msgpack</name><argument_list>(
<argument><expr><name>ShaDaReadDef</name> <operator>*</operator><specifier>const</specifier> <name>sd_reader</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>size_t</name> <name>length</name></expr></argument>,
<argument><expr><name>msgpack_unpacked</name> <operator>*</operator><name>ret_unpacked</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator><specifier>const</specifier> <name>ret_buf</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintmax_t</name></type> <name>initial_fpos</name> <init>= <expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>fl_ret</name> <init>= <expr><call><name>fread_len</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fl_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>fl_ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>did_try_to_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<label><name>shada_parse_msgpack_read_next</name>:</label> <block>{<block_content/>}</block>
<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>msgpack_unpacked</name></type> <name>unpacked</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>msgpack_unpack_return</name></type> <name>result</name> <init>=
<expr><call><name>msgpack_unpack_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>ret</name> <init>= <expr><name>kSDReadStatusSuccess</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MSGPACK_UNPACK_SUCCESS</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_parse_msgpack_extra_bytes</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>MSGPACK_UNPACK_PARSE_ERROR</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Failed to parse ShaDa file due to a msgpack parser error "</literal>
<literal type="string">"at position %"</literal> <name>PRIu64</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusNotShaDa</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>MSGPACK_UNPACK_NOMEM_ERROR</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_try_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>did_try_to_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>try_to_free_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_parse_msgpack_read_next</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_outofmem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusReadError</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>MSGPACK_UNPACK_CONTINUE</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Failed to parse ShaDa file: incomplete msgpack string "</literal>
<literal type="string">"at position %"</literal> <name>PRIu64</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusNotShaDa</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>MSGPACK_UNPACK_EXTRA_BYTES</name></expr>:</case> <block>{<block_content>
<label><name>shada_parse_msgpack_extra_bytes</name>:</label>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Failed to parse ShaDa file: extra bytes in msgpack string "</literal>
<literal type="string">"at position %"</literal> <name>PRIu64</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusNotShaDa</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>ret_buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret_unpacked</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_unpacked_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_unpacked</name> <operator>=</operator> <name>unpacked</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_buf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret_buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_unpacked_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shada_format_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ShadaEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ret</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"[ ] ts=%"</literal> <name>PRIu64</name> <literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>entry</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemMissing</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHeader</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Header { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"BufferList { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Unknown { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"SearchPattern { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"SubString { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"HistoryEntry { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Register { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf_add</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Variable { TODO }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMAT_MARK_ENTRY</name><parameter_list>(<parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name_fmt</name></type></parameter>, <parameter><type><name>name_fmt_arg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { typval_T ad_tv = { .v_type = VAR_DICT, .vval.v_dict = entry.data.filemark.additional_data }; size_t ad_len; char *const ad = encode_tv2string(&amp;ad_tv, &amp;ad_len); vim_snprintf_add( S_LEN(ret), entry_name " {" name_fmt " file=[%zu]\"%.512s\", " "pos={l=%" PRIdLINENR ",c=%" PRIdCOLNR ",a=%" PRIdCOLNR "}, " "ad={%p:[%zu]%.64s} }", name_fmt_arg, strlen(entry.data.filemark.fname), entry.data.filemark.fname, entry.data.filemark.mark.lnum, entry.data.filemark.mark.col, entry.data.filemark.mark.coladd, (void *)entry.data.filemark.additional_data, ad_len, ad); } while (0)</cpp:value></cpp:define>






















<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>FORMAT_MARK_ENTRY</name><argument_list>(<argument><expr><literal type="string">"GlobalMark"</literal></expr></argument>, <argument><expr><literal type="string">" name='%c',"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>FORMAT_MARK_ENTRY</name><argument_list>(<argument><expr><literal type="string">"Change"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>FORMAT_MARK_ENTRY</name><argument_list>(<argument><expr><literal type="string">"LocalMark"</literal></expr></argument>, <argument><expr><literal type="string">" name='%c',"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemJump</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>FORMAT_MARK_ENTRY</name><argument_list>(<argument><expr><literal type="string">"Jump"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FORMAT_MARK_ENTRY</name></cpp:undef>
</block_content>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shada_format_pfreed_entry</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>PossiblyFreedShadaEntry</name></type> <name>pfs_entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>shada_format_entry</name><argument_list>(<argument><expr><name><name>pfs_entry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>pfs_entry</name><operator>.</operator><name>can_free_entry</name></name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ShaDaWriteResult</name></type> <name>shada_read_when_writing</name><parameter_list>(
<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>srni_flags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_kbyte</name></decl></parameter>, <parameter><decl><type><name>WriteMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms</name></decl></parameter>,
<parameter><decl><type><name>msgpack_packer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>packer</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>ret</name> <init>= <expr><name>kSDWriteSuccessfull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>srni_ret</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>srni_ret</name> <operator>=</operator> <call><name>shada_read_next_item</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>srni_flags</name></expr></argument>,
<argument><expr><name>max_kbyte</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusFinished</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>srni_ret</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDReadStatusSuccess</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusFinished</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusNotShaDa</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteReadNotShada</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusReadError</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>kSDReadStatusMalformed</name></expr>:</case> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block>
</block_content>}</block></switch>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_WITH_ENTRY</name><parameter_list>(<parameter><type><name>wms_entry_</name></type></parameter>, <parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { PossiblyFreedShadaEntry *const wms_entry = (wms_entry_); if (wms_entry-&gt;data.type != kSDItemMissing) { if (wms_entry-&gt;data.timestamp &gt;= (entry).timestamp) { shada_free_shada_entry(&amp;(entry)); break; } if (wms_entry-&gt;can_free_entry) { shada_free_shada_entry(&amp;wms_entry-&gt;data); } } *wms_entry = pfs_entry; } while (0)</cpp:value></cpp:define>













<decl_stmt><decl><type><specifier>const</specifier> <name>PossiblyFreedShadaEntry</name></type> <name>pfs_entry</name> <init>= <expr><block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>true</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>entry</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>entry</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemMissing</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHeader</name></expr>:</case>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>COMPARE_WITH_ENTRY</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>is_substitute_pattern</name></name></expr>
?</condition><then> <expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>sub_search_pattern</name></name></expr>
</then><else>: <expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>search_pattern</name></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>COMPARE_WITH_ENTRY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>replacement</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name> <operator>&gt;=</operator> <name>HIST_COUNT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hms_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>hms</name><index>[<expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><call><name>op_reg_index</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>COMPARE_WITH_ENTRY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>registers</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_strset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>dumped_variables</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>processed_mark</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>wms_entry</name> <init>= <expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kSDItemGlobalMark</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>.</operator><name>timestamp</name></name> <operator>==</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>wms_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name> <operator>==</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>marks_equal</name><argument_list>(<argument><expr><name><name>wms_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>wms_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>processed_mark</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>processed_mark</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>replace_numbered_mark</name><argument_list>(<argument><expr><name>wms</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pfs_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>processed_mark</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>replace_numbered_mark</name><argument_list>(<argument><expr><name>wms</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pfs_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><call><name>mark_global_index</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>COMPARE_WITH_ENTRY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>global_marks</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_removable</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>khiter_t</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>kh_put</name><argument_list>(<argument><expr><name>file_marks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FileMarks</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filemarks</name> <init>= <expr><operator>&amp;</operator><call><name>kh_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kh_ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>filemarks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>filemarks</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;</operator> <name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemLocalMark</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><call><name>mark_local_index</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks</name></name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(
<argument><expr><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks</name></name></expr></argument>,
<argument><expr><operator>(</operator><operator>++</operator><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks_size</name></name>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks</name><index>[<expr><name><name>filemarks</name><operator>-&gt;</operator><name>additional_marks_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name>entry</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms_entry</name> <init>= <expr><operator>&amp;</operator><name><name>filemarks</name><operator>-&gt;</operator><name>marks</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>kSDItemMissing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>.</operator><name>timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wms_entry</name><operator>-&gt;</operator><name>can_free_entry</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>kh_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name><name>wms_entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kh_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms_entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>wms_entry</name> <operator>=</operator> <name>pfs_entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_POSSIBLY_FREED_SHADA_ENTRY</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (entry.can_free_entry) { shada_free_shada_entry(&amp;entry.data); } } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDE_TO_PFSDE</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((PossiblyFreedShadaEntry) { .can_free_entry = true, .data = entry })</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFTERFREE_DUMMY</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_IDX_ADJ</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<expr_stmt><expr><call><name>MERGE_JUMPS</name><argument_list>(<argument><expr><name><name>filemarks</name><operator>-&gt;</operator><name>changes_size</name></name></expr></argument>, <argument><expr><name><name>filemarks</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>,
<argument><expr><name>PossiblyFreedShadaEntry</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>timestamp</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>FREE_POSSIBLY_FREED_SHADA_ENTRY</name></expr></argument>, <argument><expr><name>SDE_TO_PFSDE</name></expr></argument>,
<argument><expr><name>DUMMY_IDX_ADJ</name></expr></argument>, <argument><expr><name>AFTERFREE_DUMMY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemJump</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>MERGE_JUMPS</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>jumps_size</name></name></expr></argument>, <argument><expr><name><name>wms</name><operator>-&gt;</operator><name>jumps</name></name></expr></argument>, <argument><expr><name>PossiblyFreedShadaEntry</name></expr></argument>,
<argument><expr><name><name>data</name><operator>.</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>jl_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>FREE_POSSIBLY_FREED_SHADA_ENTRY</name></expr></argument>, <argument><expr><name>SDE_TO_PFSDE</name></expr></argument>,
<argument><expr><name>DUMMY_IDX_ADJ</name></expr></argument>, <argument><expr><name>AFTERFREE_DUMMY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FREE_POSSIBLY_FREED_SHADA_ENTRY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SDE_TO_PFSDE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DUMMY_IDX_ADJ</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>AFTERFREE_DUMMY</name></cpp:undef>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></while>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COMPARE_WITH_ENTRY</name></cpp:undef>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>







<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>ignore_buf</name><argument_list>(<argument><expr><specifier>const</specifier> <name>buf_T</name> <operator>*</operator><specifier>const</specifier> <name>buf</name></expr></argument>,
<argument><expr><call><name>khash_t</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>removable_bufs</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_PURE</name> <name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_ALWAYS_INLINE</name>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>buf</name><operator>-&gt;</operator><name>b_p_bl</name></name> <operator>||</operator> <call><name>bt_quickfix</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> \
<operator>||</operator> <call><name>bt_terminal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>in_bufset</name><argument_list>(<argument><expr><name>removable_bufs</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ShadaEntry</name></type> <name>shada_get_buflist</name><argument_list>(
<argument><expr><call><name>khash_t</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>removable_bufs</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_NONNULL_ALL</name> <name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_ALWAYS_INLINE</name>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>max_bufs</name> <init>= <expr><call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buf_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ignore_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>removable_bufs</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><name>max_bufs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>buf_count</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>max_bufs</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>buflist_entry</name> <init>= <expr><operator>(</operator><name>ShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemBufferList</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <call><name>os_time</name><argument_list>()</argument_list></call></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>buffer_list</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>buf_count</name></expr>,
<expr><operator>.</operator><name>buffers</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>buf_count</name>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>buflist_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
}</block></expr>,
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ignore_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>buf_count</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buflist_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator>struct <name>buffer_list_buffer</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>pos</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_last_cursor</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>additional_data</name></name></expr>,
}</block></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><name>buflist_entry</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>













<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>add_search_pattern</name><parameter_list>(<parameter><decl><type><name>PossiblyFreedShadaEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_pse</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SearchPatternGetter</name></type> <name>get_pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_substitute_pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>search_last_used</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>search_highlighted</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShadaEntry</name></type> <name>defaults</name> <init>= <expr><name><name>sd_default_values</name><index>[<expr><name>kSDItemSearchPattern</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPattern</name></type> <name>pat</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pat</name><operator>.</operator><name>pat</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_pse</name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemSearchPattern</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>pat</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>search_pattern</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>magic</name> <operator>=</operator> <name><name>pat</name><operator>.</operator><name>magic</name></name></expr>,
<expr><operator>.</operator><name>smartcase</name> <operator>=</operator> <operator>!</operator><name><name>pat</name><operator>.</operator><name>no_scs</name></name></expr>,
<expr><operator>.</operator><name>has_line_offset</name> <operator>=</operator> <operator>(</operator><name>is_substitute_pattern</name>
<operator>?</operator> <name><name>defaults</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>has_line_offset</name></name>
<operator>:</operator> <name><name>pat</name><operator>.</operator><name>off</name><operator>.</operator><name>line</name></name><operator>)</operator></expr>,
<expr><operator>.</operator><name>place_cursor_at_end</name> <operator>=</operator> <operator>(</operator>
<name>is_substitute_pattern</name>
<operator>?</operator> <name><name>defaults</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>place_cursor_at_end</name></name>
<operator>:</operator> <name><name>pat</name><operator>.</operator><name>off</name><operator>.</operator><name>end</name></name><operator>)</operator></expr>,
<expr><operator>.</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>is_substitute_pattern</name>
<operator>?</operator> <name><name>defaults</name><operator>.</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>offset</name></name>
<operator>:</operator> <name><name>pat</name><operator>.</operator><name>off</name><operator>.</operator><name>off</name></name><operator>)</operator></expr>,
<expr><operator>.</operator><name>is_last_used</name> <operator>=</operator> <operator>(</operator><name>is_substitute_pattern</name> <operator>^</operator> <name>search_last_used</name><operator>)</operator></expr>,
<expr><operator>.</operator><name>is_substitute_pattern</name> <operator>=</operator> <name>is_substitute_pattern</name></expr>,
<expr><operator>.</operator><name>highlighted</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>is_substitute_pattern</name> <operator>^</operator> <name>search_last_used</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>search_highlighted</name><operator>)</operator></expr>,
<expr><operator>.</operator><name>pat</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pat</name><operator>.</operator><name>pat</name></name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>pat</name><operator>.</operator><name>additional_data</name></name></expr>,
<expr><operator>.</operator><name>search_backward</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>is_substitute_pattern</name> <operator>&amp;&amp;</operator> <name><name>pat</name><operator>.</operator><name>off</name><operator>.</operator><name>dir</name></name> <operator>==</operator> <literal type="char">'?'</literal><operator>)</operator></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>shada_initialize_registers</name><parameter_list>(<parameter><decl><type><name>WriteMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>max_reg_lines</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reg_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>limit_reg_lines</name> <init>= <expr><name>max_reg_lines</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>yankreg_T</name></type> <name>reg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>name</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_unnamed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>reg_iter</name> <operator>=</operator> <call><name>op_global_reg_iter</name><argument_list>(<argument><expr><name>reg_iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_unnamed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>limit_reg_lines</name> <operator>&amp;&amp;</operator> <name><name>reg</name><operator>.</operator><name>y_size</name></name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>max_reg_lines</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>registers</name><index>[<expr><call><name>op_reg_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemRegister</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>reg</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>reg</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>contents</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>reg</name><operator>.</operator><name>y_array</name></name></expr>,
<expr><operator>.</operator><name>contents_size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>reg</name><operator>.</operator><name>y_size</name></name></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name><name>reg</name><operator>.</operator><name>y_type</name></name></expr>,
<expr><operator>.</operator><name>width</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>reg</name><operator>.</operator><name>y_type</name></name> <operator>==</operator> <name>kMTBlockWise</name> <operator>?</operator> <name><name>reg</name><operator>.</operator><name>y_width</name></name> <operator>:</operator> <literal type="number">0</literal><operator>)</operator></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>reg</name><operator>.</operator><name>additional_data</name></name></expr>,
<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>,
<expr><operator>.</operator><name>is_unnamed</name> <operator>=</operator> <name>is_unnamed</name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>reg_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>replace_numbered_mark</name><parameter_list>(<parameter><decl><type><name>WriteMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PossiblyFreedShadaEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARRAY_LAST_ENTRY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>can_free_entry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>ARRAY_LAST_ENTRY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name>idx</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemGlobalMark</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><literal type="char">'0'</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name> <operator>+</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name> <operator>+</operator> <name>idx</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof>
<operator>*</operator> <operator>(</operator><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>idx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><literal type="char">'0'</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>idx</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>find_removable_bufs</name><argument_list>(<argument><expr><call><name>khash_t</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call> <operator>*</operator><name>removable_bufs</name></expr></argument>)</argument_list>
<block>{<block_content>
<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>shada_removable</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>kh_put</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>, <argument><expr><name>removable_bufs</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></decl></decl_stmt>







<function><type><specifier>static</specifier> <name>ShaDaWriteResult</name></type> <name>shada_write</name><parameter_list>(<parameter><decl><type><name>ShaDaWriteDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_writer</name></decl></parameter>,
<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>ret</name> <init>= <expr><name>kSDWriteSuccessfull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_kbyte_i</name> <init>= <expr><call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>max_kbyte_i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_kbyte_i</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_kbyte_i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>WriteMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name><name>dump_one_history</name><index>[<expr><name>HIST_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dump_global_vars</name> <init>= <expr><operator>(</operator><call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'!'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_reg_lines</name> <init>= <expr><call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>max_reg_lines</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_reg_lines</name> <operator>=</operator> <call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dump_registers</name> <init>= <expr><operator>(</operator><name>max_reg_lines</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<macro><name>khash_t</name><argument_list>(<argument>bufset</argument>)</argument_list></macro> <expr_stmt><expr><name>removable_bufs</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_kbyte</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>max_kbyte_i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>num_marked_files</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dump_global_marks</name> <init>= <expr><call><name>get_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>dump_history</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HIST_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>num_saved</name> <init>= <expr><call><name>get_shada_parameter</name><argument_list>(<argument><expr><call><name>hist_type2char</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num_saved</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num_saved</name> <operator>=</operator> <name>p_hi</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num_saved</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dump_history</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dump_one_history</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hms_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>num_saved</name></expr></argument>, <argument><expr><name>sd_reader</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dump_one_history</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>srni_flags</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <operator>(</operator>
<name>kSDReadUndisableableData</name>
<operator>|</operator> <name>kSDReadUnknown</name>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>dump_history</name></expr> ?</condition><then> <expr><name>kSDReadHistory</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>dump_registers</name></expr> ?</condition><then> <expr><name>kSDReadRegisters</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>dump_global_vars</name></expr> ?</condition><then> <expr><name>kSDReadVariables</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>dump_global_marks</name></expr> ?</condition><then> <expr><name>kSDReadGlobalMarks</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>num_marked_files</name></expr> ?</condition><then> <expr><name>kSDReadLocalMarks</name> <operator>|</operator> <name>kSDReadChanges</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>msgpack_packer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>packer</name> <init>= <expr><call><name>msgpack_packer_new</name><argument_list>(<argument><expr><name>sd_writer</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>msgpack_sd_writer_write</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>






<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tp</argument>, <argument>wp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>set_last_cursor</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>find_removable_bufs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><macro><name>shada_pack_entry</name><argument_list>(<argument>packer</argument>, <argument>(ShadaEntry) {
.type = kSDItemHeader</argument>,
<argument>.timestamp = os_time()</argument>,
<argument>.data = {
.header = {
.size = <literal type="number">5</literal></argument>,
<argument>.capacity = <literal type="number">5</literal></argument>,
<argument>.items = ((KeyValuePair[]) {
{ STATIC_CSTR_AS_STRING(<literal type="string">"generator"</literal>),
STRING_OBJ(STATIC_CSTR_AS_STRING(<literal type="string">"nvim"</literal>)) },
{ STATIC_CSTR_AS_STRING(<literal type="string">"version"</literal>),
STRING_OBJ(cstr_as_string(longVersion)) },
{ STATIC_CSTR_AS_STRING(<literal type="string">"max_kbyte"</literal>),
INTEGER_OBJ((Integer) max_kbyte) },
{ STATIC_CSTR_AS_STRING(<literal type="string">"pid"</literal>),
INTEGER_OBJ((Integer) os_get_pid()) },
{ STATIC_CSTR_AS_STRING(<literal type="string">"encoding"</literal>),
STRING_OBJ(cstr_as_string((char *) p_enc)) },
})</argument>,
<argument>}
}
}</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>buflist_entry</name> <init>= <expr><call><name>shada_get_buflist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name>buflist_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>buflist_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>buflist_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>dump_global_vars</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>var_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Timestamp</name></type> <name>cur_timestamp</name> <init>= <expr><call><name>os_time</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>typval_T</name></type> <name>vartv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>var_iter</name> <operator>=</operator> <call><name>var_shada_iter</name><argument_list>(<argument><expr><name>var_iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>, <argument><expr><name>VAR_FLAVOUR_SHADA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>typval_T</name></type> <name>tgttv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tgttv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>spe_ret</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>spe_ret</name> <operator>=</operator> <macro><name>shada_pack_entry</name><argument_list>(<argument>packer</argument>, <argument>(ShadaEntry) {
.type = kSDItemVariable</argument>,
<argument>.timestamp = cur_timestamp</argument>,
<argument>.data = {
.global_var = {
.name = (char *) name</argument>,
<argument>.value = tgttv</argument>,
<argument>.additional_elements = NULL</argument>,
<argument>}
}
}</argument>, <argument>max_kbyte</argument>)</argument_list></macro><operator>)</operator> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgttv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgttv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>spe_ret</name> <operator>==</operator> <name>kSDWriteSuccessfull</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>kh_put</name><argument_list>(<argument><expr><name>strset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>dumped_variables</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>var_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>setpcmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_jumplist</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>jumps_size</name></name> <operator>=</operator> <call><name>shada_init_jumps</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>jumps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>search_highlighted</name> <init>= <expr><operator>!</operator><operator>(</operator><name>no_hlsearch</name>
<operator>||</operator> <call><name>find_shada_parameter</name><argument_list>(<argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>search_last_used</name> <init>= <expr><call><name>search_was_last_used</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>add_search_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>search_pattern</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>get_search_pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>search_last_used</name></expr></argument>, <argument><expr><name>search_highlighted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>add_search_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>sub_search_pattern</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>get_substitute_pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>search_last_used</name></expr></argument>, <argument><expr><name>search_highlighted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>SubReplacementString</name></type> <name>sub</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sub_get_replacement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>replacement</name></name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemSubString</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>sub</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>sub_string</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>sub</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>sub</name><operator>.</operator><name>sub</name></name></expr>,
<expr><operator>.</operator><name>additional_elements</name> <operator>=</operator> <name><name>sub</name><operator>.</operator><name>additional_elements</name></name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
</block_content>}</block>


<if_stmt><if>if <condition>(<expr><name>dump_global_marks</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>global_mark_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>digit_mark_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>name</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xfmark_T</name></type> <name>fm</name></decl>;</decl_stmt>
<expr_stmt><expr><name>global_mark_iter</name> <operator>=</operator> <call><name>mark_global_iter</name><argument_list>(<argument><expr><name>global_mark_iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fm</name><operator>.</operator><name>fname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>shada_removable</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>fm</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>fm</name><operator>.</operator><name>fname</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>buf_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name> <init>= <expr><call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>in_bufset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PossiblyFreedShadaEntry</name></type> <name>pf_entry</name> <init>= <expr><block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemGlobalMark</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>filemark</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>additional_data</name></name></expr>,
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>replace_numbered_mark</name><argument_list>(<argument><expr><name>wms</name></expr></argument>, <argument><expr><name>digit_mark_idx</name><operator>++</operator></expr></argument>, <argument><expr><name>pf_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>wms</name><operator>-&gt;</operator><name>global_marks</name><index>[<expr><call><name>mark_global_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>pf_entry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><name>global_mark_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>dump_registers</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_initialize_registers</name><argument_list>(<argument><expr><name>wms</name></expr></argument>, <argument><expr><name>max_reg_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>num_marked_files</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>in_bufset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>local_marks_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>khiter_t</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kh_ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>kh_put</name><argument_list>(<argument><expr><name>file_marks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kh_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FileMarks</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filemarks</name> <init>= <expr><operator>&amp;</operator><call><name>kh_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kh_ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>filemarks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>filemarks</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>fmark_T</name></type> <name>fm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>name</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>local_marks_iter</name> <operator>=</operator> <call><name>mark_buffer_iter</name><argument_list>(<argument><expr><name>local_marks_iter</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>marks</name><index>[<expr><call><name>mark_local_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemLocalMark</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>filemark</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>,
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fname</name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>additional_data</name></name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;</operator> <name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>timestamp</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>local_marks_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_changelistlen</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>fmark_T</name></type> <name>fm</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>b_changelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemChange</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>filemark</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fname</name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>additional_data</name></name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;</operator> <name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>greatest_timestamp</name></name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>timestamp</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>filemarks</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_changelistlen</name></name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sd_reader</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaWriteResult</name></type> <name>srww_ret</name> <init>= <expr><call><name>shada_read_when_writing</name><argument_list>(
<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>srni_flags</name></expr></argument>, <argument><expr><name>max_kbyte</name></expr></argument>, <argument><expr><name>wms</name></expr></argument>, <argument><expr><name>packer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>srww_ret</name> <operator>!=</operator> <name>kSDWriteSuccessfull</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>srww_ret</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ignore_buf</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<macro><name>replace_numbered_mark</name><argument_list>(<argument>wms</argument>, <argument><literal type="number">0</literal></argument>, <argument>(PossiblyFreedShadaEntry) {
.can_free_entry = false</argument>,
<argument>.data = {
.type = kSDItemGlobalMark</argument>,
<argument>.timestamp = os_time()</argument>,
<argument>.data = {
.filemark = {
.mark = curwin-&gt;w_cursor</argument>,
<argument>.name = <literal type="char">'0'</literal></argument>,
<argument>.additional_data = NULL</argument>,
<argument>.fname = (char *)curbuf-&gt;b_ffname</argument>,
<argument>}
}
}</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_WMS_ARRAY</name><parameter_list>(<parameter><type><name>wms_array</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { for (size_t i_ = 0; i_ &lt; ARRAY_SIZE(wms_array); i_++) { if (wms_array[i_].data.type != kSDItemMissing) { if (shada_pack_pfreed_entry(packer, wms_array[i_], max_kbyte) == kSDWriteFailed) { ret = kSDWriteFailed; goto shada_write_exit; } } } } while (0)</cpp:value></cpp:define>











<expr_stmt><expr><call><name>PACK_WMS_ARRAY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>global_marks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_WMS_ARRAY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>numbered_marks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_WMS_ARRAY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>wms</name><operator>-&gt;</operator><name>jumps_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_pack_pfreed_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name><name>wms</name><operator>-&gt;</operator><name>jumps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>max_kbyte</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PACK_WMS_ENTRY</name><parameter_list>(<parameter><type><name>wms_entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (wms_entry.data.type != kSDItemMissing) { if (shada_pack_pfreed_entry(packer, wms_entry, max_kbyte) == kSDWriteFailed) { ret = kSDWriteFailed; goto shada_write_exit; } } } while (0)</cpp:value></cpp:define>









<expr_stmt><expr><call><name>PACK_WMS_ENTRY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>search_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_WMS_ENTRY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>sub_search_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PACK_WMS_ENTRY</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>replacement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PACK_WMS_ENTRY</name></cpp:undef>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>file_markss_size</name> <init>= <expr><call><name>kh_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileMarks</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>all_file_markss</name> <init>=
<expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>file_markss_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>all_file_markss</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileMarks</name> <modifier>*</modifier><modifier>*</modifier></type><name>cur_file_marks</name> <init>= <expr><name>all_file_markss</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>khint_t</name></type> <name>i</name> <init>= <expr><call><name>kh_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name>kh_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>kh_exist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cur_file_marks</name><operator>++</operator> <operator>=</operator> <operator>&amp;</operator><call><name>kh_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>all_file_markss</name></expr></argument>, <argument><expr><name>file_markss_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>all_file_markss</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name>compare_file_marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>file_markss_to_dump</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>num_marked_files</name></expr></argument>, <argument><expr><name>file_markss_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>file_markss_to_dump</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PACK_WMS_ARRAY</name><argument_list>(<argument><expr><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>changes_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_pack_pfreed_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>changes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
<argument><expr><name>max_kbyte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>additional_marks_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_pack_entry</name><argument_list>(<argument><expr><name>packer</name></expr></argument>, <argument><expr><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>additional_marks</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>additional_marks</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDWriteFailed</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>additional_marks</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>all_file_markss</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>additional_marks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>all_file_markss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PACK_WMS_ARRAY</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><name>dump_history</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HIST_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dump_one_history</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hms_insert_whole_neovim_history</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>HMS_ITER</name><argument_list>(<argument>&amp;wms-&gt;hms[i]</argument>, <argument>cur_entry</argument>, <argument>{
if (shada_pack_pfreed_entry(
packer, (PossiblyFreedShadaEntry) {
.data = cur_entry-&gt;data,
.can_free_entry = cur_entry-&gt;can_free_entry,
}, max_kbyte) == kSDWriteFailed) {
ret = kSDWriteFailed;
break;
}
}</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>kSDWriteFailed</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>shada_write_exit</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<label><name>shada_write_exit</name>:</label>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HIST_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dump_one_history</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hms_dealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>hms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>file_marks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>file_marks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msgpack_packer_free</name><argument_list>(<argument><expr><name>packer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kh_dealloc</name><argument_list>(<argument><expr><name>strset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wms</name><operator>-&gt;</operator><name>dumped_variables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>wms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IGNORE_BUF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PACK_STATIC_STR</name></cpp:undef>








<function><type><name>int</name></type> <name>shada_write_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nomerge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shada_disabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name> <init>= <expr><call><name>shada_filename</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShaDaWriteDef</name></type> <name>sd_writer</name> <init>= <expr><block>{
<expr><operator>.</operator><name>write</name> <operator>=</operator> <operator>&amp;</operator><name>write_file</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <operator>&amp;</operator><name>close_sd_writer</name></expr>,
<expr><operator>.</operator><name>error</name> <operator>=</operator> <name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShaDaReadDef</name></type> <name>sd_reader</name> <init>= <expr><block>{ <expr><operator>.</operator><name>close</name> <operator>=</operator> <name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nomerge</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>error</name> <operator>=</operator> <call><name>open_shada_file_for_reading</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>UV_ENOENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while opening ShaDa file %s for reading "</literal>
<literal type="string">"to merge before writing it: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nomerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_file_nomerge</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tempname</name> <operator>=</operator> <call><name>modname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">".tmp.a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tempname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nomerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>shada_write_file_nomerge</name>;</goto>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>perm</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>os_getperm</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>perm</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>perm</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>perm</name> <operator>&amp;</operator> <literal type="number">0777</literal><operator>)</operator> <operator>|</operator> <literal type="number">0600</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0600</literal></expr></else></ternary></expr>;</expr_stmt>





<label><name>shada_write_file_open</name>:</label> <block>{<block_content/>}</block>
<expr_stmt><expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name> <operator>=</operator> <call><name>file_open_new</name><argument_list>(
<argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>kFileCreateOnly</name><operator>|</operator><name>kFileNoSymlink</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>UV_EEXIST</name> <operator>||</operator> <name>error</name> <operator>==</operator> <name>UV_ELOOP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wp</name> <init>= <expr><name>tempname</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>wp</name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E138: All %s.tmp.X files exist, cannot write ShaDa file!"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sd_reader</name><operator>.</operator><name>close</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>sd_reader</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>wp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<goto>goto <name>shada_write_file_open</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while opening temporary ShaDa file %s "</literal>
<literal type="string">"for writing: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tempname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nomerge</name></expr>)</condition> <block>{<block_content>
<label><name>shada_write_file_nomerge</name>:</label> <block>{<block_content/>}</block>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tail</name> <init>= <expr><call><name>path_tail_with_sep</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tail</name> <operator>!=</operator> <name>fname</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>tail_save</name> <init>= <expr><operator>*</operator><name>tail</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>os_isdir</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>failed_dir</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>os_mkdir_recurse</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="number">0700</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>failed_dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"Failed to create directory %s "</literal>
<literal type="string">"for writing ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>failed_dir</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>failed_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>tail_save</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name> <operator>=</operator> <call><name>file_open_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>kFileCreate</name><operator>|</operator><name>kFileTruncate</name></expr></argument>,
<argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while opening ShaDa file %s for writing: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>.</operator><name>cookie</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>sd_reader</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Writing ShaDa file \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaWriteResult</name></type> <name>sw_ret</name> <init>= <expr><call><name>shada_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_writer</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>nomerge</name></expr>
?</condition><then> <expr><name>NULL</name></expr>
</then><else>: <expr><operator>&amp;</operator><name>sd_reader</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sw_ret</name> <operator>!=</operator> <name>kSDWriteIgnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nomerge</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>sd_reader</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>did_remove</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sw_ret</name> <operator>==</operator> <name>kSDWriteSuccessfull</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name>FileInfo</name></type> <name>old_info</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_fileinfo</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ROOT_UID</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_uid</name></name> <operator>!=</operator> <name>ROOT_UID</name>
<operator>||</operator> <name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_gid</name></name> <operator>!=</operator> <call><name>getgid</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uv_uid_t</name></type> <name>old_uid</name> <init>= <expr><operator>(</operator><name>uv_uid_t</name><operator>)</operator><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uv_gid_t</name></type> <name>old_gid</name> <init>= <expr><operator>(</operator><name>uv_gid_t</name><operator>)</operator><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_gid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fchown_ret</name> <init>= <expr><call><name>os_fchown</name><argument_list>(<argument><expr><call><name>file_fd</name><argument_list>(<argument><expr><name><name>sd_writer</name><operator>.</operator><name>cookie</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>old_uid</name></expr></argument>, <argument><expr><name>old_gid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fchown_ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RNERR</name> <literal type="string">"Failed setting uid and gid for file %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>tempname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>fchown_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_write_file_did_not_remove</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><ternary><condition><expr><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_uid</name></name> <operator>==</operator> <call><name>getuid</name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><operator>(</operator><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">0200</literal><operator>)</operator></expr>
</then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_gid</name></name> <operator>==</operator> <call><name>getgid</name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><operator>(</operator><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">0020</literal><operator>)</operator></expr>
</then><else>: <expr><operator>(</operator><name><name>old_info</name><operator>.</operator><name>stat</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">0002</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E137: ShaDa file is not writable: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_write_file_did_not_remove</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>vim_rename</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RNERR</name> <literal type="string">"Can't rename ShaDa file from %s to %s!"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>did_remove</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>os_remove</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sw_ret</name> <operator>==</operator> <name>kSDWriteReadNotShada</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RNERR</name> <literal type="string">"Did not rename %s because %s "</literal>
<literal type="string">"does not look like a ShaDa file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RNERR</name> <literal type="string">"Did not rename %s to %s because there were errors "</literal>
<literal type="string">"during writing it"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_remove</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>shada_write_file_did_not_remove</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>EMSG3</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RNERR</name> <literal type="string">"Do not forget to remove %s or rename it manually to %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>sd_writer</name><operator>.</operator><name>close</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>shada_read_marks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>shada_read_file</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>kShaDaWantMarks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>shada_read_everything</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>forceit</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>shada_read_file</name><argument_list>(<argument><expr><name>fname</name></expr></argument>,
<argument><expr><name>kShaDaWantInfo</name><operator>|</operator><name>kShaDaWantMarks</name><operator>|</operator><name>kShaDaGetOldfiles</name>
<operator>|</operator><operator>(</operator><ternary><condition><expr><name>forceit</name></expr>?</condition><then><expr><name>kShaDaForceit</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator><operator>(</operator><ternary><condition><expr><name>missing_ok</name></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><name>kShaDaMissingError</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shada_free_shada_entry</name><parameter_list>(<parameter><decl><type><name>ShadaEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemMissing</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>contents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHeader</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>api_free_dictionary</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case>
<case>case <expr><name>kSDItemJump</name></expr>:</case>
<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>pat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>additional_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>additional_elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>sub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BE64TOH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type> <name>be64toh</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>big_endian_64_bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ORDER_BIG_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>big_endian_64_bits</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>



<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>big_endian_64_bits</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>buf</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ret</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<function><type><specifier>static</specifier> <name>ShaDaReadResult</name></type> <name>fread_len</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buffer</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>read_bytes</name> <init>= <expr><call><name><name>sd_reader</name><operator>-&gt;</operator><name>read</name></name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>read_bytes</name> <operator>!=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>length</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while reading ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusReadError</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"last entry specified that it occupies %"</literal> <name>PRIu64</name> <literal type="string">" bytes, "</literal>
<literal type="string">"but file ended earlier"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>kSDReadStatusSuccess</name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>ShaDaReadResult</name></type> <name>msgpack_read_uint64</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>first_char</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintmax_t</name></type> <name>fpos</name> <init>= <expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>first_char</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>SERR</name> <literal type="string">"System error while reading integer from ShaDa file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusReadError</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"expected positive integer at position %"</literal> <name>PRIu64</name>
<literal type="string">", but got nothing"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>~</operator><name>first_char</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator> <name>first_char</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>first_char</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0xCC</literal></expr>:</case> <block>{<block_content> 
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0xCD</literal></expr>:</case> <block>{<block_content> 
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0xCE</literal></expr>:</case> <block>{<block_content> 
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0xCF</literal></expr>:</case> <block>{<block_content> 
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"expected positive integer at position %"</literal> <name>PRIu64</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>buf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_u8</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>fl_ret</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fl_ret</name> <operator>=</operator> <call><name>fread_len</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf_u8</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>length</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>fl_ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>be64toh</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>kSDReadStatusSuccess</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READERR</name><parameter_list>(<parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>error_desc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RERR "Error while reading ShaDa file: " entry_name " entry at position %" PRIu64 " " error_desc</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_KEY</name><parameter_list>(<parameter><type><name>key</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( key.via.str.size == sizeof(expected) - 1 &amp;&amp; STRNCMP(key.via.str.ptr, expected, sizeof(expected) - 1) == 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_GA_AND_ERROR_OUT</name><parameter_list>(<parameter><type><name>ga</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ga_clear(&amp;ga); goto shada_read_next_item_error; } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ID</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINDUP</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xmemdupz(b.ptr, b.size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOINT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int) (s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOLONG</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((long) (s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOCHAR</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char) (s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOU8</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint8_t) (s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOSIZE</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t) (s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKED_ENTRY</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>, <parameter><type><name>error_desc</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>, <parameter><type><name>proc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!(condition)) { emsgf(_(READERR(entry_name, error_desc)), initial_fpos); CLEAR_GA_AND_ERROR_OUT(ad_ga); } tgt = proc(obj.via.attr); } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_KEY_IS_STR</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (un.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) { emsgf(_(READERR(entry_name, "has key which is not a string")), initial_fpos); CLEAR_GA_AND_ERROR_OUT(ad_ga); } else if (un.data.via.map.ptr[i].key.via.str.size == 0) { emsgf(_(READERR(entry_name, "has empty key")), initial_fpos); CLEAR_GA_AND_ERROR_OUT(ad_ga); }</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKED_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>error_desc</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>condition</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>, <parameter><type><name>proc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>else if (CHECK_KEY( un.data.via.map.ptr[i].key, name)) { CHECKED_ENTRY( condition, "has " name " key value " error_desc, entry_name, un.data.via.map.ptr[i].val, tgt, attr, proc); }</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPED_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>type_name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>objtype</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>, <parameter><type><name>proc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CHECKED_KEY( un, entry_name, name, "which is not " type_name, tgt, un.data.via.map.ptr[i].val.type == MSGPACK_OBJECT_##objtype, attr, proc)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOLEAN_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPED_KEY(un, entry_name, name, "a boolean", tgt, BOOLEAN, boolean, ID)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPED_KEY(un, entry_name, name, "a binary", tgt, BIN, bin, BINDUP)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERTED_STRING_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPED_KEY(un, entry_name, name, "a binary", tgt, BIN, bin, BIN_CONVERTED)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>proc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CHECKED_KEY( un, entry_name, name, "which is not an integer", tgt, ((un.data.via.map.ptr[i].val.type == MSGPACK_OBJECT_POSITIVE_INTEGER) || (un.data.via.map.ptr[i].val.type == MSGPACK_OBJECT_NEGATIVE_INTEGER)), i64, proc)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEGER_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INT_KEY(un, entry_name, name, tgt, TOINT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>, <parameter><type><name>entry_name</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INT_KEY(un, entry_name, name, tgt, TOLONG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDITIONAL_KEY</name><parameter_list>(<parameter><type><name>un</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>else { ga_grow(&amp;ad_ga, 1); memcpy(((char *)ad_ga.ga_data) + ((size_t)ad_ga.ga_len * sizeof(*un.data.via.map.ptr)), un.data.via.map.ptr + i, sizeof(*un.data.via.map.ptr)); ad_ga.ga_len++; }</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERTED</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(xmemdupz((str), (len)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIN_CONVERTED</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CONVERTED(b.ptr, b.size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ADDITIONAL_DATA</name><parameter_list>(<parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ad_ga.ga_len) { msgpack_object obj = { .type = MSGPACK_OBJECT_MAP, .via = { .map = { .size = (uint32_t) ad_ga.ga_len, .ptr = ad_ga.ga_data, } } }; typval_T adtv; if (msgpack_to_vim(obj, &amp;adtv) == FAIL || adtv.v_type != VAR_DICT) { emsgf(_(READERR(name, "cannot be converted to a VimL dictionary")), initial_fpos); ga_clear(&amp;ad_ga); tv_clear(&amp;adtv); goto shada_read_next_item_error; } tgt = adtv.vval.v_dict; } ga_clear(&amp;ad_ga); } while (0)</cpp:value></cpp:define>

























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ADDITIONAL_ELEMENTS</name><parameter_list>(<parameter><type><name>src</name></type></parameter>, <parameter><type><name>src_maxsize</name></type></parameter>, <parameter><type><name>tgt</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((src).size &gt; (size_t) (src_maxsize)) { msgpack_object obj = { .type = MSGPACK_OBJECT_ARRAY, .via = { .array = { .size = ((src).size - (uint32_t) (src_maxsize)), .ptr = (src).ptr + (src_maxsize), } } }; typval_T aetv; if (msgpack_to_vim(obj, &amp;aetv) == FAIL) { emsgf(_(READERR(name, "cannot be converted to a VimL list")), initial_fpos); tv_clear(&amp;aetv); goto shada_read_next_item_error; } assert(aetv.v_type == VAR_LIST); (tgt) = aetv.vval.v_list; } } while (0)</cpp:value></cpp:define>

































<function><type><specifier>static</specifier> <name>ShaDaReadResult</name></type> <name>shada_read_next_item</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><name>ShadaEntry</name> <modifier>*</modifier><specifier>const</specifier></type> <name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>max_kbyte</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>ret</name> <init>= <expr><name>kSDReadStatusMalformed</name></expr></init></decl>;</decl_stmt>
<label><name>shada_read_next_item_start</name>:</label>




<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>kSDReadStatusFinished</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>type_u64</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>kSDItemMissing</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>timestamp_u64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>length_u64</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>initial_fpos</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>first_char</name> <init>= <expr><call><name>read_char</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>first_char</name> <operator>==</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>kSDReadStatusFinished</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ShaDaReadResult</name></type> <name>mru_ret</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>mru_ret</name> <operator>=</operator> <call><name>msgpack_read_uint64</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>first_char</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_u64</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusSuccess</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>mru_ret</name> <operator>=</operator> <call><name>msgpack_read_uint64</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><call><name>read_char</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>timestamp_u64</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusSuccess</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>mru_ret</name> <operator>=</operator> <call><name>msgpack_read_uint64</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><call><name>read_char</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>length_u64</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name>kSDReadStatusSuccess</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>mru_ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>length_u64</name> <operator>&gt;</operator> <name>PTRDIFF_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"there is an item at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"that is stated to be too long"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>length</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>length_u64</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>=</operator> <operator>(</operator><name>Timestamp</name><operator>)</operator><name>timestamp_u64</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type_u64</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RCERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"there is an item at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"that must not be there: Missing items are "</literal>
<literal type="string">"for internal uses only"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>kSDReadStatusNotShaDa</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>type_u64</name> <operator>&gt;</operator> <name>SHADA_LAST_ENTRY</name></expr>
?</condition><then> <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>kSDReadUnknown</name><operator>)</operator></expr>
</then><else>: <expr><operator>!</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>type_u64</name><operator>)</operator> <operator>&amp;</operator> <name>flags</name><operator>)</operator></expr></else></ternary><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>max_kbyte</name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <name>max_kbyte</name> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name>initial_fpos</name> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>type_u64</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>type_u64</name> <operator>&gt;</operator> <name>SHADA_LAST_ENTRY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>spm_ret</name> <init>= <expr><call><name>shada_parse_msgpack</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>spm_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>spm_ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>srs_ret</name> <init>= <expr><call><name>sd_reader_skip</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>srs_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>srs_ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>shada_read_next_item_start</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type_u64</name> <operator>&gt;</operator> <name>SHADA_LAST_ENTRY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kSDItemUnknown</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type_u64</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>initial_fpos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>spm_ret</name> <init>= <expr><call><name>shada_parse_msgpack</name><argument_list>(
<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>contents</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>spm_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kSDItemMissing</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>spm_ret</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>contents</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>fl_ret</name> <init>= <expr><call><name>fread_len</name><argument_list>(
<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>unknown_item</name><operator>.</operator><name>contents</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fl_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kSDItemMissing</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>fl_ret</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>msgpack_unpacked</name></type> <name>unpacked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ShaDaReadResult</name></type> <name>spm_ret</name> <init>= <expr><call><name>shada_parse_msgpack</name><argument_list>(<argument><expr><name>sd_reader</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>spm_ret</name> <operator>!=</operator> <name>kSDReadStatusSuccess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>spm_ret</name></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusMalformed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>sd_default_values</name><index>[<expr><name>type_u64</name></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><operator>(</operator><name>ShadaEntryType</name><operator>)</operator> <name>type_u64</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kSDItemHeader</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>msgpack_rpc_to_dictionary</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>unpacked</name><operator>.</operator><name>data</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>header</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"header"</literal></expr></argument>, <argument><expr><literal type="string">"is not a dictionary"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSearchPattern</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_MAP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"search pattern"</literal></expr></argument>, <argument><expr><literal type="string">"is not a dictionary"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ad_ga</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ad_ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>CHECK_KEY_IS_STR</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_MAGIC</argument>,
<argument>entry-&gt;data.search_pattern.magic</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_SMARTCASE</argument>,
<argument>entry-&gt;data.search_pattern.smartcase</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_HAS_LINE_OFFSET</argument>,
<argument>entry-&gt;data.search_pattern.has_line_offset</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_PLACE_CURSOR_AT_END</argument>,
<argument>entry-&gt;data.search_pattern.place_cursor_at_end</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_IS_LAST_USED</argument>,
<argument>entry-&gt;data.search_pattern.is_last_used</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>,
<argument>SEARCH_KEY_IS_SUBSTITUTE_PATTERN</argument>,
<argument>entry-&gt;data.search_pattern.is_substitute_pattern</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_HIGHLIGHTED</argument>,
<argument>entry-&gt;data.search_pattern.highlighted</argument>)</argument_list></macro>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_BACKWARD</argument>,
<argument>entry-&gt;data.search_pattern.search_backward</argument>)</argument_list></macro>
<macro><name>INTEGER_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_OFFSET</argument>,
<argument>entry-&gt;data.search_pattern.offset</argument>)</argument_list></macro>
<macro><name>CONVERTED_STRING_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"search pattern"</literal></argument>, <argument>SEARCH_KEY_PAT</argument>,
<argument>entry-&gt;data.search_pattern.pat</argument>)</argument_list></macro>
<macro><name>ADDITIONAL_KEY</name><argument_list>(<argument>unpacked</argument>)</argument_list></macro>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>pat</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"search pattern"</literal></expr></argument>, <argument><expr><literal type="string">"has no pattern"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>search_pattern</name><operator>.</operator><name>additional_data</name></name></expr></argument>,
<argument><expr><literal type="string">"search pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemChange</name></expr>:</case>
<case>case <expr><name>kSDItemJump</name></expr>:</case>
<case>case <expr><name>kSDItemGlobalMark</name></expr>:</case>
<case>case <expr><name>kSDItemLocalMark</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_MAP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><literal type="string">"is not a dictionary"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ad_ga</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ad_ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>CHECK_KEY_IS_STR</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"mark"</literal></argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>CHECK_KEY</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>, <argument><expr><name>KEY_NAME_CHAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type_u64</name> <operator>==</operator> <name>kSDItemJump</name> <operator>||</operator> <name>type_u64</name> <operator>==</operator> <name>kSDItemChange</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><literal type="string">"has n key which is only valid for "</literal>
<literal type="string">"local and global mark entries"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CHECKED_ENTRY</name><argument_list>(
<argument><expr><operator>(</operator><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>type</name></name>
<operator>==</operator> <name>MSGPACK_OBJECT_POSITIVE_INTEGER</name><operator>)</operator></expr></argument>,
<argument><expr><literal type="string">"has n key value which is not an unsigned integer"</literal></expr></argument>,
<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>u64</name></expr></argument>, <argument><expr><name>TOCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>LONG_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"mark"</literal></argument>, <argument>KEY_LNUM</argument>, <argument>entry-&gt;data.filemark.mark.lnum</argument>)</argument_list></macro>
<macro><name>INTEGER_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"mark"</literal></argument>, <argument>KEY_COL</argument>, <argument>entry-&gt;data.filemark.mark.col</argument>)</argument_list></macro>
<macro><name>STRING_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"mark"</literal></argument>, <argument>KEY_FILE</argument>, <argument>entry-&gt;data.filemark.fname</argument>)</argument_list></macro>
<macro><name>ADDITIONAL_KEY</name><argument_list>(<argument>unpacked</argument>)</argument_list></macro>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>fname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><literal type="string">"is missing file name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><literal type="string">"has invalid line number"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>mark</name><operator>.</operator><name>col</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>, <argument><expr><literal type="string">"has invalid column number"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>filemark</name><operator>.</operator><name>additional_data</name></name></expr></argument>, <argument><expr><literal type="string">"mark"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemRegister</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_MAP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"register"</literal></expr></argument>, <argument><expr><literal type="string">"is not a dictionary"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ad_ga</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ad_ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>CHECK_KEY_IS_STR</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"register"</literal></argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>CHECK_KEY</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>,
<argument><expr><name>REG_KEY_CONTENTS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"register"</literal></expr></argument>,
<argument><expr><literal type="string">"has "</literal> <name>REG_KEY_CONTENTS</name>
<literal type="string">" key with non-array value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"register"</literal></expr></argument>,
<argument><expr><literal type="string">"has "</literal> <name>REG_KEY_CONTENTS</name> <literal type="string">" key with empty array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>msgpack_object_array</name></type> <name>arr</name> <init>=
<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arr</name><operator>.</operator><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>MSGPACK_OBJECT_BIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"register"</literal></expr></argument>, <argument><expr><literal type="string">"has "</literal> <name>REG_KEY_CONTENTS</name> <literal type="string">" array "</literal>
<literal type="string">"with non-binary value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents_size</name></name> <operator>=</operator> <name><name>arr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>arr</name><operator>.</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>BIN_CONVERTED</name><argument_list>(<argument><expr><name><name>arr</name><operator>.</operator><name>ptr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<macro><name>BOOLEAN_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"register"</literal></argument>, <argument>REG_KEY_UNNAMED</argument>,
<argument>entry-&gt;data.reg.is_unnamed</argument>)</argument_list></macro>
<macro><name>TYPED_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"register"</literal></argument>, <argument>REG_KEY_TYPE</argument>, <argument><literal type="string">"an unsigned integer"</literal></argument>,
<argument>entry-&gt;data.reg.type</argument>, <argument>POSITIVE_INTEGER</argument>, <argument>u64</argument>, <argument>TOU8</argument>)</argument_list></macro>
<macro><name>TYPED_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"register"</literal></argument>, <argument>KEY_NAME_CHAR</argument>, <argument><literal type="string">"an unsigned integer"</literal></argument>,
<argument>entry-&gt;data.reg.name</argument>, <argument>POSITIVE_INTEGER</argument>, <argument>u64</argument>, <argument>TOCHAR</argument>)</argument_list></macro>
<macro><name>TYPED_KEY</name><argument_list>(<argument>unpacked</argument>, <argument><literal type="string">"register"</literal></argument>, <argument>REG_KEY_WIDTH</argument>, <argument><literal type="string">"an unsigned integer"</literal></argument>,
<argument>entry-&gt;data.reg.width</argument>, <argument>POSITIVE_INTEGER</argument>, <argument>u64</argument>, <argument>TOSIZE</argument>)</argument_list></macro>
<macro><name>ADDITIONAL_KEY</name><argument_list>(<argument>unpacked</argument>)</argument_list></macro>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>contents</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"register"</literal></expr></argument>, <argument><expr><literal type="string">"has missing "</literal> <name>REG_KEY_CONTENTS</name> <literal type="string">" array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_DATA</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>reg</name><operator>.</operator><name>additional_data</name></name></expr></argument>, <argument><expr><literal type="string">"register"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemHistoryEntry</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"history"</literal></expr></argument>, <argument><expr><literal type="string">"is not an array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"history"</literal></expr></argument>, <argument><expr><literal type="string">"does not have enough elements"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name>
<operator>!=</operator> <name>MSGPACK_OBJECT_POSITIVE_INTEGER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"history"</literal></expr></argument>, <argument><expr><literal type="string">"has wrong history type type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name>
<operator>!=</operator> <name>MSGPACK_OBJECT_BIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"history"</literal></expr></argument>, <argument><expr><literal type="string">"has wrong history string type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"history"</literal></expr></argument>, <argument><expr><literal type="string">"contains string with zero byte inside"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name> <operator>=</operator>
<operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>u64</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_hist_search</name> <init>=
<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>histtype</name></name> <operator>==</operator> <name>HIST_SEARCH</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_hist_search</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"search history"</literal></expr></argument>,
<argument><expr><literal type="string">"does not have separator character"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>type</name>
<operator>!=</operator> <name>MSGPACK_OBJECT_POSITIVE_INTEGER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"search history"</literal></expr></argument>,
<argument><expr><literal type="string">"has wrong history separator type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>sep</name></name> <operator>=</operator>
<operator>(</operator><name>char</name><operator>)</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>u64</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>strsize</name></decl>;</decl_stmt>
<expr_stmt><expr><name>strsize</name> <operator>=</operator> <operator>(</operator>
<name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name>
<operator>+</operator> <literal type="number">1</literal> 
<operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>strsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name></name></expr></argument>,
<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name><index>[<expr><name>strsize</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>string</name><index>[<expr><name>strsize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>sep</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name></name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>is_hist_search</name><operator>)</operator></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>history_item</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"history"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemVariable</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"variable"</literal></expr></argument>, <argument><expr><literal type="string">"is not an array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"variable"</literal></expr></argument>, <argument><expr><literal type="string">"does not have enough elements"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>MSGPACK_OBJECT_BIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"variable"</literal></expr></argument>, <argument><expr><literal type="string">"has wrong variable name type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>name</name></name> <operator>=</operator>
<call><name>xmemdupz</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>msgpack_to_vim</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>value</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"variable"</literal></expr></argument>, <argument><expr><literal type="string">"has value that cannot "</literal>
<literal type="string">"be converted to the VimL value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>global_var</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemSubString</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"sub string"</literal></expr></argument>, <argument><expr><literal type="string">"is not an array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"sub string"</literal></expr></argument>, <argument><expr><literal type="string">"does not have enough elements"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>MSGPACK_OBJECT_BIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"sub string"</literal></expr></argument>, <argument><expr><literal type="string">"has wrong sub string type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>sub</name></name> <operator>=</operator>
<call><name>BIN_CONVERTED</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>via</name><operator>.</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_ELEMENTS</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>sub_string</name><operator>.</operator><name>additional_elements</name></name></expr></argument>,
<argument><expr><literal type="string">"sub string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemBufferList</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>READERR</name><argument_list>(<argument><expr><literal type="string">"buffer list"</literal></expr></argument>, <argument><expr><literal type="string">"is not an array"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name> <operator>=</operator>
<call><name>xcalloc</name><argument_list>(<argument><expr><name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>msgpack_unpacked</name></type> <name>unpacked_2</name> <init>= <expr><operator>(</operator><name>msgpack_unpacked</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>data</name> <operator>=</operator> <name><name>unpacked</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>array</name><operator>.</operator><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>unpacked_2</name><operator>.</operator><name>data</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MSGPACK_OBJECT_MAP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"buffer list at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"contains entry that is not a dictionary"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>default_pos</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ad_ga</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ad_ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>unpacked_2</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>j</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>unpacked_2</name><operator>.</operator><name>data</name><operator>.</operator><name>via</name><operator>.</operator><name>map</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> 
<macro><name>CHECK_KEY_IS_STR</name><argument_list>(<argument>unpacked_2</argument>, <argument><literal type="string">"buffer list entry"</literal></argument>)</argument_list></macro>
<macro><name>LONG_KEY</name><argument_list>(<argument>unpacked_2</argument>, <argument><literal type="string">"buffer list entry"</literal></argument>, <argument>KEY_LNUM</argument>,
<argument>entry-&gt;data.buffer_list.buffers[j].pos.lnum</argument>)</argument_list></macro>
<macro><name>INTEGER_KEY</name><argument_list>(<argument>unpacked_2</argument>, <argument><literal type="string">"buffer list entry"</literal></argument>, <argument>KEY_COL</argument>,
<argument>entry-&gt;data.buffer_list.buffers[j].pos.col</argument>)</argument_list></macro>
<macro><name>STRING_KEY</name><argument_list>(<argument>unpacked_2</argument>, <argument><literal type="string">"buffer list entry"</literal></argument>, <argument>KEY_FILE</argument>,
<argument>entry-&gt;data.buffer_list.buffers[j].fname</argument>)</argument_list></macro>
<macro><name>ADDITIONAL_KEY</name><argument_list>(<argument>unpacked_2</argument>)</argument_list></macro>
</block_content>}</block></for>
</block_content>}</block>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt> 
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>lnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"buffer list at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"contains entry with invalid line number"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pos</name><operator>.</operator><name>col</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"buffer list at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"contains entry with invalid column number"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>RERR</name> <literal type="string">"Error while reading ShaDa file: "</literal>
<literal type="string">"buffer list at position %"</literal> <name>PRIu64</name> <literal type="string">" "</literal>
<literal type="string">"contains entry that does not have a file name"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>initial_fpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CLEAR_GA_AND_ERROR_OUT</name><argument_list>(<argument><expr><name>ad_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SET_ADDITIONAL_DATA</name><argument_list>(
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>additional_data</name></expr></argument>,
<argument><expr><literal type="string">"buffer list entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kSDItemMissing</name></expr>:</case>
<case>case <expr><name>kSDItemUnknown</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><name>ShadaEntryType</name><operator>)</operator> <name>type_u64</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>kSDReadStatusSuccess</name></expr>;</expr_stmt>
<label><name>shada_read_next_item_end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>msgpack_unpacked_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<label><name>shada_read_next_item_error</name>:</label>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><name>ShadaEntryType</name><operator>)</operator> <name>type_u64</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_free_shada_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kSDItemMissing</name></expr>;</expr_stmt>
<goto>goto <name>shada_read_next_item_end</name>;</goto>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIN_CONVERTED</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONVERTED</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BOOLEAN_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONVERTED_STRING_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STRING_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADDITIONAL_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ID</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BINDUP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOCHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOINT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOLONG</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPED_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INT_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INTEGER_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LONG_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOU8</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TOSIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_ADDITIONAL_DATA</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_ADDITIONAL_ELEMENTS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CLEAR_GA_AND_ERROR_OUT</name></cpp:undef>






<function><type><specifier>static</specifier> <name>bool</name></type> <name>shada_removable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>part</name><index>[<expr><name>MAXPATHL</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_name</name> <init>= <expr><call><name>home_replace_save</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p_shada</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>part</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>home_replace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>part</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>mb_strnicmp</name><argument_list>(<argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>








<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>shada_init_jumps</name><argument_list>(
<argument><expr><name>PossiblyFreedShadaEntry</name> <operator>*</operator><name>jumps</name></expr></argument>, <argument><expr><call><name>khash_t</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call> <operator>*</operator><specifier>const</specifier> <name>removable_bufs</name></expr></argument>)</argument_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_jumplistlen</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>jumps_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>jump_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>xfmark_T</name></type> <name>fm</name></decl>;</decl_stmt>
<expr_stmt><expr><name>jump_iter</name> <operator>=</operator> <call><name>mark_jumplist_iter</name><argument_list>(<argument><expr><name>jump_iter</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>mark</name><operator>.</operator><name>lnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>iemsgf</name><argument_list>(<argument><expr><literal type="string">"ShaDa: mark lnum zero (ji:%p, js:%p, len:%i)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>jump_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_jumplist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_jumplistlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>buf_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name>NULL</name></expr>
</then><else>: <expr><call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>
?</condition><then> <expr><call><name>in_bufset</name><argument_list>(<argument><expr><name>removable_bufs</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>fnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>fm</name><operator>.</operator><name>fname</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>fm</name><operator>.</operator><name>fname</name></name></expr></else></ternary><operator>)</operator></expr>
</then><else>: <expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>jumps</name><index>[<expr><name>jumps_size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PossiblyFreedShadaEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>can_free_entry</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>kSDItemJump</name></expr>,
<expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>timestamp</name></name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>filemark</name> <operator>=</operator> <block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>NUL</name></expr>,
<expr><operator>.</operator><name>mark</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>mark</name></name></expr>,
<expr><operator>.</operator><name>fname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fname</name></expr>,
<expr><operator>.</operator><name>additional_data</name> <operator>=</operator> <name><name>fm</name><operator>.</operator><name>fmark</name><operator>.</operator><name>additional_data</name></name></expr>,
}</block></expr>
}</block></expr>
}</block></expr>
}</block></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>jump_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<return>return <expr><name>jumps_size</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name>void</name></type> <name>shada_encode_regs</name><parameter_list>(<parameter><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>WriteMergerState</name> <modifier>*</modifier><specifier>const</specifier></type> <name>wms</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>shada_initialize_registers</name><argument_list>(<argument><expr><name>wms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>msgpack_packer</name></type> <name>packer</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_packer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>msgpack_sbuffer_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>wms</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wms</name><operator>-&gt;</operator><name>registers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>data</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>kSDItemRegister</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>kSDWriteFailed</name>
<operator>==</operator> <call><name>shada_pack_pfreed_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name><name>wms</name><operator>-&gt;</operator><name>registers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>wms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>shada_encode_jumps</name><parameter_list>(<parameter><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<macro><name>khash_t</name><argument_list>(<argument>bufset</argument>)</argument_list></macro> <expr_stmt><expr><name>removable_bufs</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_removable_bufs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PossiblyFreedShadaEntry</name></type> <name><name>jumps</name><index>[<expr><name>JUMPLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cleanup_jumplist</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>jumps_size</name> <init>= <expr><call><name>shada_init_jumps</name><argument_list>(<argument><expr><name>jumps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>msgpack_packer</name></type> <name>packer</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_packer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>msgpack_sbuffer_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>jumps_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>kSDWriteFailed</name> <operator>==</operator> <call><name>shada_pack_pfreed_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name><name>jumps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>shada_encode_buflist</name><parameter_list>(<parameter><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<macro><name>khash_t</name><argument_list>(<argument>bufset</argument>)</argument_list></macro> <expr_stmt><expr><name>removable_bufs</name> <operator>=</operator> <call><name>KHASH_EMPTY_TABLE</name><argument_list>(<argument><expr><name>bufset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_removable_bufs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ShadaEntry</name></type> <name>buflist_entry</name> <init>= <expr><call><name>shada_get_buflist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>removable_bufs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>msgpack_packer</name></type> <name>packer</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_packer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>msgpack_sbuffer_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kSDWriteFailed</name> <operator>==</operator> <call><name>shada_pack_entry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name>buflist_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>buflist_entry</name><operator>.</operator><name>data</name><operator>.</operator><name>buffer_list</name><operator>.</operator><name>buffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>shada_encode_gvars</name><parameter_list>(<parameter><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>msgpack_packer</name></type> <name>packer</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msgpack_packer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>packer</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>msgpack_sbuffer_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>var_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Timestamp</name></type> <name>cur_timestamp</name> <init>= <expr><call><name>os_time</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>typval_T</name></type> <name>vartv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>var_iter</name> <operator>=</operator> <call><name>var_shada_iter</name><argument_list>(
<argument><expr><name>var_iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>,
<argument><expr><name>VAR_FLAVOUR_DEFAULT</name> <operator>|</operator> <name>VAR_FLAVOUR_SESSION</name> <operator>|</operator> <name>VAR_FLAVOUR_SHADA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vartv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_FUNC</name> <operator>&amp;&amp;</operator> <name><name>vartv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_PARTIAL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>typval_T</name></type> <name>tgttv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tgttv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ShaDaWriteResult</name></type> <name>r</name> <init>= <macro><name>shada_pack_entry</name><argument_list>(<argument>&amp;packer</argument>, <argument>(ShadaEntry) {
.type = kSDItemVariable</argument>,
<argument>.timestamp = cur_timestamp</argument>,
<argument>.data = {
.global_var = {
.name = (char *)name</argument>,
<argument>.value = tgttv</argument>,
<argument>.additional_elements = NULL</argument>,
<argument>}
}
}</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kSDWriteFailed</name> <operator>==</operator> <name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgttv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vartv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>var_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>read_sbuf</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dest</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier></type><name>sbuf</name> <init>= <expr><operator>(</operator><name>msgpack_sbuffer</name> <operator>*</operator><operator>)</operator><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintmax_t</name></type> <name>bytes_read</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>sbuf</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>sbuf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name> <operator>+=</operator> <name>bytes_read</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>bytes_read</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> <name>sd_sbuf_reader_skip_read</name><parameter_list>(<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sd_reader</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier></type><name>sbuf</name> <init>= <expr><operator>(</operator><name>msgpack_sbuffer</name> <operator>*</operator><operator>)</operator><name><name>sd_reader</name><operator>-&gt;</operator><name>cookie</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sbuf</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintmax_t</name></type> <name>skip_bytes</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>sbuf</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_bytes</name> <operator>&lt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sd_reader</name><operator>-&gt;</operator><name>fpos</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>open_shada_sbuf_for_reading</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>,
<parameter><decl><type><name>ShaDaReadDef</name> <modifier>*</modifier></type><name>sd_reader</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sd_reader</name> <operator>=</operator> <operator>(</operator><name>ShaDaReadDef</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>read</name> <operator>=</operator> <operator>&amp;</operator><name>read_sbuf</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>skip</name> <operator>=</operator> <operator>&amp;</operator><name>sd_sbuf_reader_skip_read</name></expr>,
<expr><operator>.</operator><name>error</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>eof</name> <operator>=</operator> <name>false</name></expr>,
<expr><operator>.</operator><name>fpos</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>cookie</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sbuf</name></expr>,
}</block></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>shada_read_sbuf</name><parameter_list>(<parameter><decl><type><name>msgpack_sbuffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sbuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sbuf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sbuf</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ShaDaReadDef</name></type> <name>sd_reader</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>open_shada_sbuf_for_reading</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>shada_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sd_reader</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
