<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\spell.c">































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESCORE</name><parameter_list>(<parameter><type><name>word_score</name></type></parameter>, <parameter><type><name>sound_score</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((3 * word_score + sound_score) / 4)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXSCORE</name><parameter_list>(<parameter><type><name>word_score</name></type></parameter>, <parameter><type><name>sound_score</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((4 * word_score - sound_score) / 3)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/spell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/change.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/cursor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/edit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_cmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_cmds2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_docmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/func_attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/getchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/hashtab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mark.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/normal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os_unix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/screen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/search.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/spellfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/syntax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/undo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/input.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_MIXCAP</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_CAPMASK</name></cpp:macro> <cpp:value>(WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_BANNED</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_RARE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_OK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_LOCAL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_BAD</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>



<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>first_lang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>int_wordlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>wordcount_S</name> <block>{
<decl_stmt><decl><type><name>uint16_t</name></type> <name>wc_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>wc_word</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>wordcount_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WC_KEY_OFF</name></cpp:macro> <cpp:value>offsetof(wordcount_T, wc_word)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2WC</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXWORDCOUNT</name></cpp:macro> <cpp:value>0xffff</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>suginfo_S</name> <block>{
<decl_stmt><decl><type><name>garray_T</name></type> <name>su_ga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_maxcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_maxscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_sfmaxscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>su_sga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>su_badptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_badlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_badflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_fbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_sal_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>su_banned</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>su_sallang</name></decl>;</decl_stmt> 
}</block></struct></type> <name>suginfo_T</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>st_word</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_wordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_orglen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_altscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>st_salscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>st_had_bonus</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>st_slang</name></decl>;</decl_stmt> 
}</block></struct></type> <name>suggest_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG</name><parameter_list>(<parameter><type><name>ga</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((suggest_T *)(ga).ga_data)[i])</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAS_BANNED</name><parameter_list>(<parameter><type><name>su</name></type></parameter>, <parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!HASHITEM_EMPTY(hash_find(&amp;su-&gt;su_banned, word)))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG_CLEAN_COUNT</name><parameter_list>(<parameter><type><name>su</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((su)-&gt;su_maxcount &lt; 130 ? 150 : (su)-&gt;su_maxcount + 20)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG_MAX_COUNT</name><parameter_list>(<parameter><type><name>su</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SUG_CLEAN_COUNT(su) + 50)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SPLIT</name></cpp:macro> <cpp:value>149</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SPLIT_NO</name></cpp:macro> <cpp:value>249</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_ICASE</name></cpp:macro> <cpp:value>52</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_REGION</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_RARE</name></cpp:macro> <cpp:value>180</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SWAP</name></cpp:macro> <cpp:value>75</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SWAP3</name></cpp:macro> <cpp:value>110</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_REP</name></cpp:macro> <cpp:value>65</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SUBST</name></cpp:macro> <cpp:value>93</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SIMILAR</name></cpp:macro> <cpp:value>33</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SUBCOMP</name></cpp:macro> <cpp:value>33</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DEL</name></cpp:macro> <cpp:value>94</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DELDUP</name></cpp:macro> <cpp:value>66</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DELCOMP</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INS</name></cpp:macro> <cpp:value>96</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INSDUP</name></cpp:macro> <cpp:value>67</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INSCOMP</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_NONWORD</name></cpp:macro> <cpp:value>103</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_FILE</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_MAXINIT</name></cpp:macro> <cpp:value>350</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON1</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON2</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON3</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_THRES2</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_THRES3</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX1</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX2</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX3</name></cpp:macro> <cpp:value>400</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_BIG</name></cpp:macro> <cpp:value>SCORE_INS * 3</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_MAXMAX</name></cpp:macro> <cpp:value>999999</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_LIMITMAX</name></cpp:macro> <cpp:value>350</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_EDIT_MIN</name></cpp:macro> <cpp:value>SCORE_SIMILAR</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>matchinf_S</name> <block>{
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>mi_lp</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_word</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_fend</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_cend</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>char_u</name></type> <name><name>mi_fword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_fwordlen</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>mi_prefarridx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_prefcnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_prefixlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_cprefixlen</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>int</name></type> <name>mi_compoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>mi_compflags</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_complen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_compextra</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>mi_result</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mi_capflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>mi_win</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>mi_result2</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_end2</name></decl>;</decl_stmt> 
}</block></struct></type> <name>matchinf_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>spelload_S</name> <block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sl_lang</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>sl_slang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_nobreak</name></decl>;</decl_stmt> 
}</block></struct></type> <name>spelload_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SY_MAXLEN</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>syl_item_S</name> <block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sy_chars</name><index>[<expr><name>SY_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sy_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>syl_item_T</name>;</typedef>

<decl_stmt><decl><type><name>spelltab_T</name></type> <name>spelltab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>did_set_spelltab</name></decl>;</decl_stmt>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>short</name></type> <name>sft_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sft_word</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>sftword_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>badi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
}</block></struct></type> <name>limitscore_T</name>;</typedef>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"spell.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_YES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_INSERT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_PREFIXOK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_DIDSPLIT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_DIDDEL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_NOPREFIX</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_PREFIXTREE</name></cpp:macro> <cpp:value>0xfe</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_NOTSPECIAL</name></cpp:macro> <cpp:value>0xfd</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_FOLDWORD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_KEEPWORD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_PREFIX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_COMPOUND</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_KEEPCOMPOUND</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e_format</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E759: Format error in spell file"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>repl_from</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>repl_to</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>














<function><type><name>size_t</name></type> <name>spell_check</name><parameter_list>(
<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><name>hlf_T</name> <modifier>*</modifier></type><name>attrp</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>capcol</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>docount</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>matchinf_T</name></type> <name>mi</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>size_t</name></type> <name>nrlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wrongcaplen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>count_word</name> <init>= <expr><name>docount</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>matchinf_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>*</operator><operator>)</operator> <call><name>skipbin</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <call><name>skiphex</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <call><name>skipdigits</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>nrlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_word</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>capcol</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wrongcaplen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>capcol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_capflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_cend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_win</name></name> <operator>=</operator> <name>wp</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>, <argument><expr><name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_fwordlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result2</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_FOLDWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_KEEPWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>find_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_FOLDWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name>
<operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result2</name></name> <operator>!=</operator> <name>SP_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_result2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_end2</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>count_word</name> <operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>count_common_word</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count_word</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>!=</operator> <name>SP_OK</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>nrlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BANNED</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>nrlen</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>capcol</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>regmatch</name><operator>.</operator><name>endp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>==</operator> <name>ptr</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name>
<operator>&amp;&amp;</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_result</name> <init>= <expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_word</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fp</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name><name>mi</name><operator>.</operator><name>mi_end</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_compoff</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>fp</name> <operator>-</operator> <name><name>mi</name><operator>.</operator><name>mi_fword</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_COMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>!=</operator> <name>SP_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name>save_result</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BANNED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPB</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_RARE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPR</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wrongcaplen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_RARE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPC</name></expr>;</expr_stmt>
<return>return <expr><name>wrongcaplen</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>find_word</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_KEEPWORD</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wlen</name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_PREFIX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 

<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>endlen</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name></type> <name><name>endidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>endidxcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>





<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>endidxcnt</name> <operator>==</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>endidx</name><index>[<expr><name>endidxcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>arridx</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>



<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name> <init>= <expr><name>arridx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>hi</name> <init>= <expr><name>arridx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>idx_T</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>!=</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>word_ends</name></decl>;</decl_stmt>



<while>while <condition>(<expr><name>endidxcnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>--</operator><name>endidxcnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>endidx</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>utf_head_off</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<continue>continue;</continue> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>word_ends</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>word_ends</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>prefix_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>FIND_KEEPWORD</name> <operator>&amp;&amp;</operator> <name>has_mbyte</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>ptr</name></expr></init></decl>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name>wlen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>wlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition>
<incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>++</operator><name>arridx</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name> <init>= <expr><name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_FOLDWORD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name> <operator>!=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name> <operator>==</operator> <name>WF_KEEPCAP</name>
<operator>||</operator> <operator>!</operator><call><name>spell_valid_case</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if>



<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_PREFIX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prefix_found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefarridx</name></name></expr></argument>,
<argument><expr><name>flags</name></expr></argument>,
<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prefix_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name>
<operator>||</operator> <operator>!</operator><name>word_ends</name><operator>)</operator></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name>wlen</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>mb_charlen_len</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>,
<argument><expr><name>wlen</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name> <operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name> <operator>+</operator> <literal type="number">2</literal>
<operator>&gt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>==</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NOCOMPBEF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NOCOMPAFT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr>
</then><else>: <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></else></ternary></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>match_checkcompoundpattern</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>capflags</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>,
<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>ptr</name></expr></init></decl>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>capflags</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>capflags</name> <operator>==</operator> <name>WF_KEEPCAP</name> <operator>||</operator> <operator>(</operator><name>capflags</name> <operator>==</operator> <name>WF_ALLCAP</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>capflags</name> <operator>!=</operator> <name>WF_ALLCAP</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>capflags</name> <operator>==</operator> <name>WF_ONECAP</name></expr>
</then><else>: <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>capflags</name> <operator>!=</operator> <name>WF_ONECAP</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name><index>[<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name><index>[<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>word_ends</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>match_compoundrule</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>


<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nobreak_result</name> <init>= <expr><name>SP_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>save_result</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_end</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>save_lp</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPWORD</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>ptr</name></expr></init></decl>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name>wlen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
c = mip-&gt;mi_compoff;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_COMPROOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_win</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>!</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_COMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>||</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_KEEPCOMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 


if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {

mip-&gt;mi_compoff = c;
find_prefix(mip, FIND_COMPOUND);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>--</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_COMPROOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name> <operator>=</operator> <name>save_lp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nobreak_result</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>save_result</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name>save_end</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>SP_BAD</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_BANNED</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_region</name></name> <operator>&amp;</operator> <operator>(</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_LOCAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_RARE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>nobreak_result</name> <operator>==</operator> <name>SP_BAD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>&gt;</operator> <name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>==</operator> <name>res</name>
<operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>&gt;</operator> <name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>res</name> <operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type>
<name>match_checkcompoundpattern</name> <parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>wlen</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>wlen</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>can_compound</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>uflags</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>uflags</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uflags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_regexec_prog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name>
<operator>&amp;&amp;</operator> <call><name>count_syllables</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>bool</name></type> <name>can_be_compound</name><parameter_list>(<parameter><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>
?</condition><then> <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr> </then><else>: <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>v</name> <init>= <expr><call><name>match_compoundrule</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type> <name>match_compoundrule</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>compflags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>



<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>valid_word_prefix</name> <parameter_list>(
<parameter><decl><type><name>int</name></type> <name>totprefcnt</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>arridx</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>cond_req</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>prefcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefid</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prefid</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>prefcnt</name> <operator>=</operator> <name>totprefcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>prefcnt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>prefcnt</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>pidx</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name><index>[<expr><name>arridx</name> <operator>+</operator> <name>prefcnt</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>prefid</name> <operator>!=</operator> <operator>(</operator><name>pidx</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_HAS_AFF</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pidx</name> <operator>&amp;</operator> <name>WF_PFX_NC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>rp</name> <init>= <expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_prefprog</name><index>[<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>pidx</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_regexec_prog</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cond_req</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<return>return <expr><name>pidx</name></expr>;</return>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>find_prefix</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt> 



<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>





<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefarridx</name></name> <operator>=</operator> <name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr></argument>,
<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>arridx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>fold_more</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>,
<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>,
<argument><expr><name>MAXWLEN</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name> <operator>+=</operator> <name>flen</name></expr>;</expr_stmt>
<return>return <expr><name>flen</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type> <name>spell_valid_case</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>wordflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>treeflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>wordflags</name> <operator>==</operator> <name>WF_ALLCAP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <operator>(</operator><name>WF_ALLCAP</name> <operator>|</operator> <name>WF_KEEPCAP</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><name>wordflags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>no_spell_checking</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wp</name><operator>-&gt;</operator><name>w_p_spell</name></name> <operator>||</operator> <operator>*</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>==</operator> <name>NUL</name>
<operator>||</operator> <call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E756: Spell checking is not enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>size_t</name></type>
<name>spell_move_to</name> <parameter_list>(
<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>allwords</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>curline</name></decl></parameter>,
<parameter><decl><type><name>hlf_T</name> <modifier>*</modifier></type><name>attrp</name></decl></parameter> 

)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name></type> <name>found_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>found_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name> <init>= <expr><name>HLF_COUNT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_syntax</name> <init>= <expr><call><name>syntax_present</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>can_spell</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>capcol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>found_one</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>wrapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>










<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearpos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> <operator>&amp;&amp;</operator> <name>buflen</name> <operator>&gt;=</operator> <name>len</name> <operator>+</operator> <name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>capcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>capcol</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curline</name> <operator>&amp;&amp;</operator> <name>wp</name> <operator>==</operator> <name>curwin</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_need_cap</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>capcol</name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_cat_line</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>skip</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name>
<operator>&amp;&amp;</operator> <name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator><name>wrapped</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>&gt;=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>spell_check</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>capcol</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>HLF_COUNT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>allwords</name> <operator>||</operator> <name>attr</name> <operator>==</operator> <name>HLF_SPB</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name>
<operator>||</operator> <name>lnum</name> <operator>!=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name>
<operator>||</operator> <name>wrapped</name>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>curline</name></expr>
?</condition><then> <expr><name>p</name> <operator>-</operator> <name>buf</name> <operator>+</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>len</name></expr>
</then><else>: <expr><name>p</name> <operator>-</operator> <name>buf</name></expr></else></ternary><operator>)</operator> <operator>&gt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_syntax</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>syn_get_id</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><name>col</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>can_spell</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_spell</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>can_spell</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>can_spell</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>FORWARD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>found_pos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>attrp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curline</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>col</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>found_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>capcol</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name> <operator>&amp;&amp;</operator> <name><name>found_pos</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>found_pos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>found_len</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>curline</name></expr>)</condition> <block>{<block_content>
<break>break;</break> 
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name>wrapped</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lnum</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>p_ws</name></expr>)</condition> <block>{<block_content>
<break>break;</break> 
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>wrapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shortmess</name><argument_list>(<argument><expr><name>SHM_SEARCH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>give_warning</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>top_bot_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>capcol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>p_ws</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if> 
<else>else <block>{<block_content>


<expr_stmt><expr><name>lnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wrapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shortmess</name><argument_list>(<argument><expr><name>SHM_SEARCH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>give_warning</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>bot_top_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_one</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name>HLF_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>endp</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><operator>--</operator><name>capcol</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>capcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>spell_cat_line</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"*#/\"\t"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>maxlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>maxlen</name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_load_lang</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fname_enc</name><index>[<expr><literal type="number">85</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>spelload_T</name></type> <name>sl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>



<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>sl</name><operator>.</operator><name>sl_lang</name></name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>.</operator><name>sl_slang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>.</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname_enc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">5</literal></expr></argument>,
<argument><expr><literal type="string">"spell/%s.%s.spl"</literal></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>sl</name><operator>.</operator><name>sl_lang</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname_enc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">5</literal></expr></argument>,
<argument><expr><literal type="string">"spell/%s.ascii.spl"</literal></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>sl</name><operator>.</operator><name>sl_lang</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>round</name> <operator>==</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_SPELLFILEMISSING</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>,
<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>starting</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>char</name></type> <name><name>autocmd_buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>autocmd_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>autocmd_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"autocmd VimEnter * call spellfile#LoadFile('%s')|set spell"</literal></expr></argument>,
<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><name>autocmd_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sl</name><operator>.</operator><name>sl_slang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>fname_enc</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"add.spl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><name>DIP_ALL</name></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>char_u</name> <modifier>*</modifier></type><name>spell_enc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_enc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">60</literal> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>p_enc</name></expr></argument>, <argument><expr><literal type="string">"iso-8859-15"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p_enc</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"latin1"</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>int_wordlist_spl</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>SPL_FNAME_TMPL</name></expr></argument>,
<argument><expr><name>int_wordlist</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>slang_T</name> <modifier>*</modifier></type><name>slang_alloc</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slang_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>slang_free</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>slang_clear</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>free_salitem</name><parameter_list>(<parameter><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>free_fromto</name><parameter_list>(<parameter><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>slang_clear</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>, <argument><expr><name>fromto_T</name></expr></argument>, <argument><expr><name>free_fromto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr></argument>, <argument><expr><name>fromto_T</name></expr></argument>, <argument><expr><name>free_fromto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sofo</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GA_DEEP_CLEAR_PTR</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>salitem_T</name></expr></argument>, <argument><expr><name>free_salitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_comprules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>WC_KEY_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>slang_clear_sug</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_regions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>slang_clear_sug</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_spellbuf</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugloaded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugtime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_load_cb</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>spelload_T</name> <modifier>*</modifier></type><name>slp</name> <init>= <expr><operator>(</operator><name>spelload_T</name> <operator>*</operator><operator>)</operator><name>cookie</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <call><name>spell_load_file</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_lang</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>slp</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_add</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>count_common_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordcount_T</name> <modifier>*</modifier></type><name>wc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>p_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>p_len</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wordcount_T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>p_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_word</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_word</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>+=</operator> <name>count</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>=</operator> <name>MAXWORDCOUNT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>score_wordcount_adj</name> <parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>split</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordcount_T</name> <modifier>*</modifier></type><name>wc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bonus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newscore</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>&lt;</operator> <name>SCORE_THRES2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON1</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>&lt;</operator> <name>SCORE_THRES3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON2</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON3</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>score</name> <operator>-</operator> <name>bonus</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>score</name> <operator>-</operator> <name>bonus</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>newscore</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>bool</name></type> <name>byte_in_str</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type> <name>init_syl_tab</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>syl_item_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>SY_MAXLEN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>syl_item_T</name> <modifier>*</modifier></type><name>syl</name> <init>= <expr><call><name>GA_APPEND_VIA_PTR</name><argument_list>(<argument><expr><name>syl_item_T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_chars</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>count_syllables</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>skip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>syl_item_T</name> <modifier>*</modifier></type><name>syl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>word</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <name>len</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>syl</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>syl_item_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name> <operator>&gt;</operator> <name>len</name>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_chars</name></name></expr></argument>, <argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>char_u</name> <modifier>*</modifier></type><name>did_set_spelllang</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>splp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>region_cp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>region_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>lang</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>spf_name</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>use_region</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>dont_use_region</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>nobreak</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lp2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>recursive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ret_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spl_copy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bufref_T</name></type> <name>bufref</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>, <argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>recursive</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>langp_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_midword</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>spl_copy</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>splp</name> <operator>=</operator> <name>spl_copy</name></expr>;</init> <condition><expr><operator>*</operator><name>splp</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>splp</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>region</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_spellang</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="string">"cjk"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>fnamecmp</name><argument_list>(<argument><expr><name>lang</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><call><name>path_tail</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>region_cp</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>lang</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>region</name> <operator>=</operator> <name>region_cp</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</init> <condition><expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>slang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>path_full_compare</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>kEqualFiles</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>lang</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>region</name> <operator>=</operator> <name>lang</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lang</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</init> <condition><expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>slang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>use_region</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>region</name></expr></argument>, <argument><expr><name>use_region</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>use_region</name> <operator>=</operator> <name>region</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_load_file</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>spell_load_lang</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret_msg</name> <operator>=</operator>
<operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E797: SpellFileMissing autocommand deleted buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</init> <condition><expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>slang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>filename</name></expr>
?</condition><then> <expr><call><name>path_full_compare</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>kEqualFiles</name></expr>
</then><else>: <expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <name>REGION_ALL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name> <operator>&amp;&amp;</operator> <name>region</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>find_region</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr></argument>, <argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>REGION_ALL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_add</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>


<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: region %s not supported"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region_mask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>p_</name> <init>= <expr><call><name>GA_APPEND_VIA_PTR</name><argument_list>(<argument><expr><name>langp_T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_region</name></name> <operator>=</operator> <name>region_mask</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>use_midword</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nobreak</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>





<expr_stmt><expr><name>spf</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>spf</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>int_wordlist_spl</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spf</name></expr></argument>, <argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>lp_slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>path_full_compare</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>kEqualFiles</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<for>for <control>(<init><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</init> <condition><expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>slang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>path_full_compare</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>kEqualFiles</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="string">"internal wordlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>path_tail</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <call><name>spell_load_file</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nobreak</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <name>REGION_ALL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>use_region</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dont_use_region</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>find_region</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr></argument>, <argument><expr><name>use_region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>REGION_ALL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region_mask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>p_</name> <init>= <expr><call><name>GA_APPEND_VIA_PTR</name><argument_list>(<argument><expr><name>langp_T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_</name><operator>-&gt;</operator><name>lp_region</name></name> <operator>=</operator> <name>region_mask</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>use_midword</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name> <operator>=</operator> <name>ga</name></expr>;</expr_stmt>




<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp2</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>,
<argument><expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>=</operator> <name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp2</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>,
<argument><expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>=</operator> <name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for></block_content></block></else></if_stmt>
</block_content>}</block></for>

<label><name>theend</name>:</label>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>spl_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>redraw_win_later</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret_msg</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_midword</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>use_midword</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>bp</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>find_region</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>REGION_ALL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>region</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>rp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>region</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>i</name> <operator>/</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>captype</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstcap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>allcap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>past_second</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> 


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>end</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr> </then><else>: <expr><name>p</name> <operator>&gt;=</operator> <name>end</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>firstcap</name> <operator>=</operator> <name>allcap</name> <operator>=</operator> <call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<for>for <control>(<init>;</init> <condition><expr><ternary><condition><expr><name>end</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr> </then><else>: <expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr></else></ternary></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>past_second</name> <operator>&amp;&amp;</operator> <name>allcap</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>WF_KEEPCAP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>allcap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>allcap</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>WF_KEEPCAP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>past_second</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>allcap</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>WF_ALLCAP</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>firstcap</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>WF_ONECAP</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>




<function><type><specifier>static</specifier> <name>int</name></type> <name>badword_captype</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>captype</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>u</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>word</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>l</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>





<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;</operator> <name>l</name> <operator>&amp;&amp;</operator> <name>u</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ALLCAP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_MIXCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>spell_delete_wordlist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fname</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>os_remove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>int_wordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>int_wordlist_spl</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>os_remove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>int_wordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>spell_free_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>


<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<while>while <condition>(<expr><name>first_lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</expr_stmt>
<expr_stmt><expr><name>first_lang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>slang_free</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>spell_delete_wordlist</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>spell_reload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>init_spell_chartab</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>spell_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<macro><name>FOR_ALL_WINDOWS_IN_TAB</name><argument_list>(<argument>wp</argument>, <argument>curtab</argument>)</argument_list></macro> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_p_spell</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>did_set_spelllang</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>bytes2offset</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x00</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xe0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xc0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>nr</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>buf_T</name> <modifier>*</modifier></type><name>open_spellbuf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_spell</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_swf</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>ml_open</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ELOG</name><argument_list>(<argument><expr><literal type="string">"Error opening a new memline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ml_open_file</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>close_spellbuf</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ml_close</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>clear_spell_chartab</name><parameter_list>(<parameter><decl><type><name>spelltab_T</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></for>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'z'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>init_spell_chartab</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>did_set_spelltab</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_spell_chartab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spelltab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><call><name>utf_fold</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u</name> <init>= <expr><call><name>mb_toupper</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>mb_isupper</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <call><name>mb_islower</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>f</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><name>f</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>u</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><name>u</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>bool</name></type> <name>spell_iswordp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>l</name> <init>= <expr><call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>
?</condition><then> <expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><name>c</name></expr>]</index></name></expr>
</then><else>: <expr><operator>(</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>mb_get_class</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>



<function><type><name>bool</name></type> <name>spell_iswordp_nmw</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>mb_get_class</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type> <name>spell_mb_isword_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cl</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>cl</name> <operator>==</operator> <literal type="number">0x2800</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>cl</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">0x2070</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">0x2080</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>spell_iswordp_w</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>
</then><else>: <expr><operator>(</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>utf_class</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><operator>*</operator><name>s</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>spell_casefold</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>buflen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>outi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>str</name> <operator>+</operator> <name>len</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>outi</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>buflen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>outi</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outi</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>outi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>outi</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_BEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_FAST</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_DOUBLE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sps_flags</name> <init>= <expr><name>SPS_BEST</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sps_limit</name> <init>= <expr><literal type="number">9999</literal></expr></init></decl>;</decl_stmt> 



<function><type><name>int</name></type> <name>spell_check_sps</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>p_sps</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <call><name>getdigits_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"best"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_FAST</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"double"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_DOUBLE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"expr:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>sps_flags</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>f</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>spell_suggest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name></type> <name>prev_cursor</name> <init>= <expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>wcopy</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suginfo_T</name></type> <name>sug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mouse_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_cap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>selected</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>msg_scroll_save</name> <init>= <expr><name>msg_scroll</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>VIsual_active</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <name><name>VIsual</name><operator>.</operator><name>lnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_beep</name><argument_list>(<argument><expr><name>BO_SPELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>VIsual</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>-</operator><name>badlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name><name>VIsual</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>badlen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>end_visual_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else

if <condition>(<expr><call><name>spell_move_to</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>&gt;</operator> <name><name>prev_cursor</name><operator>.</operator><name>col</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>prev_cursor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>get_cursor_line_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>line</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <call><name>check_need_cap</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>get_cursor_line_ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>sps_limit</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Rows</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Rows</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>sps_limit</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>spell_find_suggest</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>, <argument><expr><name>badlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><name>need_cap</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, no suggestions"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, only %"</literal> <name>PRId64</name> <literal type="string">" suggestions"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>cmdmsg_rl</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_p_rl</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <name>Columns</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_row</name> <operator>=</operator> <name>Rows</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>lines_left</name> <operator>=</operator> <name>Rows</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Change \"%.*s\" to:"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"Change"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">":ot \"%.*s\" egnahC"</literal></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>wcopy</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&gt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rl_mirror</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name>wcopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&lt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" &lt; \"%.*s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <operator>(</operator><name>SPS_DOUBLE</name> <operator>|</operator> <name>SPS_BEST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" (%s%d - %d)"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name></expr> ?</condition><then> <expr><literal type="string">"s "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rl_mirror</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>msg_advance</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>cmdmsg_rl</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>selected</name> <operator>=</operator> <call><name>prompt_for_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mouse_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mouse_used</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>selected</name> <operator>-=</operator> <name>lines_left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lines_left</name> <operator>=</operator> <name>Rows</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>msg_scroll_save</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>selected</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selected</name> <operator>&lt;=</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <call><name>u_save_cursor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>selected</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&gt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>repl_from</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s%.*s"</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repl_to</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>repl_from</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repl_to</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>c</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendToRedobuff</name><argument_list>(<argument><expr><literal type="string">"ciw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendToRedobuffLit</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>c</name></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendCharToRedobuff</name><argument_list>(<argument><expr><name>ESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>prev_cursor</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>spell_find_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_need_cap</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>need_cap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>colnr_T</name></type> <name>endcol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>get_cursor_line_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>col</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name>lnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>line_copy</name> <operator>=</operator> <call><name>concat_str</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>line_copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endcol</name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>endcol</name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>endcol</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>endcol</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>line</name> <operator>||</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>regmatch</name><operator>.</operator><name>endp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>line</name> <operator>+</operator> <name>endcol</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>line_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>need_cap</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>ex_spellrepall</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name> <init>= <expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>frompat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>save_ws</name> <init>= <expr><name>p_ws</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>prev_lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>repl_from</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>repl_to</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E752: No previous spell replacement"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>frompat</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>frompat</name></expr></argument>, <argument><expr><literal type="string">"\\V\\&lt;%s\\&gt;"</literal></expr></argument>, <argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_ws</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_nsubs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_nlines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_search</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>frompat</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>SEARCH_KEEP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>u_save_cursor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>get_cursor_line_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>,
<argument><expr><name>repl_to</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>addlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>, <argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <name>prev_lnum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>sub_nlines</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_lnum</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>sub_nsubs</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>p_ws</name> <operator>=</operator> <name>save_ws</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>frompat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sub_nsubs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E753: Not found: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>do_sub_msg</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>spell_suggest_list</name> <parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxcount</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>need_cap</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>interactive</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suginfo_T</name></type> <name>sug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>spell_find_suggest</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>need_cap</name></expr></argument>, <argument><expr><name>interactive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>wcopy</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name>
<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>wcopy</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>wcopy</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>spell_find_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_find_suggest</name> <parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badptr</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>badlen</name></decl></parameter>, 
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxcount</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>banbadword</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>need_cap</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>interactive</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name> <init>= <expr><name>HLF_COUNT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>do_combine</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sps_copy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>expr_busy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suginfo_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>badptr</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>=</operator> <name>badptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tmplen</name> <init>= <expr><call><name>spell_check</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tmplen</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>tmplen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name> <operator>=</operator> <name>maxcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_MAXINIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>&gt;=</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>need_cap</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sal_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>attr</name> <operator>==</operator> <name>HLF_COUNT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>WF_ONECAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name>SCORE_ICASE</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>banbadword</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_banned</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>sps_copy</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>p_sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>sps_copy</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"expr:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr_busy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expr_busy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_suggest_expr</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expr_busy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_suggest_file</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>spell_suggest_intern</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>interactive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>do_combine</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>sps_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_combine</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>score_combine</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_expr</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>eval_spell_expr</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<macro><name>TV_LIST_ITER</name><argument_list>(<argument>list</argument>, <argument>li</argument>, <argument>{
if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {

score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);
if (score &gt;= <literal type="number">0</literal> &amp;&amp; score &lt;= su-&gt;su_maxscore) {
add_suggestion(su, &amp;su-&gt;su_ga, (const char_u *)p, su-&gt;su_badlen,
score, <literal type="number">0</literal>, true, su-&gt;su_sallang, false);
}
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_file</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>line</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>os_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRICMP</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><operator>++</operator><name>len</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>captype</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>SCORE_FILE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_intern</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>interactive</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>suggest_load_files</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>suggest_try_special</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>suggest_try_change</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>score_comp_sal</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_FAST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_BEST</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>rescore_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>









<expr_stmt><expr><call><name>suggest_try_soundalike_prep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>=</operator> <name>SCORE_MAXINIT</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&lt;</operator> <call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&lt;</operator> <call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX3</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>os_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>interactive</name> <operator>&amp;&amp;</operator> <name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_BEST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rescore_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_find_cleanup</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_SUG_WORD</name><parameter_list>(<parameter><type><name>sug</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xfree(sug-&gt;st_word)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>suggest_T</name></expr></argument>, <argument><expr><name>FREE_SUG_WORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>suggest_T</name></expr></argument>, <argument><expr><name>FREE_SUG_WORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>onecap_copy</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>upper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>upper</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>wcopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>allcap_copy</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>wcopy</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0xdf</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>-</operator> <name>wcopy</name> <operator>&gt;=</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>-</operator> <name>wcopy</name> <operator>&gt;=</operator> <name>MAXWLEN</name> <operator>-</operator> <name>MB_MAXBYTES</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_special</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><call><name>RESCORE</name><argument_list>(<argument><expr><name>SCORE_REP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>current</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proftime_T</name></type> <name><name>times</name><index>[<expr><name>STATE_FINAL</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name><name>counts</name><index>[<expr><name>STATE_FINAL</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATE_FINAL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>profile_zero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>times</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>profile_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>profile_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_store</name><parameter_list>(<parameter><decl><type><name>state_T</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>profile_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>profile_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>times</name><index>[<expr><name>state</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>counts</name><index>[<expr><name>state</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>profile_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROF_STORE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>prof_store(state);</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_report</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"suggestprof"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>profile_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"-----------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>profile_msg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>STATE_FINAL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%d: %s ("</literal><operator>%</operator><literal type="string">" PRId64)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>profile_msg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>times</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROF_STORE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_change</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>suggest_trie_walk</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_report</name><argument_list>(<argument><expr><literal type="string">"try_change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_DEEPER</name><parameter_list>(<parameter><type><name>su</name></type></parameter>, <parameter><type><name>stack</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>, <parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(stack[depth].ts_score + (add) &lt; su-&gt;su_maxscore)</cpp:value></cpp:define>































<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_trie_walk</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>soundfold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>tword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>trystate_T</name></type> <name><name>stack</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>preword</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt> 




<decl_stmt><decl><type><name>char_u</name></type> <name><name>compflags</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fbyts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pbyts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fidxs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pidxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>c3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repextra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fword_ends</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>goodword_ends</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>changename</name><index>[<expr><name>MAXWLEN</name></expr>]</index><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>breakcheckcount</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>compound_ok</name></decl>;</decl_stmt>





<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trystate_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbyts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pidxs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>fbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pbyts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_PREFIXTREE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_NOPREFIX</name></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>






<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STATE_START</name></expr>:</case>
<case>case <expr><name>STATE_NOPREFIX</name></expr>:</case>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt> 
<expr_stmt><expr><name>arridx</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>==</operator> <name>PFD_PREFIXTREE</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name> <operator>+</operator> <name>n</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_ENDNUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>STATE_NOPREFIX</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name>len</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_ENDNUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NOSUGGEST</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fword_ends</name> <operator>=</operator> <operator>(</operator><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <name>NUL</name>
<operator>||</operator> <operator>(</operator><ternary><condition><expr><name>soundfold</name></expr>
?</condition><then> <expr><call><name>ascii_iswhite</name><argument_list>(<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>&lt;=</operator> <name>PFD_NOTSPECIAL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_PREFIXOK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name></expr>]</index></name><operator>.</operator><name>ts_arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pbyts</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>pbyts</name><index>[<expr><name>n</name> <operator>+</operator> <name>c</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>|=</operator> <name>TSF_PREFIXOK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name> <operator>&amp;&amp;</operator> <name>fword_ends</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name>
<operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>preword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>newscore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>match_checkcompoundpattern</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compound_ok</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>fword_ends</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>find_keepcap_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_ALLCAP</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>==</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>
)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>&amp;=</operator> <operator>~</operator><name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_banned</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <call><name>WAS_BANNED</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <call><name>WAS_BANNED</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_REGION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_valid_case</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>,
<argument><expr><call><name>captype</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>fword_ends</name>
<operator>&amp;&amp;</operator> <name>goodword_ends</name>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name>
<operator>&amp;&amp;</operator> <name>compound_ok</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><literal type="string">"smwrd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><literal type="string">"------ %s -------"</literal></expr></argument>, <argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>depth</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>changename</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>add_sound_suggest</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_NONWORD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>+</operator> <name>newscore</name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>score</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>&amp;</operator> <name>WF_MIXCAP</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>WF_ALLCAP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>WF_ALLCAP</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>score</name> <operator>+</operator> <name>SCORE_ICASE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name> <operator>||</operator> <name>fword_ends</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>has_mbyte</name> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>
)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>try_compound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>try_split</name></decl>;</decl_stmt>






<expr_stmt><expr><name>try_split</name> <operator>=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name></expr>;</expr_stmt>













<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nocompoundsugs</name></name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&gt;=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>has_mbyte</name>
<operator>||</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call>
<operator>&gt;=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>can_be_compound</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>compflags</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nocompoundsugs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>fword_ends</name>
<operator>&amp;&amp;</operator> <name>try_compound</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDSPLIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>|=</operator> <name>TSF_DIDSPLIT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TSF_DIDSPLIT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>try_split</name> <operator>||</operator> <name>try_compound</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>fword_ends</name> <operator>||</operator> <operator>!</operator><name>goodword_ends</name><operator>)</operator></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nosplitsugs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_SPLIT_NO</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_SPLIT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fword_ends</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: split"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: compound"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SPLITUNDO</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fword_ends</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>fword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <name>fword_ends</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name>goodword_ends</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fword_ends</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SPLIT</name> <operator>-</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>try_compound</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>pbyts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_PREFIXTREE</name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_NOPREFIX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_SPLITUNDO</name></expr>:</case>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name></expr>;</expr_stmt>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>


<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STATE_ENDNUL</name></expr>:</case>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>
)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_DEL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_PLAIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_PLAIN</name></expr>:</case>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_DEL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>arridx</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>!=</operator> <name>DIFF_NONE</name><operator>)</operator></expr>
)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newscore</name> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDDEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name>c</name> <operator>!=</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_delidx</name></name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: subst %c to %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: accept %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>==</operator> <name>SCORE_SUBST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <name>DIFF_YES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <call><name>MB_BYTE2LEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newscore</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>
?</condition><then> <expr><name>DIFF_YES</name></expr> </then><else>: <expr><name>DIFF_NONE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_INSERT</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><operator>--</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_YES</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name>
<operator>+</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>utf_iscomposing</name><argument_list>(<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name>
<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>utf_iscomposing</name><argument_list>(<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>fword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SUBCOMP</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(
<expr><operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(
<argument><expr><name>slang</name></expr></argument>,
<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_INSERT</name>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>utf_iscomposing</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name> <operator>-</operator> <name>SCORE_INSCOMP</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>tword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name> <operator>-</operator> <name>SCORE_INSDUP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_DEL</name></expr>:</case>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_INS_PREP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_DEL</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_DEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: delete %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_flags</name> <operator>|=</operator> <name>TSF_DIDDEL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_delidx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>





<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidx</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>utf_iscomposing</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>-=</operator> <name>SCORE_DEL</name> <operator>-</operator> <name>SCORE_DELCOMP</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>-=</operator> <name>SCORE_DEL</name> <operator>-</operator> <name>SCORE_DELDUP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_INS_PREP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDDEL</name></expr>)</condition> <block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_INS</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>

<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_INS</name></expr>:</case>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_INS</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_INS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: insert %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_BYTE2LEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <name>fl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <name>DIFF_INSERT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>&gt;=</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name> <operator>-</operator> <name>SCORE_INSDUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_SWAP</name></expr>:</case>



<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c2</name></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP3</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>changename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%.*s-%s: swap %c and %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNSWAP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>mb_char2len</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNSWAP</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_SWAP3</name></expr>:</case>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>







<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c3</name> <operator>||</operator> <name>c3</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: swap3 %c and %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNSWAP3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>mb_char2len</name><argument_list>(<argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNSWAP3</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: rotate left %c%c%c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNROT3L</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>+=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNROT3L</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: rotate right %c%c%c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNROT3R</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNROT3R</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_REP_INI</name></expr>:</case>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name><operator>)</operator>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>+</operator> <name>SCORE_REP</name> <operator>&gt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_repsal_first</name><index>[<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep_first</name><index>[<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>

<case>case <expr><name>STATE_REP</name></expr>:</case>



<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name> <operator>!=</operator> <operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_REP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_REP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: replace %s with %s"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_UNDO</name></expr>;</expr_stmt>


<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>!=</operator> <name>tl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repextra</name> <operator>+=</operator> <name>tl</name> <operator>-</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_tcharlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>==</operator> <name>STATE_REP</name></expr>)</condition><block type="pseudo"><block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>STATE_REP_UNDO</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>!=</operator> <name>tl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repextra</name> <operator>-=</operator> <name>tl</name> <operator>-</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_prefixdepth</name> <operator>==</operator> <name>PFD_PREFIXTREE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>--</operator><name>breakcheckcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>os_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>breakcheckcount</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>go_deeper</name><parameter_list>(<parameter><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>score_add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_state</name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>+</operator> <name>score_add</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_curi</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>nofold_len</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>fword</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>fword</name> <operator>+</operator> <name>flen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>word</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>find_keepcap_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>kword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>uword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>tryidx</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>round</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>fwordidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>uwordidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>kwordlen</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>, <decl><type ref="prev"/><name>ulen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name> <init>= <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name> <init>= <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>kword</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>allcap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>uword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>round</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fwordidx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uwordidx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>kword</name><index>[<expr><name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>++</operator><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ulen</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ulen</name> <operator>=</operator> <name>flen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>flen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>ulen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>tryidx</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</init> <condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>l</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>tryidx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>tryidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>tryidx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>tryidx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>kword</name> <operator>+</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>,
<argument><expr><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>flen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>kword</name> <operator>+</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>,
<argument><expr><name>ulen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>ulen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>fwordidx</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>flen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uwordidx</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>ulen</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name>tryidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<expr_stmt><expr><operator>*</operator><name>kword</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>score_comp_sal</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>sstp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>SCORE_MAXMAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sstp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>score_combine</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>SCORE_BIG</name><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">3</literal>
<operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>spell_edit_score</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name>SCORE_BIG</name> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suginfo_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>


<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>st_word</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name> <operator>=</operator> <name>ga</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>stp_sal_score</name> <parameter_list>(
<parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>,
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pbad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pgood</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound2</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>goodsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>goodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lendiff</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lendiff</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lendiff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pbad</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>ascii_iswhite</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name><index>[<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>fword</name></expr>;</init> <condition><expr><operator>*</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>badsound2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbad</name> <operator>=</operator> <name>badsound2</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lendiff</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <name>lendiff</name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>goodword</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>-</operator> <name>lendiff</name></expr></argument>, <argument><expr><name>lendiff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pgood</name> <operator>=</operator> <name>goodword</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pgood</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>pgood</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>goodsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>soundalike_score</name><argument_list>(<argument><expr><name>goodsound</name></expr></argument>, <argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sftword_T</name></type> <name>dumsft</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIKEY2SFT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sftword_T *)(p - (dumsft.sft_word - (char_u *)&amp;dumsft)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2SFT</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HIKEY2SFT((hi)-&gt;hi_key)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike_prep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>salword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>salword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>suggest_trie_walk</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>salword</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_report</name><argument_list>(<argument><expr><literal type="string">"soundalike"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>todo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name><operator>.</operator><name>ht_used</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name><operator>.</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>HI2SFT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>


<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_sound_suggest</name> <parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>, 
<parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sfwordnr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>nrline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orgnr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>theword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sftword_T</name> <modifier>*</modifier></type><name>sft</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>





<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>goodword_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>goodword</name></expr></argument>, <argument><expr><name>goodword_len</name></expr></argument>,
<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sft</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sftword_T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>goodword_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_word</name></name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>goodword_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_word</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>sft</name> <operator>=</operator> <call><name>HI2SFT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;=</operator> <name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>sfwordnr</name> <operator>=</operator> <call><name>soundfold_find</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sfwordnr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>internal_error</name><argument_list>(<argument><expr><literal type="string">"add_sound_suggest()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>nrline</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>sfwordnr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orgnr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>nrline</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>orgnr</name> <operator>+=</operator> <call><name>bytes2offset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wordcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>wlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wlen</name> <operator>&lt;</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>wlen</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wordcount</name> <operator>==</operator> <name>orgnr</name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>wordcount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init>;</init> <condition><expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>theword</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><literal type="string">"BAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wlen</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<goto>goto <name>badword</name>;</goto>
</block_content>}</block></if></if_stmt></block_content></block></for>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>wordcount</name> <operator>+</operator> <name>wc</name> <operator>&gt;</operator> <name>orgnr</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>wordcount</name> <operator>+=</operator> <name>wc</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>theword</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<label><name>badword</name>:</label>
<expr_stmt><expr><name><name>theword</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NOSUGGEST</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>find_keepcap_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>theword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_CAPMASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>theword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>theword</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>score</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <name>SCORE_REGION</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>





<expr_stmt><expr><name>gc</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <name>SCORE_ICASE</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>








<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>MAXSCORE</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>-</operator> <name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <name>SCORE_LIMITMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <call><name>spell_edit_score</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <call><name>spell_edit_score_limit</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>goodscore</name> <operator>&lt;</operator> <name>SCORE_MAXMAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <call><name>RESCORE</name><argument_list>(<argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>goodscore</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>soundfold_find</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>word</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordnr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>



<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>++</operator><name>wordnr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wordnr</name> <operator>+=</operator> <name><name>idxs</name><index>[<expr><name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>wordnr</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>make_case_word</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_ALLCAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>allcap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>onecap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>cword</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>similar_chars</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m1</name></decl>, <decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MB_MAXBYTES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>c1</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>m1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>c2</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>m1</name> <operator>==</operator> <name>m2</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_suggestion</name> <parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, 
<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>badlenarg</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>altscore</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>had_bonus</name></decl></parameter>, 
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>maxsf</name></decl></parameter> 

)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>goodlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name></type> <name>new_sug</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>pgood</name> <init>= <expr><name>goodword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pbad</name> <init>= <expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>badlenarg</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pgood</name> <operator>-</operator> <name>goodword</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pbad</name> <operator>-</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>goodlen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>badlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>pgood</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>pgood</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>goodlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>


<return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GA_EMPTY</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>stp</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>==</operator> <name>goodlen</name>
<operator>&amp;&amp;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>==</operator> <name>badlen</name>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>goodlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_altscore</name></name> <operator>=</operator> <name>altscore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>had_bonus</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>!=</operator> <name>had_bonus</name></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>had_bonus</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_word</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_wordlen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_slang</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_orglen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>&gt;</operator> <name><name>new_sug</name><operator>.</operator><name>st_score</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_score</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_altscore</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_had_bonus</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <call><name>GA_APPEND_VIA_PTR</name><argument_list>(<argument><expr><name>suggest_T</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>goodlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>=</operator> <name>goodlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name>altscore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>had_bonus</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <call><name>SUG_MAX_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>maxsf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>=</operator> <call><name>cleanup_suggestions</name><argument_list>(<argument><expr><name>gap</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr></argument>, <argument><expr><call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <call><name>cleanup_suggestions</name><argument_list>(<argument><expr><name>gap</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_suggestions</name> <parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>longword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>longword</name></expr></argument>, <argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_wordlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>longword</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_orglen</name></expr></argument>,
<argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_check</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>longword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>HLF_COUNT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>stp</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>stp</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>add_banned</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>word_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>word</name></expr></argument>, <argument><expr><name>word_len</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>rescore_suggestions</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>rescore_one</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sal_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sal_badword</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sal_badword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>sal_badword</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name>SCORE_BIG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <call><name>RESCORE</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>sug_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator><name>suggest_T</name> <operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><name>suggest_T</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>st_score</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>st_score</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>st_altscore</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>STRICMP</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>cleanup_suggestions</name> <parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxscore</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>keep</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name> <init>= <expr><operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sug_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <name>keep</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>keep</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <name>keep</name></expr>;</expr_stmt>
<return>return <expr><name><name>stp</name><index>[<expr><name>keep</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>st_score</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>maxscore</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>char</name> <modifier>*</modifier></type><name>eval_soundfold</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>word</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_p_spell</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>lpi</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lp</name> <init>= <expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>word</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>sound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>sound</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><name>void</name></type> <name>spell_soundfold</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>folded</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sofo</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_soundfold_sofo</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>inword</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>folded</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>word</name> <operator>=</operator> <name>inword</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>inword</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>inword</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>word</name> <operator>=</operator> <name>fword</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>spell_soundfold_wsal</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_soundfold_sofo</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>prevc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>inword</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>utf_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ip</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ip</name> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ip</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>prevc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ri</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>res</name> <operator>+</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>inword</name></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ascii_iswhite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ri</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>res</name><index>[<expr><name>ri</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>ri</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>ri</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>spell_soundfold_wsal</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name> <init>= <expr><operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wres</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ws</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reslen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>z0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p0</name> <init>= <expr><operator>-</operator><literal type="number">333</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>did_white</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordlen</name></decl>;</decl_stmt>





<expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>inword</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_rem_accents</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>utf_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>did_white</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>did_white</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>did_white</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordlen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>




<expr_stmt><expr><name>i</name> <operator>=</operator> <name>reslen</name> <operator>=</operator> <name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><operator>(</operator><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_oneof_w</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pri</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k0</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pri</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>
<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>word</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal>
<operator>||</operator> <call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'$'</literal>
<operator>||</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>c0</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n0</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_followup</name></name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n0</name> <operator>&gt;=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>p0</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>


<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><operator>(</operator><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>
<operator>==</operator> <operator>(</operator><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>n0</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c0</name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>k0</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pf</name> <operator>=</operator> <name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name><operator>++</operator> <operator>!=</operator> <name><name>ws</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>k0</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_oneof_w</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>


<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>k0</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ascii_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>,
<argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>==</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&lt;</operator> <name>pri</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&gt;=</operator> <name>pri</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name><name>sm_lead_w</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>
<operator>==</operator> <operator>(</operator><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_to_w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p0</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>z</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ws</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>c</name>
<operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>*</operator><name>ws</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reslen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k0</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ws</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>wordlen</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>k</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>ws</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ws</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"^^"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>wordlen</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ascii_iswhite</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>z0</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>p0</name> <operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_collapse</name></name> <operator>||</operator> <name>reslen</name> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>


<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>reslen</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name><name>wres</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>res</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>MAXWLEN</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>soundalike_score</name> <parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodstart</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badstart</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodsound</name> <init>= <expr><name>goodstart</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name> <init>= <expr><name>badstart</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pl2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ps2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>badsound</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>*</operator><name>goodsound</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>badsound</name> <operator>!=</operator> <operator>*</operator><name>goodsound</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>badsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>goodsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>badsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <name><name>goodsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name><name>badsound</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name><name>goodsound</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_DEL</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>badsound</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>badsound</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>goodsound</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>goodsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>n</name> <operator>=</operator> <name>goodlen</name> <operator>-</operator> <name>badlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">2</literal> <operator>||</operator> <name>n</name></expr></argument> &gt;</argument_list></name> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <name>goodsound</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name>goodsound</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <operator>*</operator><name>ps</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pl</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps</name></expr>;</expr_stmt>
</block_content>}</block></while>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>
<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt> 
<while>while <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <operator>*</operator><name>ps</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>*</operator> <literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<case>case <expr><literal type="number">1</literal></expr>:</case>



<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_INS</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_INS</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pbc</name></decl>, <decl><type ref="prev"/><name>pgc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wgoodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>l_has_mbyte</name> <init>= <expr><name>has_mbyte</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodlen</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>l_has_mbyte</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>badlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>badword</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>badlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>badlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>goodword</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>goodlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>goodlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>badword</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cnt[(a) + (b) * (badlen + 1)]</cpp:value></cpp:define>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>badlen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>goodlen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>goodlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>SCORE_INS</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>badlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>SCORE_DEL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>goodlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l_has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_ICASE</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_SIMILAR</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_SUBST</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l_has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pbc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pgc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pbc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pgc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>pgc</name> <operator>&amp;&amp;</operator> <name>pbc</name> <operator>==</operator> <name>gc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_SWAP</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_DEL</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_INS</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>badlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>goodlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score_limit</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>limitscore_T</name></type> <name><name>stack</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>stackidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi</name></decl>, <decl><type ref="prev"/><name>gi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi2</name></decl>, <decl><type ref="prev"/><name>gi2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>spell_edit_score_limit_w</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>badword</name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>








<expr_stmt><expr><name>stackidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>bi</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>gi</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>!=</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>pop</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_DEL</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>badword</name><index>[<expr><operator>++</operator><name>bi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_INS</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>goodword</name><index>[<expr><operator>++</operator><name>gi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 




<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>score_off</name> <operator>=</operator> <name>score</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SCORE_DEL</name></expr> </then><else>: <expr><name>SCORE_INS</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>+</operator> <name>SCORE_EDIT_MIN</name> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>bi2</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi2</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>goodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name><name>badword</name><index>[<expr><name>bi2</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>goodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi2</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>stackidx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name><name>badword</name><index>[<expr><name>bi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>bc</name> <operator>==</operator> <name><name>goodword</name><index>[<expr><name>gi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SWAP</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>pop</name>:</label>

<if_stmt><if>if <condition>(<expr><name>stackidx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>stackidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name></expr>;</expr_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><name>minscore</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>minscore</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score_limit_w</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>limitscore_T</name></type> <name><name>stack</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>stackidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi</name></decl>, <decl><type ref="prev"/><name>gi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi2</name></decl>, <decl><type ref="prev"/><name>gi2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wgoodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>



<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>badword</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>bi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>bi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>goodword</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>gi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>gi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>








<expr_stmt><expr><name>stackidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>bi</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>gi</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>!=</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>pop</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_DEL</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>wbadword</name><index>[<expr><operator>++</operator><name>bi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content> 
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_INS</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>wgoodword</name><index>[<expr><operator>++</operator><name>gi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 




<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>score_off</name> <operator>=</operator> <name>score</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SCORE_DEL</name></expr> </then><else>: <expr><name>SCORE_INS</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>+</operator> <name>SCORE_EDIT_MIN</name> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>bi2</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi2</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>wgoodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name><name>wbadword</name><index>[<expr><name>bi2</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wgoodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi2</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>stackidx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name><name>wbadword</name><index>[<expr><name>bi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>bc</name> <operator>==</operator> <name><name>wgoodword</name><index>[<expr><name>gi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SWAP</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>pop</name>:</label>

<if_stmt><if>if <condition>(<expr><name>stackidx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>stackidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name></expr>;</expr_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><name>minscore</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>minscore</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ex_spellinfo</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><name>lpi</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lp</name> <init>= <expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><literal type="string">"file: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_info</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>msg_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_KEEPCASE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_COUNT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ICASE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ONECAP</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ALLCAP</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 


<function><type><name>void</name></type> <name>ex_spelldump</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>dummy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>get_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"spl"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spl</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><literal type="string">"spell"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><literal type="string">"spl"</literal></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>spl</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>spl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFEMPTY</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>spell_dump_compl</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr> ?</condition><then> <expr><name>DUMPFLAG_COUNT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ml_delete</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>redraw_later</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>spell_dump_compl</name> <parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>ic</name></decl></parameter>, 
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>dumpflags_arg</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>do_region</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dumpflags</name> <init>= <expr><name>dumpflags_arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>patlen</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ic</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ICASE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>WF_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ONECAP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <name>WF_ALLCAP</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>
)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ALLCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>region_names</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>region_names</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>region_names</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>do_region</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>do_region</name> <operator>&amp;&amp;</operator> <name>region_names</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"/regions=%s"</literal></expr></argument>, <argument><expr><name>region_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name><operator>++</operator></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>do_region</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><decl><type><name>int</name></type> <name>lpi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"#file: %s"</literal></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name><operator>++</operator></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>patlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>patlen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>



<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dumpflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DUMPFLAG_KEEPCASE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_KEEPCASE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>pat</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name>compl_interrupted</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ins_compl_check_keys</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>round</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>do_region</name>
<operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator>
<operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_region</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>WF_REGION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>,
<argument><expr><name>dumpflags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lnum</name> <operator>=</operator> <call><name>dump_prefixes</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>,
<argument><expr><name>dumpflags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>







<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;=</operator> <name>patlen</name>
<operator>&amp;&amp;</operator> <call><name>mb_strnicmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>depth</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dumpflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wordflags</name></decl></parameter>, <parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>keepcap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>wordflags</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ALLCAP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ALLCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_KEEPCASE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_CAPMASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_KEEPCASE</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>captype</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>WF_KEEPCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>keepcap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>tw</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>WF_BANNED</name> <operator>|</operator> <name>WF_RARE</name> <operator>|</operator> <name>WF_REGION</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>keepcap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keepcap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x10000</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>badword_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>badword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>badword</name> <operator>+</operator> <name>badword_len</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>badword</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>badword_len</name></expr></argument>,
<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>badword</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_COUNT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>


<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>tw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s\t%d"</literal></expr></argument>,
<argument><expr><name>tw</name></expr></argument>, <argument><expr><call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>wc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ICASE</name><operator>)</operator></expr>
?</condition><then> <expr><call><name>mb_strnicmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>
</then><else>: <expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>ins_compl_add_infercase</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>p_ic</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>*</operator><name>dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <name>FORWARD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>linenr_T</name></type>
<name>dump_prefixes</name> <parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dumpflags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
<parameter><decl><type><name>linenr_T</name></type> <name>startlnum</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>prefix</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word_up</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>has_word_up</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name> <init>= <expr><name>startlnum</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>



<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>c</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>onecap_copy</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>has_word_up</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 


<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <name>depth</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dumpflags</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>flags</name> <operator>|</operator> <name>WF_RARE</name><operator>)</operator></expr>
</then><else>: <expr><name>flags</name></expr></else></ternary></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>has_word_up</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <name>depth</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dumpflags</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>flags</name> <operator>|</operator> <name>WF_RARE</name><operator>)</operator></expr>
</then><else>: <expr><name>flags</name></expr></else></ternary></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>lnum</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>char_u</name> <modifier>*</modifier></type><name>spell_to_word_end</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>spell_word_start</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startcol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>startcol</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>get_cursor_line_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>startcol</name></expr>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>line</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>line</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>col</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>spell_expand_need_cap</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>spell_expand_check_cap</name><parameter_list>(<parameter><decl><type><name>colnr_T</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>spell_expand_need_cap</name> <operator>=</operator> <call><name>check_need_cap</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>expand_spelling</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>matchp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>spell_suggest_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>spell_expand_need_cap</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>matchp</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
