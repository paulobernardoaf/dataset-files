<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\eval\typval.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NVIM_EVAL_TYPVAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NVIM_EVAL_TYPVAL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/hashtab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/func_attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/profile.h"</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/pos.h"</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/gettext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/macros.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LOG_LIST_ACTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><name>int64_t</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>uint64_t</name></type> <name>uvarnumber_T</name>;</typedef>


<typedef>typedef <type><name>double</name></type> <name>float_T</name>;</typedef>


<enum>enum <block>{ <decl><name>DO_NOT_FREE_CNT</name> <init>= <expr><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl> }</block>;</enum>


<enum>enum <name>ListLenSpecials</name> <block>{




<decl><name>kListLenUnknown</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,





<decl><name>kListLenShouldKnow</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>,



<decl><name>kListLenMayKnow</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>,
}</block>;</enum>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUMBER_MAX</name></cpp:macro> <cpp:value>INT64_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUMBER_MAX</name></cpp:macro> <cpp:value>UINT64_MAX</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUMBER_MIN</name></cpp:macro> <cpp:value>INT64_MIN</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIdVARNUMBER</name></cpp:macro> <cpp:value>PRId64</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>listvar_S</name></name></type> <name>list_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>dictvar_S</name></name></type> <name>dict_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>partial_S</name></name></type> <name>partial_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>ufunc</name></name></type> <name>ufunc_T</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
<decl><name>kCallbackNone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>kCallbackFuncref</name></decl>,
<decl><name>kCallbackPartial</name></decl>,
}</block></enum></type> <name>CallbackType</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<union>union <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>funcref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>partial</name></decl>;</decl_stmt>
}</block> <decl><name>data</name></decl>;</union>
<decl_stmt><decl><type><name>CallbackType</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>Callback</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_NONE</name></cpp:macro> <cpp:value>((Callback){ .type = kCallbackNone })</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>dict_watcher</name> <block>{
<decl_stmt><decl><type><name>Callback</name></type> <name>callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key_pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>key_pattern_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QUEUE</name></type> <name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>busy</name></decl>;</decl_stmt> 
}</block></struct></type> <name>DictWatcher</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>kSpecialVarFalse</name></decl>, 
<decl><name>kSpecialVarTrue</name></decl>, 
<decl><name>kSpecialVarNull</name></decl>, 
}</block></enum></type> <name>SpecialVarValue</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>VAR_UNLOCKED</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>VAR_LOCKED</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>VAR_FIXED</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, 
}</block></enum></type> <name>VarLockStatus</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>VAR_UNKNOWN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>VAR_NUMBER</name></decl>, 
<decl><name>VAR_STRING</name></decl>, 
<decl><name>VAR_FUNC</name></decl>, 
<decl><name>VAR_LIST</name></decl>, 
<decl><name>VAR_DICT</name></decl>, 
<decl><name>VAR_FLOAT</name></decl>, 
<decl><name>VAR_SPECIAL</name></decl>, 

<decl><name>VAR_PARTIAL</name></decl>, 
}</block></enum></type> <name>VarType</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>VarType</name></type> <name>v_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VarLockStatus</name></type> <name>v_lock</name></decl>;</decl_stmt> 
<union>union <name>typval_vval_union</name> <block>{
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>v_number</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>SpecialVarValue</name></type> <name>v_special</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>float_T</name></type> <name>v_float</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>v_string</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>v_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>v_dict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>v_partial</name></decl>;</decl_stmt> 
}</block> <decl><name>vval</name></decl>;</union> 
}</block></struct></type> <name>typval_T</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>VAR_NO_SCOPE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>VAR_SCOPE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>VAR_DEF_SCOPE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, 

}</block></enum></type> <name>ScopeType</name>;</typedef>


<typedef>typedef <type><name><name>struct</name> <name>listitem_S</name></name></type> <name>listitem_T</name>;</typedef>

<struct>struct <name>listitem_S</name> <block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name></type> <name>li_tv</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><name><name>struct</name> <name>listwatch_S</name></name></type> <name>listwatch_T</name>;</typedef>

<struct>struct <name>listwatch_S</name> <block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lw_item</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lw_next</name></decl>;</decl_stmt> 
}</block>;</struct>



<struct>struct <name>listvar_S</name> <block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_last</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lv_watch</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_idx_item</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_copylist</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_used_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_used_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_copyID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VarLockStatus</name></type> <name>lv_lock</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>list_T</name></type> <name>sl_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name></type> <name><name>sl_items</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>staticList10_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_STATIC10_INIT</name></cpp:macro> <cpp:value>{ .sl_list = { .lv_first = NULL, .lv_last = NULL, .lv_refcount = 0, .lv_len = 0, .lv_watch = NULL, .lv_idx_item = NULL, .lv_lock = VAR_FIXED, .lv_used_next = NULL, .lv_used_prev = NULL, }, }</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_DICTITEM_STRUCT</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { typval_T di_tv; uint8_t di_flags; char_u di_key[__VA_ARGS__]; }</cpp:value></cpp:define>












<typedef>typedef <macro><name>TV_DICTITEM_STRUCT</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro> <expr_stmt><expr><name>ScopeDictDictItem</name></expr>;</expr_stmt></typedef>






<typedef>typedef <macro><name>TV_DICTITEM_STRUCT</name><argument_list>()</argument_list></macro> <expr_stmt><expr><name>dictitem_T</name></expr>;</expr_stmt></typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>DI_FLAGS_RO</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
<decl><name>DI_FLAGS_RO_SBX</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, 
<decl><name>DI_FLAGS_FIX</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>, 
<decl><name>DI_FLAGS_LOCK</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>, 
<decl><name>DI_FLAGS_ALLOC</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>, 
}</block></enum></type> <name>DictItemFlags</name>;</typedef>


<struct>struct <name>dictvar_S</name> <block>{
<decl_stmt><decl><type><name>VarLockStatus</name></type> <name>dv_lock</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ScopeType</name></type> <name>dv_scope</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>dv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>dv_copyID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>dv_hashtab</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_copydict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_used_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_used_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>QUEUE</name></type> <name>watchers</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><name>int</name></type> <name>scid_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIdSCID</name></cpp:macro> <cpp:value>"d"</cpp:value></cpp:define>







<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>scid_T</name></type> <name>sc_sid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sc_seq</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>sc_lnum</name></decl>;</decl_stmt> 
}</block></struct></type> <name>sctx_T</name>;</typedef>


<typedef>typedef <type><name><name>struct</name> <name>funccall_S</name></name></type> <name>funccall_T</name>;</typedef>


<struct>struct <name>ufunc</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>uf_varargs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uf_calls</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>uf_cleared</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_args</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_lines</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_profiling</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_prof_initialized</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>uf_tm_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_self</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_children</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>uf_tml_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name> <modifier>*</modifier></type><name>uf_tml_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name> <modifier>*</modifier></type><name>uf_tml_self</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_children</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_wait</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_tml_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_tml_execed</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sctx_T</name></type> <name>uf_script_ctx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>uf_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>funccall_T</name> <modifier>*</modifier></type><name>uf_scoped</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>uf_name</name><index>[]</index></name></decl>;</decl_stmt> 

}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FUNC_ARGS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<struct>struct <name>partial_S</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>pt_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pt_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>pt_func</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>pt_auto</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>pt_argc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>pt_argv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>pt_dict</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><struct>struct <name>ht_stack_S</name> <block>{
<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ht_stack_S</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>ht_stack_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>list_stack_S</name> <block>{
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_stack_S</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>list_stack_T</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt> 
}</block></struct></type> <name>ListSortItem</name>;</typedef>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>ListSorter</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LOG_LIST_ACTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>l</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>li1</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>li2</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>action</name></decl>;</decl_stmt> 
}</block></struct></type> <name>ListLogEntry</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>list_log</name></name></type> <name>ListLog</name>;</typedef>


<struct>struct <name>list_log</name> <block>{
<decl_stmt><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>capacity</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ListLogEntry</name></type> <name><name>entries</name><index>[]</index></name></decl>;</decl_stmt> 
}</block>;</struct>

<decl_stmt><decl><type><specifier>extern</specifier> <name>ListLog</name> <modifier>*</modifier></type><name>list_log_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>extern</specifier> <name>ListLog</name> <modifier>*</modifier></type><name>list_log_last</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ListLog</name> <modifier>*</modifier></type><name>list_log_alloc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>size_t</name> <name>size</name></expr></argument>)</argument_list>
<name>REAL_FATTR_ALWAYS_INLINE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ListLog</name> <modifier>*</modifier></type><name>list_log_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ListLog</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call>
<operator>+</operator> <name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>list_log_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>list_log_first</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>list_log_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>list_log_last</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_log</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>listitem_T</name> <operator>*</operator><specifier>const</specifier> <name>li1</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>listitem_T</name> <operator>*</operator><specifier>const</specifier> <name>li2</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <name>action</name></expr></argument>)</argument_list>
<name>REAL_FATTR_ALWAYS_INLINE</name></decl>;</decl_stmt>










<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>list_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>tgt</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>list_log_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tgt</name> <operator>=</operator> <call><name>list_log_new</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>list_log_last</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name><name>list_log_last</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tgt</name> <operator>=</operator> <call><name>list_log_new</name><argument_list>(<argument><expr><name><name>list_log_last</name><operator>-&gt;</operator><name>capacity</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tgt</name> <operator>=</operator> <name>list_log_last</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tgt</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name><name>tgt</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ListLogEntry</name><operator>)</operator> <block>{
<expr><operator>.</operator><name>l</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>l</name></expr>,
<expr><operator>.</operator><name>li1</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>li1</name></expr>,
<expr><operator>.</operator><name>li2</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>li2</name></expr>,
<expr><operator>.</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>l</name> <operator>==</operator> <name>NULL</name> <operator>?</operator> <literal type="number">0</literal> <operator>:</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name><operator>)</operator></expr>,
<expr><operator>.</operator><name>action</name> <operator>=</operator> <name>action</name></expr>,
}</block></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_log</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_write_log</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>list_free_log</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_DICT_HI2DI</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dictitem_T *)((hi)-&gt;hi_key - offsetof(dictitem_T, di_key)))</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_ref</name><argument_list>(<argument><expr><name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_ALWAYS_INLINE</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_ref</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_set_ret</name><argument_list>(<argument><expr><name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>, <argument><expr><name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_ALWAYS_INLINE</name> <name>REAL_FATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_set_ret</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VarLockStatus</name></type> <name>tv_list_locked</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VarLockStatus</name></type> <name>tv_list_locked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>VAR_FIXED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_lock</name></name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_set_lock</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarLockStatus</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lock</name> <operator>==</operator> <name>VAR_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_lock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_list_set_copyid</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>copyid</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_copyID</name></name> <operator>=</operator> <name>copyid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_len</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"len"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_copyid</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name> <name>REAL_FATTR_NONNULL_ALL</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_copyid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_copyID</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>list_T</name> <modifier>*</modifier></type><name>tv_list_latest_copy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name> <name>REAL_FATTR_NONNULL_ALL</name></decl>;</decl_stmt>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>list_T</name> <modifier>*</modifier></type><name>tv_list_latest_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_copylist</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_uidx</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>, <argument><expr><name>int</name> <name>n</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>tv_list_uidx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_list_has_watchers</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_list_has_watchers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>l</name> <operator>&amp;&amp;</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_first</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_first</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_last</name><argument_list>(<argument><expr><specifier>const</specifier> <name>list_T</name> <operator>*</operator><specifier>const</specifier> <name>l</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_last</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"last"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"last"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_dict_set_ret</name><argument_list>(<argument><expr><name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>, <argument><expr><name>dict_T</name> <operator>*</operator><specifier>const</specifier> <name>d</name></expr></argument>)</argument_list>
<name>REAL_FATTR_ALWAYS_INLINE</name> <name>REAL_FATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_dict_set_ret</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type> <name>tv_dict_len</name><argument_list>(<argument><expr><specifier>const</specifier> <name>dict_T</name> <operator>*</operator><specifier>const</specifier> <name>d</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type> <name>tv_dict_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0L</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_used</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_dict_is_watched</name><argument_list>(<argument><expr><specifier>const</specifier> <name>dict_T</name> <operator>*</operator><specifier>const</specifier> <name>d</name></expr></argument>)</argument_list>
<name>REAL_FATTR_PURE</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_dict_is_watched</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>d</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>QUEUE_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>watchers</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>tv_init</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_INITIAL_VALUE</name></cpp:macro> <cpp:value>((typval_T) { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED, })</cpp:value></cpp:define>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv_empty_string</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>tv_in_free_unref_items</name></decl>;</decl_stmt>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_TV_LIST_ITER_MOD</name><parameter_list>(<parameter><type><name>modifier</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>li</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { modifier list_T *const l_ = (l); list_log(l_, NULL, NULL, "iter" #modifier); if (l_ != NULL) { for (modifier listitem_T *li = l_-&gt;lv_first; li != NULL; li = li-&gt;li_next) { code } } } while (0)</cpp:value></cpp:define>



















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_ITER</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>li</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_TV_LIST_ITER_MOD(, l, li, code)</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_ITER_CONST</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>li</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_TV_LIST_ITER_MOD(const, l, li, code)</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_ITEM_TV</name><parameter_list>(<parameter><type><name>li</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;(li)-&gt;li_tv)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_ITEM_NEXT</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>li</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((li)-&gt;li_next)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_LIST_ITEM_PREV</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>li</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((li)-&gt;li_prev)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_DICT_ITER</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>di</name></type></parameter>, <parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASHTAB_ITER(&amp;(d)-&gt;dv_hashtab, di##hi_, { { dictitem_T *const di = TV_DICT_HI2DI(di##hi_); { code } } })</cpp:value></cpp:define>









<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_get_float_chk</name><argument_list>(<argument><expr><specifier>const</specifier> <name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>,
<argument><expr><name>float_T</name> <operator>*</operator><specifier>const</specifier> <name>ret_f</name></expr></argument>)</argument_list>
<name>REAL_FATTR_NONNULL_ALL</name> <name>REAL_FATTR_WARN_UNUSED_RESULT</name></decl>;</decl_stmt>


<function_decl><type><name>bool</name></type> <name>emsgf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_get_float_chk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>,
<parameter><decl><type><name>float_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_f</name> <operator>=</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_f</name> <operator>=</operator> <operator>(</operator><name>float_T</name><operator>)</operator><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E808: Number or Float required"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>DictWatcher</name> <modifier>*</modifier></type><name>tv_dict_watcher_node_data</name><argument_list>(<argument><expr><name>QUEUE</name> <operator>*</operator><name>q</name></expr></argument>)</argument_list>
<name>REAL_FATTR_NONNULL_ALL</name> <name>REAL_FATTR_NONNULL_RET</name> <name>REAL_FATTR_PURE</name>
<name>REAL_FATTR_WARN_UNUSED_RESULT</name> <name>REAL_FATTR_ALWAYS_INLINE</name></decl>;</decl_stmt>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>DictWatcher</name> <modifier>*</modifier></type><name>tv_dict_watcher_node_data</name><parameter_list>(<parameter><decl><type><name>QUEUE</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>QUEUE_DATA</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>DictWatcher</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_is_func</name><argument_list>(<argument><expr><specifier>const</specifier> <name>typval_T</name> <name>tv</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_ALWAYS_INLINE</name> <name>FUNC_ATTR_CONST</name></decl>;</decl_stmt>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>tv_is_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name></type> <name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FUNC</name> <operator>||</operator> <name><name>tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name></expr>;</return>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_TRANSLATE</name></cpp:macro> <cpp:value>(SIZE_MAX)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TV_CSTRING</name></cpp:macro> <cpp:value>(SIZE_MAX - 1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIT_TESTING</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>EXTERN</name> <specifier>const</specifier> <name>size_t</name> <name>kTVCstring</name></type> <name>INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>TV_CSTRING</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EXTERN</name> <specifier>const</specifier> <name>size_t</name> <name>kTVTranslate</name></type> <name>INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>TV_TRANSLATE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval/typval.h.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
