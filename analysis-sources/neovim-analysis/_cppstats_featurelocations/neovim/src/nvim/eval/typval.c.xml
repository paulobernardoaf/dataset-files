<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\eval\typval.c">


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/lib/queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/encode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/globals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/hashtab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/pos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/gettext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/macros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/mbyte.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/fileio.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval/typval.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>bool</name></type> <name>tv_in_free_unref_items</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_MAXNEST</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv_empty_string</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LOG_LIST_ACTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>list_log_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>list_log_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<function><type><name>void</name></type> <name>list_write_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>FileDescriptor</name></type> <name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fo_ret</name> <init>= <expr><call><name>file_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fp</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>kFileCreate</name><operator>|</operator><name>kFileAppend</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fo_ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E5142: Failed to open file %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>fo_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name>list_log_first</name></expr></init></decl>;</init> <condition><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><literal type="number">16</literal> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">8</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ListLogEntry</name></type> <name>entry</name> <init>= <expr><name><name>chunk</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>snp_len</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>snprintf</name><argument_list>(
<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%-10.10s: l:%016"</literal> <name>PRIxPTR</name> <literal type="string">"[%08d] 1:%016"</literal> <name>PRIxPTR</name> <literal type="string">" 2:%016"</literal> <name>PRIxPTR</name>
<literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>action</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>l</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>li1</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>li2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>snp_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>fw_ret</name> <init>= <expr><call><name>file_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>snp_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fw_ret</name> <operator>!=</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>snp_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fw_ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>entries</name></name> <operator>+</operator> <name>i</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>size</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E5143: Failed to write to file %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>fw_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>list_log_first</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>list_log_first</name></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fc_ret</name> <init>= <expr><call><name>file_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fc_ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E5144: Failed to close file %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>os_strerror</name><argument_list>(<argument><expr><name>fc_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type> <name>list_free_log</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>ListLog</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name>list_log_first</name></expr></init></decl>;</init> <condition><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>list_log_first</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>list_log_first</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><specifier>static</specifier> <name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_item_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC
<block>{<block_content>
<return>return <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listitem_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_item_remove</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>next_item</name> <init>= <expr><call><name>TV_LIST_ITEM_NEXT</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_list_drop_items</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>next_item</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_list_watch_add</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listwatch_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lw</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><name><name>lw</name><operator>-&gt;</operator><name>lw_next</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name> <operator>=</operator> <name>lw</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_list_watch_remove</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listwatch_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lwrem</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>listwatch_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>lwp</name> <init>= <expr><operator>&amp;</operator><name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lw</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name></expr></init></decl>;</init> <condition><expr><name>lw</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lw</name> <operator>=</operator> <name><name>lw</name><operator>-&gt;</operator><name>lw_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lw</name> <operator>==</operator> <name>lwrem</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>lwp</name> <operator>=</operator> <name><name>lw</name><operator>-&gt;</operator><name>lw_next</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lwp</name> <operator>=</operator> <operator>&amp;</operator><name><name>lw</name><operator>-&gt;</operator><name>lw_next</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_list_watch_fix</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<for>for <control>(<init><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lw</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name></expr></init></decl>;</init> <condition><expr><name>lw</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lw</name> <operator>=</operator> <name><name>lw</name><operator>-&gt;</operator><name>lw_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lw</name><operator>-&gt;</operator><name>lw_item</name></name> <operator>==</operator> <name>item</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lw</name><operator>-&gt;</operator><name>lw_item</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>














<function><type><name>list_T</name> <modifier>*</modifier></type><name>tv_list_alloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>list_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>gc_first_list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>gc_first_list</name><operator>-&gt;</operator><name>lv_used_prev</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>lv_used_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>lv_used_next</name></name> <operator>=</operator> <name>gc_first_list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc_first_list</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><literal type="string">"alloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_list_init_static10</name><parameter_list>(<parameter><decl><type><name>staticList10_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sl</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SL_SIZE</name></cpp:macro> <cpp:value>ARRAY_SIZE(sl-&gt;sl_items)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_list</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>staticList10_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>SL_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_refcount</name></name> <operator>=</operator> <name>DO_NOT_FREE_CNT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_set_lock</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>VAR_FIXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>sl_list</name><operator>.</operator><name>lv_len</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>li_prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>li_next</name> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>SL_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>li_prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>SL_SIZE</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>SL_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>li_next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SL_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name>li</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>li</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>list_T</name> <operator>*</operator><operator>)</operator><name>sl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sl</name><operator>-&gt;</operator><name>sl_items</name><index>[<expr><name>SL_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><literal type="string">"s10init"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SL_SIZE</name></cpp:undef>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_list_init_static</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>l</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_refcount</name></name> <operator>=</operator> <name>DO_NOT_FREE_CNT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"sinit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_list_free_contents</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"freecont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></init></decl>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>li_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_watch</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_list_free_list</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>lv_used_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gc_first_list</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_used_next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_used_prev</name><operator>-&gt;</operator><name>lv_used_next</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_used_next</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>lv_used_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_used_next</name><operator>-&gt;</operator><name>lv_used_prev</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_used_prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"freelist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_list_free</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv_in_free_unref_items</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_free_contents</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_free_list</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_list_unref</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>--</operator><name><name>l</name><operator>-&gt;</operator><name>lv_refcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>










<function><type><name>void</name></type> <name>tv_list_drop_items</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item2</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>item</name></expr></init></decl>;</init> <condition><expr><name>ip</name> <operator>!=</operator> <name><name>item2</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</condition> <incr><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>li_next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_watch_fix</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>item2</name><operator>-&gt;</operator><name>li_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>item2</name><operator>-&gt;</operator><name>li_next</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name><name>item2</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name><name>item2</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr></argument>, <argument><expr><literal type="string">"afterdrop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>tv_list_remove_items</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item2</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>, <argument><expr><literal type="string">"remove"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_drop_items</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><name>item</name></expr></init></decl>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>nli</name> <init>= <expr><name><name>li</name><operator>-&gt;</operator><name>li_next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>item2</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>li</name> <operator>=</operator> <name>nli</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>tv_list_move_items</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item2</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tgt_l</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>, <argument><expr><literal type="string">"move"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_drop_items</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name><name>tgt_l</name><operator>-&gt;</operator><name>lv_last</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item2</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_last</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name>item2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>tgt_l</name></expr></argument>, <argument><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></argument>, <argument><expr><name><name>tgt_l</name><operator>-&gt;</operator><name>lv_last</name></name></expr></argument>, <argument><expr><literal type="string">"movetgt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_list_insert</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ni</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1<operator>,</operator> 2</function>)
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tv_list_append</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name>ni</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>ni</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name>ni</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>








<function><type><name>void</name></type> <name>tv_list_insert_tv</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ni</name> <init>= <expr><call><name>tv_list_item_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ni</name><operator>-&gt;</operator><name>li_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_insert</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>tv_list_append</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>li_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_list_append_tv</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><call><name>tv_list_item_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_append</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>tv_list_append_owned_tv</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>typval_T</name></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><call><name>tv_list_item_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tv</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_append</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>tv_list_append_list</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>itemlist</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>l</argument>, <argument>(typval_T) {
.v_type = VAR_LIST</argument>,
<argument>.v_lock = VAR_UNLOCKED</argument>,
<argument>.vval.v_list = itemlist</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>itemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>





<function><type><name>void</name></type> <name>tv_list_append_dict</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>l</argument>, <argument>(typval_T) {
.v_type = VAR_DICT</argument>,
<argument>.v_lock = VAR_UNLOCKED</argument>,
<argument>.vval.v_dict = dict</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<if_stmt><if>if <condition>(<expr><name>dict</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>








<function><type><name>void</name></type> <name>tv_list_append_string</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ssize_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>l</argument>, <argument>(typval_T) {
.v_type = VAR_STRING</argument>,
<argument>.v_lock = VAR_UNLOCKED</argument>,
<argument>.vval.v_string = (str == NULL
? NULL
: (len &gt;= <literal type="number">0</literal>
? xmemdupz(str, (size_t)len)
: xstrdup(str)))</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block>







<function><type><name>void</name></type> <name>tv_list_append_allocated_string</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>l</argument>, <argument>(typval_T) {
.v_type = VAR_STRING</argument>,
<argument>.v_lock = VAR_UNLOCKED</argument>,
<argument>.vval.v_string = (char_u *)str</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block>






<function><type><name>void</name></type> <name>tv_list_append_number</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>varnumber_T</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<macro><name>tv_list_append_owned_tv</name><argument_list>(<argument>l</argument>, <argument>(typval_T) {
.v_type = VAR_NUMBER</argument>,
<argument>.v_lock = VAR_UNLOCKED</argument>,
<argument>.vval.v_number = n</argument>,
<argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>













<function><type><name>list_T</name> <modifier>*</modifier></type><name>tv_list_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>vimconv_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>conv</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>deep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>copyID</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>orig</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>copyID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>orig</name><operator>-&gt;</operator><name>lv_copyID</name></name> <operator>=</operator> <name>copyID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>orig</name><operator>-&gt;</operator><name>lv_copylist</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>TV_LIST_ITER</name><argument_list>(<argument>orig</argument>, <argument>item</argument>, <argument>{
if (got_int) {
break;
}
listitem_T *const ni = tv_list_item_alloc();
if (deep) {
if (var_item_copy(conv, TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni),
deep, copyID) == FAIL) {
xfree(ni);
goto tv_list_copy_error;
}
} else {
tv_copy(TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni));
}
tv_list_append(copy, ni);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>copy</name></expr>;</return>

<label><name>tv_list_copy_error</name>:</label>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_list_extend</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l2</name></decl></parameter>,
<parameter><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>bef</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name> <init>= <expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>befbef</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>bef</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>bef</name><operator>-&gt;</operator><name>li_prev</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>saved_next</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>befbef</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>befbef</name><operator>-&gt;</operator><name>li_next</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>tv_list_first</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>
;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>todo</name><operator>--</operator></expr>
;</condition> <incr><expr><name>item</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>item</name> <operator>==</operator> <name>befbef</name></expr> ?</condition><then> <expr><name>saved_next</name></expr> </then><else>: <expr><name><name>item</name><operator>-&gt;</operator><name>li_next</name></name></expr></else></ternary><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_insert_tv</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>








<function><type><name>int</name></type> <name>tv_list_concat</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l2</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>l2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>tv_list_copy</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>tv_list_copy</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>l2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_extend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>l1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>l2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name></decl>;</decl_stmt>
}</block></struct></type> <name>Join</name>;</typedef>









<function><type><specifier>static</specifier> <name>int</name></type> <name>list_join_inner</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>gap</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>join_gap</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>sumlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<macro><name>TV_LIST_ITER</name><argument_list>(<argument>l</argument>, <argument>item</argument>, <argument>{
if (got_int) {
break;
}
char *s;
size_t len;
s = encode_tv2echo(TV_LIST_ITEM_TV(item), &amp;len);
if (s == NULL) {
return FAIL;
}

sumlen += len;

Join *const p = GA_APPEND_VIA_PTR(Join, join_gap);
p-&gt;tofree = p-&gt;s = (char_u *)s;

line_breakcheck();
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<if_stmt><if>if <condition>(<expr><name><name>join_gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sumlen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>join_gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sumlen</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>join_gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Join</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator><name><name>join_gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>int</name></type> <name>tv_list_join</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>gap</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sep</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1</function>)
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>join_ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Join</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>list_join_inner</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>join_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_JOIN_TOFREE</name><parameter_list>(<parameter><type><name>join</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xfree((join)-&gt;tofree)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>GA_DEEP_CLEAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_ga</name></expr></argument>, <argument><expr><name>Join</name></expr></argument>, <argument><expr><name>FREE_JOIN_TOFREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FREE_JOIN_TOFREE</name></cpp:undef>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block>









<function><type><name>bool</name></type> <name>tv_list_equal</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>ic</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>recursive</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>==</operator> <name>l2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>l2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>tv_list_len</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item1</name> <init>= <expr><call><name>tv_list_first</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item2</name> <init>= <expr><call><name>tv_list_first</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>item1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>item2</name> <operator>!=</operator> <name>NULL</name></expr>
;</condition> <incr><expr><operator>(</operator><name>item1</name> <operator>=</operator> <call><name>TV_LIST_ITEM_NEXT</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>item2</name> <operator>=</operator> <call><name>TV_LIST_ITEM_NEXT</name><argument_list>(<argument><expr><name>l2</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tv_equal</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ic</name></expr></argument>,
<argument><expr><name>recursive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>item1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>item2</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_list_reverse</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reverse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tmp = a; a = b; b = tmp; } while (0)</cpp:value></cpp:define>





<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr></init></decl>;</init> <condition><expr><name>li</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>li</name> <operator>=</operator> <name><name>li</name><operator>-&gt;</operator><name>li_next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name><name>li</name><operator>-&gt;</operator><name>li_next</name></name></expr></argument>, <argument><expr><name><name>li</name><operator>-&gt;</operator><name>li_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SWAP</name></cpp:undef>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>-</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><name>void</name></type> <name>tv_list_item_sort</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>ListSortItem</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ptrs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ListSorter</name></type> <name>item_compare_func</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>errp</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>3<operator>,</operator> 4</function>)
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>tv_list_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>TV_LIST_ITER</name><argument_list>(<argument>l</argument>, <argument>li</argument>, <argument>{
ptrs[i].item = li;
ptrs[i].idx = i;
i++;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>ptrs</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListSortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>item_compare_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>errp</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_append</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block>










<function><type><name>listitem_T</name> <modifier>*</modifier></type><name>tv_list_find</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"n and lv_idx sizes do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>tv_list_uidx</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;</operator> <operator>(</operator><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name> <operator>+</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_last</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>idx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>idx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>li_prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_log</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_idx_item</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>lv_idx</name></name></expr></argument>, <argument><expr><literal type="string">"find"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>varnumber_T</name></type> <name>tv_list_find_nr</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_error</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><call><name>tv_list_find</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret_error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret_error</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_list_find_str</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>li</name> <init>= <expr><call><name>tv_list_find</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_listidx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_get_string</name><argument_list>(<argument><expr><call><name>TV_LIST_ITEM_TV</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><name>long</name></type> <name>tv_list_idx_of_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>listitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>TV_LIST_ITER_CONST</name><argument_list>(<argument>l</argument>, <argument>li</argument>, <argument>{
if (li == item) {
return idx;
}
idx++;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>tv_dict_watcher_free</name><parameter_list>(<parameter><decl><type><name>DictWatcher</name> <modifier>*</modifier></type><name>watcher</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>callback_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>watcher</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>watcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_dict_watcher_add</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key_pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_pattern_len</name></decl></parameter>, <parameter><decl><type><name>Callback</name></type> <name>callback</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2</function>)
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dict</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>DictWatcher</name> <modifier>*</modifier><specifier>const</specifier></type> <name>watcher</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DictWatcher</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name></name> <operator>=</operator> <call><name>xmemdupz</name><argument_list>(<argument><expr><name>key_pattern</name></expr></argument>, <argument><expr><name>key_pattern_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern_len</name></name> <operator>=</operator> <name>key_pattern_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>busy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>QUEUE_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>watchers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>watcher</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>







<function><type><name>bool</name></type> <name>tv_callback_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Callback</name> <modifier>*</modifier></type><name>cb1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Callback</name> <modifier>*</modifier></type><name>cb2</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cb1</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>cb2</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>cb1</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kCallbackFuncref</name></expr>:</case> <block>{<block_content>
<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>cb1</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>funcref</name></name></expr></argument>, <argument><expr><name><name>cb2</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>funcref</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>kCallbackPartial</name></expr>:</case> <block>{<block_content>


<return>return <expr><name><name>cb1</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial</name></name> <operator>==</operator> <name><name>cb2</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>kCallbackNone</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>callback_free</name><parameter_list>(<parameter><decl><type><name>Callback</name> <modifier>*</modifier></type><name>callback</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>callback</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kCallbackFuncref</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>func_unref</name><argument_list>(<argument><expr><name><name>callback</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>funcref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>callback</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>funcref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kCallbackPartial</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>partial_unref</name><argument_list>(<argument><expr><name><name>callback</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>partial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>kCallbackNone</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>callback</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kCallbackNone</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>bool</name></type> <name>tv_dict_watcher_remove</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key_pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_pattern_len</name></decl></parameter>,
<parameter><decl><type><name>Callback</name></type> <name>callback</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2</function>)
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dict</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QUEUE</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DictWatcher</name> <modifier>*</modifier></type><name>watcher</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<macro><name>QUEUE_FOREACH</name><argument_list>(<argument>w</argument>, <argument>&amp;dict-&gt;watchers</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>watcher</name> <operator>=</operator> <call><name>tv_dict_watcher_node_data</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_callback_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>watcher</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callback</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>watcher</name><operator>-&gt;</operator><name>key_pattern_len</name></name> <operator>==</operator> <name>key_pattern_len</name>
<operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name></name></expr></argument>, <argument><expr><name>key_pattern</name></expr></argument>, <argument><expr><name>key_pattern_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>QUEUE_REMOVE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_watcher_free</name><argument_list>(<argument><expr><name>watcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>







<function><type><specifier>static</specifier> <name>bool</name></type> <name>tv_dict_watcher_matches</name><parameter_list>(<parameter><decl><type><name>DictWatcher</name> <modifier>*</modifier></type><name>watcher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE
<block>{<block_content>



<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern_len</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>watcher</name><operator>-&gt;</operator><name>key_pattern</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_dict_watcher_notify</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>newtv</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>oldtv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1<operator>,</operator> 2</function>)
<block>{<block_content>
<decl_stmt><decl><type><name>typval_T</name></type> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>xstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_lock</name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newtv</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>v</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><name>newtv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oldtv</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>v</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><call><name>S_LEN</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><name>oldtv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QUEUE</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
<macro><name>QUEUE_FOREACH</name><argument_list>(<argument>w</argument>, <argument>&amp;dict-&gt;watchers</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>DictWatcher</name> <modifier>*</modifier></type><name>watcher</name> <init>= <expr><call><name>tv_dict_watcher_node_data</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>watcher</name><operator>-&gt;</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <call><name>tv_dict_watcher_matches</name><argument_list>(<argument><expr><name>watcher</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rettv</name> <operator>=</operator> <name>TV_INITIAL_VALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>busy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>callback_call</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>watcher</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>watcher</name><operator>-&gt;</operator><name>busy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><name>argv</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>












<function><type><name>dictitem_T</name> <modifier>*</modifier></type><name>tv_dict_item_alloc_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
FUNC_ATTR_MALLOC
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>dictitem_T</name></expr></argument>, <argument><expr><name>di_key</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>key_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>di</name><operator>-&gt;</operator><name>di_key</name><index>[<expr><name>key_len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>di</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>=</operator> <name>DI_FLAGS_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<return>return <expr><name>di</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>dictitem_T</name> <modifier>*</modifier></type><name>tv_dict_item_alloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
FUNC_ATTR_MALLOC
<block>{<block_content>
<return>return <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_dict_item_free</name><parameter_list>(<parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DI_FLAGS_ALLOC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>dictitem_T</name> <modifier>*</modifier></type><name>tv_dict_item_copy</name><parameter_list>(<parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>new_di</name> <init>= <expr><call><name>tv_dict_item_alloc</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>di</name><operator>-&gt;</operator><name>di_key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new_di</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>tv_dict_item_remove</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hi</name> <init>= <expr><call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>di_key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_intern2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tv_dict_item_remove()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>hash_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dict</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>dict_T</name> <modifier>*</modifier></type><name>tv_dict_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name> <init>= <expr><call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dict_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>gc_first_dict</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>gc_first_dict</name><operator>-&gt;</operator><name>dv_used_prev</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_next</name></name> <operator>=</operator> <name>gc_first_dict</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc_first_dict</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_scope</name></name> <operator>=</operator> <name>VAR_NO_SCOPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_copyID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>QUEUE_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>watchers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>tv_dict_free_contents</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>

<expr_stmt><expr><call><name>hash_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_locked</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>HASHTAB_ITER</name><argument_list>(<argument>&amp;d-&gt;dv_hashtab</argument>, <argument>hi</argument>, <argument>{


dictitem_T *const di = TV_DICT_HI2DI(hi);
hash_remove(&amp;d-&gt;dv_hashtab, hi);
tv_dict_item_free(di);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>QUEUE_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>watchers</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QUEUE</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>QUEUE_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>watchers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>QUEUE_REMOVE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DictWatcher</name> <modifier>*</modifier></type><name>watcher</name> <init>= <expr><call><name>tv_dict_watcher_node_data</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_dict_watcher_free</name><argument_list>(<argument><expr><name>watcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_locked</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_dict_free_dict</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gc_first_dict</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>dv_used_next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_prev</name><operator>-&gt;</operator><name>dv_used_next</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>dv_used_next</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dv_used_next</name><operator>-&gt;</operator><name>dv_used_prev</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>dv_used_prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_dict_free</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv_in_free_unref_items</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_free_contents</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_dict_free_dict</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>tv_dict_unref</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>--</operator><name><name>d</name><operator>-&gt;</operator><name>dv_refcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>










<function><type><name>dictitem_T</name> <modifier>*</modifier></type><name>tv_dict_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2</function>) <decl_stmt><decl><type><name>FUNC_ATTR_PURE</name></type> <name>FUNC_ATTR_WARN_UNUSED_RESULT</name>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>hi</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>hash_find_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>TV_DICT_HI2DI</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>









<function><type><name>varnumber_T</name></type> <name>tv_dict_get_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><name>char</name> <modifier>*</modifier></type><name>tv_dict_get_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>save</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>numbuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s</name> <init>= <expr><call><name>tv_dict_get_string_buf</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>save</name> <operator>&amp;&amp;</operator> <name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_dict_get_string_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>numbuf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_get_string_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_dict_get_string_buf_chk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>key_len</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>numbuf</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>def</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>def</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><name>bool</name></type> <name>tv_dict_get_callback</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>key_len</name></decl></parameter>,
<parameter><decl><type><name>Callback</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2<operator>,</operator> 4</function>) <macro><name>FUNC_ATTR_WARN_UNUSED_RESULT</name></macro>
<block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kCallbackNone</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>di</name> <init>= <expr><call><name>tv_dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tv_is_func</name><argument_list>(<argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E6000: Argument is not a function or function name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_selfdict</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>res</name> <init>= <expr><call><name>callback_from_typval</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>









<function><type><name>int</name></type> <name>tv_dict_add</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>hash_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>di_key</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>tv_dict_add_list</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>tv_dict_add_dict</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>tv_dict_add_nr</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>varnumber_T</name></type> <name>nr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>tv_dict_add_special</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><name>SpecialVarValue</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_special</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>tv_dict_add_str</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>val</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>tv_dict_add_allocated_str</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>, <argument><expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><name>int</name></type> <name>tv_dict_add_str_len</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>1<operator>,</operator> 2</function>)
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><name>val</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>xstrndup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>tv_dict_add_allocated_str</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<function><type><name>int</name></type> <name>tv_dict_add_allocated_str</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>key_len</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>val</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>tv_dict_item_alloc_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_item_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_dict_clear</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<expr_stmt><expr><call><name>hash_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name><operator>.</operator><name>ht_locked</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>HASHTAB_ITER</name><argument_list>(<argument>&amp;d-&gt;dv_hashtab</argument>, <argument>hi</argument>, <argument>{
tv_dict_item_free(TV_DICT_HI2DI(hi));
hash_remove(&amp;d-&gt;dv_hashtab, hi);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>hash_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><name>void</name></type> <name>tv_dict_extend</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d1</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>action</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>watched</name> <init>= <expr><call><name>tv_dict_is_watched</name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>arg_errmsg</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"extend() argument"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>arg_errmsg_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>arg_errmsg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>TV_DICT_ITER</name><argument_list>(<argument>d2</argument>, <argument>di2</argument>, <argument>{
dictitem_T *const di1 = tv_dict_find(d1, (const char *)di2-&gt;di_key, -<literal type="number">1</literal>);
if (d1-&gt;dv_scope != VAR_NO_SCOPE) {


if (d1-&gt;dv_scope == VAR_DEF_SCOPE
&amp;&amp; tv_is_func(di2-&gt;di_tv)
&amp;&amp; !var_check_func_name((const char *)di2-&gt;di_key, di1 == NULL)) {
break;
}
if (!valid_varname((const char *)di2-&gt;di_key)) {
break;
}
}
if (di1 == NULL) {
dictitem_T *const new_di = tv_dict_item_copy(di2);
if (tv_dict_add(d1, new_di) == FAIL) {
tv_dict_item_free(new_di);
} else if (watched) {
tv_dict_watcher_notify(d1, (const char *)new_di-&gt;di_key, &amp;new_di-&gt;di_tv,
NULL);
}
} else if (*action == <literal type="char">'e'</literal>) {
emsgf(_(<literal type="string">"E737: Key already exists: %s"</literal>), di2-&gt;di_key);
break;
} else if (*action == <literal type="char">'f'</literal> &amp;&amp; di2 != di1) {
typval_T oldtv;

if (tv_check_lock(di1-&gt;di_tv.v_lock, arg_errmsg, arg_errmsg_len)
|| var_check_ro(di1-&gt;di_flags, arg_errmsg, arg_errmsg_len)) {
break;
}

if (watched) {
tv_copy(&amp;di1-&gt;di_tv, &amp;oldtv);
}

tv_clear(&amp;di1-&gt;di_tv);
tv_copy(&amp;di2-&gt;di_tv, &amp;di1-&gt;di_tv);

if (watched) {
tv_dict_watcher_notify(d1, (const char *)di1-&gt;di_key, &amp;di1-&gt;di_tv,
&amp;oldtv);
tv_clear(&amp;oldtv);
}
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>







<function><type><name>bool</name></type> <name>tv_dict_equal</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d1</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>ic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>recursive</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>==</operator> <name>d2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>d2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tv_dict_len</name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>tv_dict_len</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>TV_DICT_ITER</name><argument_list>(<argument>d1</argument>, <argument>di1</argument>, <argument>{
dictitem_T *const di2 = tv_dict_find(d2, (const char *)di1-&gt;di_key, -<literal type="number">1</literal>);
if (di2 == NULL) {
return false;
}
if (!tv_equal(&amp;di1-&gt;di_tv, &amp;di2-&gt;di_tv, ic, recursive)) {
return false;
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>dict_T</name> <modifier>*</modifier></type><name>tv_dict_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>vimconv_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>conv</name></decl></parameter>,
<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>orig</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>deep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>copyID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>orig</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>copyID</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>orig</name><operator>-&gt;</operator><name>dv_copyID</name></name> <operator>=</operator> <name>copyID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>orig</name><operator>-&gt;</operator><name>dv_copydict</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>TV_DICT_ITER</name><argument_list>(<argument>orig</argument>, <argument>di</argument>, <argument>{
if (got_int) {
break;
}
dictitem_T *new_di;
if (conv == NULL || conv-&gt;vc_type == CONV_NONE) {
new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);
} else {
size_t len = STRLEN(di-&gt;di_key);
char *const key = (char *)string_convert(conv, di-&gt;di_key, &amp;len);
if (key == NULL) {
new_di = tv_dict_item_alloc_len((const char *)di-&gt;di_key, len);
} else {
new_di = tv_dict_item_alloc_len(key, len);
xfree(key);
}
}
if (deep) {
if (var_item_copy(conv, &amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv, deep,
copyID) == FAIL) {
xfree(new_di);
break;
}
} else {
tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);
}
if (tv_dict_add(copy, new_di) == FAIL) {
tv_dict_item_free(new_di);
break;
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copy</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_dict_set_keys_readonly</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dict</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<macro><name>TV_DICT_ITER</name><argument_list>(<argument>dict</argument>, <argument>di</argument>, <argument>{
di-&gt;di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>
















<function><type><name>list_T</name> <modifier>*</modifier></type><name>tv_list_alloc_ret</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_tv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name> <init>= <expr><call><name>tv_list_alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_list_set_ret</name><argument_list>(<argument><expr><name>ret_tv</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret_tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_dict_alloc_ret</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ret_tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name> <init>= <expr><call><name>tv_dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_dict_set_ret</name><argument_list>(<argument><expr><name>ret_tv</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret_tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:macro> <cpp:value>false</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NIL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tv-&gt;vval.v_special = kSpecialVarFalse; tv-&gt;v_lock = VAR_UNLOCKED; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_BOOL</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPVAL_ENCODE_CONV_NIL(tv)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (void)num; tv-&gt;vval.v_number = 0; tv-&gt;v_lock = VAR_UNLOCKED; } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FLOAT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>flt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tv-&gt;vval.v_float = 0; tv-&gt;v_lock = VAR_UNLOCKED; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { xfree(buf); tv-&gt;vval.v_string = NULL; tv-&gt;v_lock = VAR_UNLOCKED; } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_STR_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EXT_STRING</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>_nothing_conv_func_start</name><argument_list>(<argument><expr><name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>,
<argument><expr><name>char_u</name> <operator>*</operator><specifier>const</specifier> <name>fun</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_ALWAYS_INLINE</name> <name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pt_</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pt_</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pt_</name><operator>-&gt;</operator><name>pt_refcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pt_</name><operator>-&gt;</operator><name>pt_refcount</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>func_unref</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>fun</name> <operator>!=</operator> <name>tv_empty_string</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>NOTDONE</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>fun</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (_nothing_conv_func_start(tv, fun) != NOTDONE) { return OK; } } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_nothing_conv_func_end</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>copyID</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pt</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>pt_dict</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pt</name><operator>-&gt;</operator><name>pt_dict</name><operator>-&gt;</operator><name>dv_copyID</name></name> <operator>==</operator> <name>copyID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>pt_dict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>pt_argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>pt_refcount</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>partial_unref</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>==</operator> <name>VAR_UNLOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_FUNC_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_nothing_conv_func_end(tv, copyID)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tv_list_unref(tv-&gt;vval.v_list); tv-&gt;vval.v_list = NULL; tv-&gt;v_lock = VAR_UNLOCKED; } while (0)</cpp:value></cpp:define>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_nothing_conv_empty_dict</name><argument_list>(<argument><expr><name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>,
<argument><expr><name>dict_T</name> <operator>*</operator><operator>*</operator><specifier>const</specifier> <name>dictp</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_ALWAYS_INLINE</name> <name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><operator>*</operator><name>dictp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dictp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert((void *)&amp;dict != (void *)&amp;TYPVAL_ENCODE_NODICT_VAR); _nothing_conv_empty_dict(tv, ((dict_T **)&amp;dict)); } while (0)</cpp:value></cpp:define>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>_nothing_conv_real_list_after_start</name><parameter_list>(
<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>MPConvStackVal</name> <modifier>*</modifier><specifier>const</specifier></type> <name>mpsv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name><operator>-&gt;</operator><name>lv_refcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name><operator>-&gt;</operator><name>lv_refcount</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mpsv</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>l</name><operator>.</operator><name>li</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NOTDONE</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (_nothing_conv_real_list_after_start(tv, &amp;mpsv) != NOTDONE) { goto typval_encode_stop_converting_one_item; } } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_nothing_conv_list_end</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_LIST_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_nothing_conv_list_end(tv)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>_nothing_conv_real_dict_after_start</name><parameter_list>(
<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>dictp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>nodictvar</name></decl></parameter>,
<parameter><decl><type><name>MPConvStackVal</name> <modifier>*</modifier><specifier>const</specifier></type> <name>mpsv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>dictp</name> <operator>!=</operator> <name>nodictvar</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>dictp</name><operator>)</operator><operator>-&gt;</operator><name>dv_refcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>dictp</name><operator>)</operator><operator>-&gt;</operator><name>dv_refcount</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dictp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mpsv</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>d</name><operator>.</operator><name>todo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NOTDONE</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>, <parameter><type><name>mpsv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (_nothing_conv_real_dict_after_start( tv, (dict_T **)&amp;dict, (void *)&amp;TYPVAL_ENCODE_NODICT_VAR, &amp;mpsv) != NOTDONE) { goto typval_encode_stop_converting_one_item; } } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_nothing_conv_dict_end</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>,
<parameter><decl><type><name>dict_T</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>dictp</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>nodictvar</name></decl></parameter>)</parameter_list>
FUNC_ATTR_ALWAYS_INLINE
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>dictp</name> <operator>!=</operator> <name>nodictvar</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><operator>*</operator><name>dictp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dictp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_DICT_END</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>, <parameter><type><name>dict</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_nothing_conv_dict_end(tv, (dict_T **)&amp;dict, (void *)&amp;TYPVAL_ENCODE_NODICT_VAR)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_CONV_RECURSE</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>conv_type</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_SCOPE</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_NAME</name></cpp:macro> <cpp:value>nothing</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:macro> <cpp:value>const void *const</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:macro> <cpp:value>ignored</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval/typval_encode.c.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SCOPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_NAME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_FIRST_ARG_NAME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_ALLOW_SPECIALS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NIL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_BOOL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_NUMBER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FLOAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_STR_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EXT_STRING</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_FUNC_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_LIST</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_EMPTY_DICT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_LIST_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_DICT_END</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPVAL_ENCODE_CONV_RECURSE</name></cpp:undef>




<function><type><name>void</name></type> <name>tv_clear</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>evn_ret</name> <init>= <expr><call><name>encode_vim_to_nothing</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><literal type="string">"tv_clear() argument"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>evn_ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>evn_ret</name> <operator>==</operator> <name>OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>tv_free</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>partial_unref</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_FUNC</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>func_unref</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FALLTHROUGH</name></expr>;</expr_stmt>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_unref</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_dict_unref</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>













<function><type><name>void</name></type> <name>tv_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>v_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>=</operator> <name>VAR_UNLOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>vval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>from</name><operator>-&gt;</operator><name>vval</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>func_ref</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name><operator>-&gt;</operator><name>pt_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>tv_list_ref</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name><operator>-&gt;</operator><name>dv_refcount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_intern2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tv_copy(UNKNOWN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>tv_item_lock</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>deep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>lock</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&gt;=</operator> <name>DICT_MAXNEST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E743: variable nested too deep for (un)lock"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>deep</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>recurse</name><operator>++</operator></expr>;</expr_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHANGE_LOCK</name><parameter_list>(<parameter><type><name>lock</name></type></parameter>, <parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { var = ((VarLockStatus[]) { [VAR_UNLOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), [VAR_LOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), [VAR_FIXED] = VAR_FIXED, })[var]; } while (0)</cpp:value></cpp:define>







<expr_stmt><expr><call><name>CHANGE_LOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>l</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHANGE_LOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>deep</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>deep</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<macro><name>TV_LIST_ITER</name><argument_list>(<argument>l</argument>, <argument>li</argument>, <argument>{
tv_item_lock(TV_LIST_ITEM_TV(li), deep - <literal type="number">1</literal>, lock);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>d</name> <init>= <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHANGE_LOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>dv_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>deep</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>deep</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<macro><name>TV_DICT_ITER</name><argument_list>(<argument>d</argument>, <argument>di</argument>, <argument>{
tv_item_lock(&amp;di-&gt;di_tv, deep - <literal type="number">1</literal>, lock);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_STRING</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHANGE_LOCK</name></cpp:undef>
<expr_stmt><expr><name>recurse</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>bool</name></type> <name>tv_islocked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>v_lock</name></name> <operator>==</operator> <name>VAR_LOCKED</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>tv_list_locked</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VAR_LOCKED</name><operator>)</operator><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name>
<operator>&amp;&amp;</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name><operator>-&gt;</operator><name>dv_lock</name></name> <operator>==</operator> <name>VAR_LOCKED</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>



















<function><type><name>bool</name></type> <name>tv_check_lock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarLockStatus</name></type> <name>lock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>name_len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>lock</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_UNLOCKED</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_LOCKED</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>error_message</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E741: Value is locked: %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_FIXED</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>error_message</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E742: Cannot change value of %.*s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>error_message</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unknown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>name_len</name> <operator>==</operator> <name>TV_TRANSLATE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>name_len</name> <operator>==</operator> <name>TV_CSTRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>name_len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tv_equal_recurse_limit</name></decl>;</decl_stmt>














<function><type><name>bool</name></type> <name>tv_equal</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv1</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>ic</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>recursive</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursive_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tv_is_func</name><argument_list>(<argument><expr><operator>*</operator><name>tv1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tv_is_func</name><argument_list>(<argument><expr><operator>*</operator><name>tv2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>tv1</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name><name>tv2</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursive</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tv_equal_recurse_limit</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>recursive_cnt</name> <operator>&gt;=</operator> <name>tv_equal_recurse_limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tv_equal_recurse_limit</name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>tv1</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>recursive_cnt</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>r</name> <init>= <expr><call><name>tv_list_equal</name><argument_list>(<argument><expr><name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>, <argument><expr><name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>, <argument><expr><name>ic</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>recursive_cnt</name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>recursive_cnt</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>r</name> <init>= <expr><call><name>tv_dict_equal</name><argument_list>(<argument><expr><name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>, <argument><expr><name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>, <argument><expr><name>ic</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>recursive_cnt</name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tv1</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name> <operator>&amp;&amp;</operator> <name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>tv2</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name> <operator>&amp;&amp;</operator> <name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>recursive_cnt</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>r</name> <init>= <expr><call><name>func_equal</name><argument_list>(<argument><expr><name>tv1</name></expr></argument>, <argument><expr><name>tv2</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>recursive_cnt</name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <block>{<block_content>
<return>return <expr><name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>==</operator> <name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <block>{<block_content>
<return>return <expr><name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name> <operator>==</operator> <name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf1</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf2</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><call><name>tv_get_string_buf</name><argument_list>(<argument><expr><name>tv1</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><call><name>tv_get_string_buf</name><argument_list>(<argument><expr><name>tv2</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>mb_strcmp_ic</name><argument_list>(<argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>ic</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<return>return <expr><name><name>tv1</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name> <operator>==</operator> <name><name>tv2</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>


<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>












<function><type><name>bool</name></type> <name>tv_check_str_or_nr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E805: Expected a Number or a String, Float found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E703: Expected a Number or a String, Funcref found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E745: Expected a Number or a String, List found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E728: Expected a Number or a String, Dictionary found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E5300: Expected a Number or a String"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_intern2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tv_check_str_or_nr(UNKNOWN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_ERROR</name></cpp:macro> <cpp:value>"E703: Using a Funcref as a Number"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>num_errors</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>VAR_PARTIAL</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><name>FUNC_ERROR</name></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_FUNC</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><name>FUNC_ERROR</name></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_LIST</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E745: Using a List as a Number"</literal></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_DICT</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E728: Using a Dictionary as a Number"</literal></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_FLOAT</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E805: Using a Float as a Number"</literal></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_UNKNOWN</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E685: using an invalid value as a Number"</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FUNC_ERROR</name></cpp:undef>









<function><type><name>bool</name></type> <name>tv_check_num</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_FUNC</name></expr>:</case>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_LIST</name></expr>:</case>
<case>case <expr><name>VAR_DICT</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>num_errors</name><index>[<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_ERROR</name></cpp:macro> <cpp:value>"E729: using Funcref as a String"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>str_errors</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>VAR_PARTIAL</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><name>FUNC_ERROR</name></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_FUNC</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><name>FUNC_ERROR</name></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_LIST</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E730: using List as a String"</literal></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_DICT</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E731: using Dictionary as a String"</literal></expr></argument>)</argument_list></call></expr>,
<expr><index>[<expr><name>VAR_FLOAT</name></expr>]</index><operator>=</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>e_float_as_string</name><operator>)</operator></expr>,
<expr><index>[<expr><name>VAR_UNKNOWN</name></expr>]</index><operator>=</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E908: using an invalid value as a String"</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FUNC_ERROR</name></cpp:undef>









<function><type><name>bool</name></type> <name>tv_check_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case>
<case>case <expr><name>VAR_LIST</name></expr>:</case>
<case>case <expr><name>VAR_DICT</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>str_errors</name><index>[<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>












<function><type><name>varnumber_T</name></type> <name>tv_get_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













<decl_stmt><decl><type><name>varnumber_T</name></type> <name>tv_get_number_chk</name><argument_list>(<argument><expr><specifier>const</specifier> <name>typval_T</name> <operator>*</operator><specifier>const</specifier> <name>tv</name></expr></argument>, <argument><expr><name>bool</name> <operator>*</operator><specifier>const</specifier> <name>ret_error</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_WARN_UNUSED_RESULT</name> <name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_FUNC</name></expr>:</case>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_LIST</name></expr>:</case>
<case>case <expr><name>VAR_DICT</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>num_errors</name><index>[<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <block>{<block_content>
<return>return <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>STR2NR_ALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name> <operator>==</operator> <name>kSpecialVarTrue</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_intern2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tv_get_number(UNKNOWN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>ret_error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>ret_error</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<function><type><name>linenr_T</name></type> <name>tv_get_lnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name> <init>= <expr><operator>(</operator><name>linenr_T</name><operator>)</operator><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>fnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fp</name> <init>= <expr><call><name>var2fpos</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>fp</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>lnum</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>float_T</name></type> <name>tv_get_float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <block>{<block_content>
<return>return <expr><operator>(</operator><name>float_T</name><operator>)</operator><operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name><operator>)</operator></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <block>{<block_content>
<return>return <expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E891: Using a Funcref as a Float"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E892: Using a String as a Float"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_LIST</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E893: Using a List as a Float"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_DICT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E894: Using a Dictionary as a Float"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E907: Using a special value as a Float"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>emsgf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_intern2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tv_get_float(UNKNOWN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_get_string_buf_chk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NUMBUFLEN</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIdVARNUMBER</name></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_STRING</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>encode_special_var_names</name><index>[<expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_special</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>
<case>case <expr><name>VAR_FUNC</name></expr>:</case>
<case>case <expr><name>VAR_LIST</name></expr>:</case>
<case>case <expr><name>VAR_DICT</name></expr>:</case>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>
<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>str_errors</name><index>[<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_get_string_chk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>mybuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<return>return <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>mybuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_get_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>mybuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<return>return <expr><call><name>tv_get_string_buf</name><argument_list>(<argument><expr><operator>(</operator><name>typval_T</name> <operator>*</operator><operator>)</operator><name>tv</name></expr></argument>, <argument><expr><name>mybuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tv_get_string_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>typval_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tv</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buf</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>res</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>res</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
