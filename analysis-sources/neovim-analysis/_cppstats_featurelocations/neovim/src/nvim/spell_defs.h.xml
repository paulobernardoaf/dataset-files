<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\spell_defs.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NVIM_SPELL_DEFS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NVIM_SPELL_DEFS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/buffer_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXWLEN</name></cpp:macro> <cpp:value>254</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXREGIONS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>



<typedef>typedef <type><name>int</name></type> <name>idx_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_TMPL</name></cpp:macro> <cpp:value>"%s.%s.spl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ADD</name></cpp:macro> <cpp:value>".add."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ASCII</name></cpp:macro> <cpp:value>".ascii."</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_REGION</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_ONECAP</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_ALLCAP</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_RARE</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_BANNED</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_AFX</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_FIXCAP</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_KEEPCAP</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_HAS_AFF</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NEEDCOMP</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOSUGGEST</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_COMPROOT</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOCOMPBEF</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOCOMPAFT</name></cpp:macro> <cpp:value>0x2000</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_RARE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_NC</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_UP</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_COMPPERMIT</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_COMPFORBID</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_RAREPFX</name></cpp:macro> <cpp:value>(WFP_RARE &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_NC</name></cpp:macro> <cpp:value>(WFP_NC &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_UP</name></cpp:macro> <cpp:value>(WFP_UP &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_COMPPERMIT</name></cpp:macro> <cpp:value>(WFP_COMPPERMIT &lt;&lt; 24)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_COMPFORBID</name></cpp:macro> <cpp:value>(WFP_COMPFORBID &lt;&lt; 24)</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKDUP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKREP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKCASE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKTRIPLE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>fromto_S</name> <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ft_from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ft_to</name></decl>;</decl_stmt>
}</block></struct></type> <name>fromto_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>salitem_S</name> <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_lead</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sm_leadlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_oneof</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_rules</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_to</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_lead_w</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_oneof_w</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_to_w</name></decl>;</decl_stmt> 
}</block></struct></type> <name>salitem_T</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>salfirst_T</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_TRUNCERROR</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_FORMERROR</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_OTHERERROR</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define> 














<typedef>typedef <type><name><name>struct</name> <name>slang_S</name></name></type> <name>slang_T</name>;</typedef>

<struct>struct <name>slang_S</name> <block>{
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>sl_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_fname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_add</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_fbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_fidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_kbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_kidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_pbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_pidxs</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_info</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sl_regions</name><index>[<expr><name>MAXREGIONS</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_midword</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_wordcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_compmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compminlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compsylmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compoptions</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_comppat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>sl_compprog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_comprules</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_compstartflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_compallflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_nobreak</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_syllable</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_syl_items</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_prefixcnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>sl_prefprog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_rep</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>sl_rep_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_sal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>salfirst_T</name></type> <name><name>sl_sal_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>sl_followup</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_collapse</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_rem_accents</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_sofo</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_repsal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int16_t</name></type> <name><name>sl_repsal_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_nosplitsugs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_nocompoundsugs</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>time_t</name></type> <name>sl_sugtime</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_sbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_sidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>sl_sugbuf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>sl_sugloaded</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>bool</name></type> <name>sl_has_map</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_map_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>sl_map_array</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_sounddone</name></decl>;</decl_stmt> 

}</block>;</struct>


<typedef>typedef <type><struct>struct <name>langp_S</name> <block>{
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_slang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_sallang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_replang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lp_region</name></decl>;</decl_stmt> 
}</block></struct></type> <name>langp_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANGP_ENTRY</name><parameter_list>(<parameter><type><name>ga</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((langp_T *)(ga).ga_data) + (i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGIC</name></cpp:macro> <cpp:value>"VIMsug"</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGICL</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGVERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGION_ALL</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define> 



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>bool</name></type> <name><name>st_isw</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name><name>st_isu</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_fold</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_upper</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>spelltab_T</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>STATE_START</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 


<decl><name>STATE_NOPREFIX</name></decl>, 
<decl><name>STATE_SPLITUNDO</name></decl>, 
<decl><name>STATE_ENDNUL</name></decl>, 
<decl><name>STATE_PLAIN</name></decl>, 
<decl><name>STATE_DEL</name></decl>, 
<decl><name>STATE_INS_PREP</name></decl>, 
<decl><name>STATE_INS</name></decl>, 
<decl><name>STATE_SWAP</name></decl>, 
<decl><name>STATE_UNSWAP</name></decl>, 
<decl><name>STATE_SWAP3</name></decl>, 
<decl><name>STATE_UNSWAP3</name></decl>, 
<decl><name>STATE_UNROT3L</name></decl>, 
<decl><name>STATE_UNROT3R</name></decl>, 
<decl><name>STATE_REP_INI</name></decl>, 
<decl><name>STATE_REP</name></decl>, 
<decl><name>STATE_REP_UNDO</name></decl>, 
<decl><name>STATE_FINAL</name></decl> 
}</block></enum></type> <name>state_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>trystate_S</name> <block>{
<decl_stmt><decl><type><name>state_T</name></type> <name>ts_state</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ts_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name></type> <name>ts_arridx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>ts_curi</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fidxtry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_twordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_prefixdepth</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>ts_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_tcharlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_tcharidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_isdiff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fcharstart</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_prewordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_splitoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_splitfidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_complen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_compsplit</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_save_badflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_delidx</name></decl>;</decl_stmt> 

}</block></struct></type> <name>trystate_T</name>;</typedef>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOFOLD</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 128 ? utf_fold(c) : (int)spelltab.st_fold[c])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 128 ? mb_toupper(c) : (int)spelltab.st_upper[c])</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ISUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 128 ? mb_isupper(c) : spelltab.st_isu[c])</cpp:value></cpp:define>



<decl_stmt><decl><type><specifier>extern</specifier> <name>slang_T</name> <modifier>*</modifier></type><name>first_lang</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>extern</specifier> <name>char_u</name> <modifier>*</modifier></type><name>int_wordlist</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>spelltab_T</name></type> <name>spelltab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>did_set_spelltab</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>e_format</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
