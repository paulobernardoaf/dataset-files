<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\neovim-analysis\_cppstats_featurelocations\neovim\src\nvim\path.c">


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/vim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_docmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/ex_getln.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/fileio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/file_search.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/garray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/misc1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/option.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/shell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os_unix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/quickfix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/regexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/screen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/os/input.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nvim/window.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URL_SLASH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URL_BACKSLASH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>gen_expand_wildcards</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>gen_expand_wildcards</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_GENERATED_DECLARATIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"path.c.generated.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>









<function><type><name>FileComparison</name></type> <name>path_full_compare</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>checkname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>expandenv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s1</name> <operator>&amp;&amp;</operator> <name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>exp1</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>full1</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>full2</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileID</name></type> <name>file_id_1</name></decl>, <decl><type ref="prev"/><name>file_id_2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>expandenv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>expand_env</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>exp1</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>exp1</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s1</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>id_ok_1</name> <init>= <expr><call><name>os_fileid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>exp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_id_1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>id_ok_2</name> <init>= <expr><call><name>os_fileid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_id_2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id_ok_1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>id_ok_2</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>checkname</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>vim_FullName</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>exp1</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>full1</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_FullName</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>full2</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fnamecmp</name><argument_list>(<argument><expr><name>full1</name></expr></argument>, <argument><expr><name>full2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>kEqualFileNames</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>kBothFilesMissing</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id_ok_1</name> <operator>||</operator> <operator>!</operator><name>id_ok_2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>kOneFileMissing</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_fileid_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file_id_1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_id_2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>kEqualFiles</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>kDifferentFiles</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>char_u</name> <modifier>*</modifier></type><name>path_tail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><call><name>get_past_head</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>tail</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>tail</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>char_u</name> <modifier>*</modifier></type><name>path_tail_with_sep</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>past_head</name> <init>= <expr><call><name>get_past_head</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><call><name>path_tail</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>tail</name> <operator>&gt;</operator> <name>past_head</name> <operator>&amp;&amp;</operator> <call><name>after_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tail</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>tail</name></expr>;</return>
</block_content>}</block></function>










<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>invocation_path_tail</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char_u</name> <operator>*</operator><name>invocation</name></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator><name>len</name></expr></argument>)</argument_list>
<name>FUNC_ATTR_NONNULL_RET</name> <name>FUNC_ATTR_NONNULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><call><name>get_past_head</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>invocation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>tail</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>was_sep</name> <init>= <expr><call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>was_sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>tail</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>tail</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path_next_component</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>fname</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fname</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fname</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>fname</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>char_u</name> <modifier>*</modifier></type><name>get_past_head</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>path</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>retval</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>retval</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>vim_ispathsep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>;</return> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>vim_ispathsep_nocolon</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">':'</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>vim_ispathlistsep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">';'</literal></expr>;</return> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><name>char_u</name> <modifier>*</modifier></type><name>shorten_dir</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><call><name>path_tail</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>skip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>str</name></expr></init></decl>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name>tail</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>bool</name></type> <name>dir_of_file_exists</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>path_tail_with_sep</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>fname</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>os_isdir</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>path_fnamecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname2</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>path_fnamencmp</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>mb_strcmp_ic</name><argument_list>(<argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>p_fic</name></expr></argument>, <argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>










<function><type><name>int</name></type> <name>path_fnamencmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname2</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>c1</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c2</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>fname1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><name>fname2</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c1</name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <name>c2</name> <operator>==</operator> <name>NUL</name>
<operator>||</operator> <operator>(</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>c1</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name>c1</name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c2</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c2</name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>p_fic</name></expr> ?</condition><then> <expr><operator>(</operator><name>c1</name> <operator>!=</operator> <name>c2</name> <operator>&amp;&amp;</operator> <call><name>CH_FOLD</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CH_FOLD</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p1</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>c1</name> <operator>-</operator> <name>c2</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name>p_fic</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>mb_strnicmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>fname1</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char_u</name> <operator>*</operator><operator>)</operator><name>fname2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>do_concat_fnames</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sep</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>fname1</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>after_pathsep</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>fname1</name> <operator>+</operator> <name>len1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fname1</name><index>[<expr><name>len1</name></expr>]</index></name> <operator>=</operator> <name>PATHSEP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>fname1</name> <operator>+</operator> <name>len1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fname2</name></expr></argument>, <argument><expr><name>len2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>fname1</name> <operator>+</operator> <name>len1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>, <argument><expr><name>len2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>fname1</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>char</name> <modifier>*</modifier></type><name>concat_fnames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sep</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len1</name> <operator>+</operator> <name>len2</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>len1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>do_concat_fnames</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><name>char</name> <modifier>*</modifier></type><name>concat_fnames_realloc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sep</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>do_concat_fnames</name><argument_list>(<argument><expr><call><name>xrealloc</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>len1</name> <operator>+</operator> <name>len2</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len1</name></expr></argument>,
<argument><expr><name>fname2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type> <name>add_pathsep</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>after_pathsep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>pathsep_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PATHSEPSTR</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>MAXPATHL</name> <operator>-</operator> <name>pathsep_len</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>PATHSEPSTR</name></expr></argument>, <argument><expr><name>pathsep_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>char</name> <modifier>*</modifier></type><name>FullName_save</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>vim_FullName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>xstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>char</name> <modifier>*</modifier></type><name>save_abs_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>path_is_absolute</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>FullName_save</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strsave</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type> <name>path_has_wildcard</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wildcards</name> <init>= <expr><literal type="string">"*?[{`'$"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wildcards</name> <init>= <expr><literal type="string">"?*$[`"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>wildcards</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>pstrcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>pathcmp</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type> <name>path_has_exp_wildcard</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wildcards</name> <init>= <expr><literal type="string">"*?[{"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wildcards</name> <init>= <expr><literal type="string">"*?["</literal></expr></init></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>wildcards</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>size_t</name></type> <name>path_expand</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<return>return <expr><call><name>do_path_expand</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scandir_next_with_dots</name><parameter_list>(<parameter><decl><type><name>Directory</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><literal type="string">".."</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>os_scandir_next</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>size_t</name></type> <name>do_path_expand</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>wildoff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>didstar</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>start_len</name> <init>= <expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>starstar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stardepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 


<if_stmt><if>if <condition>(<expr><name>stardepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>os_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>path_end</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>path_end</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>path_end</name> <operator>&gt;=</operator> <name>path</name> <operator>+</operator> <name>wildoff</name> <operator>&amp;&amp;</operator> <call><name>rem_backslash</name><argument_list>(<argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>path_end</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><operator>*</operator><name>path_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>path_end</name> <operator>&gt;=</operator> <name>path</name> <operator>+</operator> <name>wildoff</name>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"*?[{~$"</literal></expr></argument>, <argument><expr><operator>*</operator><name>path_end</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <operator>(</operator><operator>!</operator><name>p_fic</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_ICASE</name><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>isalpha</name><argument_list>(<argument><expr><call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path_end</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>path_end</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>path_end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>wildoff</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>s</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>starstar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>


<decl_stmt><decl><type><name>int</name></type> <name>starts_with_dot</name> <init>= <expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>file_pat_to_reg_pat</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_ICASE</name><operator>)</operator> <operator>||</operator> <name>p_fic</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EW_NOERROR</name> <operator>|</operator> <name>EW_NOTWILD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>emsg_silent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>RE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EW_NOERROR</name> <operator>|</operator> <name>EW_NOTWILD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>emsg_silent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_NOTWILD</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>didstar</name> <operator>&amp;&amp;</operator> <name>stardepth</name> <operator>&lt;</operator> <literal type="number">100</literal> <operator>&amp;&amp;</operator> <name>starstar</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>-</operator> <name>s</name> <operator>==</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <operator>*</operator><name>path_end</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>path_end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stardepth</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>do_path_expand</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>s</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stardepth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Directory</name></type> <name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dirpath</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>buf</name> <operator>==</operator> <name>NUL</name></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_file_is_readable</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>os_scandir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>scandir_next_with_dots</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<while>while <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>scandir_next_with_dots</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal>
<operator>||</operator> <name>starts_with_dot</name>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_DODOT</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name><operator>)</operator><operator>)</operator><operator>)</operator> 
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_NOTWILD</name><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>fnamencmp</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <operator>(</operator><name>s</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>starstar</name> <operator>&amp;&amp;</operator> <name>stardepth</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"/**"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>stardepth</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>do_path_expand</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>stardepth</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>path_has_exp_wildcard</name><argument_list>(<argument><expr><name>path_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>do_path_expand</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>FileInfo</name></type> <name>file_info</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path_end</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>backslash_halve</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_ALLLINKS</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>os_fileinfo_link</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>os_path_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addfile</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>os_closedir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>matches</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <name>start_len</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>matches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>start_len</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pstrcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>matches</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>find_previous_pathsep</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>psep</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>psep</name> <operator>&gt;</operator> <name>path</name> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>psep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><operator>*</operator><name>psep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>psep</name> <operator>&gt;</operator> <name>path</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>psep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>OK</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><name>psep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_unique</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>maybe_unique</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>other_paths</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>i</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue> 
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>candidate_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>maybe_unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>other_path_len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>other_paths</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>other_path_len</name> <operator>&lt;</operator> <name>candidate_len</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue> 
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rival</name> <init>= <expr><name><name>other_paths</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>other_path_len</name> <operator>-</operator> <name>candidate_len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fnamecmp</name><argument_list>(<argument><expr><name>maybe_unique</name></expr></argument>, <argument><expr><name>rival</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>rival</name> <operator>==</operator> <name><name>other_paths</name><index>[<expr><name>j</name></expr>]</index></name> <operator>||</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>rival</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return> 
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>expand_path_option</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>curdir</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path_option</name> <init>= <expr><ternary><condition><expr><operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_path</name></name> <operator>==</operator> <name>NUL</name></expr> ?</condition><then> <expr><name>p_path</name></expr> </then><else>: <expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_path</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>path_option</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_option</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">" ,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>path_tail</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ffname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MAXPATHL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>simplify_filename</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>path_with_url</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>path_is_absolute</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal> <operator>&gt;</operator> <name>MAXPATHL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><name>PATHSEP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>simplify_filename</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GA_APPEND</name><argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>get_path_cutoff</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>maxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>path_part</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cutoff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name><name>fname</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>path_part</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <operator>(</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>fname</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>path_part</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>)</operator> 
<operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>path_part</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>maxlen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cutoff</name> <operator>=</operator> <operator>&amp;</operator><name><name>fname</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>cutoff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>cutoff</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>cutoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>cutoff</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>uniquefy_paths</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnames</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>sort_again</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>path_ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>in_curdir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>short_name</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_remove_duplicate_strings</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>file_pattern</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>file_pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file_pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>file_pattern</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>file_pat_to_reg_pat</name><argument_list>(<argument><expr><name>file_pattern</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>file_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>curdir</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>os_dirname</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expand_path_option</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>in_curdir</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>fnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_in_curdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dir_end</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>gettail_dir</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pathsep_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path_cutoff</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is_in_curdir</name> <operator>=</operator> <call><name>fnamencmp</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir_end</name> <operator>-</operator> <name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name><name>curdir</name><index>[<expr><name>dir_end</name> <operator>-</operator> <name>path</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_in_curdir</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>in_curdir</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>path_cutoff</name> <operator>=</operator> <call><name>get_path_cutoff</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal>
<operator>&amp;&amp;</operator> <call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><name><name>pattern</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>path_cutoff</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>path_cutoff</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>is_unique</name><argument_list>(<argument><expr><name>path_cutoff</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sort_again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_cutoff</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>path_cutoff</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>pathsep_p</name> <operator>=</operator> <name>path</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>find_previous_pathsep</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathsep_p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>pathsep_p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>is_unique</name><argument_list>(<argument><expr><name>pathsep_p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>path_cutoff</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pathsep_p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>path_cutoff</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sort_again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathsep_p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pathsep_p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>path_is_absolute</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>










<expr_stmt><expr><name>short_name</name> <operator>=</operator> <call><name>path_shorten_fname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>short_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>short_name</name> <operator>&gt;</operator> <name>path</name> <operator>+</operator> <literal type="number">1</literal></expr>
)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>short_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>os_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rel_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>in_curdir</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<expr_stmt><expr><name>short_name</name> <operator>=</operator> <call><name>path_shorten_fname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>short_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>short_name</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_unique</name><argument_list>(<argument><expr><name>short_name</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>short_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rel_path</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>short_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>PATHSEPSTR</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rel_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>short_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rel_path</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sort_again</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>os_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>in_curdir</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>in_curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sort_again</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ga_remove_duplicate_strings</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>









<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gettail_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fname</name></decl></parameter>)</parameter_list>
FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir_end</name> <init>= <expr><name>fname</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next_dir_end</name> <init>= <expr><name>fname</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>look_for_sep</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>fname</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>look_for_sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next_dir_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>look_for_sep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>look_for_sep</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dir_end</name> <operator>=</operator> <name>next_dir_end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>look_for_sep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>dir_end</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type> <name>expand_in_path</name><parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier><specifier>const</specifier></type> <name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>path_ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>curdir</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>os_dirname</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expand_path_option</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><specifier>const</specifier></type> <name>paths</name> <init>= <expr><call><name>ga_concat_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>glob_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EW_ICASE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>glob_flags</name> <operator>|=</operator> <name>WILD_ICASE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EW_ADDSLASH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>glob_flags</name> <operator>|=</operator> <name>WILD_ADD_SLASH</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>globpath</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>glob_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_env_var</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <literal type="string">"$"</literal></expr></argument> , <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPECIAL_WILDCHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_special_wildchar</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>SPECIAL_WILDCHAR</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'`'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



















<function><type><name>int</name></type> <name>gen_expand_wildcards</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_pat</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>recursive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>add_pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>did_expand_in_path</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name>recursive</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPECIAL_WILDCHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>os_expand_wildcards</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>FAIL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPECIAL_WILDCHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>






<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>has_special_wildchar</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>vim_backtick</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>os_expand_wildcards</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pat</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>add_pat</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_backtick</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_pat</name> <operator>=</operator> <call><name>expand_backtick</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>add_pat</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>has_env_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_NOTENV</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>expand_env_save_opt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>





<if type="elseif">else if <condition>(<expr><call><name>has_env_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>os_expand_wildcards</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
<argument><expr><name>flags</name> <operator>|</operator> <name>EW_KEEPDOLLAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><call><name>path_has_exp_wildcard</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_PATH</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>path_is_absolute</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>
)</condition> <block>{<block_content>


<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>add_pat</name> <operator>=</operator> <call><name>expand_in_path</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>did_expand_in_path</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tmp_add_pat</name> <init>= <expr><call><name>path_expand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tmp_add_pat</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>add_pat</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>tmp_add_pat</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>add_pat</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>add_pat</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_NOTFOUND</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>backslash_halve_save</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EW_NOTFOUND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>EW_DIR</name> <operator>|</operator> <name>EW_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>did_expand_in_path</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GA_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_PATH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>uniquefy_paths</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_EMPTYOK</name><operator>)</operator> <operator>||</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>OK</name></expr> </then><else>: <expr><name>FAIL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>vim_backtick</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'`'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'`'</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>expand_backtick</name><parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>vim_strnsave</name><argument_list>(<argument><expr><name>pat</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>eval_to_string</name><argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>get_cmd_output</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_SILENT</name><operator>)</operator></expr> ?</condition><then> <expr><name>kShellOptSilent</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name>i</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addfile</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>cmd</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></while>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>








<function><type><name>void</name></type> <name>slash_adjust</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>path_with_url</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <operator>(</operator><name>char_u</name><operator>)</operator><name>psepcN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><name>psepc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><name>void</name></type> <name>addfile</name><parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>isdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileInfo</name></type> <name>file_info</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_NOTFOUND</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_ALLLINKS</name><operator>)</operator></expr>
?</condition><then> <expr><operator>!</operator><call><name>os_fileinfo_link</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><operator>!</operator><call><name>os_path_exists</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FNAME_ILLEGAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>vim_strpbrk</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>FNAME_ILLEGAL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>isdir</name> <operator>=</operator> <call><name>os_isdir</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isdir</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_DIR</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>isdir</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_FILE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isdir</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_EXEC</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>os_can_exe</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_SHELLCMD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>isdir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>slash_adjust</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<if_stmt><if>if <condition>(<expr><name>isdir</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_ADDSLASH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>GA_APPEND</name><argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>simplify_filename</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>components</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>stripping_disabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>relative</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>relative</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<do>do<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block>
while <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt> 

<do>do <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>relative</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if> 
<else>else <block>{<block_content>




<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>components</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>bool</name></type> <name>do_strip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name>saved_char</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stripping_disabled</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>saved_char</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FileInfo</name></type> <name>file_info</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>os_fileinfo_link</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>do_strip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>saved_char</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>after_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>start</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_strip</name></expr>)</condition> <block>{<block_content>










<expr_stmt><expr><name>saved_char</name> <operator>=</operator> <operator>*</operator><name>tail</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_fileinfo</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>do_strip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>stripping_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>saved_char</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>do_strip</name></expr>)</condition> <block>{<block_content>







<decl_stmt><decl><type><name>FileInfo</name></type> <name>new_file_info</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>relative</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>os_fileinfo</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_file_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>saved_char</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>os_fileinfo</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_file_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>saved_char</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>os_fileinfo_id_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_file_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>do_strip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>



</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_strip</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>
<expr_stmt><expr><name>components</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>relative</name> <operator>&amp;&amp;</operator> <name><name>tail</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <name><name>tail</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>--</operator><name>components</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name>start</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>relative</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>start</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>tail</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>components</name><operator>++</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>path_next_component</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>eval_includeexpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>set_vim_var_string</name><argument_list>(<argument><expr><name>VV_FNAME</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>eval_to_string_safe</name><argument_list>(
<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_inex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>was_set_insecurely</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"includeexpr"</literal></expr></argument>,
<argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_vim_var_string</name><argument_list>(<argument><expr><name>VV_FNAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>char_u</name> <modifier>*</modifier></type>
<name>find_file_name_in_path</name> <parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rel_fname</name></decl></parameter> 
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>file_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>FNAME_INCL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_inex</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tofree</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <call><name>eval_includeexpr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tofree</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tofree</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>FNAME_EXP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>file_name</name> <operator>=</operator> <call><name>find_file_in_path</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>FNAME_MESS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>rel_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>file_name</name> <operator>==</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>FNAME_INCL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_inex</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tofree</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <call><name>eval_includeexpr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tofree</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tofree</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_name</name> <operator>=</operator> <call><name>find_file_in_path</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>FNAME_MESS</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>rel_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>file_name</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>FNAME_MESS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name>c</name> <init>= <expr><name><name>ptr</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMSG2</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E447: Can't find file \"%s\" in path"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<while>while <condition>(<expr><name>file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>--</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file_name</name> <operator>=</operator> <call><name>find_file_in_path</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>rel_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>file_name</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>file_name</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>path_is_url</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"://"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>URL_SLASH</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">":\\\\"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>URL_BACKSLASH</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>path_with_url</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>fname</name></expr>;</init> <condition><expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content/>}</block></for>
<return>return <expr><call><name>path_is_url</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>vim_isAbsName</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>path_with_url</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>path_is_absolute</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><name>int</name></type> <name>vim_FullName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ARG<parameter_list>(</parameter_list>2</function>)
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>slash_adjust</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>path_with_url</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>path_to_absolute</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>slash_adjust</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block>











<function><type><name>char</name> <modifier>*</modifier></type><name>fix_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>FullName_save</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_isAbsName</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"//"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>FullName_save</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FNAME_CASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>path_fix_case</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>path_fix_case</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><name>FileInfo</name></type> <name>file_info</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>os_fileinfo_link</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>slash</name> <init>= <expr><call><name>STRRCHR</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Directory</name></type> <name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ok</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>os_scandir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>slash</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>os_scandir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>slash</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <call><name>os_scandir_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>newname</name><index>[<expr><name>MAXPATHL</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>newname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name>newname</name> <operator>+</operator> <operator>(</operator><name>tail</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
<argument><expr><name>MAXPATHL</name> <operator>-</operator> <operator>(</operator><name>tail</name> <operator>-</operator> <name>name</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FileInfo</name></type> <name>file_info_new</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_fileinfo_link</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>newname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info_new</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>os_fileinfo_id_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file_info_new</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>os_closedir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>after_pathsep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>p</name> <operator>&gt;</operator> <name>b</name> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>utf_head_off</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type> <name>same_directory</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>f2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>ffname</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t2</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>f1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>f2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vim_FullName</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f1</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ffname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>path_tail_with_sep</name><argument_list>(<argument><expr><name>ffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>path_tail_with_sep</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>t1</name> <operator>-</operator> <name>ffname</name> <operator>==</operator> <name>t2</name> <operator>-</operator> <name>f2</name>
<operator>&amp;&amp;</operator> <call><name>pathcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ffname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>t1</name> <operator>-</operator> <name>ffname</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type> <name>pathcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name>maxlen</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>maxlen</name><operator>)</operator></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>q</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>p_fic</name></expr> ?</condition><then> <expr><call><name>mb_toupper</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>mb_toupper</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr></else></ternary><operator>)</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>c1</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name>c2</name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>c1</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>c2</name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>p_fic</name></expr> ?</condition><then> <expr><call><name>mb_toupper</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>mb_toupper</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>c1</name> <operator>-</operator> <name>c2</name></expr></else></ternary></expr>;</return> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>q</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>i</name> <operator>+</operator> <call><name>utfc_ptr2len</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>after_pathsep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>(</operator><name>c1</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name>c1</name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<operator>&amp;&amp;</operator> <name>c1</name> <operator>==</operator> <literal type="char">'/'</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>q</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>









<function><type><name>char_u</name> <modifier>*</modifier></type><name>path_try_shorten_fname</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>full_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>full_path</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>os_dirname</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>path_shorten_fname</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>full_path</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>char_u</name> <modifier>*</modifier></type><name>path_shorten_fname</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>full_path</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dir_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>full_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dir_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dir_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>full_path</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fnamencmp</name><argument_list>(<argument><expr><name>dir_name</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>!</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>















<function><type><name>int</name></type> <name>expand_wildcards_eval</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>eval_pat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>exp_pat</name> <init>= <expr><operator>*</operator><name>pat</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ignored_msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>usedlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>exp_pat</name> <operator>==</operator> <literal type="char">'%'</literal> <operator>||</operator> <operator>*</operator><name>exp_pat</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator> <operator>*</operator><name>exp_pat</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>emsg_off</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eval_pat</name> <operator>=</operator> <call><name>eval_vars</name><argument_list>(<argument><expr><name>exp_pat</name></expr></argument>, <argument><expr><name>exp_pat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usedlen</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignored_msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>emsg_off</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eval_pat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>exp_pat</name> <operator>=</operator> <call><name>concat_str</name><argument_list>(<argument><expr><name>eval_pat</name></expr></argument>, <argument><expr><name>exp_pat</name> <operator>+</operator> <name>usedlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exp_pat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>expand_wildcards</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exp_pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eval_pat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>exp_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>eval_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>int</name></type> <name>expand_wildcards</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_pat</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_files</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>files</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>non_suf_match</name></decl>;</decl_stmt> 

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>gen_expand_wildcards</name><argument_list>(<argument><expr><name>num_pat</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_files</name></expr></argument>, <argument><expr><name>files</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EW_KEEPALL</name><operator>)</operator> <operator>||</operator> <name>retval</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_wig</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ffname</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>num_files</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>files</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_files</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ffname</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>FullName_save</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ffname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>match_file_list</name><argument_list>(<argument><expr><name>p_wig</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>ffname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <operator>*</operator><name>num_files</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_files</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>num_files</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>files</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_files</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>non_suf_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_files</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_suffix</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <name>non_suf_match</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>files</name><operator>)</operator><index>[<expr><name>non_suf_match</name><operator>++</operator></expr>]</index> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_files</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XFREE_CLEAR</name><argument_list>(<argument><expr><operator>*</operator><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>match_suffix</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXSUFLEN</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>suf_buf</name><index>[<expr><name>MAXSUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fnamelen</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>setsuflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>char_u</name> <modifier>*</modifier></type><name>setsuf</name> <init>= <expr><name>p_su</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>setsuf</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>setsuflen</name> <operator>=</operator> <call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>setsuf</name></expr></argument>, <argument><expr><name>suf_buf</name></expr></argument>, <argument><expr><name>MAXSUFLEN</name></expr></argument>, <argument><expr><literal type="string">".,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>setsuflen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><call><name>path_tail</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>setsuflen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fnamelen</name> <operator>&gt;=</operator> <name>setsuflen</name>
<operator>&amp;&amp;</operator> <call><name>fnamencmp</name><argument_list>(<argument><expr><name>suf_buf</name></expr></argument>, <argument><expr><name>fname</name> <operator>+</operator> <name>fnamelen</name> <operator>-</operator> <name>setsuflen</name></expr></argument>, <argument><expr><name>setsuflen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>setsuflen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>setsuflen</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>path_full_dir_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>SUCCESS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>os_dirname</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>old_dir</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>os_dirname</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>old_dir</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>os_chdir</name><argument_list>(<argument><expr><name>old_dir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SUCCESS</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>os_chdir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SUCCESS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>FAIL</name> <operator>||</operator> <call><name>os_dirname</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>os_chdir</name><argument_list>(<argument><expr><name>old_dir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SUCCESS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMSG</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_prev_dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>append_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_append</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>current_length</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>to_append_length</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>to_append</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>to_append_length</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>to_append</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>current_length</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>current_length</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>current_length</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 


<if_stmt><if>if <condition>(<expr><name>current_length</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>max_len</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PATHSEPSTR</name></expr></argument>, <argument><expr><name>max_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>current_length</name> <operator>+</operator> <name>to_append_length</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>max_len</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>to_append</name></expr></argument>, <argument><expr><name>max_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>int</name></type> <name>path_to_absolute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relative_directory</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end_of_path</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fname</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <operator>!</operator><call><name>path_is_absolute</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>STRRCHR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>STRRCHR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>fname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>relative_directory</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>PATHSEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>relative_directory</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>relative_directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>fname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>relative_directory</name><index>[<expr><name>p</name><operator>-</operator><name>fname</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>end_of_path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>relative_directory</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_of_path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fname</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>FAIL</name> <operator>==</operator> <call><name>path_full_dir_name</name><argument_list>(<argument><expr><name>relative_directory</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>relative_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>relative_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>append_path</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>end_of_path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>path_is_absolute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><operator>(</operator><operator>(</operator><call><name>isalpha</name><argument_list>(<argument><expr><name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal>
<operator>&amp;&amp;</operator> <call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><name><name>fname</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <operator>(</operator><call><name>vim_ispathsep_nocolon</name><argument_list>(<argument><expr><name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>fname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><operator>*</operator><name>fname</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>fname</name> <operator>==</operator> <literal type="char">'~'</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>path_guess_exepath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
FUNC_ATTR_NONNULL_ALL
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>os_getenv</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>path_is_absolute</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>argv0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>argv0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>PATHSEP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>os_dirname</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>PATHSEPSTR</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>dir_len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>vim_env_iter</name><argument_list>(<argument><expr><name>ENV_SEPCHAR</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>dir_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dir_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NameBuff</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NameBuff</name></expr></argument>, <argument><expr><name>PATHSEPSTR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xstrlcat</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NameBuff</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>os_can_exe</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NameBuff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NameBuff</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>xstrlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
