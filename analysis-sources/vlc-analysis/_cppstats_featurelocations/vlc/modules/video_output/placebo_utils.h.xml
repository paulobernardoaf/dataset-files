<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\vlc-analysis\_cppstats_featurelocations\vlc\modules\video_output\placebo_utils.h">



















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VLC_PLACEBO_UTILS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLC_PLACEBO_UTILS_H</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_picture.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libplacebo/colorspace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libplacebo/shaders/colorspace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libplacebo/utils/upload.h&gt;</cpp:file></cpp:include>


<function_decl><type><name><name>struct</name> <name>pl_context</name></name> <modifier>*</modifier></type><name>vlc_placebo_Create</name><parameter_list>(<parameter><decl><type><name>vlc_object_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name><name>struct</name> <name>pl_color_space</name></name></type> <name>vlc_placebo_ColorSpace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>video_format_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>pl_color_repr</name></name></type> <name>vlc_placebo_ColorRepr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>video_format_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>enum</name> <name>pl_chroma_location</name></name></type> <name>vlc_placebo_ChromaLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>video_format_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>int</name></type> <name>vlc_placebo_PlaneFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>video_format_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pl_plane_data</name></name>[</type></decl></parameter></parameter_list>4]</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><name>int</name></type> <name>vlc_placebo_PlaneData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>picture_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pl_plane_data</name></name>[</type></decl></parameter></parameter_list>4]<operator>,</operator>
const struct pl_buf *buf</function_decl>)<empty_stmt>;</empty_stmt>


<function_decl><type><name>bool</name></type> <name>vlc_placebo_FormatSupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pl_gpu</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>vlc_fourcc_t</name></type></decl></parameter>)</parameter_list>;</function_decl>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENDER_INTENT_TEXT</name></cpp:macro> <cpp:value>"Rendering intent for color conversion"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENDER_INTENT_LONGTEXT</name></cpp:macro> <cpp:value>"The mapping type used to convert between color spaces."</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>intent_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>PL_INTENT_PERCEPTUAL</name></expr>,
<expr><name>PL_INTENT_RELATIVE_COLORIMETRIC</name></expr>,
<expr><name>PL_INTENT_SATURATION</name></expr>,
<expr><name>PL_INTENT_ABSOLUTE_COLORIMETRIC</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>intent_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Perceptual"</literal></expr>,
<expr><literal type="string">"Relative colorimetric"</literal></expr>,
<expr><literal type="string">"Absolute colorimetric"</literal></expr>,
<expr><literal type="string">"Saturation"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIM_TEXT</name></cpp:macro> <cpp:value>"Display primaries"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIM_LONGTEXT</name></cpp:macro> <cpp:value>"The primaries associated with the output display"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>prim_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>PL_COLOR_PRIM_UNKNOWN</name></expr>,
<expr><name>PL_COLOR_PRIM_BT_601_525</name></expr>,
<expr><name>PL_COLOR_PRIM_BT_601_625</name></expr>,
<expr><name>PL_COLOR_PRIM_BT_709</name></expr>,
<expr><name>PL_COLOR_PRIM_BT_470M</name></expr>,
<expr><name>PL_COLOR_PRIM_BT_2020</name></expr>,
<expr><name>PL_COLOR_PRIM_APPLE</name></expr>,
<expr><name>PL_COLOR_PRIM_ADOBE</name></expr>,
<expr><name>PL_COLOR_PRIM_PRO_PHOTO</name></expr>,
<expr><name>PL_COLOR_PRIM_CIE_1931</name></expr>,
<expr><name>PL_COLOR_PRIM_DCI_P3</name></expr>,
<expr><name>PL_COLOR_PRIM_V_GAMUT</name></expr>,
<expr><name>PL_COLOR_PRIM_S_GAMUT</name></expr>,
<expr><name>PL_COLOR_PRIM_DISPLAY_P3</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>prim_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Automatic / Unknown primaries"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.601 (525-line = NTSC, SMPTE-C)"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.601 (625-line = PAL, SECAM)"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.709 (HD), also sRGB"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.470 M"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.2020 (UltraHD)"</literal></expr>,
<expr><literal type="string">"Apple RGB"</literal></expr>,
<expr><literal type="string">"Adobe RGB (1998)"</literal></expr>,
<expr><literal type="string">"ProPhoto RGB (ROMM)"</literal></expr>,
<expr><literal type="string">"CIE 1931 RGB primaries"</literal></expr>,
<expr><literal type="string">"DCI-P3 (Digital Cinema)"</literal></expr>,
<expr><literal type="string">"Panasonic V-Gamut (VARICAM)"</literal></expr>,
<expr><literal type="string">"Sony S-Gamut"</literal></expr>,
<expr><literal type="string">"Display-P3 (Digital Cinema with D65)"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRC_TEXT</name></cpp:macro> <cpp:value>"Display gamma / transfer function"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRC_LONGTEXT</name></cpp:macro> <cpp:value>"The gamma/transfer function associated with the output display"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>trc_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>PL_COLOR_TRC_UNKNOWN</name></expr>,
<expr><name>PL_COLOR_TRC_BT_1886</name></expr>,
<expr><name>PL_COLOR_TRC_SRGB</name></expr>,
<expr><name>PL_COLOR_TRC_LINEAR</name></expr>,
<expr><name>PL_COLOR_TRC_GAMMA18</name></expr>,
<expr><name>PL_COLOR_TRC_GAMMA22</name></expr>,
<expr><name>PL_COLOR_TRC_GAMMA28</name></expr>,
<expr><name>PL_COLOR_TRC_PRO_PHOTO</name></expr>,
<expr><name>PL_COLOR_TRC_PQ</name></expr>,
<expr><name>PL_COLOR_TRC_HLG</name></expr>,
<expr><name>PL_COLOR_TRC_V_LOG</name></expr>,
<expr><name>PL_COLOR_TRC_S_LOG1</name></expr>,
<expr><name>PL_COLOR_TRC_S_LOG2</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>trc_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Automatic / Unknown gamma"</literal></expr>,
<expr><literal type="string">"ITU-R Rec. BT.1886 (CRT emulation + OOTF)"</literal></expr>,
<expr><literal type="string">"IEC 61966-2-4 sRGB (CRT emulation)"</literal></expr>,
<expr><literal type="string">"Linear light content"</literal></expr>,
<expr><literal type="string">"Pure power gamma 1.8"</literal></expr>,
<expr><literal type="string">"Pure power gamma 2.2"</literal></expr>,
<expr><literal type="string">"Pure power gamma 2.8"</literal></expr>,
<expr><literal type="string">"ProPhoto RGB (ROMM)"</literal></expr>,
<expr><literal type="string">"ITU-R BT.2100 PQ (perceptual quantizer), aka SMPTE ST2084"</literal></expr>,
<expr><literal type="string">"ITU-R BT.2100 HLG (hybrid log-gamma), aka ARIB STD-B67"</literal></expr>,
<expr><literal type="string">"Panasonic V-Log (VARICAM)"</literal></expr>,
<expr><literal type="string">"Sony S-Log1"</literal></expr>,
<expr><literal type="string">"Sony S-Log2"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAPPING_TEXT</name></cpp:macro> <cpp:value>"Tone-mapping algorithm"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAPPING_LONGTEXT</name></cpp:macro> <cpp:value>"Algorithm to use when converting from wide gamut to standard gamut, or from HDR to SDR."</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>tone_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>PL_TONE_MAPPING_HABLE</name></expr>,
<expr><name>PL_TONE_MAPPING_MOBIUS</name></expr>,
<expr><name>PL_TONE_MAPPING_REINHARD</name></expr>,
<expr><name>PL_TONE_MAPPING_GAMMA</name></expr>,
<expr><name>PL_TONE_MAPPING_LINEAR</name></expr>,
<expr><name>PL_TONE_MAPPING_CLIP</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>tone_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Hable (filmic mapping, recommended)"</literal></expr>,
<expr><literal type="string">"Mobius (linear + knee)"</literal></expr>,
<expr><literal type="string">"Reinhard (simple non-linear)"</literal></expr>,
<expr><literal type="string">"Gamma-Power law"</literal></expr>,
<expr><literal type="string">"Linear stretch (peak to peak)"</literal></expr>,
<expr><literal type="string">"Hard clip out-of-gamut"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAP_PARAM_TEXT</name></cpp:macro> <cpp:value>"Tone-mapping parameter"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAP_PARAM_LONGTEXT</name></cpp:macro> <cpp:value>"This parameter can be used to tune the tone-mapping curve. Specifics depend on the curve used. If left as 0, the curve's preferred default is used."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAP_DESAT_TEXT</name></cpp:macro> <cpp:value>"Tone-mapping desaturation coefficient"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TONEMAP_DESAT_LONGTEXT</name></cpp:macro> <cpp:value>"How strongly to desaturate bright spectral colors towards white. 0.0 disables this behavior."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_STRENGTH_TEXT</name></cpp:macro> <cpp:value>"Desaturation strength"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_STRENGTH_LONGTEXT</name></cpp:macro> <cpp:value>"How strongly to desaturate bright spectral colors towards white. 0.0 disables this behavior, 1.0 enables full desaturation (hollywood-style)"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_EXPONENT_TEXT</name></cpp:macro> <cpp:value>"Desaturation exponent"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_EXPONENT_LONGTEXT</name></cpp:macro> <cpp:value>"Controls the steepness of the desaturation curve. If you set this to 0.0, the curve will be flat, i.e. desaturation always enabled (hollywood-style)."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_BASE_TEXT</name></cpp:macro> <cpp:value>"Desaturation base"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESAT_BASE_LONGTEXT</name></cpp:macro> <cpp:value>"Controls the starting offset of the desaturation curve. Brightness values below this base will always be colorimetrically tone mapped (never desaturated)."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BOOST_TEXT</name></cpp:macro> <cpp:value>"Maximum brightness boost"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BOOST_LONGTEXT</name></cpp:macro> <cpp:value>"Maximum allowed brightness boost to compensate for dark scenes. A value of 1.0 means no brightness boost is allowed."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GAMUT_WARN_TEXT</name></cpp:macro> <cpp:value>"Highlight clipped pixels"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GAMUT_WARN_LONGTEXT</name></cpp:macro> <cpp:value>"Debugging tool to indicate which pixels were clipped as part of the tone mapping process."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEAK_FRAMES_TEXT</name></cpp:macro> <cpp:value>"HDR peak detection buffer size"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEAK_FRAMES_LONGTEXT</name></cpp:macro> <cpp:value>"How many input frames to consider when determining the brightness of HDR signals. Higher values result in a slower/smoother response to brightness level changes. Setting this to 0 disables peak detection entirely."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEAK_PERIOD_TEXT</name></cpp:macro> <cpp:value>"HDR peak detection period"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEAK_PERIOD_LONGTEXT</name></cpp:macro> <cpp:value>"This option enables peak detection with the specified smoothing period. A value of 0.0 disables peak detection. Higher values result in a larger smoothing period which means the detected values will be stable over a longer number of frames, at the cost of responding more slowly to changes in scene brightness"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TARGET_AVG_TEXT</name></cpp:macro> <cpp:value>"Target peak brightness average"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TARGET_AVG_LONGTEXT</name></cpp:macro> <cpp:value>"If the source frame has an average brightness exceeding this number, the frame will be automatically darkened to compensate. This feature only works when peak detection is enabled."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_TEXT</name></cpp:macro> <cpp:value>"HDR peak scene change threshold"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_LONGTEXT</name></cpp:macro> <cpp:value>"When using HDR peak detection, this sets a threshold for sudden brightness changes that should be considered as scene changes. This will result in the detected peak being immediately updated to the new value, rather than gradually being adjusted. Setting this to 0 disables this feature."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_LOW_TEXT</name></cpp:macro> <cpp:value>"Scene change lower threshold"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_LOW_LONGTEXT</name></cpp:macro> <cpp:value>"When using HDR peak detection, this sets the lower boundary of a brightness change indicating a scene change. Brightness changes between frames that exceed this threshold will begin to be mixed into the detected peak more strongly, bypassing the peak smoothing. Setting this to a negative number disables this logic."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_HIGH_TEXT</name></cpp:macro> <cpp:value>"Scene change upper threshold"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCENE_THRESHOLD_HIGH_LONGTEXT</name></cpp:macro> <cpp:value>"This sets the upper boundary of a brightness change indicating a scene change. Brightness changes that exceed this value will instantly replace the detected peak, bypassing all smoothing. Setting this to a negative number disables this logic."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_TEXT</name></cpp:macro> <cpp:value>"Dithering algorithm"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_LONGTEXT</name></cpp:macro> <cpp:value>"The algorithm to use when dithering to a lower bit depth."</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>dither_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>-</operator><literal type="number">1</literal></expr>, 
<expr><name>PL_DITHER_BLUE_NOISE</name></expr>,
<expr><name>PL_DITHER_ORDERED_FIXED</name></expr>,
<expr><name>PL_DITHER_ORDERED_LUT</name></expr>,
<expr><name>PL_DITHER_WHITE_NOISE</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>dither_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Disabled"</literal></expr>,
<expr><literal type="string">"Blue noise (high quality)"</literal></expr>,
<expr><literal type="string">"Bayer matrix (ordered dither), 16x16 fixed size (fast)"</literal></expr>,
<expr><literal type="string">"Bayer matrix (ordered dither), any size"</literal></expr>,
<expr><literal type="string">"White noise (fast but low quality)"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_SIZE_TEXT</name></cpp:macro> <cpp:value>"Dither LUT size (log 2)"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_SIZE_LONGTEXT</name></cpp:macro> <cpp:value>"Controls the size of the dither matrix, as a power of two (e.g. the default of 6 corresponds to a 64x64 matrix). Does not affect all algorithms."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEMPORAL_DITHER_TEXT</name></cpp:macro> <cpp:value>"Temporal dithering"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEMPORAL_DITHER_LONGTEXT</name></cpp:macro> <cpp:value>"Enables perturbing the dither matrix across frames. This reduces the persistence of dithering artifacts, but can cause flickering on some (cheap) LCD screens."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_DEPTH_TEXT</name></cpp:macro> <cpp:value>"Dither depth override (0 = auto)"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DITHER_DEPTH_LONGTEXT</name></cpp:macro> <cpp:value>"Overrides the detected framebuffer depth. Useful to dither to lower bit depths than otherwise required."</cpp:value></cpp:define>

<enum>enum <block>{
<decl><name>SCALE_BUILTIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>SCALE_SPLINE16</name></decl>,
<decl><name>SCALE_SPLINE36</name></decl>,
<decl><name>SCALE_SPLINE64</name></decl>,
<decl><name>SCALE_MITCHELL</name></decl>,
<decl><name>SCALE_BICUBIC</name></decl>,
<decl><name>SCALE_EWA_LANCZOS</name></decl>,
<decl><name>SCALE_NEAREST</name></decl>,
<decl><name>SCALE_BILINEAR</name></decl>,
<decl><name>SCALE_GAUSSIAN</name></decl>,
<decl><name>SCALE_LANCZOS</name></decl>,
<decl><name>SCALE_GINSENG</name></decl>,
<decl><name>SCALE_EWA_GINSENG</name></decl>,
<decl><name>SCALE_EWA_HANN</name></decl>,
<decl><name>SCALE_HAASNSOFT</name></decl>,
<decl><name>SCALE_CATMULL_ROM</name></decl>,
<decl><name>SCALE_ROBIDOUX</name></decl>,
<decl><name>SCALE_ROBIDOUXSHARP</name></decl>,
<decl><name>SCALE_EWA_ROBIDOUX</name></decl>,
<decl><name>SCALE_EWA_ROBIDOUXSHARP</name></decl>,
<decl><name>SCALE_SINC</name></decl>,
<decl><name>SCALE_EWA_JINC</name></decl>,
<decl><name>SCALE_CUSTOM</name></decl>,
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>scale_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>SCALE_BUILTIN</name></expr>,
<expr><name>SCALE_SPLINE16</name></expr>,
<expr><name>SCALE_SPLINE36</name></expr>,
<expr><name>SCALE_SPLINE64</name></expr>,
<expr><name>SCALE_MITCHELL</name></expr>,
<expr><name>SCALE_BICUBIC</name></expr>,
<expr><name>SCALE_EWA_LANCZOS</name></expr>,
<expr><name>SCALE_NEAREST</name></expr>,
<expr><name>SCALE_BILINEAR</name></expr>,
<expr><name>SCALE_GAUSSIAN</name></expr>,
<expr><name>SCALE_LANCZOS</name></expr>,
<expr><name>SCALE_GINSENG</name></expr>,
<expr><name>SCALE_EWA_GINSENG</name></expr>,
<expr><name>SCALE_EWA_HANN</name></expr>,
<expr><name>SCALE_HAASNSOFT</name></expr>,
<expr><name>SCALE_CATMULL_ROM</name></expr>,
<expr><name>SCALE_ROBIDOUX</name></expr>,
<expr><name>SCALE_ROBIDOUXSHARP</name></expr>,
<expr><name>SCALE_EWA_ROBIDOUX</name></expr>,
<expr><name>SCALE_EWA_ROBIDOUXSHARP</name></expr>,
<expr><name>SCALE_SINC</name></expr>,
<expr><name>SCALE_EWA_JINC</name></expr>,
<expr><name>SCALE_CUSTOM</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>scale_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Built-in / fixed function (fast)"</literal></expr>,
<expr><literal type="string">"Spline 2 taps"</literal></expr>,
<expr><literal type="string">"Spline 3 taps (recommended upscaler)"</literal></expr>,
<expr><literal type="string">"Spline 4 taps"</literal></expr>,
<expr><literal type="string">"Mitchell-Netravali (recommended downscaler)"</literal></expr>,
<expr><literal type="string">"Bicubic"</literal></expr>,
<expr><literal type="string">"Jinc / EWA Lanczos 3 taps (high quality, slow)"</literal></expr>,
<expr><literal type="string">"Nearest neighbor"</literal></expr>,
<expr><literal type="string">"Bilinear"</literal></expr>,
<expr><literal type="string">"Gaussian"</literal></expr>,
<expr><literal type="string">"Lanczos 3 taps"</literal></expr>,
<expr><literal type="string">"Ginseng 3 taps"</literal></expr>,
<expr><literal type="string">"EWA Ginseng"</literal></expr>,
<expr><literal type="string">"EWA Hann"</literal></expr>,
<expr><literal type="string">"HaasnSoft (blurred EWA Hann)"</literal></expr>,
<expr><literal type="string">"Catmull-Rom"</literal></expr>,
<expr><literal type="string">"Robidoux"</literal></expr>,
<expr><literal type="string">"RobidouxSharp"</literal></expr>,
<expr><literal type="string">"EWA Robidoux"</literal></expr>,
<expr><literal type="string">"EWA RobidouxSharp"</literal></expr>,
<expr><literal type="string">"Unwindowed sinc (clipped)"</literal></expr>,
<expr><literal type="string">"Unwindowed EWA Jinc (clipped)"</literal></expr>,
<expr><literal type="string">"Custom (see below)"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>pl_filter_config</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>scale_config</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>SCALE_BUILTIN</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
<expr><index>[<expr><name>SCALE_SPLINE16</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_spline16</name></expr>,
<expr><index>[<expr><name>SCALE_SPLINE36</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_spline36</name></expr>,
<expr><index>[<expr><name>SCALE_SPLINE64</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_spline64</name></expr>,
<expr><index>[<expr><name>SCALE_NEAREST</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_box</name></expr>,
<expr><index>[<expr><name>SCALE_BILINEAR</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_triangle</name></expr>,
<expr><index>[<expr><name>SCALE_GAUSSIAN</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_gaussian</name></expr>,
<expr><index>[<expr><name>SCALE_SINC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_sinc</name></expr>,
<expr><index>[<expr><name>SCALE_LANCZOS</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_lanczos</name></expr>,
<expr><index>[<expr><name>SCALE_GINSENG</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_ginseng</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_JINC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_ewa_jinc</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_LANCZOS</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_ewa_lanczos</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_GINSENG</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_ewa_ginseng</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_HANN</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_ewa_hann</name></expr>,
<expr><index>[<expr><name>SCALE_HAASNSOFT</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_haasnsoft</name></expr>,
<expr><index>[<expr><name>SCALE_BICUBIC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_bicubic</name></expr>,
<expr><index>[<expr><name>SCALE_CATMULL_ROM</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_catmull_rom</name></expr>,
<expr><index>[<expr><name>SCALE_MITCHELL</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_mitchell</name></expr>,
<expr><index>[<expr><name>SCALE_ROBIDOUX</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_robidoux</name></expr>,
<expr><index>[<expr><name>SCALE_ROBIDOUXSHARP</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_robidouxsharp</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_ROBIDOUX</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_robidoux</name></expr>,
<expr><index>[<expr><name>SCALE_EWA_ROBIDOUXSHARP</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_robidouxsharp</name></expr>,
<expr><index>[<expr><name>SCALE_CUSTOM</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPSCALER_PRESET_TEXT</name></cpp:macro> <cpp:value>"Upscaler preset"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOWNSCALER_PRESET_TEXT</name></cpp:macro> <cpp:value>"Downscaler preset"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCALER_PRESET_LONGTEXT</name></cpp:macro> <cpp:value>"Choose from one of the built-in scaler presets. If set to custom, you can choose your own combination of kernel/window functions."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUT_ENTRIES_TEXT</name></cpp:macro> <cpp:value>"Scaler LUT size"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUT_ENTRIES_LONGTEXT</name></cpp:macro> <cpp:value>"Size of the LUT texture used for up/downscalers that require one. Reducing this may boost performance at the cost of quality."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANTIRING_TEXT</name></cpp:macro> <cpp:value>"Anti-ringing strength"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANTIRING_LONGTEXT</name></cpp:macro> <cpp:value>"Enables anti-ringing for non-polar filters. A value of 1.0 completely removes ringing, a value of 0.0 is a no-op."</cpp:value></cpp:define>

<enum>enum <block>{
<decl><name>FILTER_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>FILTER_BOX</name></decl>,
<decl><name>FILTER_TRIANGLE</name></decl>,
<decl><name>FILTER_HANN</name></decl>,
<decl><name>FILTER_HAMMING</name></decl>,
<decl><name>FILTER_WELCH</name></decl>,
<decl><name>FILTER_KAISER</name></decl>,
<decl><name>FILTER_BLACKMAN</name></decl>,
<decl><name>FILTER_GAUSSIAN</name></decl>,
<decl><name>FILTER_SINC</name></decl>,
<decl><name>FILTER_JINC</name></decl>,
<decl><name>FILTER_SPHINX</name></decl>,
<decl><name>FILTER_BCSPLINE</name></decl>,
<decl><name>FILTER_CATMULL_ROM</name></decl>,
<decl><name>FILTER_MITCHELL</name></decl>,
<decl><name>FILTER_ROBIDOUX</name></decl>,
<decl><name>FILTER_ROBIDOUXSHARP</name></decl>,
<decl><name>FILTER_BICUBIC</name></decl>,
<decl><name>FILTER_SPLINE16</name></decl>,
<decl><name>FILTER_SPLINE36</name></decl>,
<decl><name>FILTER_SPLINE64</name></decl>,
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>filter_values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>FILTER_NONE</name></expr>,
<expr><name>FILTER_BOX</name></expr>,
<expr><name>FILTER_TRIANGLE</name></expr>,
<expr><name>FILTER_HANN</name></expr>,
<expr><name>FILTER_HAMMING</name></expr>,
<expr><name>FILTER_WELCH</name></expr>,
<expr><name>FILTER_KAISER</name></expr>,
<expr><name>FILTER_BLACKMAN</name></expr>,
<expr><name>FILTER_GAUSSIAN</name></expr>,
<expr><name>FILTER_SINC</name></expr>,
<expr><name>FILTER_JINC</name></expr>,
<expr><name>FILTER_SPHINX</name></expr>,
<expr><name>FILTER_BCSPLINE</name></expr>,
<expr><name>FILTER_CATMULL_ROM</name></expr>,
<expr><name>FILTER_MITCHELL</name></expr>,
<expr><name>FILTER_ROBIDOUX</name></expr>,
<expr><name>FILTER_ROBIDOUXSHARP</name></expr>,
<expr><name>FILTER_BICUBIC</name></expr>,
<expr><name>FILTER_SPLINE16</name></expr>,
<expr><name>FILTER_SPLINE36</name></expr>,
<expr><name>FILTER_SPLINE64</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>filter_text</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"None"</literal></expr>,
<expr><literal type="string">"Box / Nearest"</literal></expr>,
<expr><literal type="string">"Triangle / Linear"</literal></expr>,
<expr><literal type="string">"Hann"</literal></expr>,
<expr><literal type="string">"Hamming"</literal></expr>,
<expr><literal type="string">"Welch"</literal></expr>,
<expr><literal type="string">"Kaiser"</literal></expr>,
<expr><literal type="string">"Blackman"</literal></expr>,
<expr><literal type="string">"Gaussian"</literal></expr>,
<expr><literal type="string">"Sinc"</literal></expr>,
<expr><literal type="string">"Jinc"</literal></expr>,
<expr><literal type="string">"Sphinx"</literal></expr>,
<expr><literal type="string">"BC spline"</literal></expr>,
<expr><literal type="string">"Catmull-Rom"</literal></expr>,
<expr><literal type="string">"Mitchell-Netravali"</literal></expr>,
<expr><literal type="string">"Robidoux"</literal></expr>,
<expr><literal type="string">"RobidouxSharp"</literal></expr>,
<expr><literal type="string">"Bicubic"</literal></expr>,
<expr><literal type="string">"Spline16"</literal></expr>,
<expr><literal type="string">"Spline36"</literal></expr>,
<expr><literal type="string">"Spline64"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>pl_filter_function</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>filter_fun</name><index>[]</index></name> <init>= <expr><block>{
<expr><index>[<expr><name>FILTER_NONE</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>,
<expr><index>[<expr><name>FILTER_BOX</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_box</name></expr>,
<expr><index>[<expr><name>FILTER_TRIANGLE</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_triangle</name></expr>,
<expr><index>[<expr><name>FILTER_HANN</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_hann</name></expr>,
<expr><index>[<expr><name>FILTER_HAMMING</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_hamming</name></expr>,
<expr><index>[<expr><name>FILTER_WELCH</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_welch</name></expr>,
<expr><index>[<expr><name>FILTER_KAISER</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_kaiser</name></expr>,
<expr><index>[<expr><name>FILTER_BLACKMAN</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_blackman</name></expr>,
<expr><index>[<expr><name>FILTER_GAUSSIAN</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_gaussian</name></expr>,
<expr><index>[<expr><name>FILTER_SINC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_sinc</name></expr>,
<expr><index>[<expr><name>FILTER_JINC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_jinc</name></expr>,
<expr><index>[<expr><name>FILTER_SPHINX</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_sphinx</name></expr>,
<expr><index>[<expr><name>FILTER_BCSPLINE</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_bcspline</name></expr>,
<expr><index>[<expr><name>FILTER_CATMULL_ROM</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_catmull_rom</name></expr>,
<expr><index>[<expr><name>FILTER_MITCHELL</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_mitchell</name></expr>,
<expr><index>[<expr><name>FILTER_ROBIDOUX</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_robidoux</name></expr>,
<expr><index>[<expr><name>FILTER_ROBIDOUXSHARP</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_robidouxsharp</name></expr>,
<expr><index>[<expr><name>FILTER_BICUBIC</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_bicubic</name></expr>,
<expr><index>[<expr><name>FILTER_SPLINE16</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_spline16</name></expr>,
<expr><index>[<expr><name>FILTER_SPLINE36</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_spline36</name></expr>,
<expr><index>[<expr><name>FILTER_SPLINE64</name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>pl_filter_function_spline64</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KERNEL_TEXT</name></cpp:macro> <cpp:value>"Kernel function"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KERNEL_LONGTEXT</name></cpp:macro> <cpp:value>"Main function defining the filter kernel."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_TEXT</name></cpp:macro> <cpp:value>"Window function"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_LONGTEXT</name></cpp:macro> <cpp:value>"Window the kernel by an additional function. (Optional)"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP_TEXT</name></cpp:macro> <cpp:value>"Clamping coefficient"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAMP_LONGTEXT</name></cpp:macro> <cpp:value>"If 1.0, clamp the kernel to only allow non-negative coefficients. If 0.0, no clamping is performed. Values in between are linear."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLUR_TEXT</name></cpp:macro> <cpp:value>"Blur/Sharpen coefficient"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLUR_LONGTEXT</name></cpp:macro> <cpp:value>"If 1.0, no change is performed. Values below 1.0 sharpen/narrow the kernel, values above 1.0 blur/widen the kernel. Avoid setting too low values!"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAPER_TEXT</name></cpp:macro> <cpp:value>"Taper width"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAPER_LONGTEXT</name></cpp:macro> <cpp:value>"Taper the kernel - all inputs within the range [0, taper] will return 1.0, and the rest of the kernel is squished into (taper, radius]."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_TEXT</name></cpp:macro> <cpp:value>"Use as EWA / Polar filter"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_LONGTEXT</name></cpp:macro> <cpp:value>"EWA/Polar filters are much slower but higher quality. Not all functions are good candidates. It's recommended to use jinc as the kernel."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_TEXT</name></cpp:macro> <cpp:value>"Enable debanding"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_LONGTEXT</name></cpp:macro> <cpp:value>"Turns on the debanding step. This algorithm can be further tuned with the iterations and grain options."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_ITER_TEXT</name></cpp:macro> <cpp:value>"Debanding iterations"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_ITER_LONGTEXT</name></cpp:macro> <cpp:value>"The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (&gt;4) are practically useless. A value of 0 is a no-op."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_THRESH_TEXT</name></cpp:macro> <cpp:value>"Gradient threshold"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_THRESH_LONGTEXT</name></cpp:macro> <cpp:value>"The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically, but progressively diminish image details."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_RADIUS_TEXT</name></cpp:macro> <cpp:value>"Search radius"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_RADIUS_LONGTEXT</name></cpp:macro> <cpp:value>"The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_GRAIN_TEXT</name></cpp:macro> <cpp:value>"Grain strength"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBAND_GRAIN_LONGTEXT</name></cpp:macro> <cpp:value>"Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_TEXT</name></cpp:macro> <cpp:value>"Use sigmoidization when upscaling"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_LONGTEXT</name></cpp:macro> <cpp:value>"If true, sigmoidizes the signal before upscaling. This helps prevent ringing artifacts. Not always in effect, even if enabled."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_CENTER_TEXT</name></cpp:macro> <cpp:value>"Sigmoid center"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_CENTER_LONGTEXT</name></cpp:macro> <cpp:value>"The center (bias) of the sigmoid curve."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_SLOPE_TEXT</name></cpp:macro> <cpp:value>"Sigmoid slope"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGMOID_SLOPE_LONGTEXT</name></cpp:macro> <cpp:value>"The slope (steepness) of the sigmoid curve."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_CUTOFF_TEXT</name></cpp:macro> <cpp:value>"Cut-off value for polar samplers"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_CUTOFF_LONGTEXT</name></cpp:macro> <cpp:value>"As a micro-optimization, all samples with a weight below this value will be ignored. This reduces the need to perform unnecessary work that doesn't noticeably change the resulting image. Setting it to a value of 0.0 disables this optimization."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_AA_TEXT</name></cpp:macro> <cpp:value>"Disable anti-aliasing when downscaling"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_AA_LONGTEXT</name></cpp:macro> <cpp:value>"This will result in moirÃ© artifacts and nasty, jagged pixels when downscaling, except for some very limited special cases (e.g. bilinear downsampling to exactly 0.5x). Significantly speeds up downscaling with high downscaling ratios."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERLAY_DIRECT_TEXT</name></cpp:macro> <cpp:value>"Force GPU built-in sampling for overlay textures"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERLAY_DIRECT_LONGTEXT</name></cpp:macro> <cpp:value>"Normally, the configured up/downscalers will be used when overlay textures (such as subtitles) need to be scaled up or down. Enabling this option overrides this behavior and forces overlay textures to go through the GPU's built-in sampling instead (typically bilinear)."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_LINEAR_TEXT</name></cpp:macro> <cpp:value>"Don't linearize before scaling"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_LINEAR_LONGTEXT</name></cpp:macro> <cpp:value>"Normally, the image is converted to linear light before scaling (under certain conditions). Enabling this option disables this behavior."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_GENERAL_TEXT</name></cpp:macro> <cpp:value>"Force the use of general-purpose scalers"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_GENERAL_LONGTEXT</name></cpp:macro> <cpp:value>"Normally, certain special scalers will be replaced by faster versions instead of going through the general scaler architecture. Enabling this option disables these optimizations."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELAYED_PEAK_TEXT</name></cpp:macro> <cpp:value>"Allow delaying peak detection by up to one frame"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELAYED_PEAK_LONGTEXT</name></cpp:macro> <cpp:value>"In some cases, peak detection may be more convenient to compute if the results are delayed by a frame. When this option is disabled, libplacebo will use an indirect buffer simply to force peak detection results to be up-to-date. Enabling it allows skipping this indirection in order to improve performance at the cost of some potentially noticeable brightness flickering immediately after a scene change."</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
