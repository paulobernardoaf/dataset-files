<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\vlc-analysis\_cppstats_featurelocations\vlc\modules\misc\medialibrary\medialibrary.h">



















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MEDIALIBRARY_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEDIALIBRARY_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/IMediaLibrary.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/parser/IParserService.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/parser/IItem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/parser/Parser.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/IMedia.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;medialibrary/IThumbnailer.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_threads.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_input_item.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_input.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_media_library.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_cxx_helpers.hpp&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdarg&gt;</cpp:file></cpp:include>

<struct_decl>struct <name>vlc_event_t</name>;</struct_decl>
<struct_decl>struct <name>vlc_object_t</name>;</struct_decl>
<struct_decl>struct <name>vlc_thumbnailer_t</name>;</struct_decl>
<struct_decl>struct <name>vlc_thumbnailer_request_t</name>;</struct_decl>

<decl_stmt><decl><type><name>class</name></type> <name>Logger</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>MetadataExtractor</name> <range>: <expr><name>public</name> <name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>IParserService</name>
<block>{
<expr><name>private</name><operator>:</operator>
struct <name>ParseContext</name>
<block>{
<expr><call><name>ParseContext</name><argument_list>( <argument><expr><name>MetadataExtractor</name><operator>*</operator> <name>mde</name></expr></argument>, <argument><expr><name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>IItem</name><operator>&amp;</operator> <name>item</name></expr></argument> )</argument_list></call>
<operator>:</operator> <call><name>needsProbing</name><argument_list>( <argument><expr><name>false</name></expr></argument> )</argument_list></call></expr>
, <expr><call><name>success</name><argument_list>( <argument><expr><name>false</name></expr></argument> )</argument_list></call></expr>
, <expr><call><name>mde</name><argument_list>( <argument><expr><name>mde</name></expr></argument> )</argument_list></call></expr>
, <expr><call><name>item</name><argument_list>( <argument><expr><name>item</name></expr></argument> )</argument_list></call></expr>
, <expr><call><name>inputItem</name><argument_list>( <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_item_Release</name></expr></argument> )</argument_list></call></expr>
, <macro><name>inputParser</name><argument_list>( <argument>nullptr</argument>, <argument>&amp;input_item_parser_id_Release</argument> )</argument_list></macro>
<expr><block>{
}</block>

<name>bool</name> <name>needsProbing</name></expr>;
<expr><name>bool</name> <name>success</name></expr>;
<expr><name>MetadataExtractor</name><operator>*</operator> <name>mde</name></expr>;
<expr><name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>IItem</name><operator>&amp;</operator> <name>item</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>input_item_t</name></expr></argument>, <argument><expr><name>decltype</name><operator>(</operator><operator>&amp;</operator><name>input_item_Release</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>inputItem</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>input_item_parser_id_t</name></expr></argument>, <argument><expr><name>decltype</name><operator>(</operator><operator>&amp;</operator><name>input_item_parser_id_Release</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>inputParser</name></expr>;
}</block></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>MetadataExtractor</name><argument_list>( <argument><expr><name>vlc_object_t</name><operator>*</operator> <name>parent</name></expr></argument> )</argument_list></call></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>MetadataExtractor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;



<expr><name>private</name><operator>:</operator>
<name>virtual</name> <name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>Status</name> <macro><name>run</name><argument_list>( <argument>medialibrary::parser::IItem&amp; item</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <specifier>const</specifier> <name>char</name><operator>*</operator><macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>virtual</name> <name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>Step</name> <macro><name>targetedStep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>virtual</name> <name>bool</name> <macro><name>initialize</name><argument_list>( <argument>medialibrary::IMediaLibrary* ml</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onFlushing</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onRestarted</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>stop</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>onParserEnded</name><argument_list>( <argument>ParseContext&amp; ctx</argument>, <argument>int status</argument> )</argument_list></macro></expr>;
<expr><name>void</name> <call><name>addSubtree</name><argument_list>( <argument><expr><name>ParseContext</name><operator>&amp;</operator> <name>ctx</name></expr></argument>, <argument><expr><name>input_item_node_t</name> <operator>*</operator><name>root</name></expr></argument> )</argument_list></call></expr>;
<expr><name>void</name> <call><name>populateItem</name><argument_list>( <argument><expr><name>medialibrary</name><operator>::</operator><name>parser</name><operator>::</operator><name>IItem</name><operator>&amp;</operator> <name>item</name></expr></argument>, <argument><expr><name>input_item_t</name><operator>*</operator> <name>inputItem</name></expr></argument> )</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>onParserEnded</name><argument_list>( <argument>input_item_t *</argument>, <argument>int status</argument>, <argument>void *user_data</argument> )</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>void</name> <call><name>onParserSubtreeAdded</name><argument_list>( <argument><expr><name>input_item_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>input_item_node_t</name> <operator>*</operator><name>subtree</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>user_data</name></expr></argument> )</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>vlc</name><operator>::</operator><name>threads</name><operator>::</operator><name>condition_variable</name> <name>m_cond</name></expr>;
<expr><name>vlc</name><operator>::</operator><name>threads</name><operator>::</operator><name>mutex</name> <name>m_mutex</name></expr>;
<expr><name>ParseContext</name><operator>*</operator> <name>m_currentCtx</name></expr>;
<expr><name>vlc_object_t</name><operator>*</operator> <name>m_obj</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Thumbnailer</name> <range>: <expr><name>public</name> <name>medialibrary</name><operator>::</operator><name>IThumbnailer</name>
<block>{
struct <expr><name>ThumbnailerCtx</name>
<block>{
<expr><operator>~</operator><macro><name>ThumbnailerCtx</name><argument_list>()</argument_list></macro>
<block>{
<if_stmt><if>if <condition>( <expr><name>thumbnail</name> <operator>!=</operator> <name>nullptr</name></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>picture_Release</name><argument_list>( <argument><expr><name>thumbnail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>
<name>Thumbnailer</name><operator>*</operator> <name>thumbnailer</name></expr>;
<expr><name>bool</name> <name>done</name></expr>;
<expr><name>picture_t</name><operator>*</operator> <name>thumbnail</name></expr>;
<expr><name>vlc_thumbnailer_request_t</name><operator>*</operator> <name>request</name></expr>;
}</block></expr>;
<expr><name>public</name><operator>:</operator>
<call><name>Thumbnailer</name><argument_list>(<argument><expr><name>vlc_medialibrary_module_t</name><operator>*</operator> <name>ml</name></expr></argument>)</argument_list></call></expr>;
<expr><name>virtual</name> <name>bool</name> <macro><name>generate</name><argument_list>( <argument>const medialibrary::IMedia&amp;</argument>, <argument>const std::string&amp; mrl</argument>,
<argument>uint32_t desiredWidth</argument>, <argument>uint32_t desiredHeight</argument>,
<argument>float position</argument>, <argument>const std::string&amp; dest</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>stop</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name>void</name> <call><name>onThumbnailComplete</name><argument_list>( <argument><expr><name>void</name><operator>*</operator> <name>data</name></expr></argument>, <argument><expr><name>picture_t</name><operator>*</operator> <name>thumbnail</name></expr></argument> )</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>vlc_medialibrary_module_t</name><operator>*</operator> <name>m_ml</name></expr>;
<expr><name>vlc</name><operator>::</operator><name>threads</name><operator>::</operator><name>mutex</name> <name>m_mutex</name></expr>;
<expr><name>vlc</name><operator>::</operator><name>threads</name><operator>::</operator><name>condition_variable</name> <name>m_cond</name></expr>;
<expr><name>ThumbnailerCtx</name><operator>*</operator> <name>m_currentContext</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>vlc_thumbnailer_t</name></expr></argument>, <argument><expr><name>void</name><operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>vlc_thumbnailer_t</name><operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>m_thumbnailer</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>MediaLibrary</name> <range>: <expr><name>public</name> <name>medialibrary</name><operator>::</operator><name>IMediaLibraryCb</name>
<block>{
<expr><name>public</name><operator>:</operator>
<call><name>MediaLibrary</name><argument_list>( <argument><expr><name>vlc_medialibrary_module_t</name><operator>*</operator> <name>ml</name></expr></argument> )</argument_list></call></expr>;
<expr><name>bool</name> <call><name>Init</name><argument_list>()</argument_list></call></expr>;
<expr><name>bool</name> <call><name>Start</name><argument_list>()</argument_list></call></expr>;
<expr><name>int</name> <macro><name>Control</name><argument_list>( <argument>int query</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>List</name><argument_list>( <argument>int query</argument>, <argument>const vlc_ml_query_params_t* params</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>void</name><operator>*</operator> <macro><name>Get</name><argument_list>( <argument>int query</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;

<expr><name>private</name><operator>:</operator>
<name>int</name> <macro><name>controlMedia</name><argument_list>( <argument>int query</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>getMeta</name><argument_list>( <argument>const medialibrary::IMedia&amp; media</argument>, <argument>int meta</argument>, <argument>char** result</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <call><name>getMeta</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IMedia</name><operator>&amp;</operator> <name>media</name></expr></argument>, <argument><expr><name>vlc_ml_playback_states_all</name><operator>*</operator> <name>result</name></expr></argument> )</argument_list></call></expr>;
<expr><name>int</name> <macro><name>setMeta</name><argument_list>( <argument>medialibrary::IMedia&amp; media</argument>, <argument>int meta</argument>, <argument>const char* value</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <call><name>setMeta</name><argument_list>( <argument><expr><name>medialibrary</name><operator>::</operator><name>IMedia</name><operator>&amp;</operator> <name>media</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>vlc_ml_playback_states_all</name><operator>*</operator> <name>values</name></expr></argument> )</argument_list></call></expr>;
<expr><name>int</name> <macro><name>filterListChildrenQuery</name><argument_list>( <argument>int query</argument>, <argument>int parentType</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>listAlbums</name><argument_list>( <argument>int listQuery</argument>, <argument>const medialibrary::QueryParameters* paramsPtr</argument>,
<argument>const char* pattern</argument>, <argument>uint32_t nbItems</argument>, <argument>uint32_t offset</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>listArtists</name><argument_list>( <argument>int listQuery</argument>, <argument>const medialibrary::QueryParameters* paramsPtr</argument>,
<argument>const char* pattern</argument>, <argument>uint32_t nbItems</argument>, <argument>uint32_t offset</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>listGenre</name><argument_list>( <argument>int listQuery</argument>, <argument>const medialibrary::QueryParameters* paramsPtr</argument>,
<argument>const char* pattern</argument>, <argument>uint32_t nbItems</argument>, <argument>uint32_t offset</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;
<expr><name>int</name> <macro><name>listPlaylist</name><argument_list>( <argument>int listQuery</argument>, <argument>const medialibrary::QueryParameters* paramsPtr</argument>,
<argument>const char* pattern</argument>, <argument>uint32_t nbItems</argument>, <argument>uint32_t offset</argument>, <argument>va_list args</argument> )</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>medialibrary</name><operator>::</operator><name>IMedia</name><operator>::</operator><name>MetadataType</name> <macro><name>metadataType</name><argument_list>( <argument>int meta</argument> )</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>medialibrary</name><operator>::</operator><name>SortingCriteria</name> <macro><name>sortingCriteria</name><argument_list>( <argument>int sort</argument> )</argument_list></macro></expr>;

<expr><name>private</name><operator>:</operator>
<name>vlc_medialibrary_module_t</name><operator>*</operator> <name>m_vlc_ml</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Logger</name></expr></argument>&gt;</argument_list></name> <name>m_logger</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>medialibrary</name><operator>::</operator><name>IMediaLibrary</name></expr></argument>&gt;</argument_list></name> <name>m_ml</name></expr>;


<expr><name>public</name><operator>:</operator>
<name>virtual</name> <name>void</name> <macro><name>onMediaAdded</name><argument_list>(<argument>std::vector&lt;medialibrary::MediaPtr&gt; media</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaModified</name><argument_list>(<argument>std::vector&lt;int64_t&gt; media</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaDeleted</name><argument_list>(<argument>std::vector&lt;int64_t&gt; mediaIds</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onArtistsAdded</name><argument_list>(<argument>std::vector&lt;medialibrary::ArtistPtr&gt; artists</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onArtistsModified</name><argument_list>(<argument>std::vector&lt;int64_t&gt; artists</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onArtistsDeleted</name><argument_list>(<argument>std::vector&lt;int64_t&gt; artistsIds</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onAlbumsAdded</name><argument_list>(<argument>std::vector&lt;medialibrary::AlbumPtr&gt; albums</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onAlbumsModified</name><argument_list>(<argument>std::vector&lt;int64_t&gt; albums</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onAlbumsDeleted</name><argument_list>(<argument>std::vector&lt;int64_t&gt; albumsIds</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onPlaylistsAdded</name><argument_list>(<argument>std::vector&lt;medialibrary::PlaylistPtr&gt; playlists</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onPlaylistsModified</name><argument_list>(<argument>std::vector&lt;int64_t&gt; playlists</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onPlaylistsDeleted</name><argument_list>(<argument>std::vector&lt;int64_t&gt; playlistIds</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onGenresAdded</name><argument_list>(<argument>std::vector&lt;medialibrary::GenrePtr&gt; genres</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onGenresModified</name><argument_list>(<argument>std::vector&lt;int64_t&gt; genres</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onGenresDeleted</name><argument_list>(<argument>std::vector&lt;int64_t&gt; genreIds</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaGroupAdded</name><argument_list>( <argument>std::vector&lt;medialibrary::MediaGroupPtr&gt; mediaGroups</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaGroupModified</name><argument_list>( <argument>std::vector&lt;int64_t&gt; mediaGroupsIds</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaGroupDeleted</name><argument_list>( <argument>std::vector&lt;int64_t&gt; mediaGroupsIds</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onDiscoveryStarted</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onDiscoveryProgress</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onDiscoveryCompleted</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onReloadStarted</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onReloadCompleted</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onEntryPointAdded</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onEntryPointRemoved</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onEntryPointBanned</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onEntryPointUnbanned</name><argument_list>(<argument>const std::string&amp; entryPoint</argument>, <argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onParsingStatsUpdated</name><argument_list>(<argument>uint32_t percent</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onBackgroundTasksIdleChanged</name><argument_list>(<argument>bool isIdle</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onMediaThumbnailReady</name><argument_list>(<argument>medialibrary::MediaPtr media</argument>,
<argument>medialibrary::ThumbnailSizeType sizeType</argument>,
<argument>bool success</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onHistoryChanged</name><argument_list>( <argument>medialibrary::HistoryType historyType</argument> )</argument_list></macro> <name>override</name></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>onRescanStarted</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IMedia</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_media_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IFile</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_file_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IMovie</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_movie_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IShowEpisode</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_show_episode_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IAlbumTrack</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_album_track_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IAlbum</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_album_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IArtist</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_artist_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IGenre</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_genre_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IShow</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_show_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>ILabel</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_label_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IPlaylist</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_playlist_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Convert</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IFolder</name><operator>*</operator> <name>input</name></expr></argument>, <argument><expr><name>vlc_ml_entry_point_t</name><operator>&amp;</operator> <name>output</name></expr></argument> )</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>input_item_t</name><modifier>*</modifier></type> <name>MediaToInputItem</name><argument_list>( <argument><expr><specifier>const</specifier> <name>medialibrary</name><operator>::</operator><name>IMedia</name><operator>*</operator> <name>media</name></expr></argument> )</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>, <argument><expr><name>typename</name> <name>ItemType</name></expr></argument>, <argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
<name>To</name><modifier>*</modifier></type> <name>ml_convert_list</name><argument_list>( <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>input</name></expr></argument> )</argument_list>
<block>{<block_content>

<expr_stmt><expr><call><name>static_assert</name><argument_list>( <argument><expr><name>std</name><operator>::</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>==</operator> <name>false</name></expr></argument>,
<argument><expr><literal type="string">"Destination type must not be a pointer"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>static_assert</name><argument_list>( <argument><expr><name>std</name><operator>::</operator><name><name>is_array</name><argument_list type="generic">&lt;<argument><expr><name>decltype</name><operator>(</operator><name>To</name><operator>::</operator><name>p_items</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>==</operator> <name>false</name> <operator>||</operator>
<operator>(</operator> <name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_extent</name><argument_list type="generic">&lt;<argument><expr><name>decltype</name><operator>(</operator><name>To</name><operator>::</operator><name>p_items</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>ItemType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>)</operator></expr></argument>, <argument><expr><literal type="string">"Invalid/mismatching list/item types"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>auto</name></type> <name>list</name> <init>= <expr><name>vlc</name><operator>::</operator><call><name>wrap_cptr</name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>To</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>( <argument><expr><call><name>calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>To</name></expr></argument> )</argument_list></sizeof> <operator>+</operator> <call><name><name>input</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>( <argument><expr><name>ItemType</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr></argument>,
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>To</name><operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>( <argument><expr><operator>&amp;</operator><name>vlc_ml_release</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>( <expr><call><name>unlikely</name><argument_list>( <argument><expr><name>list</name> <operator>==</operator> <name>nullptr</name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>i_nb_items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>( <init><decl><type><name>auto</name></type> <name>i</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>input</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr> )</control>
<block>{<block_content>
<if_stmt><if>if <condition>( <expr><call><name>Convert</name><argument_list>( <argument><expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>p_items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call> <operator>==</operator> <name>false</name></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>i_nb_items</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name><name>list</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Input</name></expr></argument>&gt;</argument_list></name>
<name>T</name><modifier>*</modifier></type> <name>CreateAndConvert</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>Input</name><modifier>*</modifier></type> <name>input</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>( <expr><name>input</name> <operator>==</operator> <name>nullptr</name></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>res</name> <init>= <expr><name>vlc</name><operator>::</operator><call><name>wrap_cptr</name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>( <argument><expr><call><name>calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>T</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr></argument>,
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>T</name><operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>( <argument><expr><operator>&amp;</operator><name>vlc_ml_release</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>( <expr><call><name>unlikely</name><argument_list>( <argument><expr><name>res</name> <operator>==</operator> <name>nullptr</name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><call><name>Convert</name><argument_list>( <argument><expr><name>input</name></expr></argument>, <argument><expr><operator>*</operator><name>res</name></expr></argument> )</argument_list></call> <operator>==</operator> <name>false</name></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>





<return>return <expr><call><name><name>res</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
