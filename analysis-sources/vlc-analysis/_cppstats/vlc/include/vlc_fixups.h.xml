<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\vlc-analysis\_cppstats\vlc\include\vlc_fixups.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FEATURES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;features.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__UCLIBC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__native_client__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_FORMAT_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_FORMAT_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_CONSTANT_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_CONSTANT_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_LIMIT_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_LIMIT_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_THREADS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;threads.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>thread_local</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_THREAD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thread_local</name></cpp:macro> <cpp:value>_Thread_local</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thread_local</name></cpp:macro> <cpp:value>__declspec(thread)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_GMTIME_R</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_LOCALTIME_R</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_TIMEGM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LLDIV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>quot</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>rem</name></decl>;</decl_stmt> 

}</block></struct></type> <name>lldiv_t</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETENV</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USELOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_REWIND</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_GETDELIM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_ALIGNED_ALLOC</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_MEMRCHR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_POSIX_MEMALIGN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_QSORT_R</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_STRLCPY</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_STRNDUP</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_STRNLEN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_STRNSTR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_VASPRINTF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_GETDELIM</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_GETPID</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_SWAB</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_FDOPENDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLC_NOTHROW</name></cpp:macro> <cpp:value>throw ()</cpp:value></cpp:define>

<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLC_NOTHROW</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGWAIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__native_client__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<function_decl><type><name>int</name></type> <name>sigwait</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sigset_t</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sig</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_MAX_ALIGN_T</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ll</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>ld</name></decl>;</decl_stmt>

}</block></struct></type> <name>max_align_t</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ASPRINTF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>asprintf</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FLOCKFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>flockfile</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>funlockfile</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>getc_unlocked</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>getchar_unlocked</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>putc_unlocked</name> <parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>putchar_unlocked</name> <parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETDELIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>ssize_t</name></type> <name>getdelim</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ssize_t</name></type> <name>getline</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REWIND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>rewind</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_VASPRINTF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>vasprintf</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>va_list</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMRCHR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>memrchr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRCASECMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>strcasecmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRCASESTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strcasestr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRDUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strdup</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRVERSCMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>strverscmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>size_t</name></type> <name>strnlen</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNSTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type> <name>strnstr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNDUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strndup</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRLCPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>size_t</name></type> <name>strlcpy</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strsep</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRTOK_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strtok_r</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ATOF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__ANDROID__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>double</name></type> <name>atof</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ATOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>long</name> <name>long</name></type> <name>atoll</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LLDIV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>lldiv_t</name></type> <name>lldiv</name> <parameter_list>(<parameter><decl><type><name>long</name></type> <name>long</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>long</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRTOF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__ANDROID__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>float</name></type> <name>strtof</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRTOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>long</name> <name>long</name> <name>int</name></type> <name>strtoll</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GMTIME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>gmtime_r</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALTIME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>localtime_r</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMEGM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>time_t</name></type> <name>timegm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TIMESPEC_GET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_UTC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<struct_decl>struct <name>timespec</name>;</struct_decl>

<function_decl><type><name>int</name></type> <name>timespec_get</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETTIMEOFDAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>timezone</name>;</struct_decl>

<function_decl><type><name>int</name></type> <name>gettimeofday</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timezone</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>pid_t</name></type> <name>getpid</name> <argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>VLC_NOTHROW</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>fsync</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PATHCONF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>long</name></type> <name>pathconf</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> (<name>dirfd</name>) <parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FDOPENDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>DIR</name> <modifier>*</modifier></type><name>fdopendir</name> <parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type><name>getenv</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>name</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>setenv</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>unsetenv</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_MEMALIGN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>posix_memalign</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ALIGNED_ALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>aligned_alloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__mingw_aligned_free(ptr)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_aligned_free(ptr)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>free(ptr)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__native_client__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_USELOCALE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NEWLOCALE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CXX_LOCALE_T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_NEWLOCALE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USELOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NEWLOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_ALL_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_NUMERIC_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_MESSAGES_MASK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LC_GLOBAL_LOCALE</name></cpp:macro> <cpp:value>((locale_t)(uintptr_t)1)</cpp:value></cpp:define>

<typedef>typedef <type><name>void</name> <modifier>*</modifier></type><name>locale_t</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>freelocale</name><parameter_list>(<parameter><decl><type><name>locale_t</name></type> <name>loc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>loc</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>locale_t</name></type> <name>newlocale</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>locale</name></decl></parameter>, <parameter><decl><type><name>locale_t</name></type> <name>base</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mask</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>locale</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>base</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>locale_t</name></type> <name>uselocale</name><parameter_list>(<parameter><decl><type><name>locale_t</name></type> <name>loc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>loc</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_STATIC_ASSERT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__cpp_static_assert</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATIC_ASSERT_CONCAT_</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a##b</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATIC_ASSERT_CONCAT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>STATIC_ASSERT_CONCAT_(a, b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Static_assert</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern char STATIC_ASSERT_CONCAT(static_assert_, __LINE__)[sizeof(struct { unsigned:-!(x); })]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>static_assert</name></cpp:macro> <cpp:value>_Static_assert</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vlc_gettext (str)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>gettext_noop (str)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gettext_noop</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(str)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SWAB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>swab</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_PTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>int</name></type> <name>socklen_t</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>int</name></type> <name>inet_pton</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inet_ntop</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>socklen_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__native_client__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>( <argument><expr><name>HAVE_NETINET_TCP_H</name></expr></argument> )</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCP_NODELAY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_POLLFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<enum>enum

<block>{

<decl><name>POLLERR</name><init>=<expr><literal type="number">0x1</literal></expr></init></decl>,

<decl><name>POLLHUP</name><init>=<expr><literal type="number">0x2</literal></expr></init></decl>,

<decl><name>POLLNVAL</name><init>=<expr><literal type="number">0x4</literal></expr></init></decl>,

<decl><name>POLLWRNORM</name><init>=<expr><literal type="number">0x10</literal></expr></init></decl>,

<decl><name>POLLWRBAND</name><init>=<expr><literal type="number">0x20</literal></expr></init></decl>,

<decl><name>POLLRDNORM</name><init>=<expr><literal type="number">0x100</literal></expr></init></decl>,

<decl><name>POLLRDBAND</name><init>=<expr><literal type="number">0x200</literal></expr></init></decl>,

<decl><name>POLLPRI</name><init>=<expr><literal type="number">0x400</literal></expr></init></decl>,

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLIN</name></cpp:macro> <cpp:value>(POLLRDNORM|POLLRDBAND)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLOUT</name></cpp:macro> <cpp:value>(POLLWRNORM|POLLWRBAND)</cpp:value></cpp:define>

<struct>struct <name>pollfd</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>events</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>revents</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>pollfd</name>;</struct_decl>

<function_decl><type><name>int</name></type> <name>poll</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IF_NAMEINDEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_IF_NAMEINDEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>if_nameindex</name>

<block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>if_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>if_name</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>if_nameindex</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(errno = ENOBUFS, NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>if_freenameindex</name><parameter_list>(<parameter><type><name>list</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_TIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>timespec</name> <block>{

<decl_stmt><decl><type><name>time_t</name></type> <name>tv_sec</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>tv_nsec</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>iovec</name>

<block>{

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>iov_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>iov_len</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOV_MAX</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>

<struct>struct <name>msghdr</name>

<block>{

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>msg_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>msg_namelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>msg_iov</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>msg_iovlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>msg_control</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>msg_controllen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>msg_flags</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_NEWLIB_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOV_MAX</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_RECVMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>msghdr</name>;</struct_decl>

<function_decl><type><name>ssize_t</name></type> <name>recvmsg</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>msghdr</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SENDMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>msghdr</name>;</struct_decl>

<function_decl><type><name>ssize_t</name></type> <name>sendmsg</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>msghdr</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEARCH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <name>entry</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block></struct></type> <name>ENTRY</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>FIND</name></decl>, <decl><name>ENTER</name></decl>

}</block></enum></type> <name>ACTION</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>preorder</name></decl>,

<decl><name>postorder</name></decl>,

<decl><name>endorder</name></decl>,

<decl><name>leaf</name></decl>

}</block></enum></type> <name>VISIT</name>;</typedef>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>tsearch</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>rootp</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>tfind</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>rootp</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>tdelete</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>rootp</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>twalk</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type>(<modifier>*</modifier><name>action</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>nodep</name></decl></parameter>, <parameter><decl><type><name>VISIT</name></type> <name>which</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>lfind</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nmemb</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEARCH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;search.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lfind</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lfind((a),(b), &amp;(unsigned){ (*(c) &gt; UINT_MAX) ? UINT_MAX : *(c) }, (d),(e))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TDESTROY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>tdestroy</name><parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_node</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>nodep</name></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NRAND48</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>double</name></type> <name>erand48</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name><name>subi</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>long</name></type> <name>jrand48</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name><name>subi</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>long</name></type> <name>nrand48</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name><name>subi</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_FORK</name></cpp:undef> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUT_RD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUT_WR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUT_RDWR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_BADFLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_BADFLAGS</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_NONAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_NONAME</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_AGAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_AGAIN</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_FAIL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_FAIL</name></cpp:macro> <cpp:value>-4</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_NODATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_NODATA</name></cpp:macro> <cpp:value>-5</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_FAMILY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_FAMILY</name></cpp:macro> <cpp:value>-6</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SOCKTYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_SOCKTYPE</name></cpp:macro> <cpp:value>-7</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SERVICE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_SERVICE</name></cpp:macro> <cpp:value>-8</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_ADDRFAMILY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_ADDRFAMILY</name></cpp:macro> <cpp:value>-9</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_MEMORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_MEMORY</name></cpp:macro> <cpp:value>-10</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_OVERFLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_OVERFLOW</name></cpp:macro> <cpp:value>-11</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_SYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAI_SYSTEM</name></cpp:macro> <cpp:value>-12</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_NUMERICHOST</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_NUMERICSERV</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_NOFQDN</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_NAMEREQD</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_DGRAM</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXHOST</name></cpp:macro> <cpp:value>1025</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXSERV</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AI_PASSIVE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AI_CANONNAME</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AI_NUMERICHOST</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<struct>struct <name>addrinfo</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>ai_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ai_family</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ai_socktype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ai_protocol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ai_addrlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>ai_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ai_canonname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>ai_next</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gai_strerror</name> <parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>getaddrinfo</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>service</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>hints</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>freeaddrinfo</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>getnameinfo</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name></type> <name>salen</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hostlen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>serv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>servlen</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<struct>struct <name>in6_addr</name>

<block>{

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>s6_addr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>sockaddr_in6</name>

<block>{

<decl_stmt><decl><type><name>uint8_t</name></type> <name>sin6_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>sin6_family</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>sin6_port</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>sin6_flowinfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>sin6_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>sin6_scope_id</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN6_IS_ADDR_MULTICAST</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((__const uint8_t *) (a))[0] == 0xff)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>in6_addr</name></name></type> <name>in6addr_any</name> <init>=

<expr><block>{ <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EPROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EPROTO</name></cpp:macro> <cpp:value>(ELAST + 1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IF_NAMETOINDEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>if_nametoindex</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>atoi(name)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NANF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nanf</name><parameter_list>(<parameter><type><name>tagp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NAN</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SINCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>sincos</name><parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>sincosf</name><parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>realpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>restrict</specifier></type> <name>pathname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier> <specifier>restrict</specifier></type> <name>resolved_path</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>FILE</name> <modifier>*</modifier></type><name>vlc_win32_tmpfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW64_VERSION_MAJOR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN6_IS_ADDR_MULTICAST</name></cpp:macro> <cpp:value>IN6_IS_ADDR_MULTICAST</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fdatasync</name></cpp:macro> <cpp:value>fsync</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TIMER_ABSTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMER_ABSTIME</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCK_REALTIME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCK_MONOTONIC</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_GETTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>clock_gettime</name><parameter_list>(<parameter><decl><type><name>clockid_t</name></type> <name>clock_id</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_GETRES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>clock_getres</name><parameter_list>(<parameter><decl><type><name>clockid_t</name></type> <name>clock_id</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLOCK_NANOSLEEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type> <name>clock_nanosleep</name><parameter_list>(<parameter><decl><type><name>clockid_t</name></type> <name>clock_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>rqtp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>rmtp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
