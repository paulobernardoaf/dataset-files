<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\vlc-analysis\_cppstats\vlc\modules\access\dcp\dcpparser.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_demux.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_plugin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gcrypt.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_gcrypt.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iostream&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;list&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>using</name> <name>namespace</name></type> <name>std</name></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <block>{

<decl><name>TRACK_UNKNOWN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>TRACK_PICTURE</name></decl>,

<decl><name>TRACK_SOUND</name></decl>,

<decl><name>TRACK_SUBTITLE</name></decl>

}</block></enum></type> <name>TrackType_t</name>;</typedef>

<decl_stmt><decl><type><name>class</name></type> <name>Asset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AssetList</name><range>: <expr><name>public</name> <name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>Asset</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PKL</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AESKey</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AESKeyList</name><range>: <expr><name>public</name> <name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>AESKey</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

<struct>struct <name>info_reel</name>

<block>{

<decl_stmt><decl><type><name>string</name></type> <name>filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_entrypoint</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_duration</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_correction</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i_absolute_end</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>AESKey</name> <modifier>*</modifier></type> <name>p_key</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>dcp_t</name>

<block>{

<decl_stmt><decl><type><name>string</name></type> <name>path</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PKL</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>pkls</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AssetList</name> <modifier>*</modifier></type><name>p_asset_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AESKeyList</name> <modifier>*</modifier></type><name>p_key_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>info_reel</name></expr></argument>&gt;</argument_list></name></type> <name>audio_reels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>info_reel</name></expr></argument>&gt;</argument_list></name></type> <name>video_reels</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dcp_t</name><argument_list>()</argument_list></call><operator>:</operator>

<call><name>p_asset_list</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>p_key_list</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <expr><block>{}</block></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>dcp_t</name><argument_list>( )</argument_list></macro> <block>{

<expr><call><name>vlc_delete_all</name><argument_list>(<argument><expr><name>pkls</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>( <expr><name>p_asset_list</name> <operator>!=</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vlc_delete_all</name><argument_list>(<argument><expr><operator>*</operator><name>p_asset_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>delete</name><argument_list>(<argument><expr><name>p_asset_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>( <expr><name>p_key_list</name> <operator>!=</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vlc_delete_all</name><argument_list>(<argument><expr><operator>*</operator><name>p_key_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>delete</name><argument_list>(<argument><expr><name>p_key_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

}</block>

<decl/></struct>};

<decl_stmt><decl><type><name>class</name></type> <name>XmlFile</name>

<block>{<block_content>

<label><name>public</name>:</label>

<macro><name>XmlFile</name><argument_list>( <argument>demux_t * p_demux</argument>, <argument>string s_path</argument>)</argument_list></macro>:

<expr_stmt><expr><call><name>p_demux</name><argument_list>(<argument><expr><name>p_demux</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>s_path</name><argument_list>(<argument><expr><name>s_path</name></expr></argument>)</argument_list></call></expr><operator>,</operator>

<expr><call><name>p_stream</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr><operator>,</operator>

<macro><name>p_xmlReader</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <operator>~</operator><call><name>XmlFile</name><argument_list>( )</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>int</name></type> <name>Parse</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadNextNode</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>, <parameter><decl><type><name>string</name><modifier>&amp;</modifier></type> <name>s_node</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadEndNode</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>s_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i_type</name></decl></parameter>, <parameter><decl><type><name>string</name> <modifier>&amp;</modifier></type><name>s_value</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>isCPL</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>protected</name>:</label>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> <name>OpenXml</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CloseXml</name><parameter_list>()</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Chunk</name> <block>{<block_content>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>Chunk</name><argument_list>(<argument><expr><name>demux_t</name> <operator>*</operator> <name>demux</name></expr></argument>)</argument_list></call><operator>:</operator>

<call><name>i_vol_index</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>i_offset</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>i_length</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>

<macro><name>p_demux</name><argument_list>(<argument>demux</argument>)</argument_list></macro> <expr><block>{}</block></expr>;</expr_stmt>

<function_decl><type><name>int</name></type> <name>Parse</name><parameter_list>(<parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>p_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>string</name></type> <name>getPath</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_path</name></name></expr>;</return> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>string</name></type> <name>s_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_vol_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Asset</name> <block>{<block_content>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>Asset</name> <argument_list>(<argument><expr><name>demux_t</name> <operator>*</operator> <name>demux</name></expr></argument>)</argument_list></call><operator>:</operator>

<call><name>b_is_packing_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ui_size</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>

<expr><call><name>i_intrisic_duration</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>i_entry_point</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>i_duration</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>

<macro><name>p_demux</name><argument_list>(<argument>demux</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <operator>~</operator><call><name>Asset</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>

<function><type><name>void</name></type> <name>setId</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_string</name></decl></parameter> )</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_id</name></name> <operator>=</operator> <name>p_string</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setPath</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_string</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_path</name></name> <operator>=</operator> <name>p_string</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setAnnotation</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_string</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>-&gt;</operator><name>s_annotation</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_annotation</name></name> <operator>=</operator> <name>p_string</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_annotation</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>s_annotation</name></name> <operator>+</operator> <literal type="string">"--"</literal> <operator>+</operator> <name>p_string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setKeyId</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_string</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_key_id</name></name> <operator>=</operator> <name>p_string</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setPackingList</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>p_bool</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>s_path</name></name> <operator>=</operator> <name>p_bool</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setEntryPoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i_val</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>i_entry_point</name></name> <operator>=</operator> <name>i_val</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setDuration</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>i_val</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>i_duration</name></name> <operator>=</operator> <name>i_val</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type> <name>setIntrinsicDuration</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>i_val</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>i_intrisic_duration</name></name> <operator>=</operator> <name>i_val</name></expr>;</expr_stmt> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>string</name> <macro><name>getId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_id</name></name></expr>;</return> }</block></expr></expr_stmt> <empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>string</name> <macro><name>getPath</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_path</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>string</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_type</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>string</name> <macro><name>getOriginalFilename</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_original_filename</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>string</name> <macro><name>getKeyId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_key_id</name></name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>int</name> <macro><name>getEntryPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>i_entry_point</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>int</name> <macro><name>getDuration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>i_duration</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>int</name> <macro><name>getIntrinsicDuration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>i_intrisic_duration</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isPackingList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>b_is_packing_list</name></name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>int</name></type> <name>Parse</name><parameter_list>( <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ParsePKL</name><parameter_list>( <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>AESKey</name> <modifier>*</modifier></type> <name>getAESKeyById</name><parameter_list>( <parameter><decl><type><name>AESKeyList</name><modifier>*</modifier></type></decl></parameter> , <parameter><decl><type><specifier>const</specifier> <name>string</name></type> <name>s_id</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Dump</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>string</name></type> <name>s_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_annotation</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>b_is_packing_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>ui_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_original_filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_edit_rate</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_intrisic_duration</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_entry_point</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_duration</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_key_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_frame_rate</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_screen_aspect_ratio</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_language</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Chunk</name></expr></argument>&gt;</argument_list></name> <name>chunk_vec</name></expr>;</expr_stmt>

<function_decl><type><name>int</name></type> <name>parseChunkList</name><parameter_list>( <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>p_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p_type</name></decl></parameter>)</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Reel</name>

<block>{<block_content>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>Reel</name><argument_list>(<argument><expr><name>demux_t</name> <operator>*</operator> <name>demux</name></expr></argument>, <argument><expr><name>AssetList</name> <operator>*</operator><name>asset_list</name></expr></argument>, <argument><expr><name>xml_reader_t</name> <operator>*</operator><name>xmlReader</name></expr></argument>)</argument_list></call>

<operator>:</operator> <call><name>p_asset_list</name><argument_list>(<argument><expr><name>asset_list</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>p_xmlReader</name><argument_list>(<argument><expr><name>xmlReader</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>p_demux</name><argument_list>(<argument><expr><name>demux</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>p_picture_track</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>p_sound_track</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>p_subtitle_track</name><argument_list>(<argument>NULL</argument>)</argument_list></macro>

<expr><block>{}</block></expr>;</expr_stmt>

<function_decl><type><name>int</name></type> <name>Parse</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Asset</name> <modifier>*</modifier></type> <name>getTrack</name><parameter_list>(<parameter><decl><type><name>TrackType_t</name></type> <name>e_track</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>AssetList</name> <modifier>*</modifier></type><name>p_asset_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xmlReader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_annotation</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Asset</name> <modifier>*</modifier></type><name>p_picture_track</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Asset</name> <modifier>*</modifier></type><name>p_sound_track</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Asset</name> <modifier>*</modifier></type><name>p_subtitle_track</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> <name>ParseAssetList</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ParseAsset</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>p_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p_type</name></decl></parameter>, <parameter><decl><type><name>TrackType_t</name></type> <name>e_track</name></decl></parameter>)</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CPL</name> <range>: <expr><name>public</name> <name>XmlFile</name>

<block>{

<expr><name>public</name><operator>:</operator>

<macro><name>CPL</name><argument_list>(<argument>demux_t * p_demux</argument>, <argument>string s_path</argument>, <argument>AssetList *_asset_list</argument>)</argument_list></macro>

<operator>:</operator> <call><name>XmlFile</name><argument_list>(<argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>)</argument_list></call></expr>, <macro><name>asset_list</name><argument_list>( <argument>_asset_list</argument>)</argument_list></macro>

<expr><block>{}</block></expr>;

<expr><operator>~</operator><call><name>CPL</name><argument_list>()</argument_list></call></expr>;

<expr><name>virtual</name> <name>int</name> <call><name>Parse</name><argument_list>()</argument_list></call></expr>;

<expr><name>Reel</name> <operator>*</operator><macro><name>getReel</name><argument_list>(<argument>int pos</argument>)</argument_list></macro> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>vec_reel</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</return> }</block></expr> ;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Reel</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReelList</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>vec_reel</name></name></expr>;</return> }</block></expr> ;

<expr><name>private</name> <operator>:</operator>

<name>AssetList</name> <operator>*</operator><name>asset_list</name></expr>;

<expr><name>string</name> <name>s_id</name></expr>;

<expr><name>string</name> <name>s_annotation</name></expr>;

<expr><name>string</name> <name>s_icon_id</name></expr>;

<expr><name>string</name> <name>s_issue_date</name></expr>;

<expr><name>string</name> <name>s_issuer</name></expr>;

<expr><name>string</name> <name>s_creator</name></expr>;

<expr><name>string</name> <name>s_content_title</name></expr>;

<expr><name>string</name> <name>s_content_kind</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Reel</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>vec_reel</name></expr>;

<expr><name>int</name> <macro><name>DummyParse</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

<expr><name>int</name> <macro><name>ParseReelList</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PKL</name> <range>: <expr><name>public</name> <name>XmlFile</name>

<block>{

<expr><name>public</name><operator>:</operator>

<macro><name>PKL</name><argument_list>( <argument>demux_t * p_demux</argument>, <argument>string s_path</argument>, <argument>AssetList *_asset_list</argument>, <argument>string s</argument> )</argument_list></macro>

<operator>:</operator> <call><name>XmlFile</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument> )</argument_list></call></expr>, <expr><call><name>asset_list</name><argument_list>( <argument><expr><name>_asset_list</name></expr></argument> )</argument_list></call></expr>, <macro><name>s_dcp_path</name><argument_list>( <argument>s</argument> )</argument_list></macro>

<expr><block>{}</block></expr>;

<expr><operator>~</operator><call><name>PKL</name><argument_list>()</argument_list></call></expr>;

<expr><name>virtual</name> <name>int</name> <call><name>Parse</name><argument_list>()</argument_list></call></expr>;

<expr><name>int</name> <call><name>FindCPLs</name><argument_list>()</argument_list></call></expr>;

<expr><name>CPL</name> <operator>*</operator><macro><name>getCPL</name><argument_list>(<argument>int pos</argument>)</argument_list></macro> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>vec_cpl</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</return> }</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>AssetList</name> <operator>*</operator><name>asset_list</name></expr>;

<expr><name>string</name> <name>s_id</name></expr>;

<expr><name>string</name> <name>s_annotation</name></expr>;

<expr><name>string</name> <name>s_issue_date</name></expr>;

<expr><name>string</name> <name>s_issuer</name></expr>;

<expr><name>string</name> <name>s_creator</name></expr>;

<expr><name>string</name> <name>s_icon_id</name></expr>;

<expr><name>string</name> <name>s_group_id</name></expr>;

<expr><name>string</name> <name>s_dcp_path</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CPL</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>vec_cpl</name></expr>;

<expr><name>int</name> <macro><name>ParseAssetList</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

<expr><name>int</name> <macro><name>ParseAsset</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

<expr><name>int</name> <macro><name>ParseSigner</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

<expr><name>int</name> <macro><name>ParseSignature</name><argument_list>(<argument>string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AssetMap</name> <range>: <expr><name>public</name> <name>XmlFile</name> <block>{

<expr><name>public</name><operator>:</operator>

<macro><name>AssetMap</name><argument_list>( <argument>demux_t * p_demux</argument>, <argument>string s_path</argument>, <argument>dcp_t *_p_dcp</argument>)</argument_list></macro>

<operator>:</operator> <call><name>XmlFile</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument> )</argument_list></call></expr>, <macro><name>p_dcp</name><argument_list>( <argument>_p_dcp</argument>)</argument_list></macro> <expr><block>{}</block></expr>;

<expr><operator>~</operator><call><name>AssetMap</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>Asset</name> <operator>*</operator> <macro><name>getAssetById</name><argument_list>(<argument>AssetList*</argument>, <argument>const string p_id</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>int</name> <call><name>Parse</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>

<name>dcp_t</name> <operator>*</operator><name>p_dcp</name></expr>;

<expr><name>int</name> <macro><name>ParseAssetList</name> <argument_list>(<argument>xml_reader_t *p_xmlReader</argument>, <argument>const string p_node</argument>, <argument>int p_type</argument>)</argument_list></macro></expr>;

}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>KDM</name> <range>: <expr><name>public</name> <name>XmlFile</name> <block>{

<expr><name>public</name><operator>:</operator>

<macro><name>KDM</name><argument_list>( <argument>demux_t * p_demux</argument>, <argument>string s_path</argument>, <argument>dcp_t *_p_dcp</argument> )</argument_list></macro>

<operator>:</operator> <call><name>XmlFile</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument> )</argument_list></call></expr>, <macro><name>p_dcp</name><argument_list>(<argument>_p_dcp</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>int</name> <call><name>Parse</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>

<name>dcp_t</name> <operator>*</operator><name>p_dcp</name></expr>;

<expr><name>int</name> <macro><name>ParsePrivate</name><argument_list>( <argument>const string s_node</argument>, <argument>int i_type</argument> )</argument_list></macro></expr>;

}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AESKey</name>

<block>{<block_content>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>AESKey</name><argument_list>( <argument><expr><name>demux_t</name> <operator>*</operator><name>demux</name></expr></argument> )</argument_list></call><operator>:</operator> <macro><name>p_demux</name><argument_list>( <argument>demux</argument> )</argument_list></macro> <block>{ }</block>

<name>virtual</name> <operator>~</operator><macro><name>AESKey</name><argument_list>()</argument_list></macro> <block>{}</block></expr>;</expr_stmt>

<function><type><specifier>const</specifier> <name>string</name></type> <name>getKeyId</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>s_key_id</name></name></expr>;</return> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>getKey</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>ps_key</name></name></expr>;</return> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<function_decl><type><name>int</name></type> <name>Parse</name><parameter_list>( <parameter><decl><type><name>xml_reader_t</name> <modifier>*</modifier></type><name>p_xml_reader</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>s_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i_type</name></decl></parameter> )</parameter_list>;</function_decl>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_key_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ps_key</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> <name>decryptRSA</name><parameter_list>( <parameter><decl><type><name>string</name></type> <name>s_cipher_text_b64</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>extractInfo</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type> <name>ps_plain_text</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>smpte</name></decl></parameter> )</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>RSAKey</name>

<block>{<block_content>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>RSAKey</name><argument_list>( <argument><expr><name>demux_t</name> <operator>*</operator><name>demux</name></expr></argument> )</argument_list></call><operator>:</operator>

<call><name>priv_key</name><argument_list>( <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr><operator>,</operator> <macro><name>p_demux</name><argument_list>( <argument>demux</argument> )</argument_list></macro> <expr><block>{ }</block>

<name>virtual</name> <operator>~</operator><macro><name>RSAKey</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>gcry_sexp_release</name><argument_list>( <argument><expr><name>priv_key</name></expr></argument> )</argument_list></call></expr>; }</block>

enum

<block>{

<expr><name>TAG_INTEGER</name> <operator>=</operator> <literal type="number">2</literal></expr>,

<expr><name>TAG_SEQUENCE</name> <operator>=</operator> <literal type="number">16</literal></expr>,

}</block></expr>;</expr_stmt>

<struct>struct <name>tag_info</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>class_</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tag</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>length</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>nhdr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ndef</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cons</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt> 

}</block>;</struct>

<function_decl><type><name>int</name></type> <name>setPath</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>readPEM</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>readDER</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>ps_data_der</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>parseTag</name><parameter_list>( <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buflen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tag_info</name></name> <modifier>*</modifier></type><name>ti</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>gcry_sexp_t</name></type> <name>priv_key</name></decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>string</name></type> <name>s_path</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</unit>
