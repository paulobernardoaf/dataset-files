



































#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <limits.h>

#include <vlc_common.h>
#include <vlc_plugin.h>
#include <vlc_demux.h>
#include <vlc_codec.h>
#include <vlc_meta.h>
#include <vlc_input_item.h>
#include "../codec/cc.h"

#include "mpeg/pes.h"

#include <assert.h>




static int Open ( vlc_object_t * );
static void Close( vlc_object_t * );

vlc_module_begin ()
set_shortname( N_("TY") )
set_description(N_("TY Stream audio/video demux"))
set_category( CAT_INPUT )
set_subcategory( SUBCAT_INPUT_DEMUX )
set_capability("demux", 6)




set_callbacks( Open, Close )
add_shortcut("ty", "tivo")
vlc_module_end ()




static int Demux ( demux_t * );
static int Control( demux_t *, int, va_list );

#define SERIES1_PES_LENGTH (11) 
#define SERIES2_PES_LENGTH (16) 
#define AC3_PES_LENGTH (14) 
#define VIDEO_PES_LENGTH (16) 
#define DTIVO_PTS_OFFSET (6) 
#define SA_PTS_OFFSET (9) 
#define AC3_PTS_OFFSET (9) 
#define VIDEO_PTS_OFFSET (9) 
#define AC3_PKT_LENGTH (1536) 
static const uint8_t ty_VideoPacket[] = { 0x00, 0x00, 0x01, 0xe0 };
static const uint8_t ty_MPEGAudioPacket[] = { 0x00, 0x00, 0x01, 0xc0 };
static const uint8_t ty_AC3AudioPacket[] = { 0x00, 0x00, 0x01, 0xbd };

#define CHUNK_PEEK_COUNT (3) 



















#define TIVO_PES_FILEID ( 0xf5467abd )
#define TIVO_PART_LENGTH ( 0x20000000 ) 
#define CHUNK_SIZE ( 128 * 1024 )

typedef struct
{
long l_rec_size;
uint8_t ex[2];
uint8_t rec_type;
uint8_t subrec_type;
bool b_ext;
uint64_t l_ty_pts; 
} ty_rec_hdr_t;

typedef struct
{
uint64_t l_timestamp;
uint8_t chunk_bitmask[8];
} ty_seq_table_t;

typedef enum
{
TIVO_TYPE_UNKNOWN,
TIVO_TYPE_SA,
TIVO_TYPE_DTIVO
} tivo_type_t;

typedef enum
{
TIVO_SERIES_UNKNOWN,
TIVO_SERIES1,
TIVO_SERIES2
} tivo_series_t;

typedef enum
{
TIVO_AUDIO_UNKNOWN,
TIVO_AUDIO_AC3,
TIVO_AUDIO_MPEG
} tivo_audio_t;

#define XDS_MAX_DATA_SIZE (32)
typedef enum
{
XDS_CLASS_CURRENT = 0,
XDS_CLASS_FUTURE = 1,
XDS_CLASS_CHANNEL = 2,
XDS_CLASS_MISCELLANEOUS = 3,
XDS_CLASS_PUBLIC_SERVICE = 4,
XDS_CLASS_RESERVED = 5,
XDS_CLASS_UNDEFINED = 6,
XDS_CLASS_OTHER = 7,

XDS_MAX_CLASS_COUNT
} xds_class_t;
typedef struct
{
bool b_started;
size_t i_data;
uint8_t p_data[XDS_MAX_DATA_SIZE];
int i_sum;
} xds_packet_t;
typedef enum
{
XDS_META_PROGRAM_RATING_NONE,
XDS_META_PROGRAM_RATING_MPAA,
XDS_META_PROGRAM_RATING_TPG,

} xds_meta_program_rating_t;
typedef struct
{
char *psz_name;
xds_meta_program_rating_t rating;
char *psz_rating;

} xds_meta_program_t;
typedef struct
{
char *psz_channel_name;
char *psz_channel_call_letter;
char *psz_channel_number;

xds_meta_program_t current;
xds_meta_program_t future;
} xds_meta_t;
typedef struct
{

bool b_xds;


xds_class_t i_class;
int i_type;
bool b_future;


xds_packet_t pkt[XDS_MAX_CLASS_COUNT][128]; 


bool b_meta_changed;
xds_meta_t meta;

} xds_t;

typedef struct
{
es_out_id_t *p_video; 
es_out_id_t *p_audio; 

cc_data_t cc;
es_out_id_t *p_cc[4];

xds_t xds;

int i_cur_chunk;
int i_stuff_cnt;
size_t i_stream_size; 

bool b_seekable; 
bool b_have_master; 
tivo_type_t tivo_type; 
tivo_series_t tivo_series; 
tivo_audio_t audio_type; 
int i_Pes_Length; 
int i_Pts_Offset; 
uint8_t pes_buffer[20]; 
int i_pes_buf_cnt; 
size_t l_ac3_pkt_size; 
uint64_t l_last_ty_pts; 

uint64_t l_first_ty_pts; 
uint64_t l_final_ty_pts; 
unsigned i_seq_table_size; 
unsigned i_bits_per_seq_entry; 

vlc_tick_t lastAudioPTS;
vlc_tick_t lastVideoPTS;

ty_rec_hdr_t *rec_hdrs; 
int i_cur_rec; 
int i_num_recs; 
int i_seq_rec; 
ty_seq_table_t *seq_table; 
bool eof;
bool b_first_chunk;
} demux_sys_t;

static int get_chunk_header(demux_t *);
static vlc_tick_t get_pts( const uint8_t *buf );
static int find_es_header( const uint8_t *header,
const uint8_t *buffer, int i_search_len );
static int ty_stream_seek_pct(demux_t *p_demux, double seek_pct);
static int ty_stream_seek_time(demux_t *, uint64_t);

static ty_rec_hdr_t *parse_chunk_headers( const uint8_t *p_buf,
int i_num_recs, int *pi_payload_size);
static int probe_stream(demux_t *p_demux);
static void analyze_chunk(demux_t *p_demux, const uint8_t *p_chunk);
static int parse_master(demux_t *p_demux);

static int DemuxRecVideo( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in );
static int DemuxRecAudio( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in );
static int DemuxRecCc( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in );

static void DemuxDecodeXds( demux_t *p_demux, uint8_t d1, uint8_t d2 );

static void XdsInit( xds_t * );
static void XdsExit( xds_t * );

#define TY_ES_GROUP (1)











static int Open(vlc_object_t *p_this)
{
demux_t *p_demux = (demux_t *)p_this;
demux_sys_t *p_sys;
es_format_t fmt;
const uint8_t *p_peek;
int i;



if( vlc_stream_Peek( p_demux->s, &p_peek, 12 ) < 12 )
return VLC_EGENERIC;

if ( U32_AT(p_peek) != TIVO_PES_FILEID ||
U32_AT(&p_peek[4]) != 0x02 ||
U32_AT(&p_peek[8]) != CHUNK_SIZE )
{
if( !p_demux->obj.force &&
!demux_IsPathExtension( p_demux, ".ty" ) &&
!demux_IsPathExtension( p_demux, ".ty+" ) )
return VLC_EGENERIC;
msg_Warn( p_demux, "this does not look like a TY file, "
"continuing anyway..." );
}


msg_Dbg( p_demux, "valid TY stream detected" );

p_sys = malloc(sizeof(demux_sys_t));
if( unlikely(p_sys == NULL) )
return VLC_ENOMEM;


p_demux->pf_demux = Demux;
p_demux->pf_control = Control;


p_demux->p_sys = p_sys;
memset(p_sys, 0, sizeof(demux_sys_t));


p_sys->b_first_chunk = true;
p_sys->b_have_master = (U32_AT(p_peek) == TIVO_PES_FILEID);
p_sys->lastAudioPTS = VLC_TICK_INVALID;
p_sys->lastVideoPTS = VLC_TICK_INVALID;
p_sys->i_stream_size = stream_Size(p_demux->s);
p_sys->tivo_type = TIVO_TYPE_UNKNOWN;
p_sys->audio_type = TIVO_AUDIO_UNKNOWN;
p_sys->tivo_series = TIVO_SERIES_UNKNOWN;
p_sys->i_Pes_Length = 0;
p_sys->i_Pts_Offset = 0;
p_sys->l_ac3_pkt_size = 0;


vlc_stream_Control( p_demux->s, STREAM_CAN_SEEK, &p_sys->b_seekable );

if (probe_stream(p_demux) != VLC_SUCCESS) {

return VLC_EGENERIC;
}

if (!p_sys->b_have_master)
msg_Warn(p_demux, "No master chunk found; seeking will be limited.");


if (p_sys->audio_type == TIVO_AUDIO_MPEG) {
es_format_Init( &fmt, AUDIO_ES, VLC_CODEC_MPGA );
} else {
es_format_Init( &fmt, AUDIO_ES, VLC_CODEC_A52 );
}
fmt.i_group = TY_ES_GROUP;
p_sys->p_audio = es_out_Add( p_demux->out, &fmt );


es_format_Init( &fmt, VIDEO_ES, VLC_CODEC_MPGV );
fmt.i_group = TY_ES_GROUP;
p_sys->p_video = es_out_Add( p_demux->out, &fmt );


for( i = 0; i < 4; i++ )
p_sys->p_cc[i] = NULL;
cc_Init( &p_sys->cc );

XdsInit( &p_sys->xds );

return VLC_SUCCESS;
}










static int Demux( demux_t *p_demux )
{
demux_sys_t *p_sys = p_demux->p_sys;
ty_rec_hdr_t *p_rec;
block_t *p_block_in = NULL;




if( p_sys->eof )
return VLC_DEMUXER_EOF;
















if( p_sys->b_first_chunk || p_sys->i_cur_rec >= p_sys->i_num_recs )
{
if( get_chunk_header(p_demux) == 0 || p_sys->i_num_recs == 0 )
return VLC_DEMUXER_EOF;
}




p_rec = &p_sys->rec_hdrs[p_sys->i_cur_rec];

if( !p_rec->b_ext )
{
const long l_rec_size = p_rec->l_rec_size;




if( l_rec_size <= 0 )
{

p_sys->i_cur_rec++;
return VLC_DEMUXER_SUCCESS;
}


if( !( p_block_in = vlc_stream_Block( p_demux->s, l_rec_size ) ) )
return VLC_DEMUXER_EOF;


p_block_in->i_pts =
p_block_in->i_dts = VLC_TICK_INVALID;
}








switch( p_rec->rec_type )
{
case 0xe0: 
DemuxRecVideo( p_demux, p_rec, p_block_in );
break;

case 0xc0: 
DemuxRecAudio( p_demux, p_rec, p_block_in );
break;

case 0x01:
case 0x02:

DemuxRecCc( p_demux, p_rec, p_block_in );
break;

default:
msg_Dbg(p_demux, "Invalid record type 0x%02x", p_rec->rec_type );


case 0x03: 
case 0x05: 
if( p_block_in )
block_Release( p_block_in );
}


p_sys->i_cur_rec++;
return VLC_DEMUXER_SUCCESS;
}


static int Control(demux_t *p_demux, int i_query, va_list args)
{
demux_sys_t *p_sys = p_demux->p_sys;
double f, *pf;
int64_t i64;


switch( i_query )
{
case DEMUX_CAN_SEEK:
*va_arg( args, bool * ) = p_sys->b_seekable;
return VLC_SUCCESS;

case DEMUX_GET_POSITION:

if( ( i64 = p_sys->i_stream_size ) > 0 )
{
pf = va_arg( args, double* );
*pf = ((double)1.0) * vlc_stream_Tell( p_demux->s ) / (double) i64;
return VLC_SUCCESS;
}
return VLC_EGENERIC;

case DEMUX_SET_POSITION:

f = va_arg( args, double );

if ((i64 = p_sys->i_stream_size) > 0)
return ty_stream_seek_pct(p_demux, f);
return VLC_EGENERIC;
case DEMUX_GET_TIME:




*va_arg(args, vlc_tick_t *) = VLC_TICK_FROM_NS(p_sys->l_last_ty_pts);
return VLC_SUCCESS;
case DEMUX_GET_LENGTH: 

*va_arg(args, vlc_tick_t *) = 0;
return VLC_SUCCESS;
case DEMUX_SET_TIME: 
return ty_stream_seek_time(p_demux,
NS_FROM_VLC_TICK(va_arg( args, vlc_tick_t )));
case DEMUX_CAN_PAUSE:
case DEMUX_SET_PAUSE_STATE:
case DEMUX_CAN_CONTROL_PACE:
case DEMUX_GET_PTS_DELAY:
return demux_vaControlHelper( p_demux->s, 0, -1, 0, 1, i_query, args );
case DEMUX_GET_FPS:
default:
return VLC_EGENERIC;
}
}


static void Close( vlc_object_t *p_this )
{
demux_t *p_demux = (demux_t*)p_this;
demux_sys_t *p_sys = p_demux->p_sys;

XdsExit( &p_sys->xds );
cc_Exit( &p_sys->cc );
free( p_sys->rec_hdrs );
free( p_sys->seq_table );
free(p_sys);
}





static vlc_tick_t get_pts( const uint8_t *buf )
{
stime_t i_pts = GetPESTimestamp( buf );
return FROM_SCALE_NZ(i_pts); 
}



static int find_es_header( const uint8_t *header,
const uint8_t *buffer, int i_search_len )
{
int count;

for( count = 0; count < i_search_len; count++ )
{
if( !memcmp( &buffer[count], header, 4 ) )
return count;
}
return -1;
}










static int check_sync_pes( demux_t *p_demux, block_t *p_block,
int32_t offset, int32_t rec_len )
{
demux_sys_t *p_sys = p_demux->p_sys;

if ( offset < 0 || offset + p_sys->i_Pes_Length > rec_len )
{

msg_Dbg( p_demux, "PES header at %d not complete in record. storing.",
offset );

if( offset < 0 )
{

memset( p_sys->pes_buffer, 0, 4 );
p_sys->i_pes_buf_cnt = 4;
if( rec_len > 4 )
msg_Err( p_demux, "PES header not found in record of %d bytes!",
rec_len );
return -1;
}

memcpy( p_sys->pes_buffer, p_block->p_buffer + offset,
rec_len - offset );
p_sys->i_pes_buf_cnt = rec_len - offset;

if( offset > 0 )
{

p_block->i_buffer -= rec_len - offset;
return 1;
}
return -1; 
}

p_sys->lastAudioPTS = VLC_TICK_0 + get_pts( &p_block->p_buffer[ offset +
p_sys->i_Pts_Offset ] );
p_block->i_pts = p_sys->lastAudioPTS;


memmove(p_block->p_buffer + offset, p_block->p_buffer + offset +
p_sys->i_Pes_Length, rec_len - p_sys->i_Pes_Length);
p_block->i_buffer -= p_sys->i_Pes_Length;
#if 0
msg_Dbg(p_demux, "pes hdr removed; buffer len=%d and has "
"%02x %02x %02x %02x %02x %02x %02x %02x "
"%02x %02x %02x %02x %02x %02x %02x %02x", p_block->i_buffer,
p_block->p_buffer[0], p_block->p_buffer[1],
p_block->p_buffer[2], p_block->p_buffer[3],
p_block->p_buffer[4], p_block->p_buffer[5],
p_block->p_buffer[6], p_block->p_buffer[7],
p_block->p_buffer[8], p_block->p_buffer[9],
p_block->p_buffer[10], p_block->p_buffer[11],
p_block->p_buffer[12], p_block->p_buffer[13],
p_block->p_buffer[14], p_block->p_buffer[15]);
#endif
return 0;
}

static int DemuxRecVideo( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in )
{
demux_sys_t *p_sys = p_demux->p_sys;
const int subrec_type = rec_hdr->subrec_type;
const long l_rec_size = rec_hdr->l_rec_size; 
int esOffset1;
int i;

assert( rec_hdr->rec_type == 0xe0 );
if( !p_block_in )
return -1;

#if 0
msg_Dbg(p_demux, "packet buffer has "
"%02x %02x %02x %02x %02x %02x %02x %02x "
"%02x %02x %02x %02x %02x %02x %02x %02x",
p_block_in->p_buffer[0], p_block_in->p_buffer[1],
p_block_in->p_buffer[2], p_block_in->p_buffer[3],
p_block_in->p_buffer[4], p_block_in->p_buffer[5],
p_block_in->p_buffer[6], p_block_in->p_buffer[7],
p_block_in->p_buffer[8], p_block_in->p_buffer[9],
p_block_in->p_buffer[10], p_block_in->p_buffer[11],
p_block_in->p_buffer[12], p_block_in->p_buffer[13],
p_block_in->p_buffer[14], p_block_in->p_buffer[15]);
#endif

if( subrec_type != 0x02 && subrec_type != 0x0c &&
subrec_type != 0x08 && l_rec_size > 4 )
{



esOffset1 = find_es_header( ty_VideoPacket, p_block_in->p_buffer, 5 );
if( esOffset1 != -1 )
{


p_sys->lastVideoPTS = VLC_TICK_0 + get_pts(
&p_block_in->p_buffer[ esOffset1 + VIDEO_PTS_OFFSET ] );


if (subrec_type != 0x06) {



if (l_rec_size >= VIDEO_PES_LENGTH) {
p_block_in->p_buffer += VIDEO_PES_LENGTH + esOffset1;
p_block_in->i_buffer -= VIDEO_PES_LENGTH + esOffset1;
} else {
msg_Dbg(p_demux, "video rec type 0x%02x has short PES"
" (%ld bytes)", subrec_type, l_rec_size);

p_block_in->i_buffer = 0;
}
}
}


}

if(subrec_type == 0x06 )
{

block_Release(p_block_in);
return 0;
}


if( subrec_type != 0x02 )
{






if (subrec_type == 0x0c && l_rec_size >= 6)
p_block_in->p_buffer[5] |= 0x08;

if (subrec_type == 0x07) {
p_sys->l_last_ty_pts = rec_hdr->l_ty_pts;


} else {






p_sys->l_last_ty_pts += 35000000;

}

if (p_sys->lastVideoPTS != VLC_TICK_INVALID)
{
p_block_in->i_pts = p_sys->lastVideoPTS;



p_sys->lastVideoPTS = VLC_TICK_INVALID;
}
}


uint64_t i_chans = p_sys->cc.i_608channels;
for( i = 0; i_chans > 0; i++, i_chans >>= 1 )
{
if( (i_chans & 1) == 0 || p_sys->p_cc[i] )
continue;

static const char *ppsz_description[4] = {
N_("Closed captions 1"),
N_("Closed captions 2"),
N_("Closed captions 3"),
N_("Closed captions 4"),
};

es_format_t fmt;


es_format_Init( &fmt, SPU_ES, VLC_CODEC_CEA608 );
fmt.subs.cc.i_channel = i;
fmt.psz_description = strdup( vlc_gettext(ppsz_description[i]) );
fmt.i_group = TY_ES_GROUP;
p_sys->p_cc[i] = es_out_Add( p_demux->out, &fmt );
es_format_Clean( &fmt );

}

if( p_block_in->i_pts != VLC_TICK_INVALID && p_sys->cc.i_data > 0 )
{
for( i = 0; i < 4; i++ )
{
if( p_sys->p_cc[i] )
{
block_t *p_cc = block_Alloc( p_sys->cc.i_data );
p_cc->i_flags |= BLOCK_FLAG_TYPE_I;
p_cc->i_pts = p_block_in->i_pts;
memcpy( p_cc->p_buffer, p_sys->cc.p_data, p_sys->cc.i_data );

es_out_Send( p_demux->out, p_sys->p_cc[i], p_cc );
}
}
cc_Flush( &p_sys->cc );
}



es_out_Send(p_demux->out, p_sys->p_video, p_block_in);
return 0;
}
static int DemuxRecAudio( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in )
{
demux_sys_t *p_sys = p_demux->p_sys;
const int subrec_type = rec_hdr->subrec_type;
const long l_rec_size = rec_hdr->l_rec_size;
int esOffset1;

assert( rec_hdr->rec_type == 0xc0 );
if( !p_block_in )
return -1;
#if 0
int i;
fprintf( stderr, "Audio Packet Header " );
for( i = 0 ; i < 24 ; i++ )
fprintf( stderr, "%2.2x ", p_block_in->p_buffer[i] );
fprintf( stderr, "\n" );
#endif

if( subrec_type == 2 )
{





if (p_sys->i_pes_buf_cnt > 0)
{
const int i_need = p_sys->i_Pes_Length - p_sys->i_pes_buf_cnt;

msg_Dbg(p_demux, "continuing PES header");

if (i_need >= l_rec_size)
{

memcpy(&p_sys->pes_buffer[p_sys->i_pes_buf_cnt],
p_block_in->p_buffer, l_rec_size);
p_sys->i_pes_buf_cnt += l_rec_size;

block_Release(p_block_in);
return 0;
}


memcpy(&p_sys->pes_buffer[p_sys->i_pes_buf_cnt],
p_block_in->p_buffer, i_need);

p_block_in->p_buffer += i_need;
p_block_in->i_buffer -= i_need;

if (p_sys->audio_type == TIVO_AUDIO_MPEG)
esOffset1 = find_es_header(ty_MPEGAudioPacket,
p_sys->pes_buffer, 5);
else
esOffset1 = find_es_header(ty_AC3AudioPacket,
p_sys->pes_buffer, 5);
if (esOffset1 < 0)
{

msg_Err(p_demux, "can't find audio PES header in packet");
}
else
{
p_sys->lastAudioPTS = VLC_TICK_0 + get_pts(
&p_sys->pes_buffer[ esOffset1 + p_sys->i_Pts_Offset ] );
p_block_in->i_pts = p_sys->lastAudioPTS;
}
p_sys->i_pes_buf_cnt = 0;
}






if (p_sys->audio_type == TIVO_AUDIO_AC3 &&
p_sys->tivo_series == TIVO_SERIES2) {
if (p_sys->l_ac3_pkt_size + p_block_in->i_buffer >
AC3_PKT_LENGTH) {
p_block_in->i_buffer -= 2;
p_sys->l_ac3_pkt_size = 0;
} else {
p_sys->l_ac3_pkt_size += p_block_in->i_buffer;
}
}
}
else if( subrec_type == 0x03 )
{


esOffset1 = find_es_header( ty_MPEGAudioPacket,
p_block_in->p_buffer, 5 );








if ( ( esOffset1 == 0 ) && ( l_rec_size == 16 ) )
{
p_sys->lastAudioPTS = VLC_TICK_0 + get_pts( &p_block_in->p_buffer[
SA_PTS_OFFSET ] );

block_Release(p_block_in);
return 0;

}




if (check_sync_pes(p_demux, p_block_in, esOffset1,
l_rec_size) == -1)
{


block_Release(p_block_in);
return 0;
}
#if 0
msg_Dbg(p_demux, "packet buffer has "
"%02x %02x %02x %02x %02x %02x %02x %02x "
"%02x %02x %02x %02x %02x %02x %02x %02x",
p_block_in->p_buffer[0], p_block_in->p_buffer[1],
p_block_in->p_buffer[2], p_block_in->p_buffer[3],
p_block_in->p_buffer[4], p_block_in->p_buffer[5],
p_block_in->p_buffer[6], p_block_in->p_buffer[7],
p_block_in->p_buffer[8], p_block_in->p_buffer[9],
p_block_in->p_buffer[10], p_block_in->p_buffer[11],
p_block_in->p_buffer[12], p_block_in->p_buffer[13],
p_block_in->p_buffer[14], p_block_in->p_buffer[15]);
#endif
}
else if( subrec_type == 0x04 )
{





if (p_sys->lastAudioPTS != VLC_TICK_INVALID )
p_block_in->i_pts = p_sys->lastAudioPTS;
}
else if( subrec_type == 0x09 )
{


esOffset1 = find_es_header( ty_AC3AudioPacket,
p_block_in->p_buffer, 5 );

#if 0
msg_Dbg(p_demux, "buffer has "
"%02x %02x %02x %02x %02x %02x %02x %02x "
"%02x %02x %02x %02x %02x %02x %02x %02x",
p_block_in->p_buffer[0], p_block_in->p_buffer[1],
p_block_in->p_buffer[2], p_block_in->p_buffer[3],
p_block_in->p_buffer[4], p_block_in->p_buffer[5],
p_block_in->p_buffer[6], p_block_in->p_buffer[7],
p_block_in->p_buffer[8], p_block_in->p_buffer[9],
p_block_in->p_buffer[10], p_block_in->p_buffer[11],
p_block_in->p_buffer[12], p_block_in->p_buffer[13],
p_block_in->p_buffer[14], p_block_in->p_buffer[15]);
msg_Dbg(p_demux, "audio ES AC3 hdr at offset %d", esOffset1);
#endif


if (check_sync_pes(p_demux, p_block_in, esOffset1,
l_rec_size) == -1)
{

block_Release(p_block_in);
return 0;
}

if (p_sys->tivo_series == TIVO_SERIES2) {
if (p_block_in->i_buffer > AC3_PKT_LENGTH) {
p_block_in->i_buffer -= 2;
p_sys->l_ac3_pkt_size = 0;
} else {
p_sys->l_ac3_pkt_size = p_block_in->i_buffer;
}
}
}
else
{

block_Release(p_block_in);
return 0;
}


if( p_block_in->i_pts != VLC_TICK_INVALID )
es_out_Control( p_demux->out, ES_OUT_SET_PCR,
p_block_in->i_pts );

es_out_Send( p_demux->out, p_sys->p_audio, p_block_in );
return 0;
}

static int DemuxRecCc( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block_in )
{
demux_sys_t *p_sys = p_demux->p_sys;
int i_field;

if( p_block_in )
block_Release(p_block_in);

if( rec_hdr->rec_type == 0x01 )
i_field = 0;
else if( rec_hdr->rec_type == 0x02 )
i_field = 1;
else
return 0;


if( i_field == 1 )
DemuxDecodeXds( p_demux, rec_hdr->ex[0], rec_hdr->ex[1] );

if( p_sys->cc.i_data + 3 > CC_MAX_DATA_SIZE )
return 0;

cc_AppendData( &p_sys->cc, CC_PKT_BYTE0(i_field), rec_hdr->ex );
return 0;
}


static int ty_stream_seek_pct(demux_t *p_demux, double seek_pct)
{
demux_sys_t *p_sys = p_demux->p_sys;
int64_t seek_pos = p_sys->i_stream_size * seek_pct;
uint64_t l_skip_amt;
unsigned i_cur_part;


if (!p_sys->b_seekable)
return VLC_EGENERIC;


i_cur_part = seek_pos / TIVO_PART_LENGTH;
p_sys->i_cur_chunk = seek_pos / CHUNK_SIZE;


if (vlc_stream_Seek( p_demux->s, i_cur_part * TIVO_PART_LENGTH ) ||
parse_master(p_demux) != VLC_SUCCESS)
{

return VLC_EGENERIC;
}


if ( vlc_stream_Seek( p_demux->s, p_sys->i_cur_chunk * CHUNK_SIZE))
{

return VLC_EGENERIC;
}

p_sys->i_stuff_cnt = 0;
get_chunk_header(p_demux);


p_sys->i_cur_rec = (int)
((double) ((seek_pos % CHUNK_SIZE) / (double) (CHUNK_SIZE)) * p_sys->i_num_recs);
msg_Dbg(p_demux, "Seeked to file pos %"PRId64, seek_pos);
msg_Dbg(p_demux, " (chunk %d, record %d)",
p_sys->i_cur_chunk - 1, p_sys->i_cur_rec);



l_skip_amt = 0;
for ( int i=0; i<p_sys->i_cur_rec; i++)
l_skip_amt += p_sys->rec_hdrs[i].l_rec_size;
if( vlc_stream_Seek(p_demux->s, ((p_sys->i_cur_chunk-1) * CHUNK_SIZE) +
(p_sys->i_num_recs * 16) + l_skip_amt + 4) != VLC_SUCCESS )
return VLC_EGENERIC;



return VLC_SUCCESS;
}



static void XdsInit( xds_t *h )
{
h->b_xds = false;
h->i_class = XDS_MAX_CLASS_COUNT;
h->i_type = 0;
h->b_future = false;
for( int i = 0; i < XDS_MAX_CLASS_COUNT; i++ )
{
for( int j = 0; j < 128; j++ )
h->pkt[i][j].b_started = false;
}
h->b_meta_changed = false;
memset( &h->meta, 0, sizeof(h->meta) );
}
static void XdsExit( xds_t *h )
{

free( h->meta.psz_channel_name );
free( h->meta.psz_channel_call_letter );
free( h->meta.psz_channel_number );


free( h->meta.current.psz_name );
free( h->meta.current.psz_rating );

free( h->meta.future.psz_name );
free( h->meta.future.psz_rating );
}
static void XdsStringUtf8( char dst[2*32+1], const uint8_t *p_src, size_t i_src )
{
size_t i_dst = 0;
for( size_t i = 0; i < i_src; i++ )
{
switch( p_src[i] )
{
#define E2( c, u1, u2 ) case c: dst[i_dst++] = u1; dst[i_dst++] = u2; break
E2( 0x2a, 0xc3,0xa1); 
E2( 0x5c, 0xc3,0xa9); 
E2( 0x5e, 0xc3,0xad); 
E2( 0x5f, 0xc3,0xb3); 
E2( 0x60, 0xc3,0xba); 
E2( 0x7b, 0xc3,0xa7); 
E2( 0x7c, 0xc3,0xb7); 
E2( 0x7d, 0xc3,0x91); 
E2( 0x7e, 0xc3,0xb1); 
#undef E2
default:
dst[i_dst++] = p_src[i];
break;
}
}
dst[i_dst++] = '\0';
}
static bool XdsChangeString( xds_t *h, char **ppsz_dst, const char *psz_new )
{
if( *ppsz_dst && psz_new && !strcmp( *ppsz_dst, psz_new ) )
return false;
if( *ppsz_dst == NULL && psz_new == NULL )
return false;

free( *ppsz_dst );
if( psz_new )
*ppsz_dst = strdup( psz_new );
else
*ppsz_dst = NULL;

h->b_meta_changed = true;
return true;
}

static void XdsDecodeCurrentFuture( xds_t *h, xds_packet_t *pk )
{
xds_meta_program_t *p_prg = h->b_future ? &h->meta.future : &h->meta.current;
char name[2*32+1];
int i_rating;

switch( h->i_type )
{
case 0x03:
XdsStringUtf8( name, pk->p_data, pk->i_data );
if( XdsChangeString( h, &p_prg->psz_name, name ) )
{


}
break;
case 0x05:
i_rating = (pk->p_data[0] & 0x18);
if( i_rating == 0x08 )
{

static const char *pppsz_ratings[8][2] = {
{ "None", "No rating (no content advisory)" },
{ "TV-Y", "All Children (no content advisory)" },
{ "TV-Y7", "Directed to Older Children (V = Fantasy Violence)" },
{ "TV-G", "General Audience (no content advisory)" },
{ "TV-PG", "Parental Guidance Suggested" },
{ "TV-14", "Parents Strongly Cautioned" },
{ "TV-MA", "Mature Audience Only" },
{ "None", "No rating (no content advisory)" }
};
p_prg->rating = XDS_META_PROGRAM_RATING_TPG;
if( XdsChangeString( h, &p_prg->psz_rating, pppsz_ratings[pk->p_data[1]&0x07][0] ) )
{



}
}
else if( i_rating == 0x00 || i_rating == 0x10 )
{

static const char *pppsz_ratings[8][2] = {
{ "N/A", "N/A" },
{ "G", "General Audiences" },
{ "PG", "Parental Guidance Suggested" },
{ "PG-13", "Parents Strongly Cautioned" },
{ "R", "Restricted" },
{ "NC-17", "No one 17 and under admitted" },
{ "X", "No one under 17 admitted" },
{ "NR", "Not Rated" },
};
p_prg->rating = XDS_META_PROGRAM_RATING_MPAA;
if( XdsChangeString( h, &p_prg->psz_rating, pppsz_ratings[pk->p_data[0]&0x07][0] ) )
{



}
}
else
{

assert( i_rating == 0x18 ); 
p_prg->rating = XDS_META_PROGRAM_RATING_NONE;
if( XdsChangeString( h, &p_prg->psz_rating, NULL ) )
{


}
}
break;

default:
#ifdef TY_XDS_DEBUG
fprintf( stderr, "xxxxxxxxxxxxxxxXDS XdsDecode: class 'Current/Future (Unknown 0x%x)'\n", h->i_type );
#endif
break;
}
}

static void XdsDecodeChannel( xds_t *h, xds_packet_t *pk )
{
char name[2*32+1];
char chan[2*32+1];

switch( h->i_type )
{
case 0x01:
if( pk->i_data < 2 )
return;
XdsStringUtf8( name, pk->p_data, pk->i_data );
if( XdsChangeString( h, &h->meta.psz_channel_name, name ) )
{


}
break;

case 0x02:
if( pk->i_data < 4 )
return;

XdsStringUtf8( name, pk->p_data, 4 );
if( XdsChangeString( h, &h->meta.psz_channel_call_letter, name ) )
{


}
if( pk->i_data >= 6 )
{
XdsStringUtf8( chan, &pk->p_data[4], 2 );
if( XdsChangeString( h, &h->meta.psz_channel_number, chan ) )
{


}
}
else
{
if( XdsChangeString( h, &h->meta.psz_channel_number, NULL ) )
{


}
}
break;
case 0x03:

break;
case 0x04:

break;
default:
#ifdef TY_XDS_DEBUG
fprintf( stderr, "xxxxxxxxxxxxxxxXDS XdsDecode: class 'Channel (Unknown 0x%x)'\n", h->i_type );
#endif
break;
}
}

static void XdsDecode( xds_t *h, xds_packet_t *pk )
{
switch( h->i_class )
{
case XDS_CLASS_CURRENT:
case XDS_CLASS_FUTURE:
XdsDecodeCurrentFuture( h, pk );
break;
case XDS_CLASS_CHANNEL:
XdsDecodeChannel( h, pk );
break;
case XDS_CLASS_MISCELLANEOUS:
#ifdef TY_XDS_DEBUG
fprintf( stderr, "xxxxxxxxxxxxxxxXDS XdsDecode: class 'Miscellaneous'\n" );
#endif
break;
case XDS_CLASS_PUBLIC_SERVICE:
#ifdef TY_XDS_DEBUG
fprintf( stderr, "xxxxxxxxxxxxxxxXDS XdsDecode: class 'Public Service'\n" );
#endif
break;
default:

break;
}
}

static void XdsParse( xds_t *h, uint8_t d1, uint8_t d2 )
{

d1 &= 0x7f;
d2 &= 0x7f;


if( d1 >= 0x01 && d1 <= 0x0e )
{
const xds_class_t i_class = ( d1 - 1 ) >> 1;
const int i_type = d2;
const bool b_start = d1 & 0x01;
xds_packet_t *pk = &h->pkt[i_class][i_type];

if( !b_start && !pk->b_started )
{

h->b_xds = false;
return;
}

h->b_xds = true;
h->i_class = i_class;
h->i_type = i_type;
h->b_future = !b_start;
pk->b_started = true;
if( b_start )
{
pk->i_data = 0;
pk->i_sum = d1 + d2;
}
}
else if( d1 == 0x0f && h->b_xds )
{
xds_packet_t *pk = &h->pkt[h->i_class][h->i_type];


pk->i_sum += d1 + d2;
if( pk->i_sum & 0x7f )
{

pk->b_started = false;
return;
}
if( pk->i_data <= 0 )
{

pk->b_started = false;
return;
}



XdsDecode( h, pk );


pk->b_started = false;
}
else if( d1 >= 0x20 && h->b_xds )
{
xds_packet_t *pk = &h->pkt[h->i_class][h->i_type];

if( pk->i_data+2 > XDS_MAX_DATA_SIZE )
{


h->b_xds = false;
pk->b_started = false;
return;
}

pk->p_data[pk->i_data++] = d1 & 0x7f;
pk->p_data[pk->i_data++] = d2 & 0x7f;
pk->i_sum += d1+d2;
}
else
{
h->b_xds = false;
}
}

static void DemuxDecodeXds( demux_t *p_demux, uint8_t d1, uint8_t d2 )
{
demux_sys_t *p_sys = p_demux->p_sys;

XdsParse( &p_sys->xds, d1, d2 );
if( p_sys->xds.b_meta_changed )
{
xds_meta_t *m = &p_sys->xds.meta;
vlc_meta_t *p_meta;


p_meta = vlc_meta_New();
if( m->psz_channel_name )
vlc_meta_SetPublisher( p_meta, m->psz_channel_name );
if( m->psz_channel_call_letter )
vlc_meta_SetTitle( p_meta, m->psz_channel_call_letter );
if( m->psz_channel_number )
vlc_meta_AddExtra( p_meta, "Channel number", m->psz_channel_number );
es_out_Control( p_demux->out, ES_OUT_SET_GROUP_META, TY_ES_GROUP, p_meta );
vlc_meta_Delete( p_meta );


if( m->current.psz_name )
{
vlc_epg_t *p_epg = vlc_epg_New( TY_ES_GROUP, TY_ES_GROUP );
if ( p_epg )
{
vlc_epg_event_t *p_evt = vlc_epg_event_New( 0, 0, 0 );
if ( p_evt )
{
if( m->current.psz_name )
p_evt->psz_name = strdup( m->current.psz_name );
if( !vlc_epg_AddEvent( p_epg, p_evt ) )
vlc_epg_event_Delete( p_evt );
}


vlc_epg_SetCurrent( p_epg, 0 );

if( m->future.psz_name )
{
}
if( p_epg->i_event > 0 )
es_out_Control( p_demux->out, ES_OUT_SET_GROUP_EPG,
TY_ES_GROUP, p_epg );
vlc_epg_Delete( p_epg );
}
}
}
p_sys->xds.b_meta_changed = false;
}




static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)
{
demux_sys_t *p_sys = p_demux->p_sys;
unsigned i_seq_entry = 0;
unsigned i;
int i_skip_cnt;
int64_t l_cur_pos = vlc_stream_Tell(p_demux->s);
unsigned i_cur_part = l_cur_pos / TIVO_PART_LENGTH;
uint64_t l_seek_secs = l_seek_time / 1000000000;
uint64_t l_fwd_stamp = 1;


if (!p_sys->b_seekable || !p_sys->b_have_master)
return VLC_EGENERIC;

msg_Dbg(p_demux, "Skipping to time %02"PRIu64":%02"PRIu64":%02"PRIu64,
l_seek_secs / 3600, (l_seek_secs / 60) % 60, l_seek_secs % 60);



while (l_seek_time < p_sys->l_first_ty_pts) {
msg_Dbg(p_demux, "skipping to prior segment.");

if (i_cur_part == 0) {
p_sys->eof = (vlc_stream_Seek(p_demux->s, l_cur_pos) != VLC_SUCCESS);
msg_Err(p_demux, "Attempt to seek past BOF");
return VLC_EGENERIC;
}
if(vlc_stream_Seek(p_demux->s, (i_cur_part - 1) * TIVO_PART_LENGTH) != VLC_SUCCESS)
return VLC_EGENERIC;
i_cur_part--;
if(parse_master(p_demux) != VLC_SUCCESS)
return VLC_EGENERIC;
}

while (l_seek_time > p_sys->l_final_ty_pts) {
msg_Dbg(p_demux, "skipping to next segment.");

if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {

p_sys->eof = (vlc_stream_Seek(p_demux->s, l_cur_pos) != VLC_SUCCESS);
msg_Err(p_demux, "seek error");
return VLC_EGENERIC;
}
if(vlc_stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH) != VLC_SUCCESS)
return VLC_EGENERIC;
i_cur_part++;
if(parse_master(p_demux) != VLC_SUCCESS)
return VLC_EGENERIC;
}



for (i=1; i<p_sys->i_seq_table_size; i++) {
if (p_sys->seq_table[i].l_timestamp > l_seek_time) {



msg_Dbg(p_demux, "stopping at seq entry %d.", i);
l_fwd_stamp = p_sys->seq_table[i].l_timestamp;
i_seq_entry = i-1;
break;
}
}





if (i == p_sys->i_seq_table_size) {
if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {

p_sys->eof = (vlc_stream_Seek(p_demux->s, l_cur_pos) != VLC_SUCCESS);
msg_Err(p_demux, "seek error");
return VLC_EGENERIC;
}
if(vlc_stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH) != VLC_SUCCESS)
return VLC_EGENERIC;
i_cur_part++;
if(parse_master(p_demux) != VLC_SUCCESS)
return VLC_EGENERIC;
i_seq_entry = 0;
}


for (i=0; i<p_sys->i_bits_per_seq_entry; i++) {
uint64_t l_chunk_nr = i_seq_entry * p_sys->i_bits_per_seq_entry + i;
uint64_t l_chunk_offset = (l_chunk_nr + 1) * CHUNK_SIZE;
msg_Dbg(p_demux, "testing part %d chunk %"PRIu64" mask 0x%02X bit %d",
i_cur_part, l_chunk_nr,
p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8], i%8);
if (p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8] & (1 << (i%8))) {

msg_Dbg(p_demux, "has SEQ. seeking to chunk at 0x%"PRIu64,
(i_cur_part * TIVO_PART_LENGTH) + l_chunk_offset);
if(vlc_stream_Seek(p_demux->s, (i_cur_part * TIVO_PART_LENGTH) +
l_chunk_offset) != VLC_SUCCESS)
return VLC_EGENERIC;


p_sys->i_stuff_cnt = 0;
get_chunk_header(p_demux);

if (p_sys->i_seq_rec < 0 || p_sys->i_seq_rec > p_sys->i_num_recs) {
msg_Err(p_demux, "no SEQ hdr in chunk; table had one.");

if(vlc_stream_Seek(p_demux->s, (l_cur_pos / CHUNK_SIZE) * CHUNK_SIZE) != VLC_SUCCESS)
p_sys->eof = true;
p_sys->i_stuff_cnt = 0;
get_chunk_header(p_demux);
return VLC_EGENERIC;
}
l_seek_secs = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts /
1000000000;
msg_Dbg(p_demux, "found SEQ hdr for timestamp %02"PRIu64":%02"PRIu64":%02"PRIu64,
l_seek_secs / 3600,
(l_seek_secs / 60) % 60, l_seek_secs % 60);
if (p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts >= l_seek_time) {



msg_Dbg(p_demux, "seek target found.");
break;
}
msg_Dbg(p_demux, "timestamp too early. still scanning.");
}
}




if (i == p_sys->i_bits_per_seq_entry)
return ty_stream_seek_time(p_demux, l_fwd_stamp);




i_skip_cnt = 0;
for (int j=0; j<p_sys->i_seq_rec; j++)
i_skip_cnt += p_sys->rec_hdrs[j].l_rec_size;
if(vlc_stream_Read(p_demux->s, NULL, i_skip_cnt) != i_skip_cnt)
return VLC_EGENERIC;
p_sys->i_cur_rec = p_sys->i_seq_rec;



return VLC_SUCCESS;
}





static int parse_master(demux_t *p_demux)
{
demux_sys_t *p_sys = p_demux->p_sys;
uint8_t mst_buf[32];
int64_t i_save_pos = vlc_stream_Tell(p_demux->s);
int64_t i_pts_secs;








free(p_sys->seq_table);


if( vlc_stream_Read(p_demux->s, mst_buf, 32) != 32 )
return VLC_EGENERIC;

uint32_t i_map_size = U32_AT(&mst_buf[20]); 
uint32_t i = U32_AT(&mst_buf[28]); 

p_sys->i_bits_per_seq_entry = i_map_size * 8;
p_sys->i_seq_table_size = i / (8 + i_map_size);

if(p_sys->i_seq_table_size == 0)
{
p_sys->seq_table = NULL;
return VLC_SUCCESS;
}

#if (UINT32_MAX > SSIZE_MAX)
if (i_map_size > SSIZE_MAX)
return VLC_EGENERIC;
#endif


p_sys->seq_table = calloc(p_sys->i_seq_table_size, sizeof(ty_seq_table_t));
if (p_sys->seq_table == NULL)
{
p_sys->i_seq_table_size = 0;
return VLC_SUCCESS;
}
for (unsigned j=0; j<p_sys->i_seq_table_size; j++) {
if(vlc_stream_Read(p_demux->s, mst_buf, 8) != 8)
return VLC_EGENERIC;
p_sys->seq_table[j].l_timestamp = U64_AT(&mst_buf[0]);
if (i_map_size > 8) {
msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
if (vlc_stream_Read(p_demux->s, NULL, i_map_size)
< (ssize_t)i_map_size)
return VLC_EGENERIC;
} else {
if (vlc_stream_Read(p_demux->s, mst_buf + 8, i_map_size)
< (ssize_t)i_map_size)
return VLC_EGENERIC;
memcpy(p_sys->seq_table[j].chunk_bitmask, &mst_buf[8], i_map_size);
}
}


p_sys->l_first_ty_pts = p_sys->seq_table[0].l_timestamp;
p_sys->l_final_ty_pts =
p_sys->seq_table[p_sys->i_seq_table_size - 1].l_timestamp;
p_sys->b_have_master = true;

i_pts_secs = p_sys->l_first_ty_pts / 1000000000;
msg_Dbg( p_demux,
"first TY pts in master is %02"PRId64":%02"PRId64":%02"PRId64,
i_pts_secs / 3600, (i_pts_secs / 60) % 60, i_pts_secs % 60 );
i_pts_secs = p_sys->l_final_ty_pts / 1000000000;
msg_Dbg( p_demux,
"final TY pts in master is %02"PRId64":%02"PRId64":%02"PRId64,
i_pts_secs / 3600, (i_pts_secs / 60) % 60, i_pts_secs % 60 );


return vlc_stream_Seek(p_demux->s, i_save_pos + CHUNK_SIZE);
}








static int probe_stream(demux_t *p_demux)
{
demux_sys_t *p_sys = p_demux->p_sys;
const uint8_t *p_buf;
int i;
bool b_probe_error = false;


if (vlc_stream_Peek( p_demux->s, &p_buf, CHUNK_PEEK_COUNT * CHUNK_SIZE ) <
CHUNK_PEEK_COUNT * CHUNK_SIZE) {
msg_Err(p_demux, "Can't peek %d chunks", CHUNK_PEEK_COUNT);

return VLC_EGENERIC;
}


for (i = 0; i < CHUNK_PEEK_COUNT; i++) {
analyze_chunk(p_demux, p_buf);
if (p_sys->tivo_series != TIVO_SERIES_UNKNOWN &&
p_sys->audio_type != TIVO_AUDIO_UNKNOWN &&
p_sys->tivo_type != TIVO_TYPE_UNKNOWN)
break;
p_buf += CHUNK_SIZE;
}


if (p_sys->tivo_series == TIVO_SERIES_UNKNOWN) {
msg_Err(p_demux, "Can't determine Tivo Series.");
b_probe_error = true;
}
if (p_sys->audio_type == TIVO_AUDIO_UNKNOWN) {
msg_Err(p_demux, "Can't determine Tivo Audio Type.");
b_probe_error = true;
}
if (p_sys->tivo_type == TIVO_TYPE_UNKNOWN) {
msg_Err(p_demux, "Can't determine Tivo Type (SA/DTivo).");
b_probe_error = true;
}
return b_probe_error?VLC_EGENERIC:VLC_SUCCESS;
}




static void analyze_chunk(demux_t *p_demux, const uint8_t *p_chunk)
{
demux_sys_t *p_sys = p_demux->p_sys;
int i_num_recs, i;
ty_rec_hdr_t *p_hdrs;
int i_num_6e0, i_num_be0, i_num_9c0, i_num_3c0;
int i_payload_size;


if( U32_AT( &p_chunk[ 0 ] ) == TIVO_PES_FILEID )
return;



i_num_recs = p_chunk[0];
if (i_num_recs < 5) {

return;
}

p_chunk += 4; 

p_hdrs = parse_chunk_headers(p_chunk, i_num_recs, &i_payload_size);







i_num_6e0 = i_num_be0 = i_num_9c0 = i_num_3c0 = 0;
for (i=0; i<i_num_recs; i++) {



switch (p_hdrs[i].subrec_type << 8 | p_hdrs[i].rec_type) {
case 0x6e0:
i_num_6e0++;
break;
case 0xbe0:
i_num_be0++;
break;
case 0x3c0:
i_num_3c0++;
break;
case 0x9c0:
i_num_9c0++;
break;
}
}
msg_Dbg(p_demux, "probe: chunk has %d 0x6e0 recs, %d 0xbe0 recs.",
i_num_6e0, i_num_be0);


if (i_num_6e0 > 0) {
msg_Dbg(p_demux, "detected Series 1 Tivo");
p_sys->tivo_series = TIVO_SERIES1;
p_sys->i_Pes_Length = SERIES1_PES_LENGTH;
} else if (i_num_be0 > 0) {
msg_Dbg(p_demux, "detected Series 2 Tivo");
p_sys->tivo_series = TIVO_SERIES2;
p_sys->i_Pes_Length = SERIES2_PES_LENGTH;
}
if (i_num_9c0 > 0) {
msg_Dbg(p_demux, "detected AC-3 Audio (DTivo)" );
p_sys->audio_type = TIVO_AUDIO_AC3;
p_sys->tivo_type = TIVO_TYPE_DTIVO;
p_sys->i_Pts_Offset = AC3_PTS_OFFSET;
p_sys->i_Pes_Length = AC3_PES_LENGTH;
} else if (i_num_3c0 > 0) {
p_sys->audio_type = TIVO_AUDIO_MPEG;
msg_Dbg(p_demux, "detected MPEG Audio" );
}



if (p_sys->tivo_type == TIVO_TYPE_UNKNOWN) {
uint32_t i_data_offset = (16 * i_num_recs);
for (i=0; i<i_num_recs; i++) {
if ((p_hdrs[i].subrec_type << 0x08 | p_hdrs[i].rec_type) == 0x3c0 &&
p_hdrs[i].l_rec_size > 15) {

int i_pes_offset = find_es_header(ty_MPEGAudioPacket,
&p_chunk[i_data_offset], 5);
if (i_pes_offset >= 0) {



if ((p_chunk[i_data_offset + 6 + i_pes_offset] & 0x80) == 0x80) {

if (p_sys->tivo_series == TIVO_SERIES1)
msg_Dbg(p_demux, "detected Stand-Alone Tivo" );
p_sys->tivo_type = TIVO_TYPE_SA;
p_sys->i_Pts_Offset = SA_PTS_OFFSET;
} else {
if (p_sys->tivo_series == TIVO_SERIES1)
msg_Dbg(p_demux, "detected DirecTV Tivo" );
p_sys->tivo_type = TIVO_TYPE_DTIVO;
p_sys->i_Pts_Offset = DTIVO_PTS_OFFSET;
}
break;
}
}
i_data_offset += p_hdrs[i].l_rec_size;
}
}
free(p_hdrs);
}



static int get_chunk_header(demux_t *p_demux)
{
int i_readSize, i_num_recs;
uint8_t *p_hdr_buf;
const uint8_t *p_peek;
demux_sys_t *p_sys = p_demux->p_sys;
int i_payload_size; 

msg_Dbg(p_demux, "parsing ty chunk #%d", p_sys->i_cur_chunk );


if (p_sys->i_stuff_cnt > 0) {
if(vlc_stream_Read(p_demux->s, NULL, p_sys->i_stuff_cnt) != p_sys->i_stuff_cnt)
return 0;
p_sys->i_stuff_cnt = 0;
}


i_readSize = vlc_stream_Peek( p_demux->s, &p_peek, 4 );
p_sys->i_cur_chunk++;

if ( (i_readSize < 4) || ( U32_AT(&p_peek[ 0 ] ) == 0 ))
{

p_sys->eof = 1;
return 0;
}


if( U32_AT( &p_peek[ 0 ] ) == TIVO_PES_FILEID )
{

if(parse_master(p_demux) != VLC_SUCCESS)
return 0;
return get_chunk_header(p_demux);
}


if (p_peek[3] & 0x80)
{

p_sys->i_num_recs = i_num_recs = (p_peek[1] << 8) + p_peek[0];
p_sys->i_seq_rec = (p_peek[3] << 8) + p_peek[2];
if (p_sys->i_seq_rec != 0xffff)
{
p_sys->i_seq_rec &= ~0x8000;
}
}
else
{

p_sys->i_num_recs = i_num_recs = p_peek[0];
p_sys->i_seq_rec = p_peek[1];
}
p_sys->i_cur_rec = 0;
p_sys->b_first_chunk = false;



free(p_sys->rec_hdrs);
p_sys->rec_hdrs = NULL;


if(vlc_stream_Read(p_demux->s, NULL, 4) != 4)
return 0;


p_hdr_buf = xmalloc(i_num_recs * 16);
if (vlc_stream_Read(p_demux->s, p_hdr_buf, i_num_recs * 16) < i_num_recs * 16) {
free( p_hdr_buf );
p_sys->eof = true;
return 0;
}

p_sys->rec_hdrs = parse_chunk_headers(p_hdr_buf, i_num_recs,
&i_payload_size);
free(p_hdr_buf);

p_sys->i_stuff_cnt = CHUNK_SIZE - 4 -
(p_sys->i_num_recs * 16) - i_payload_size;
if (p_sys->i_stuff_cnt > 0)
msg_Dbg( p_demux, "chunk has %d stuff bytes at end",
p_sys->i_stuff_cnt );
return 1;
}


static ty_rec_hdr_t *parse_chunk_headers( const uint8_t *p_buf,
int i_num_recs, int *pi_payload_size)
{
int i;
ty_rec_hdr_t *p_hdrs, *p_rec_hdr;

*pi_payload_size = 0;
p_hdrs = xmalloc(i_num_recs * sizeof(ty_rec_hdr_t));

for (i = 0; i < i_num_recs; i++)
{
const uint8_t *record_header = p_buf + (i * 16);
p_rec_hdr = &p_hdrs[i]; 
p_rec_hdr->rec_type = record_header[3];
p_rec_hdr->subrec_type = record_header[2] & 0x0f;
if ((record_header[ 0 ] & 0x80) == 0x80)
{
uint8_t b1, b2;

b1 = ( ( ( record_header[ 0 ] & 0x0f ) << 4 ) |
( ( record_header[ 1 ] & 0xf0 ) >> 4 ) );
b2 = ( ( ( record_header[ 1 ] & 0x0f ) << 4 ) |
( ( record_header[ 2 ] & 0xf0 ) >> 4 ) );

p_rec_hdr->ex[0] = b1;
p_rec_hdr->ex[1] = b2;
p_rec_hdr->l_rec_size = 0;
p_rec_hdr->l_ty_pts = 0;
p_rec_hdr->b_ext = true;
}
else
{
p_rec_hdr->l_rec_size = ( record_header[ 0 ] << 8 |
record_header[ 1 ] ) << 4 | ( record_header[ 2 ] >> 4 );
*pi_payload_size += p_rec_hdr->l_rec_size;
p_rec_hdr->b_ext = false;
p_rec_hdr->l_ty_pts = U64_AT( &record_header[ 8 ] );
}

} 
return p_hdrs;
}
