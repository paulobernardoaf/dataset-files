<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\vlc-analysis\_cppstats\vlc\modules\demux\ogg.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBVORBIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vorbis/codec.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_common.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_plugin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_access.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_demux.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_meta.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_input.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ogg/ogg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_codecs.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vlc_bits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xiph.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xiph_metadata.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ogg.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oggseek.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ogg_granule.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"opus.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Open</name> <parameter_list>( <parameter><decl><type><name>vlc_object_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Close</name><parameter_list>( <parameter><decl><type><name>vlc_object_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<macro><name>vlc_module_begin</name> <argument_list>()</argument_list></macro>

<macro><name>set_shortname</name> <argument_list>( <argument><literal type="string">"OGG"</literal></argument> )</argument_list></macro>

<macro><name>set_description</name><argument_list>( <argument>N_(<literal type="string">"OGG demuxer"</literal> )</argument> )</argument_list></macro>

<macro><name>set_category</name><argument_list>( <argument>CAT_INPUT</argument> )</argument_list></macro>

<macro><name>set_subcategory</name><argument_list>( <argument>SUBCAT_INPUT_DEMUX</argument> )</argument_list></macro>

<macro><name>set_capability</name><argument_list>( <argument><literal type="string">"demux"</literal></argument>, <argument><literal type="number">50</literal></argument> )</argument_list></macro>

<macro><name>set_callbacks</name><argument_list>( <argument>Open</argument>, <argument>Close</argument> )</argument_list></macro>

<macro><name>add_shortcut</name><argument_list>( <argument><literal type="string">"ogg"</literal></argument> )</argument_list></macro>

<macro><name>vlc_module_end</name> <argument_list>()</argument_list></macro>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>height</name></decl>;</decl_stmt>

}</block></struct></type> <name>stream_header_video_t</name>;</typedef>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>ogg_int16_t</name></type> <name>channels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int16_t</name></type> <name>padding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int16_t</name></type> <name>blockalign</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>avgbytespersec</name></decl>;</decl_stmt>

}</block></struct></type> <name>stream_header_audio_t</name>;</typedef>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>char</name></type> <name><name>streamtype</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>subtype</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ogg_int64_t</name></type> <name>time_unit</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ogg_int64_t</name></type> <name>samples_per_unit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>default_len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ogg_int32_t</name></type> <name>buffersize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int16_t</name></type> <name>bits_per_sample</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_int16_t</name></type> <name>padding</name></decl>;</decl_stmt>

<union>union

<block>{

<decl_stmt><decl><type><name>stream_header_video_t</name></type> <name>video</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>stream_header_audio_t</name></type> <name>audio</name></decl>;</decl_stmt>

}</block> <decl><name>sh</name></decl>;</union>

}</block></struct></type> <name>stream_header_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VORBIS_HEADER_IDENTIFICATION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VORBIS_HEADER_COMMENT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VORBIS_HEADER_SETUP</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VORBIS_HEADER_TO_FLAG</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1 &lt;&lt; (i - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VORBIS_HEADERS_VALID</name><parameter_list>(<parameter><type><name>p_stream</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p_stream-&gt;special.vorbis.i_headers_flags &amp; 0x07) == 0x07)</cpp:value></cpp:define> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Demux</name> <parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Control</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>va_list</name></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Ogg_ReadPage</name> <parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_page</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_DecodePacket</name> <parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>Ogg_OpusPacketDuration</name><parameter_list>( <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_QueueBlocks</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>block_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_SendQueuedBlock</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>Ogg_HasQueuedBlocks</name><parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>queue</name><operator>.</operator><name>p_blocks</name></name> <operator>!=</operator> <name>NULL</name> <operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_CreateES</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Ogg_BeginningOfStream</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>Ogg_FindLogicalStreams</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_EndOfStream</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_LogicalStreamInit</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_LogicalStreamDelete</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_LogicalStreamResetEsFormat</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ResetStream</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ExtractMeta</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>es_format_t</name> <modifier>*</modifier></type><name>p_fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p_headers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i_headers</name></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadDaalaHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadTheoraHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadVorbisHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadSpeexHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ReadOpusHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadKateHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadFlacStreamInfo</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ReadAnnodexHeader</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadDiracHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadVP8Header</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ReadSkeletonHeader</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>Ogg_ReadOggSpotsHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ReadSkeletonBones</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ReadSkeletonIndex</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_FreeSkeleton</name><parameter_list>( <parameter><decl><type><name>ogg_skeleton_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_ApplySkeleton</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_CleanSpecificData</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBVORBIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_DecodeVorbisHeader</name><parameter_list>( <parameter><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ogg_packet</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter> )</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_channels_info</name><parameter_list>(<parameter><decl><type><name>audio_format_t</name> <modifier>*</modifier></type><name>audio</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>pi_channels_map</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <init>=

<expr><block>{

<expr><literal type="number">0</literal></expr>,

<expr><name>AOUT_CHAN_CENTER</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name></expr>,

<expr><name>AOUT_CHAN_CENTER</name> <operator>|</operator> <name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name> <operator>|</operator> <name>AOUT_CHAN_REARLEFT</name>

<operator>|</operator> <name>AOUT_CHAN_REARRIGHT</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name> <operator>|</operator> <name>AOUT_CHAN_CENTER</name>

<operator>|</operator> <name>AOUT_CHAN_REARLEFT</name> <operator>|</operator> <name>AOUT_CHAN_REARRIGHT</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name> <operator>|</operator> <name>AOUT_CHAN_CENTER</name>

<operator>|</operator> <name>AOUT_CHAN_REARLEFT</name> <operator>|</operator> <name>AOUT_CHAN_REARRIGHT</name> <operator>|</operator> <name>AOUT_CHAN_LFE</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name> <operator>|</operator> <name>AOUT_CHAN_CENTER</name>

<operator>|</operator> <name>AOUT_CHAN_REARCENTER</name> <operator>|</operator> <name>AOUT_CHAN_MIDDLELEFT</name>

<operator>|</operator> <name>AOUT_CHAN_MIDDLERIGHT</name> <operator>|</operator> <name>AOUT_CHAN_LFE</name></expr>,

<expr><name>AOUT_CHAN_LEFT</name> <operator>|</operator> <name>AOUT_CHAN_RIGHT</name> <operator>|</operator> <name>AOUT_CHAN_CENTER</name> <operator>|</operator> <name>AOUT_CHAN_REARLEFT</name>

<operator>|</operator> <name>AOUT_CHAN_REARRIGHT</name> <operator>|</operator> <name>AOUT_CHAN_MIDDLELEFT</name> <operator>|</operator> <name>AOUT_CHAN_MIDDLERIGHT</name>

<operator>|</operator> <name>AOUT_CHAN_LFE</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>chans</name> <init>= <expr><name><name>audio</name><operator>-&gt;</operator><name>i_channels</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>chans</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pi_channels_map</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pi_channels_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>audio</name><operator>-&gt;</operator><name>i_physical_channels</name></name> <operator>=</operator> <name><name>pi_channels_map</name><index>[<expr><name>chans</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>Open</name><parameter_list>( <parameter><decl><type><name>vlc_object_t</name> <modifier>*</modifier></type> <name>p_this</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name> <init>= <expr><operator>(</operator><name>demux_t</name> <operator>*</operator><operator>)</operator><name>p_this</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p_peek</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><call><name>vlc_stream_Peek</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_peek</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> )</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>VLC_EGENERIC</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p_demux</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>force</name></name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>( <argument><expr><name>p_peek</name></expr></argument>, <argument><expr><literal type="string">"OggS"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> )</argument_list></call></expr> )</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>psz_mime</name> <init>= <expr><call><name>stream_ContentType</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>s</name></name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><operator>!</operator><name>psz_mime</name></expr> )</condition>

<block>{<block_content>

<return>return <expr><name>VLC_EGENERIC</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>( <expr><call><name>strcmp</name><argument_list>( <argument><expr><name>psz_mime</name></expr></argument>, <argument><expr><literal type="string">"application/ogg"</literal></expr></argument> )</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>( <argument><expr><name>psz_mime</name></expr></argument>, <argument><expr><literal type="string">"video/ogg"</literal></expr></argument> )</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>( <argument><expr><name>psz_mime</name></expr></argument>, <argument><expr><literal type="string">"audio/ogg"</literal></expr></argument> )</argument_list></call></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>psz_mime</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>VLC_EGENERIC</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>psz_mime</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name> <operator>=</operator> <name>p_sys</name> <operator>=</operator> <call><name>calloc</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>( <argument><expr><name>demux_sys_t</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><operator>!</operator><name>p_sys</name></expr> )</condition><block type="pseudo"><block_content>

<return>return <expr><name>VLC_ENOMEM</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_length</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_preparsing_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_demux</name><operator>-&gt;</operator><name>pf_demux</name></name> <operator>=</operator> <name>Demux</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_demux</name><operator>-&gt;</operator><name>pf_control</name></name> <operator>=</operator> <name>Control</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ogg_sync_init</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>oy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TAB_INIT</name><argument_list>( <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_seekpoints</name></name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_seekpoints</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>es_out_Control</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>ES_OUT_SET_ES_CAT_POLICY</name></expr></argument>, <argument><expr><name>AUDIO_ES</name></expr></argument>,

<argument><expr><name>ES_OUT_ES_POLICY_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<while>while <condition>( <expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_preparsing_done</name></name> <operator>&amp;&amp;</operator> <call><name><name>p_demux</name><operator>-&gt;</operator><name>pf_demux</name></name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>

<block>{<block_content/>}</block></while>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_preparsing_done</name></name> <operator>&amp;&amp;</operator> <name><name>p_demux</name><operator>-&gt;</operator><name>b_preparsing</name></name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Ogg_CreateES</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>true</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>VLC_SUCCESS</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>Close</name><parameter_list>( <parameter><decl><type><name>vlc_object_t</name> <modifier>*</modifier></type><name>p_this</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name> <init>= <expr><operator>(</operator><name>demux_t</name> <operator>*</operator><operator>)</operator><name>p_this</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name> <init>= <expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name></expr></init></decl> ;</decl_stmt>

<expr_stmt><expr><call><name>ogg_sync_clear</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>oy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Ogg_EndOfStream</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_old_stream</name></name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Ogg_LogicalStreamDelete</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_old_stream</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>p_sys</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>vlc_tick_t</name></type> <name>Ogg_GetLastDTS</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type> <name>p_demux</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name> <init>= <expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vlc_tick_t</name></type> <name>i_dts</name> <init>= <expr><name>VLC_TICK_INVALID</name></expr></init></decl>;</decl_stmt>

<for>for<control>( <init><decl><type><name>int</name></type> <name>i_stream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<decl_stmt><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>b_initializing</name></name></expr> )</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>&gt;</operator> <name>i_dts</name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i_dts</name> <operator>=</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>i_dts</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>vlc_tick_t</name></type> <name>Ogg_GeneratePCR</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type> <name>p_demux</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>b_drain</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name> <init>= <expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vlc_tick_t</name></type> <name>i_pcr_candidate</name> <init>= <expr><name>VLC_TICK_INVALID</name></expr></init></decl>;</decl_stmt>

<for>for<control>( <init><decl><type><name>int</name></type> <name>i_stream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<decl_stmt><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>fmt</name><operator>.</operator><name>i_cat</name></name> <operator>==</operator> <name>SPU_ES</name></expr> )</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>fmt</name><operator>.</operator><name>i_codec</name></name> <operator>==</operator> <name>VLC_CODEC_OGGSPOTS</name></expr> )</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>==</operator> <name>VLC_TICK_INVALID</name></expr> )</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><operator>!</operator><name>b_drain</name> <operator>&amp;&amp;</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>b_finished</name></name><operator>)</operator> <operator>||</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>b_initializing</name></name></expr> )</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name>i_pcr_candidate</name> <operator>==</operator> <name>VLC_TICK_INVALID</name> <operator>||</operator>

<name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>&lt;</operator> <name>i_pcr_candidate</name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name>i_pcr_candidate</name> <operator>=</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>i_pcr_candidate</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>Ogg_OutputQueues</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type><name>p_demux</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>b_drain</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name> <init>= <expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vlc_tick_t</name></type> <name>i_pcr</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>==</operator> <name>VLC_TICK_INVALID</name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name>i_pcr</name> <operator>=</operator> <call><name>Ogg_GeneratePCR</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>b_drain</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name>i_pcr</name> <operator>!=</operator> <name>VLC_TICK_INVALID</name> <operator>&amp;&amp;</operator> <name>i_pcr</name> <operator>!=</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>=</operator> <name>i_pcr</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><call><name>likely</name><argument_list>( <argument><expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_slave</name></name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>es_out_SetPCR</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>!=</operator> <name>VLC_TICK_INVALID</name></expr> )</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>b_continue</name></decl>;</decl_stmt>

<do>do

<block>{<block_content>

<expr_stmt><expr><name>b_continue</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<for>for<control>( <init><decl><type><name>int</name></type> <name>i_stream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<decl_stmt><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><call><name>Ogg_HasQueuedBlocks</name><argument_list>( <argument><expr><name>p_stream</name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Ogg_SendQueuedBlock</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>p_stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b_continue</name> <operator>|=</operator> <call><name>Ogg_HasQueuedBlocks</name><argument_list>( <argument><expr><name>p_stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i_pcr</name> <operator>=</operator> <call><name>Ogg_GeneratePCR</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>b_drain</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name>i_pcr</name> <operator>!=</operator> <name>VLC_TICK_INVALID</name> <operator>&amp;&amp;</operator> <name>i_pcr</name> <operator>!=</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>=</operator> <name>i_pcr</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><call><name>likely</name><argument_list>( <argument><expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_slave</name></name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>es_out_SetPCR</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>( <expr><name>b_continue</name></expr> )</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>Demux</name><parameter_list>( <parameter><decl><type><name>demux_t</name> <modifier>*</modifier></type> <name>p_demux</name></decl></parameter> )</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>demux_sys_t</name> <modifier>*</modifier></type><name>p_sys</name> <init>= <expr><name><name>p_demux</name><operator>-&gt;</operator><name>p_sys</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ogg_packet</name></type> <name>oggpacket</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_stream</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>b_canseek</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i_active_streams</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>( <init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>b_finished</name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i_active_streams</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>( <expr><name>i_active_streams</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr> )</condition> 

<block>{<block_content>

<expr_stmt><expr><call><name>msg_Dbg</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><literal type="string">"end of a group of %d logical streams"</literal></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Ogg_OutputQueues</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>true</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>vlc_tick_t</name></type> <name>i_lastdts</name> <init>= <expr><call><name>Ogg_GetLastDTS</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>p_es</name></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_old_stream</name></name></expr> )</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>Ogg_LogicalStreamDelete</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_old_stream</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_old_stream</name></name> <operator>=</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TAB_CLEAN</name><argument_list>( <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr></argument>, <argument><expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Ogg_EndOfStream</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_chained_boundary</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name>i_lastdts</name> <operator>!=</operator> <name>VLC_TICK_INVALID</name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_nzpcr_offset</name></name> <operator>=</operator> <name>i_lastdts</name> <operator>-</operator> <name>VLC_TICK_0</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><call><name>likely</name><argument_list>( <argument><expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_slave</name></name></expr></argument> )</argument_list></call></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>es_out_SetPCR</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>i_lastdts</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>=</operator> <name>VLC_TICK_INVALID</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><call><name>Ogg_BeginningOfStream</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>VLC_SUCCESS</name></expr> )</condition><block type="pseudo"><block_content>

<return>return <expr><name>VLC_DEMUXER_EOF</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>msg_Dbg</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><literal type="string">"beginning of a group of logical streams"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_chained_boundary</name></name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vlc_stream_Control</name><argument_list>( <argument><expr><name><name>p_demux</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>STREAM_CAN_SEEK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_canseek</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><name>b_canseek</name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Oggseek_ProbeEnd</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_chained_boundary</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_preparsing_done</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_es_created</name></name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Ogg_CreateES</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><name>false</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_page_waiting</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if<condition>( <expr><call><name>Ogg_ReadPage</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <name>VLC_SUCCESS</name></expr> )</condition><block type="pseudo"><block_content>

<return>return <expr><name>VLC_DEMUXER_EOF</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if<condition>( <expr><call><name>ogg_page_eos</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_skelstream</name></name></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>p_skelstream</name><operator>-&gt;</operator><name>i_serial_no</name></name> <operator>==</operator> <call><name>ogg_page_serialno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument>)</argument_list></call></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>msg_Dbg</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><literal type="string">"End of Skeleton"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>b_preparsing_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<for>for<control>( <init><expr><name>i_stream</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<decl_stmt><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Ogg_ApplySkeleton</name><argument_list>( <argument><expr><name>p_stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for<control>( <init><expr><name>i_stream</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name><operator>-&gt;</operator><name>i_serial_no</name> <operator>==</operator> <call><name>ogg_page_serialno</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name><operator>-&gt;</operator><name>b_finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for<control>( <init><expr><name>i_stream</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i_stream</name> <operator>&lt;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name></expr>;</condition> <incr><expr><name>i_stream</name><operator>++</operator></expr></incr> )</control>

<block>{<block_content>

<decl_stmt><decl><type><name>logical_stream_t</name> <modifier>*</modifier></type><name>p_stream</name> <init>= <expr><name><name>p_sys</name><operator>-&gt;</operator><name>pp_stream</name><index>[<expr><name>i_stream</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p_sys</name><operator>-&gt;</operator><name>b_page_waiting</name></name></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if<condition>( <expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_streams</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<call><name>ogg_page_serialno</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>os</name><operator>.</operator><name>serialno</name></name></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>msg_Err</name><argument_list>( <argument><expr><name>p_demux</name></expr></argument>, <argument><expr><literal type="string">"Broken Ogg stream (serialno) mismatch"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Ogg_ResetStream</name><argument_list>( <argument><expr><name>p_stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>!=</operator> <name>VLC_TICK_INVALID</name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p_sys</name><operator>-&gt;</operator><name>i_nzpcr_offset</name></name> <operator>=</operator> <name><name>p_stream</name><operator>-&gt;</operator><name>i_pcr</name></name> <operator>-</operator> <name>VLC_TICK_0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ogg_stream_reset_serialno</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_stream</name><operator>-&gt;</operator><name>os</name></name></expr></argument>, <argument><expr><call><name>ogg_page_serialno</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>( <expr><call><name>ogg_stream_pagein</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_stream</name><operator>-&gt;</operator><name>os</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>

<block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><operator>!</operator> <call><name>ogg_page_eos</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_sys</name><operator>-&gt;</operator><name>current_page</name></name></expr></argument> )</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p_sys</name><operator>-&gt;</operator><name>p_skelstream</name></name> <operator>!=</operator> <name>p_stream</name></expr> )</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p_stream</name><operator>-&gt;</operator><name>b_finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<macro><name>DemuxDebug</name><argument_list>(

<argument>if ( p_stream-&gt;fmt.i_cat == VIDEO_ES )

msg_Dbg(p_demux, <literal type="string">"DEMUX READ pageno %ld g%"</literal>PRId64<literal type="string">" (%d packets) cont %d %ld bytes"</literal>,

ogg_page_pageno( &amp;p_sys-&gt;current_page ),

ogg_page_granulepos( &amp;p_sys-&gt;current_page ),

ogg_page_packets( &amp;p_sys-&gt;current_page ),

ogg_page_continued(&amp;p_sys-&gt;current_page),

p_sys-&gt;current_page.body_len )</argument>

)</argument_list></macro><empty_stmt>;</empty_stmt>

<while>while<condition>( <expr><call><name>ogg_stream_packetout</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>p_stream</name><operator>-&gt;</operator><name>os</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oggpacket</name></expr></argument> )</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>i_secondary_header_packets</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>

<block>{<block_content>

<if_stmt><if>if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>fmt</name><operator>.</operator><name>i_codec</name></name> <operator>==</operator> <name>VLC_CODEC_THEORA</name> <operator>&amp;&amp;</operator>

<name><name>oggpacket</name><operator>.</operator><name>bytes</name></name> <operator>&gt;=</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator>

<operator>!</operator> <call><name>memcmp</name><argument_list>( <argument><expr><name><name>oggpacket</name><operator>.</operator><name>packet</name></name></expr></argument>, <argument><expr><literal type="string">"\x80theora"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument> )</argument_list></call></expr> )</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>Ogg_ReadTheoraHeader</name><argument_list>( <argument><expr><name>p_stream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oggpacket</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p_stream</name><operator>-&gt;</operator><name>i_secondary_header_packets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if<condition>( <expr><name><name>p_stream</name><operator>-&gt;</operator><name>fmt</name><operator>.</operator><name>i_codec</name></name> <operator>==</operator> <name>VLC_CODEC_DAALA</name> <operator>&amp;&amp;</operator>

<name><name>oggpacket</name><operator>.</operator><name>bytes</name></name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>

<operator>!</operator> <macro><name>memcmp</name><argument_list>( <argument>oggpacket.packet</argument>, <argument><literal type="string">"\x80""</literal>daala<literal type="string">", 6 ) )

{

Ogg_ReadDaalaHeader( p_stream, &amp;oggpacket );

p_stream-&gt;i_secondary_header_packets = 0;

}

else if( p_stream-&gt;fmt.i_codec == VLC_CODEC_VORBIS &amp;&amp;

oggpacket.bytes &gt;= 7 &amp;&amp;

! memcmp( oggpacket.packet, "</literal>\x01vorbis<literal type="string">", 7 ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_VORBIS );

Ogg_ReadVorbisHeader( p_stream, &amp;oggpacket );

p_stream-&gt;i_secondary_header_packets = 0;

}

/* update start of data pointer */

p_stream-&gt;i_data_start = vlc_stream_Tell( p_demux-&gt;s );

}

if( p_stream-&gt;b_reinit )

{

p_stream-&gt;b_reinit = false;

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_OPUS )

{

p_stream-&gt;i_skip_frames = p_stream-&gt;i_pre_skip;

}

}

Ogg_DecodePacket( p_demux, p_stream, &amp;oggpacket );

}

if( !p_sys-&gt;b_page_waiting )

break;

}

/* if a page was waiting, it's now processed */

p_sys-&gt;b_page_waiting = false;

if ( p_sys-&gt;p_skelstream &amp;&amp; !p_sys-&gt;p_skelstream-&gt;b_finished )

p_sys-&gt;b_preparsing_done = false;

else

p_sys-&gt;b_preparsing_done = true;

if( p_sys-&gt;b_preparsing_done )

{

for( i_stream = 0; i_stream &lt; p_sys-&gt;i_streams; i_stream++ )

{

logical_stream_t *p_stream = p_sys-&gt;pp_stream[i_stream];

if ( p_stream-&gt;b_initializing )

{

/* We have 1 or more streams needing more than 1 page for preparsing */

p_sys-&gt;b_preparsing_done = false;

break;

}

}

}

if( p_sys-&gt;b_preparsing_done )

Ogg_OutputQueues( p_demux, false );

return VLC_DEMUXER_SUCCESS;

}

static void Ogg_ResetStream( logical_stream_t *p_stream )

{

#if defined(HAVE_LIBVORBIS)
if ( p_stream-&gt;fmt.i_codec == VLC_CODEC_VORBIS )

{

p_stream-&gt;special.vorbis.i_prev_blocksize = 0;

}

#endif

/* we'll trash all the data until we find the next pcr */

p_stream-&gt;b_reinit = true;

p_stream-&gt;i_pcr = VLC_TICK_INVALID;

p_stream-&gt;i_next_block_flags = 0;

p_stream-&gt;b_interpolation_failed = false;

date_Set( &amp;p_stream-&gt;dts, VLC_TICK_INVALID );

ogg_stream_reset( &amp;p_stream-&gt;os );

block_ChainRelease( p_stream-&gt;queue.p_blocks );

p_stream-&gt;queue.p_blocks = NULL;

p_stream-&gt;queue.pp_append = &amp;p_stream-&gt;queue.p_blocks;

}

static void Ogg_PreparePostSeek( demux_sys_t *p_sys )

{

for( int i = 0; i &lt; p_sys-&gt;i_streams; i++ )

{

Ogg_ResetStream( p_sys-&gt;pp_stream[i] );

p_sys-&gt;pp_stream[i]-&gt;i_next_block_flags = BLOCK_FLAG_DISCONTINUITY;

}

ogg_sync_reset( &amp;p_sys-&gt;oy );

p_sys-&gt;i_pcr = VLC_TICK_INVALID;

}

static logical_stream_t * Ogg_GetSelectedStream( demux_t *p_demux )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

logical_stream_t *p_stream = NULL;

for( int i=0; i&lt;p_sys-&gt;i_streams; i++ )

{

logical_stream_t *p_candidate = p_sys-&gt;pp_stream[i];

if ( !p_candidate-&gt;p_es ) continue;

bool b_selected = false;

es_out_Control( p_demux-&gt;out, ES_OUT_GET_ES_STATE,

p_candidate-&gt;p_es, &amp;b_selected );

if ( !b_selected ) continue;

if ( !p_stream &amp;&amp; p_candidate-&gt;fmt.i_cat == AUDIO_ES )

{

p_stream = p_candidate;

continue; /* Try to find video anyway */

}

if ( p_candidate-&gt;fmt.i_cat == VIDEO_ES )

{

p_stream = p_candidate;

break;

}

}

return p_stream;

}

/*****************************************************************************

* Control:

*****************************************************************************/

static int Control( demux_t *p_demux, int i_query, va_list args )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

vlc_meta_t *p_meta;

vlc_tick_t i64;

double f;

bool *pb_bool, b, acc;

logical_stream_t *p_stream;

switch( i_query )

{

case DEMUX_CAN_SEEK:

return vlc_stream_vaControl( p_demux-&gt;s, i_query, args );

case DEMUX_GET_META:

p_meta = va_arg( args, vlc_meta_t * );

if( p_sys-&gt;p_meta )

vlc_meta_Merge( p_meta, p_sys-&gt;p_meta );

return VLC_SUCCESS;

case DEMUX_HAS_UNSUPPORTED_META:

pb_bool = va_arg( args, bool* );

*pb_bool = true;

return VLC_SUCCESS;

case DEMUX_SET_NEXT_DEMUX_TIME:

p_sys-&gt;b_slave = true;

return VLC_EGENERIC;

case DEMUX_GET_TIME:

if( p_sys-&gt;i_pcr != VLC_TICK_INVALID || p_sys-&gt;b_slave )

{

*va_arg( args, vlc_tick_t * ) = p_sys-&gt;i_pcr;

return VLC_SUCCESS;

}

return VLC_EGENERIC;

case DEMUX_SET_TIME:

{

i64 = va_arg( args, vlc_tick_t );

acc = va_arg( args, int );

p_stream = Ogg_GetSelectedStream( p_demux );

if ( !p_stream )

{

msg_Err( p_demux, "</literal>No selected seekable stream found<literal type="string">" );

return VLC_EGENERIC;

}

vlc_stream_Control( p_demux-&gt;s, STREAM_CAN_FASTSEEK, &amp;b );

if ( Oggseek_BlindSeektoAbsoluteTime( p_demux, p_stream, VLC_TICK_0 + i64, b ) )

{

Ogg_PreparePostSeek( p_sys );

if( acc )

es_out_Control( p_demux-&gt;out, ES_OUT_SET_NEXT_DISPLAY_TIME,

VLC_TICK_0 + i64 );

return VLC_SUCCESS;

}

else

return VLC_EGENERIC;

}

case DEMUX_GET_ATTACHMENTS:

{

input_attachment_t ***ppp_attach =

va_arg( args, input_attachment_t *** );

int *pi_int = va_arg( args, int * );

if( p_sys-&gt;i_attachments &lt;= 0 )

return VLC_EGENERIC;

*ppp_attach = vlc_alloc( p_sys-&gt;i_attachments, sizeof(input_attachment_t*) );

if (!**ppp_attach)

return VLC_ENOMEM;

*pi_int = p_sys-&gt;i_attachments;

for( int i = 0; i &lt; p_sys-&gt;i_attachments; i++ )

(*ppp_attach)[i] = vlc_input_attachment_Duplicate( p_sys-&gt;attachments[i] );

return VLC_SUCCESS;

}

case DEMUX_GET_POSITION: {

double pos = 0.;

uint64_t size;

if( p_sys-&gt;i_length &gt; 0 &amp;&amp; p_sys-&gt;i_pcr != VLC_TICK_INVALID )

{

vlc_tick_t duration = vlc_tick_from_sec( p_sys-&gt;i_length );

pos = (double) p_sys-&gt;i_pcr / (double) duration;

}

else if( vlc_stream_GetSize( p_demux-&gt;s, &amp;size ) == 0 &amp;&amp; size &gt; 0 )

{

uint64_t offset = vlc_stream_Tell( p_demux-&gt;s );

pos = (double) offset / (double) size;

}

*va_arg( args, double * ) = pos;

return VLC_SUCCESS;

}

case DEMUX_SET_POSITION:

/* forbid seeking if we haven't initialized all logical bitstreams yet;

if we allowed, some headers would not get backed up and decoder init

would fail, making that logical stream unusable */

for ( int i=0; i&lt; p_sys-&gt;i_streams; i++ )

{

if ( p_sys-&gt;pp_stream[i]-&gt;b_initializing )

return VLC_EGENERIC;

}

p_stream = Ogg_GetSelectedStream( p_demux );

if ( !p_stream )

{

msg_Err( p_demux, "</literal>No selected seekable stream found<literal type="string">" );

return VLC_EGENERIC;

}

vlc_stream_Control( p_demux-&gt;s, STREAM_CAN_FASTSEEK, &amp;b );

f = va_arg( args, double );

acc = va_arg( args, int );

if ( p_sys-&gt;i_length &lt;= 0 || !b /* || ! STREAM_CAN_FASTSEEK */ )

{

Ogg_PreparePostSeek( p_sys );

return Oggseek_BlindSeektoPosition( p_demux, p_stream, f, b );

}

assert( p_sys-&gt;i_length &gt; 0 );

i64 = vlc_tick_from_sec( f * p_sys-&gt;i_length );

Ogg_PreparePostSeek( p_sys );

if ( Oggseek_SeektoAbsolutetime( p_demux, p_stream, VLC_TICK_0 + i64 ) &gt;= 0 )

{

if( acc )

es_out_Control( p_demux-&gt;out, ES_OUT_SET_NEXT_DISPLAY_TIME,

VLC_TICK_0 + i64 );

return VLC_SUCCESS;

}

return VLC_EGENERIC;

case DEMUX_GET_LENGTH:

if ( p_sys-&gt;i_length &lt; 0 )

return demux_vaControlHelper( p_demux-&gt;s, 0, -1, p_sys-&gt;i_bitrate,

1, i_query, args );

*va_arg( args, vlc_tick_t * ) = vlc_tick_from_sec(p_sys-&gt;i_length);

return VLC_SUCCESS;

case DEMUX_GET_TITLE_INFO:

{

input_title_t ***ppp_title = va_arg( args, input_title_t *** );

int *pi_int = va_arg( args, int* );

int *pi_title_offset = va_arg( args, int* );

int *pi_seekpoint_offset = va_arg( args, int* );

if( p_sys-&gt;i_seekpoints &gt; 0 )

{

*pi_int = 1;

*ppp_title = malloc( sizeof( input_title_t* ) );

input_title_t *p_title = (*ppp_title)[0] = vlc_input_title_New();

for( int i = 0; i &lt; p_sys-&gt;i_seekpoints; i++ )

{

seekpoint_t *p_seekpoint_copy = vlc_seekpoint_Duplicate( p_sys-&gt;pp_seekpoints[i] );

if ( likely( p_seekpoint_copy ) )

TAB_APPEND( p_title-&gt;i_seekpoint, p_title-&gt;seekpoint, p_seekpoint_copy );

}

*pi_title_offset = 0;

*pi_seekpoint_offset = 0;

return VLC_SUCCESS;

}

return VLC_EGENERIC;

}

case DEMUX_SET_TITLE:

{

const int i_title = va_arg( args, int );

if( i_title &gt; 1 )

return VLC_EGENERIC;

return VLC_SUCCESS;

}

case DEMUX_SET_SEEKPOINT:

{

const int i_seekpoint = va_arg( args, int );

if( i_seekpoint &gt; p_sys-&gt;i_seekpoints )

return VLC_EGENERIC;

for ( int i=0; i&lt; p_sys-&gt;i_streams; i++ )

{

if ( p_sys-&gt;pp_stream[i]-&gt;b_initializing )

return VLC_EGENERIC;

}

i64 = p_sys-&gt;pp_seekpoints[i_seekpoint]-&gt;i_time_offset;

p_stream = Ogg_GetSelectedStream( p_demux );

if ( !p_stream )

{

msg_Err( p_demux, "</literal>No selected seekable stream found<literal type="string">" );

return VLC_EGENERIC;

}

vlc_stream_Control( p_demux-&gt;s, STREAM_CAN_FASTSEEK, &amp;b );

if ( Oggseek_BlindSeektoAbsoluteTime( p_demux, p_stream, VLC_TICK_0 + i64, b ) )

{

Ogg_PreparePostSeek( p_sys );

es_out_Control( p_demux-&gt;out, ES_OUT_SET_NEXT_DISPLAY_TIME,

VLC_TICK_0 + i64 );

p_sys-&gt;updates |= INPUT_UPDATE_SEEKPOINT;

p_sys-&gt;cur_seekpoint = i_seekpoint;

return VLC_SUCCESS;

}

else

return VLC_EGENERIC;

}

case DEMUX_TEST_AND_CLEAR_FLAGS:

{

unsigned *restrict flags = va_arg( args, unsigned * );

*flags &amp;= p_sys-&gt;updates;

p_sys-&gt;updates &amp;= ~*flags;

return VLC_SUCCESS;

}

case DEMUX_GET_TITLE:

*va_arg( args, int * ) = 0;

return VLC_SUCCESS;

case DEMUX_GET_SEEKPOINT:

*va_arg( args, int * ) = p_sys-&gt;cur_seekpoint;

return VLC_SUCCESS;

default:

return demux_vaControlHelper( p_demux-&gt;s, 0, -1, p_sys-&gt;i_bitrate,

1, i_query, args );

}

}

/****************************************************************************

* Ogg_ReadPage: Read a full Ogg page from the physical bitstream.

****************************************************************************

* Returns VLC_SUCCESS if a page has been read. An error might happen if we

* are at the end of stream.

****************************************************************************/

static int Ogg_ReadPage( demux_t *p_demux, ogg_page *p_oggpage )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys ;

int i_read = 0;

char *p_buffer;

while( ogg_sync_pageout( &amp;p_ogg-&gt;oy, p_oggpage ) != 1 )

{

p_buffer = ogg_sync_buffer( &amp;p_ogg-&gt;oy, OGGSEEK_BYTES_TO_READ );

i_read = vlc_stream_Read( p_demux-&gt;s, p_buffer, OGGSEEK_BYTES_TO_READ );

if( i_read &lt;= 0 )

return VLC_EGENERIC;

ogg_sync_wrote( &amp;p_ogg-&gt;oy, i_read );

}

return VLC_SUCCESS;

}

static void Ogg_SetNextFrame( demux_t *p_demux, logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

VLC_UNUSED(p_demux);

ogg_int64_t i_granule = p_oggpacket-&gt;granulepos;

if( Ogg_GranuleIsValid( p_stream, i_granule ) )

{

vlc_tick_t i_endtime = Ogg_GranuleToTime( p_stream, i_granule, false, false );

assert( !p_stream-&gt;b_contiguous || i_endtime != VLC_TICK_INVALID );

if( i_endtime != VLC_TICK_INVALID )

{

date_Set( &amp;p_stream-&gt;dts, i_endtime );

return;

}

}

/* Do Interpolation if can't compute directly from granule */

if( date_Get( &amp;p_stream-&gt;dts ) != VLC_TICK_INVALID )

{

if( p_stream-&gt;fmt.i_cat == VIDEO_ES )

{

date_Increment( &amp;p_stream-&gt;dts, 1 );

}

else if( p_stream-&gt;fmt.i_cat == AUDIO_ES )

{

int64_t i_samples = 0;

switch( p_stream-&gt;fmt.i_codec )

{

case VLC_CODEC_OPUS:

i_samples = Ogg_OpusPacketDuration( p_oggpacket );

break;

case VLC_CODEC_SPEEX:

i_samples = p_stream-&gt;special.speex.i_framesize *

p_stream-&gt;special.speex.i_framesperpacket;

break;

#if defined(HAVE_LIBVORBIS)
case VLC_CODEC_VORBIS:

if( p_stream-&gt;special.vorbis.p_info &amp;&amp;

VORBIS_HEADERS_VALID(p_stream) )

{

long i_blocksize = vorbis_packet_blocksize(

p_stream-&gt;special.vorbis.p_info, p_oggpacket );

/* duration in samples per channel */

if ( p_stream-&gt;special.vorbis.i_prev_blocksize )

i_samples = ( i_blocksize + p_stream-&gt;special.vorbis.i_prev_blocksize ) / 4;

else

i_samples = i_blocksize / 2;

p_stream-&gt;special.vorbis.i_prev_blocksize = i_blocksize;

}

break;

#endif

default:

if( p_stream-&gt;fmt.i_bitrate )

{

i_samples = 8 * p_oggpacket-&gt;bytes * p_stream-&gt;dts.i_divider_num;

i_samples /= p_stream-&gt;fmt.i_bitrate / p_stream-&gt;dts.i_divider_den;

}

break;

}

if( i_samples == 0 )

p_stream-&gt;b_interpolation_failed = true;

else

date_Increment( &amp;p_stream-&gt;dts, i_samples );

}

}

}

static vlc_tick_t Ogg_FixupOutputQueue( demux_t *p_demux, logical_stream_t *p_stream )

{

vlc_tick_t i_enddts = VLC_TICK_INVALID;

#if defined(HAVE_LIBVORBIS)
long i_prev_blocksize = 0;

#else

VLC_UNUSED(p_demux);

#endif

// PASS 1, set number of samples

unsigned i_total_samples = 0;

for( block_t *p_block = p_stream-&gt;queue.p_blocks; p_block; p_block = p_block-&gt;p_next )

{

if( p_block-&gt;i_dts != VLC_TICK_INVALID )

{

i_enddts = p_block-&gt;i_dts;

break;

}

if( p_block-&gt;i_flags &amp; BLOCK_FLAG_HEADER )

continue;

ogg_packet dumb_packet;

dumb_packet.bytes = p_block-&gt;i_buffer;

dumb_packet.packet = p_block-&gt;p_buffer;

switch( p_stream-&gt;fmt.i_codec )

{

case VLC_CODEC_SPEEX:

p_block-&gt;i_nb_samples = p_stream-&gt;special.speex.i_framesize *

p_stream-&gt;special.speex.i_framesperpacket;

break;

case VLC_CODEC_OPUS:

p_block-&gt;i_nb_samples = Ogg_OpusPacketDuration( &amp;dumb_packet );

break;

#if defined(HAVE_LIBVORBIS)
case VLC_CODEC_VORBIS:

{

if( !VORBIS_HEADERS_VALID(p_stream) )

{

msg_Err( p_demux, "</literal>missing vorbis headers</argument>, <argument>can<literal type="char">'t compute block size" );

break;

}

long i_blocksize = vorbis_packet_blocksize( p_stream-&gt;special.vorbis.p_info,

&amp;dumb_packet );

if ( i_prev_blocksize )

p_block-&gt;i_nb_samples = ( i_blocksize + i_prev_blocksize ) / 4;

else

p_block-&gt;i_nb_samples = i_blocksize / 2;

i_prev_blocksize = i_blocksize;

break;

}

#endif

default:

if( p_stream-&gt;fmt.i_cat == VIDEO_ES )

p_block-&gt;i_nb_samples = 1;

break;

}

i_total_samples += p_block-&gt;i_nb_samples;

}

// PASS 2

if( i_enddts != VLC_TICK_INVALID )

{

date_t d = p_stream-&gt;dts;

date_Set( &amp;d, i_enddts );

i_enddts = date_Decrement( &amp;d, i_total_samples );

for( block_t *p_block = p_stream-&gt;queue.p_blocks; p_block; p_block = p_block-&gt;p_next )

{

if( p_block-&gt;i_dts != VLC_TICK_INVALID )

break;

if( p_block-&gt;i_flags &amp; BLOCK_FLAG_HEADER )

continue;

p_block-&gt;i_dts = date_Get( &amp;d );

date_Increment( &amp;d, p_block-&gt;i_nb_samples );

}

} /* else can'</literal>t do anything</argument>, <argument>no timestamped blocks in stream */

return i_enddts;

}

static void Ogg_QueueBlocks( demux_t *p_demux, logical_stream_t *p_stream, block_t *p_block )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

VLC_UNUSED(p_sys);

if( p_block == NULL )

{

assert( p_block != NULL );

return;

}

block_ChainLastAppend( &amp;p_stream-&gt;queue.pp_append, p_block );

if( p_stream-&gt;i_pcr == VLC_TICK_INVALID &amp;&amp; p_block-&gt;i_dts != VLC_TICK_INVALID )

{

p_stream-&gt;i_pcr = Ogg_FixupOutputQueue( p_demux, p_stream );

}

DemuxDebug( msg_Dbg( p_demux, <literal type="string">"%4.4s block queued &gt; dts %"</literal>PRId64<literal type="string">" spcr %"</literal>PRId64<literal type="string">" pcr %"</literal>PRId64,

(char*)&amp;p_stream-&gt;fmt.i_codec, p_block-&gt;i_dts, p_stream-&gt;i_pcr, p_sys-&gt;i_pcr ); )

}

static void Ogg_SendQueuedBlock( demux_t *p_demux, logical_stream_t *p_stream )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

if( Ogg_HasQueuedBlocks( p_stream ) )

{

block_t *p_queued = p_stream-&gt;queue.p_blocks;

p_stream-&gt;queue.p_blocks = p_queued-&gt;p_next;

p_queued-&gt;p_next = NULL;

if( p_queued-&gt;i_dts == VLC_TICK_INVALID )

p_queued-&gt;i_dts = p_queued-&gt;i_pts;

if( p_queued-&gt;i_flags &amp; BLOCK_FLAG_HEADER )

{

if( p_sys-&gt;i_nzpcr_offset &gt; <literal type="number">0</literal> || 

p_stream-&gt;fmt.i_extra &gt; <literal type="number">0</literal> ) 

{

block_Release( p_queued );

goto end;

}

p_queued-&gt;i_flags &amp;= ~BLOCK_FLAG_HEADER;

}

unsigned i_toskip = <literal type="number">0</literal>;

if( p_stream-&gt;i_skip_frames &gt; <literal type="number">0</literal> )

{

if( p_sys-&gt;i_nzpcr_offset &gt; <literal type="number">0</literal> )

{

p_stream-&gt;i_skip_frames = <literal type="number">0</literal>;

}

else

{

i_toskip = __MIN( p_stream-&gt;i_skip_frames, p_queued-&gt;i_nb_samples );

p_stream-&gt;i_skip_frames -= i_toskip;

p_queued-&gt;i_nb_samples -= i_toskip;

if( p_queued-&gt;i_nb_samples == <literal type="number">0</literal> )

p_queued-&gt;i_flags |= BLOCK_FLAG_PREROLL;

}

}

p_queued-&gt;i_flags |= p_stream-&gt;i_next_block_flags;

p_stream-&gt;i_next_block_flags = <literal type="number">0</literal>;

p_stream-&gt;i_pcr = p_queued-&gt;i_dts;

DemuxDebug( msg_Dbg( p_demux, <literal type="string">"%4.4s block sent &gt; dts %"</literal>PRId64<literal type="string">" pts %"</literal>PRId64<literal type="string">" spcr %"</literal>PRId64<literal type="string">" pcr %"</literal>PRId64

<literal type="string">" samples (%d/%d)"</literal>,

(char*)&amp;p_stream-&gt;fmt.i_codec, p_queued-&gt;i_dts,

p_queued-&gt;i_pts, p_stream-&gt;i_pcr, p_sys-&gt;i_pcr,

p_queued-&gt;i_nb_samples, i_toskip ); );

assert( p_sys-&gt;i_pcr != VLC_TICK_INVALID );

if( p_stream-&gt;p_es )

es_out_Send( p_demux-&gt;out, p_stream-&gt;p_es, p_queued );

else

block_Release( p_queued );

}

end:

if( p_stream-&gt;queue.p_blocks == NULL )

p_stream-&gt;queue.pp_append = &amp;p_stream-&gt;queue.p_blocks;

}

static bool Ogg_IsHeaderPacket( const logical_stream_t *p_stream,

const ogg_packet *p_oggpacket )

{

if ( p_stream-&gt;b_oggds )

{

return p_oggpacket-&gt;bytes &gt; <literal type="number">0</literal> &amp;&amp;

(p_oggpacket-&gt;packet[<literal type="number">0</literal>] &amp; PACKET_TYPE_HEADER);

}

else return ( p_oggpacket-&gt;granulepos == <literal type="number">0</literal> &amp;&amp; p_stream-&gt;i_first_frame_index &gt; <literal type="number">0</literal> );

}

static void Ogg_DecodePacket( demux_t *p_demux,

logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

block_t *p_block;

bool b_selected;

long i_header_len = <literal type="number">0</literal>;

if( p_oggpacket-&gt;bytes &gt;= <literal type="number">7</literal> &amp;&amp;

! memcmp ( p_oggpacket-&gt;packet, <literal type="string">"Annodex"</literal>, <literal type="number">7</literal> ) )

{

return;

}

else if( p_oggpacket-&gt;bytes &gt;= <literal type="number">7</literal> &amp;&amp;

! memcmp ( p_oggpacket-&gt;packet, <literal type="string">"AnxData"</literal>, <literal type="number">7</literal> ) )

{

return;

}

else if( p_oggpacket-&gt;bytes &gt;= <literal type="number">8</literal> &amp;&amp;

! memcmp ( p_oggpacket-&gt;packet, <literal type="string">"fisbone"</literal>, <literal type="number">8</literal> ) )

{

Ogg_ReadSkeletonBones( p_demux, p_oggpacket );

return;

}

else if( p_oggpacket-&gt;bytes &gt;= <literal type="number">6</literal> &amp;&amp;

! memcmp ( p_oggpacket-&gt;packet, <literal type="string">"index"</literal>, <literal type="number">6</literal> ) )

{

Ogg_ReadSkeletonIndex( p_demux, p_oggpacket );

return;

}

else if( p_stream-&gt;fmt.i_codec == VLC_CODEC_VP8 &amp;&amp;

p_oggpacket-&gt;bytes &gt;= <literal type="number">7</literal> &amp;&amp;

!memcmp( p_oggpacket-&gt;packet, <literal type="string">"OVP80\x02\x20"</literal>, <literal type="number">7</literal> ) )

{

Ogg_ReadVP8Header( p_demux, p_stream, p_oggpacket );

return;

}

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_SUBT &amp;&amp; p_oggpacket-&gt;bytes &gt; <literal type="number">0</literal> &amp;&amp;

p_oggpacket-&gt;packet[<literal type="number">0</literal>] &amp; PACKET_TYPE_BITS ) return;

if ( !p_stream-&gt;p_es )

b_selected = true;

else

es_out_Control( p_demux-&gt;out, ES_OUT_GET_ES_STATE,

p_stream-&gt;p_es, &amp;b_selected );

if( p_stream-&gt;b_force_backup )

{

bool b_xiph;

p_stream-&gt;i_packets_backup++;

switch( p_stream-&gt;fmt.i_codec )

{

case VLC_CODEC_VORBIS:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBVORBIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
Ogg_DecodeVorbisHeader( p_stream, p_oggpacket, p_stream-&gt;i_packets_backup );

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

case VLC_CODEC_THEORA:

if( p_stream-&gt;i_packets_backup == <literal type="number">3</literal> )

p_stream-&gt;b_force_backup = false;

b_xiph = true;

break;

case VLC_CODEC_DAALA:

if( p_stream-&gt;i_packets_backup == <literal type="number">3</literal> )

p_stream-&gt;b_force_backup = false;

b_xiph = true;

break;

case VLC_CODEC_SPEEX:

if( p_stream-&gt;i_packets_backup == <literal type="number">2</literal> + p_stream-&gt;i_extra_headers_packets )

p_stream-&gt;b_force_backup = false;

b_xiph = true;

break;

case VLC_CODEC_OPUS:

if( p_stream-&gt;i_packets_backup == <literal type="number">2</literal> )

p_stream-&gt;b_force_backup = false;

b_xiph = true;

break;

case VLC_CODEC_FLAC:

if( p_stream-&gt;i_packets_backup == <literal type="number">1</literal> + p_stream-&gt;i_extra_headers_packets )

{

p_stream-&gt;b_force_backup = false;

}

if( p_stream-&gt;special.flac.b_old )

{

Ogg_ReadFlacStreamInfo( p_demux, p_stream, p_oggpacket );

}

else if( p_stream-&gt;i_packets_backup == <literal type="number">1</literal> )

{

if( p_oggpacket-&gt;bytes &gt;= <literal type="number">9</literal> ) 

{

p_oggpacket-&gt;packet += <literal type="number">9</literal>;

p_oggpacket-&gt;bytes -= <literal type="number">9</literal>;

}

}

b_xiph = false;

break;

case VLC_CODEC_KATE:

if( p_stream-&gt;i_packets_backup == p_stream-&gt;special.kate.i_num_headers )

p_stream-&gt;b_force_backup = false;

b_xiph = true;

break;

default:

p_stream-&gt;b_force_backup = false;

b_xiph = false;

break;

}

if( !b_xiph )

{

uint8_t *p_realloc = realloc( p_stream-&gt;p_headers, p_stream-&gt;i_headers + p_oggpacket-&gt;bytes );

if( p_realloc )

{

memcpy( &amp;p_realloc[p_stream-&gt;i_headers], p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes );

p_stream-&gt;i_headers += p_oggpacket-&gt;bytes;

p_stream-&gt;p_headers = p_realloc;

}

else

{

free( p_stream-&gt;p_headers );

p_stream-&gt;i_headers = <literal type="number">0</literal>;

p_stream-&gt;p_headers = NULL;

}

}

else if( xiph_AppendHeaders( &amp;p_stream-&gt;i_headers, &amp;p_stream-&gt;p_headers,

p_oggpacket-&gt;bytes, p_oggpacket-&gt;packet ) )

{

p_stream-&gt;i_headers = <literal type="number">0</literal>;

p_stream-&gt;p_headers = NULL;

}

if( p_stream-&gt;i_headers &gt; <literal type="number">0</literal> )

{

if( !p_stream-&gt;b_force_backup )

{

free( p_stream-&gt;fmt.p_extra );

p_stream-&gt;fmt.i_extra = p_stream-&gt;i_headers;

p_stream-&gt;fmt.p_extra = malloc( p_stream-&gt;i_headers );

if( p_stream-&gt;fmt.p_extra )

memcpy( p_stream-&gt;fmt.p_extra, p_stream-&gt;p_headers,

p_stream-&gt;i_headers );

else

p_stream-&gt;fmt.i_extra = <literal type="number">0</literal>;

if( p_stream-&gt;i_headers &gt; <literal type="number">0</literal> )

Ogg_ExtractMeta( p_demux, &amp; p_stream-&gt;fmt,

p_stream-&gt;p_headers, p_stream-&gt;i_headers );

p_stream-&gt;b_initializing = false;

}

}

b_selected = false; 

}

else

{

p_stream-&gt;b_initializing = false;

}

vlc_tick_t i_dts = Ogg_GranuleToTime( p_stream, p_oggpacket-&gt;granulepos, true, false );

vlc_tick_t i_expected_dts = p_stream-&gt;b_interpolation_failed ? VLC_TICK_INVALID :

date_Get( &amp;p_stream-&gt;dts ); 

if( i_dts == VLC_TICK_INVALID )

i_dts = i_expected_dts;

else

date_Set( &amp;p_stream-&gt;dts, i_dts );

bool b_header = Ogg_IsHeaderPacket( p_stream, p_oggpacket );

if( !b_header )

Ogg_SetNextFrame( p_demux, p_stream, p_oggpacket );

if( !b_selected )

{

if( !b_header &amp;&amp; !p_stream-&gt;b_initializing )

{

vlc_tick_t i_pcr = date_Get( &amp;p_stream-&gt;dts );

if( i_pcr != VLC_TICK_INVALID )

p_stream-&gt;i_pcr = p_sys-&gt;i_nzpcr_offset + i_pcr;

}

return;

}

if( !( p_block = block_Alloc( p_oggpacket-&gt;bytes ) ) )

return;

if( i_dts != VLC_TICK_INVALID )

p_block-&gt;i_dts = p_sys-&gt;i_nzpcr_offset + i_dts;

if( p_oggpacket-&gt;e_o_s )

{

vlc_tick_t i_endtime = Ogg_GranuleToTime( p_stream, p_oggpacket-&gt;granulepos, false, false );

if( i_endtime != VLC_TICK_INVALID &amp;&amp; i_expected_dts != VLC_TICK_INVALID )

{

p_block-&gt;i_length = i_endtime - i_expected_dts;

p_block-&gt;i_flags |= BLOCK_FLAG_END_OF_SEQUENCE;

}

}

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_OPUS ) 

p_block-&gt;i_nb_samples = Ogg_OpusPacketDuration( p_oggpacket );

DemuxDebug( msg_Dbg(p_demux, <literal type="string">"%4.4s block set from granule %"</literal>PRId64<literal type="string">" to pts/pcr %"</literal>PRId64<literal type="string">" skip %d"</literal>,

(char *) &amp;p_stream-&gt;fmt.i_codec, p_oggpacket-&gt;granulepos,

p_block-&gt;i_dts, p_stream-&gt;i_skip_frames); )

if ( p_stream-&gt;fmt.i_cat == VIDEO_ES )

{

if( Ogg_IsKeyFrame( p_stream, p_oggpacket ) )

p_block-&gt;i_flags |= BLOCK_FLAG_TYPE_I;

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_DIRAC )

{

if( p_oggpacket-&gt;granulepos &gt; <literal type="number">0</literal> )

p_block-&gt;i_pts = Ogg_GranuleToTime( p_stream, p_oggpacket-&gt;granulepos, true, true );

}

else if( p_stream-&gt;fmt.i_codec == VLC_CODEC_THEORA )

{

p_block-&gt;i_pts = p_block-&gt;i_dts;

}

}

else if( p_stream-&gt;fmt.i_cat == AUDIO_ES )

{

if( p_stream-&gt;b_interpolation_failed &amp;&amp; p_oggpacket-&gt;granulepos &lt; <literal type="number">0</literal> )

p_block-&gt;i_pts = VLC_TICK_INVALID;

else

p_block-&gt;i_pts = p_block-&gt;i_dts;

}

else if( p_stream-&gt;fmt.i_cat == SPU_ES )

{

p_block-&gt;i_length = <literal type="number">0</literal>;

p_block-&gt;i_pts = p_block-&gt;i_dts;

}

p_stream-&gt;b_interpolation_failed = false;

if( p_stream-&gt;b_oggds )

{

if( p_oggpacket-&gt;bytes &lt;= <literal type="number">0</literal> )

{

msg_Dbg( p_demux, <literal type="string">"discarding 0 sized packet"</literal> );

block_Release( p_block );

return;

}

i_header_len = (*p_oggpacket-&gt;packet &amp; PACKET_LEN_BITS01) &gt;&gt; <literal type="number">6</literal>;

i_header_len |= (*p_oggpacket-&gt;packet &amp; PACKET_LEN_BITS2) &lt;&lt; <literal type="number">1</literal>;

if( i_header_len &gt;= p_oggpacket-&gt;bytes )

{

msg_Dbg( p_demux, <literal type="string">"discarding invalid packet"</literal> );

block_Release( p_block );

return;

}

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_SUBT)

{

int i</argument>, <argument>lenbytes = <literal type="number">0</literal>;

if( i_header_len &gt; <literal type="number">0</literal> &amp;&amp; p_oggpacket-&gt;bytes &gt;= i_header_len + <literal type="number">1</literal> )

{

for( i = <literal type="number">0</literal>, lenbytes = <literal type="number">0</literal>; i &lt; i_header_len; i++ )

{

lenbytes = lenbytes &lt;&lt; <literal type="number">8</literal>;

lenbytes += *(p_oggpacket-&gt;packet + i_header_len - i);

}

}

if( p_oggpacket-&gt;bytes - <literal type="number">1</literal> - i_header_len &gt; <literal type="number">2</literal> ||

( p_oggpacket-&gt;packet[i_header_len + <literal type="number">1</literal>] != <literal type="char">' '</literal> &amp;&amp;

p_oggpacket-&gt;packet[i_header_len + <literal type="number">1</literal>] != <literal type="number">0</literal> &amp;&amp;

p_oggpacket-&gt;packet[i_header_len + <literal type="number">1</literal>] != <literal type="char">'\n'</literal> &amp;&amp;

p_oggpacket-&gt;packet[i_header_len + <literal type="number">1</literal>] != <literal type="char">'\r'</literal> ) )

{

p_block-&gt;i_length = (vlc_tick_t)lenbytes * <literal type="number">1000</literal>;

}

}

i_header_len++;

if( p_block-&gt;i_buffer &gt;= (unsigned int)i_header_len )

p_block-&gt;i_buffer -= i_header_len;

else

p_block-&gt;i_buffer = <literal type="number">0</literal>;

}

if( b_header )

p_block-&gt;i_flags |= BLOCK_FLAG_HEADER;

memcpy( p_block-&gt;p_buffer, p_oggpacket-&gt;packet + i_header_len,

p_oggpacket-&gt;bytes - i_header_len );

Ogg_QueueBlocks( p_demux, p_stream, p_block );

}

static unsigned Ogg_OpusPacketDuration( ogg_packet *p_oggpacket )

{

return opus_frame_duration(p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

}

static int Ogg_FindLogicalStreams( demux_t *p_demux )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys;

ogg_packet oggpacket;

p_ogg-&gt;i_total_length = stream_Size ( p_demux-&gt;s );

msg_Dbg( p_demux, <literal type="string">"File length is %"</literal>PRId64<literal type="string">" bytes"</literal>, p_ogg-&gt;i_total_length );

while( Ogg_ReadPage( p_demux, &amp;p_ogg-&gt;current_page ) == VLC_SUCCESS )

{

if( ogg_page_bos( &amp;p_ogg-&gt;current_page ) )

{

while( ogg_page_bos( &amp;p_ogg-&gt;current_page ) )

{

logical_stream_t *p_stream = malloc( sizeof(logical_stream_t) );

if( unlikely( !p_stream ) )

return VLC_ENOMEM;

Ogg_LogicalStreamInit( p_stream );

p_stream-&gt;i_serial_no = ogg_page_serialno( &amp;p_ogg-&gt;current_page );

ogg_stream_init( &amp;p_stream-&gt;os, p_stream-&gt;i_serial_no );

TAB_APPEND( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream, p_stream );

if( ogg_stream_pagein( &amp;p_stream-&gt;os, &amp;p_ogg-&gt;current_page ) &lt; <literal type="number">0</literal> )

{

msg_Err( p_demux, <literal type="string">"error reading first page of "</literal>

<literal type="string">"Ogg bitstream data"</literal> );

return VLC_EGENERIC;

}

if ( ogg_stream_packetpeek( &amp;p_stream-&gt;os, &amp;oggpacket ) != <literal type="number">1</literal> )

{

msg_Err( p_demux, <literal type="string">"error in ogg_stream_packetpeek"</literal> );

return VLC_EGENERIC;

}

if( oggpacket.bytes &gt;= <literal type="number">7</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"\x01vorbis"</literal>, <literal type="number">7</literal> ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_VORBIS);

if ( Ogg_ReadVorbisHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux, <literal type="string">"found vorbis header"</literal> );

else

{

msg_Dbg( p_demux, <literal type="string">"found invalid vorbis header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else if( oggpacket.bytes &gt;= <literal type="number">5</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"Speex"</literal>, <literal type="number">5</literal> ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_SPEEX );

if ( Ogg_ReadSpeexHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux, <literal type="string">"found speex header, channels: %i, "</literal>

<literal type="string">"rate: %"</literal>PRIu32<literal type="string">"/%"</literal>PRIu32<literal type="string">", bitrate: %i, frames: %i group %i"</literal>,

p_stream-&gt;fmt.audio.i_channels,

p_stream-&gt;dts.i_divider_num, p_stream-&gt;dts.i_divider_den,

p_stream-&gt;fmt.i_bitrate,

p_stream-&gt;special.speex.i_framesize,

p_stream-&gt;special.speex.i_framesperpacket );

else

{

msg_Dbg( p_demux, <literal type="string">"found invalid Speex header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else if( oggpacket.bytes &gt;= <literal type="number">8</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"OpusHead"</literal>, <literal type="number">8</literal> ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_OPUS );

Ogg_ReadOpusHeader( p_stream, &amp;oggpacket );

msg_Dbg( p_demux, <literal type="string">"found opus header, channels: %i, "</literal>

<literal type="string">"pre-skip: %i"</literal>,

p_stream-&gt;fmt.audio.i_channels,

(int)p_stream-&gt;i_pre_skip);

p_stream-&gt;i_skip_frames = p_stream-&gt;i_pre_skip;

}

else if( oggpacket.bytes &gt;= <literal type="number">4</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"fLaC"</literal>, <literal type="number">4</literal> ) )

{

msg_Dbg( p_demux, <literal type="string">"found FLAC header"</literal> );

p_stream-&gt;b_force_backup = true;

p_stream-&gt;i_extra_headers_packets = <literal type="number">1</literal>;

p_stream-&gt;special.flac.b_old = true;

date_Init( &amp;p_stream-&gt;dts, <literal type="number">48000</literal>, <literal type="number">1</literal> ); 

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_FLAC );

}

else if( oggpacket.bytes &gt;= <literal type="number">13</literal> &amp;&amp; oggpacket.packet[<literal type="number">0</literal>] ==<literal type="number">0x7F</literal> &amp;&amp;

! memcmp( &amp;oggpacket.packet[<literal type="number">1</literal>], <literal type="string">"FLAC"</literal>, <literal type="number">4</literal> ) &amp;&amp;

! memcmp( &amp;oggpacket.packet[<literal type="number">9</literal>], <literal type="string">"fLaC"</literal>, <literal type="number">4</literal> ) )

{

int i_packets = ((int)oggpacket.packet[<literal type="number">7</literal>]) &lt;&lt; <literal type="number">8</literal> |

oggpacket.packet[<literal type="number">8</literal>];

msg_Dbg( p_demux, <literal type="string">"found FLAC header version %i.%i "</literal>

<literal type="string">"(%i header packets)"</literal>,

oggpacket.packet[<literal type="number">5</literal>], oggpacket.packet[<literal type="number">6</literal>],

i_packets );

p_stream-&gt;b_force_backup = true;

p_stream-&gt;i_extra_headers_packets = i_packets;

p_stream-&gt;special.flac.b_old = false;

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_FLAC );

oggpacket.packet += <literal type="number">13</literal>; oggpacket.bytes -= <literal type="number">13</literal>; 

if ( !Ogg_ReadFlacStreamInfo( p_demux, p_stream, &amp;oggpacket ) )

{

msg_Dbg( p_demux, <literal type="string">"found invalid Flac header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

p_stream-&gt;fmt.b_packetized = false;

}

else if( oggpacket.bytes &gt;= <literal type="number">7</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"\x80theora"</literal>, <literal type="number">7</literal> ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_THEORA );

if ( Ogg_ReadTheoraHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux,

<literal type="string">"found theora header, bitrate: %i, rate: %"</literal>PRIu32<literal type="string">"/%"</literal>PRIu32,

p_stream-&gt;fmt.i_bitrate,

p_stream-&gt;dts.i_divider_num, p_stream-&gt;dts.i_divider_den );

else

{

msg_Dbg( p_demux, <literal type="string">"found invalid Theora header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else if( oggpacket.bytes &gt;= <literal type="number">6</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"\x80""</literal>daala<literal type="string">", 6 ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_DAALA );

if ( Ogg_ReadDaalaHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux,

"</literal>found daala header, bitrate: %i, rate: %<literal type="string">"PRIu32"</literal>/%<literal type="string">"PRIu32,

p_stream-&gt;fmt.i_bitrate,

p_stream-&gt;dts.i_divider_num, p_stream-&gt;dts.i_divider_den );

else

{

msg_Dbg( p_demux, "</literal>found invalid Daala header<literal type="string">" );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for Dirac header */

else if( ( oggpacket.bytes &gt;= 5 &amp;&amp;

! memcmp( oggpacket.packet, "</literal>BBCD\x00<literal type="string">", 5 ) ) ||

( oggpacket.bytes &gt;= 9 &amp;&amp;

! memcmp( oggpacket.packet, "</literal>KW-DIRAC\x00<literal type="string">", 9 ) ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_DIRAC );

if( Ogg_ReadDiracHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux, "</literal>found dirac header<literal type="string">" );

else

{

msg_Warn( p_demux, "</literal>found dirac header isn<literal type="char">'t decodable" );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for VP8 header */

else if( oggpacket.bytes &gt;= 26 &amp;&amp;

! memcmp( oggpacket.packet, "OVP80", 5 ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_VP8 );

if ( Ogg_ReadVP8Header( p_demux, p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux, "found VP8 header "

"fps: %"PRIu32"/%"PRIu32", width:%i; height:%i",

p_stream-&gt;dts.i_divider_num, p_stream-&gt;dts.i_divider_den,

p_stream-&gt;fmt.video.i_width,

p_stream-&gt;fmt.video.i_height );

else

{

msg_Dbg( p_demux, "invalid VP8 header found");

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for Annodex header */

else if( oggpacket.bytes &gt;= 7 &amp;&amp;

! memcmp( oggpacket.packet, "Annodex", 7 ) )

{

Ogg_ReadAnnodexHeader( p_demux, p_stream, &amp;oggpacket );

/* kill annodex track */

FREENULL( p_stream );

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

/* Check for Annodex header */

else if( oggpacket.bytes &gt;= 7 &amp;&amp;

! memcmp( oggpacket.packet, "AnxData", 7 ) )

{

Ogg_ReadAnnodexHeader( p_demux, p_stream, &amp;oggpacket );

}

/* Check for Kate header */

else if( oggpacket.bytes &gt;= 8 &amp;&amp;

! memcmp( &amp;oggpacket.packet[1], "kate\0\0\0", 7 ) )

{

es_format_Change( &amp;p_stream-&gt;fmt, SPU_ES, VLC_CODEC_KATE );

if ( Ogg_ReadKateHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux, "found kate header" );

else

{

msg_Dbg( p_demux, "invalid kate header found");

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for OggDS */

else if( oggpacket.bytes &gt;= 142 &amp;&amp;

!memcmp( &amp;oggpacket.packet[1],

"Direct Show Samples embedded in Ogg", 35 ))

{

/* Old header type */

p_stream-&gt;b_oggds = true;

p_stream-&gt;b_contiguous = false;

/* Check for video header (old format) */

if( GetDWLE((oggpacket.packet+96)) == 0x05589f80 &amp;&amp;

oggpacket.bytes &gt;= 184 )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES,

VLC_FOURCC( oggpacket.packet[68],

oggpacket.packet[69],

oggpacket.packet[70],

oggpacket.packet[71] ) );

msg_Dbg( p_demux, "found video header of type: %.4s",

(char *)&amp;p_stream-&gt;fmt.i_codec );

unsigned num = OGGDS_RESOLUTION;

unsigned den = GetQWLE(oggpacket.packet+164);

vlc_ureduce( &amp;num, &amp;den, num, den &gt; 0 ? den : 1, OGGDS_RESOLUTION );

p_stream-&gt;fmt.video.i_frame_rate = num;

p_stream-&gt;fmt.video.i_frame_rate_base = den;

date_Init( &amp;p_stream-&gt;dts, num, den );

p_stream-&gt;fmt.video.i_bits_per_pixel =

GetWLE((oggpacket.packet+182));

if( !p_stream-&gt;fmt.video.i_bits_per_pixel )

/* hack, FIXME */

p_stream-&gt;fmt.video.i_bits_per_pixel = 24;

p_stream-&gt;fmt.video.i_width =

GetDWLE((oggpacket.packet+176));

p_stream-&gt;fmt.video.i_height =

GetDWLE((oggpacket.packet+180));

p_stream-&gt;fmt.video.i_visible_width =

p_stream-&gt;fmt.video.i_width;

p_stream-&gt;fmt.video.i_visible_height =

p_stream-&gt;fmt.video.i_height;

msg_Dbg( p_demux,

"fps: %u/%u, width:%i; height:%i, bitcount:%i",

p_stream-&gt;fmt.video.i_frame_rate,

p_stream-&gt;fmt.video.i_frame_rate_base,

p_stream-&gt;fmt.video.i_width,

p_stream-&gt;fmt.video.i_height,

p_stream-&gt;fmt.video.i_bits_per_pixel);

if ( !p_stream-&gt;fmt.video.i_frame_rate ||

!p_stream-&gt;fmt.video.i_frame_rate_base )

{

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for audio header (old format) */

else if( GetDWLE((oggpacket.packet+96)) == 0x05589F81 )

{

int i_extra_size;

unsigned int i_format_tag;

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, 0 );

i_extra_size = GetWLE((oggpacket.packet+140));

if( i_extra_size &gt; 0 &amp;&amp; i_extra_size &lt; oggpacket.bytes - 142 )

{

p_stream-&gt;fmt.i_extra = i_extra_size;

p_stream-&gt;fmt.p_extra = malloc( i_extra_size );

if( p_stream-&gt;fmt.p_extra )

memcpy( p_stream-&gt;fmt.p_extra,

oggpacket.packet + 142, i_extra_size );

else

p_stream-&gt;fmt.i_extra = 0;

}

i_format_tag = GetWLE((oggpacket.packet+124));

p_stream-&gt;fmt.audio.i_channels =

GetWLE((oggpacket.packet+126));

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

p_stream-&gt;fmt.audio.i_rate =

GetDWLE((oggpacket.packet+128));

p_stream-&gt;fmt.i_bitrate =

GetDWLE((oggpacket.packet+132)) * 8;

p_stream-&gt;fmt.audio.i_blockalign =

GetWLE((oggpacket.packet+136));

p_stream-&gt;fmt.audio.i_bitspersample =

GetWLE((oggpacket.packet+138));

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.audio.i_rate, 1 );

wf_tag_to_fourcc( i_format_tag,

&amp;p_stream-&gt;fmt.i_codec, 0 );

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_UNKNOWN )

{

p_stream-&gt;fmt.i_codec = VLC_FOURCC( '</literal>m<literal type="char">', '</literal>s<literal type="char">',

( i_format_tag &gt;&gt; 8 ) &amp; 0xff,

i_format_tag &amp; 0xff );

}

msg_Dbg( p_demux, "found audio header of type: %.4s",

(char *)&amp;p_stream-&gt;fmt.i_codec );

msg_Dbg( p_demux, "audio:0x%4.4x channels:%d %dHz "

"%dbits/sample %dkb/s",

i_format_tag,

p_stream-&gt;fmt.audio.i_channels,

p_stream-&gt;fmt.audio.i_rate,

p_stream-&gt;fmt.audio.i_bitspersample,

p_stream-&gt;fmt.i_bitrate / 1024 );

if ( p_stream-&gt;fmt.audio.i_rate == 0 )

{

msg_Dbg( p_demux, "invalid oggds audio header" );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

else

{

msg_Dbg( p_demux, "stream %d has an old header "

"but is of an unknown type", p_ogg-&gt;i_streams-1 );

FREENULL( p_stream );

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - 1 );

}

}

/* Check for OggDS */

else if( oggpacket.bytes &gt;= 44+1 &amp;&amp;

(*oggpacket.packet &amp; PACKET_TYPE_BITS ) == PACKET_TYPE_HEADER )

{

stream_header_t tmp;

stream_header_t *st = &amp;tmp;

p_stream-&gt;b_oggds = true;

p_stream-&gt;b_contiguous = false;

memcpy( st-&gt;streamtype, &amp;oggpacket.packet[1+0], 8 );

memcpy( st-&gt;subtype, &amp;oggpacket.packet[1+8], 4 );

st-&gt;size = GetDWLE( &amp;oggpacket.packet[1+12] );

st-&gt;time_unit = GetQWLE( &amp;oggpacket.packet[1+16] );

st-&gt;samples_per_unit = GetQWLE( &amp;oggpacket.packet[1+24] );

st-&gt;default_len = GetDWLE( &amp;oggpacket.packet[1+32] );

st-&gt;buffersize = GetDWLE( &amp;oggpacket.packet[1+36] );

st-&gt;bits_per_sample = GetWLE( &amp;oggpacket.packet[1+40] ); // (padding 2)

/* Check for video header (new format) */

if( !strncmp( st-&gt;streamtype, "video", 5 ) &amp;&amp;

oggpacket.bytes &gt;= 52+1 )

{

st-&gt;sh.video.width = GetDWLE( &amp;oggpacket.packet[1+44] );

st-&gt;sh.video.height = GetDWLE( &amp;oggpacket.packet[1+48] );

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, 0 );

/* We need to get rid of the header packet */

ogg_stream_packetout( &amp;p_stream-&gt;os, &amp;oggpacket );

p_stream-&gt;fmt.i_codec =

VLC_FOURCC( st-&gt;subtype[0], st-&gt;subtype[1],

st-&gt;subtype[2], st-&gt;subtype[3] );

msg_Dbg( p_demux, "found video header of type: %.4s",

(char *)&amp;p_stream-&gt;fmt.i_codec );

/* FIXME: no clue where it'</literal>s from */

if( st-&gt;time_unit &lt;= <literal type="number">0</literal> )

st-&gt;time_unit = <literal type="number">400000</literal>;

unsigned num, den;

vlc_ureduce( &amp;num, &amp;den,

st-&gt;samples_per_unit * OGGDS_RESOLUTION,

st-&gt;time_unit &gt; <literal type="number">0</literal> ? st-&gt;time_unit : OGGDS_RESOLUTION,

OGGDS_RESOLUTION );

date_Init( &amp;p_stream-&gt;dts, num, den );

p_stream-&gt;fmt.video.i_frame_rate = num;

p_stream-&gt;fmt.video.i_frame_rate_base = den;

p_stream-&gt;fmt.video.i_bits_per_pixel = st-&gt;bits_per_sample;

p_stream-&gt;fmt.video.i_width = st-&gt;sh.video.width;

p_stream-&gt;fmt.video.i_height = st-&gt;sh.video.height;

p_stream-&gt;fmt.video.i_visible_width =

p_stream-&gt;fmt.video.i_width;

p_stream-&gt;fmt.video.i_visible_height =

p_stream-&gt;fmt.video.i_height;

msg_Dbg( p_demux,

<literal type="string">"fps: %u/%u, width:%i; height:%i, bitcount:%i"</literal>,

p_stream-&gt;fmt.video.i_frame_rate,

p_stream-&gt;fmt.video.i_frame_rate_base,

p_stream-&gt;fmt.video.i_width,

p_stream-&gt;fmt.video.i_height,

p_stream-&gt;fmt.video.i_bits_per_pixel );

}

else if( !strncmp( st-&gt;streamtype, <literal type="string">"audio"</literal>, <literal type="number">5</literal> ) &amp;&amp;

oggpacket.bytes &gt;= <literal type="number">56</literal>+<literal type="number">1</literal> )

{

char p_buffer[<literal type="number">5</literal>];

int i_extra_size;

int i_format_tag;

st-&gt;sh.audio.channels = GetWLE( &amp;oggpacket.packet[<literal type="number">1</literal>+<literal type="number">44</literal>] );

st-&gt;sh.audio.blockalign = GetWLE( &amp;oggpacket.packet[<literal type="number">1</literal>+<literal type="number">48</literal>] );

st-&gt;sh.audio.avgbytespersec = GetDWLE( &amp;oggpacket.packet[<literal type="number">1</literal>+<literal type="number">52</literal>] );

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, <literal type="number">0</literal> );

ogg_stream_packetout( &amp;p_stream-&gt;os, &amp;oggpacket );

i_extra_size = st-&gt;size - <literal type="number">56</literal>;

if( i_extra_size &gt; <literal type="number">0</literal> &amp;&amp;

i_extra_size &lt; oggpacket.bytes - <literal type="number">1</literal> - <literal type="number">56</literal> )

{

p_stream-&gt;fmt.i_extra = i_extra_size;

p_stream-&gt;fmt.p_extra = malloc( p_stream-&gt;fmt.i_extra );

if( p_stream-&gt;fmt.p_extra )

memcpy( p_stream-&gt;fmt.p_extra, oggpacket.packet + <literal type="number">57</literal>,

p_stream-&gt;fmt.i_extra );

else

p_stream-&gt;fmt.i_extra = <literal type="number">0</literal>;

}

memcpy( p_buffer, st-&gt;subtype, <literal type="number">4</literal> );

p_buffer[<literal type="number">4</literal>] = <literal type="char">'\0'</literal>;

i_format_tag = strtol(p_buffer,NULL,<literal type="number">16</literal>);

p_stream-&gt;fmt.audio.i_channels = st-&gt;sh.audio.channels;

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

unsigned num,den;

vlc_ureduce( &amp;num, &amp;den,

st-&gt;samples_per_unit * OGGDS_RESOLUTION,

st-&gt;time_unit &gt; <literal type="number">0</literal> ? st-&gt;time_unit : OGGDS_RESOLUTION,

OGGDS_RESOLUTION );

date_Init( &amp;p_stream-&gt;dts, num, den );

p_stream-&gt;fmt.audio.i_rate = num / den;

p_stream-&gt;fmt.i_bitrate = st-&gt;sh.audio.avgbytespersec * <literal type="number">8</literal>;

p_stream-&gt;fmt.audio.i_blockalign = st-&gt;sh.audio.blockalign;

p_stream-&gt;fmt.audio.i_bitspersample = st-&gt;bits_per_sample;

wf_tag_to_fourcc( i_format_tag,

&amp;p_stream-&gt;fmt.i_codec, <literal type="number">0</literal> );

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_UNKNOWN )

{

p_stream-&gt;fmt.i_codec = VLC_FOURCC( <literal type="char">'m'</literal>, <literal type="char">'s'</literal>,

( i_format_tag &gt;&gt; <literal type="number">8</literal> ) &amp; <literal type="number">0xff</literal>,

i_format_tag &amp; <literal type="number">0xff</literal> );

}

msg_Dbg( p_demux, <literal type="string">"found audio header of type: %.4s"</literal>,

(char *)&amp;p_stream-&gt;fmt.i_codec );

msg_Dbg( p_demux, <literal type="string">"audio:0x%4.4x channels:%d %dHz "</literal>

<literal type="string">"%dbits/sample %dkb/s"</literal>,

i_format_tag,

p_stream-&gt;fmt.audio.i_channels,

p_stream-&gt;fmt.audio.i_rate,

p_stream-&gt;fmt.audio.i_bitspersample,

p_stream-&gt;fmt.i_bitrate / <literal type="number">1024</literal> );

if ( p_stream-&gt;fmt.audio.i_rate == <literal type="number">0</literal> )

{

msg_Dbg( p_demux, <literal type="string">"invalid oggds audio header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else if( !strncmp(st-&gt;streamtype, <literal type="string">"text"</literal>, <literal type="number">4</literal>) )

{

ogg_stream_packetout( &amp;p_stream-&gt;os, &amp;oggpacket );

msg_Dbg( p_demux, <literal type="string">"found text subtitle header"</literal> );

es_format_Change( &amp;p_stream-&gt;fmt, SPU_ES, VLC_CODEC_SUBT );

date_Init( &amp;p_stream-&gt;dts, <literal type="number">1000</literal>, <literal type="number">1</literal> ); 

}

else

{

msg_Dbg( p_demux, <literal type="string">"stream %d has a header marker "</literal>

<literal type="string">"but is of an unknown type"</literal>, p_ogg-&gt;i_streams-<literal type="number">1</literal> );

FREENULL( p_stream );

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else if( oggpacket.bytes &gt;= <literal type="number">8</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"fishead\0"</literal>, <literal type="number">8</literal> ) )

{

msg_Dbg( p_demux, <literal type="string">"stream %d is a skeleton"</literal>,

p_ogg-&gt;i_streams-<literal type="number">1</literal> );

Ogg_ReadSkeletonHeader( p_demux, p_stream, &amp;oggpacket );

}

else if( oggpacket.bytes &gt;= <literal type="number">8</literal> &amp;&amp;

! memcmp( oggpacket.packet, <literal type="string">"SPOTS\0\0"</literal>, <literal type="number">8</literal> ) )

{

if ( Ogg_ReadOggSpotsHeader( p_stream, &amp;oggpacket ) )

msg_Dbg( p_demux,

<literal type="string">"found OggSpots header, time resolution: %u/%u"</literal>,

p_stream-&gt;fmt.video.i_frame_rate,

p_stream-&gt;fmt.video.i_frame_rate_base );

else

{

msg_Err( p_demux, <literal type="string">"found invalid OggSpots header"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

}

}

else

{

Ogg_LogicalStreamDelete( p_demux, p_stream );

p_stream = NULL;

TAB_ERASE( p_ogg-&gt;i_streams, p_ogg-&gt;pp_stream,

p_ogg-&gt;i_streams - <literal type="number">1</literal> );

msg_Dbg( p_demux, <literal type="string">"stream %d is of unknown type"</literal>,

p_ogg-&gt;i_streams );

}

if ( p_stream )

p_stream-&gt;b_initializing &amp;= p_stream-&gt;b_force_backup;

if( Ogg_ReadPage( p_demux, &amp;p_ogg-&gt;current_page ) != VLC_SUCCESS )

return VLC_EGENERIC;

}

for( int i_stream = <literal type="number">0</literal>; i_stream &lt; p_ogg-&gt;i_streams; i_stream++ )

{

if( ogg_stream_pagein( &amp;p_ogg-&gt;pp_stream[i_stream]-&gt;os,

&amp;p_ogg-&gt;current_page ) == <literal type="number">0</literal> )

{

p_ogg-&gt;b_page_waiting = true;

break;

}

}

return VLC_SUCCESS;

}

}

return VLC_EGENERIC;

}

static void Ogg_CreateES( demux_t *p_demux, bool stable_id )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys;

logical_stream_t *p_old_stream = p_ogg-&gt;p_old_stream;

int i_stream;

for( i_stream = <literal type="number">0</literal> ; i_stream &lt; p_ogg-&gt;i_streams; i_stream++ )

{

logical_stream_t *p_stream = p_ogg-&gt;pp_stream[i_stream];

if ( p_stream-&gt;p_es == NULL &amp;&amp; !p_stream-&gt;b_finished )

{

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_MPGA ||

p_stream-&gt;fmt.i_codec == VLC_CODEC_A52 )

p_stream-&gt;fmt.b_packetized = false;

if( p_old_stream &amp;&amp;

p_old_stream-&gt;fmt.i_cat == p_stream-&gt;fmt.i_cat &amp;&amp;

p_old_stream-&gt;fmt.i_codec == p_stream-&gt;fmt.i_codec &amp;&amp;

p_old_stream-&gt;p_es != NULL &amp;&amp; p_stream-&gt;p_es != NULL )

{

msg_Dbg( p_demux, <literal type="string">"will reuse old stream to avoid glitch"</literal> );

p_stream-&gt;p_es = p_old_stream-&gt;p_es;

p_stream-&gt;b_finished = false;

p_stream-&gt;b_reinit = false;

p_stream-&gt;b_initializing = false;

p_stream-&gt;i_pre_skip = <literal type="number">0</literal>;

es_format_Clean( &amp;p_stream-&gt;fmt_old );

es_format_Copy( &amp;p_stream-&gt;fmt_old, &amp;p_old_stream-&gt;fmt );

bool b_resetdecoder = Ogg_LogicalStreamResetEsFormat( p_demux, p_stream );

p_old_stream-&gt;p_es = NULL;

p_old_stream = NULL;

if ( b_resetdecoder )

{

es_out_Control( p_demux-&gt;out, ES_OUT_SET_ES_FMT,

p_stream-&gt;p_es, &amp;p_stream-&gt;fmt );

}

}

else

{

if( stable_id )

{

p_stream-&gt;fmt.i_id = i_stream;

}

p_stream-&gt;p_es = es_out_Add( p_demux-&gt;out, &amp;p_stream-&gt;fmt );

}

}

}

if( p_ogg-&gt;p_old_stream )

{

if( p_ogg-&gt;p_old_stream-&gt;p_es )

msg_Dbg( p_demux, <literal type="string">"old stream not reused"</literal> );

Ogg_LogicalStreamDelete( p_demux, p_ogg-&gt;p_old_stream );

p_ogg-&gt;p_old_stream = NULL;

}

p_ogg-&gt;b_es_created = true;

}

static int Ogg_BeginningOfStream( demux_t *p_demux )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys ;

int i_stream;

if( Ogg_FindLogicalStreams( p_demux ) != VLC_SUCCESS )

{

msg_Warn( p_demux, <literal type="string">"couldn't find any ogg logical stream"</literal> );

return VLC_EGENERIC;

}

p_ogg-&gt;i_bitrate = <literal type="number">0</literal>;

for( i_stream = <literal type="number">0</literal> ; i_stream &lt; p_ogg-&gt;i_streams; i_stream++ )

{

logical_stream_t *p_stream = p_ogg-&gt;pp_stream[i_stream];

p_stream-&gt;p_es = NULL;

p_stream-&gt;idx=NULL;

if ( p_stream-&gt;fmt.i_bitrate == <literal type="number">0</literal> &amp;&amp;

( p_stream-&gt;fmt.i_cat == VIDEO_ES ||

p_stream-&gt;fmt.i_cat == AUDIO_ES ) )

p_ogg-&gt;b_partial_bitrate = true;

else

p_ogg-&gt;i_bitrate += p_stream-&gt;fmt.i_bitrate;

p_stream-&gt;i_pcr = VLC_TICK_INVALID;

p_stream-&gt;b_reinit = false;

}

p_ogg-&gt;i_total_frames = <literal type="number">0</literal>;

return VLC_SUCCESS;

}

static void Ogg_EndOfStream( demux_t *p_demux )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys ;

int i_stream;

for( i_stream = <literal type="number">0</literal> ; i_stream &lt; p_ogg-&gt;i_streams; i_stream++ )

Ogg_LogicalStreamDelete( p_demux, p_ogg-&gt;pp_stream[i_stream] );

free( p_ogg-&gt;pp_stream );

p_ogg-&gt;i_bitrate = <literal type="number">0</literal>;

p_ogg-&gt;i_streams = <literal type="number">0</literal>;

p_ogg-&gt;pp_stream = NULL;

p_ogg-&gt;skeleton.major = <literal type="number">0</literal>;

p_ogg-&gt;skeleton.minor = <literal type="number">0</literal>;

p_ogg-&gt;b_preparsing_done = false;

p_ogg-&gt;b_es_created = false;

if( p_ogg-&gt;p_meta )

vlc_meta_Delete( p_ogg-&gt;p_meta );

p_ogg-&gt;p_meta = NULL;

for(int i=<literal type="number">0</literal>; i&lt;p_ogg-&gt;i_attachments; i++)

vlc_input_attachment_Delete( p_ogg-&gt;attachments[i] );

TAB_CLEAN(p_ogg-&gt;i_attachments, p_ogg-&gt;attachments);

for ( int i=<literal type="number">0</literal>; i &lt; p_ogg-&gt;i_seekpoints; i++ )

{

if ( p_ogg-&gt;pp_seekpoints[i] )

vlc_seekpoint_Delete( p_ogg-&gt;pp_seekpoints[i] );

}

TAB_CLEAN( p_ogg-&gt;i_seekpoints, p_ogg-&gt;pp_seekpoints );

}

static void Ogg_CleanSpecificData( logical_stream_t *p_stream )

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBVORBIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
if ( p_stream-&gt;fmt.i_codec == VLC_CODEC_VORBIS )

{

if( p_stream-&gt;special.vorbis.p_info )

vorbis_info_clear( p_stream-&gt;special.vorbis.p_info );

FREENULL( p_stream-&gt;special.vorbis.p_info );

if( p_stream-&gt;special.vorbis.p_comment )

vorbis_comment_clear( p_stream-&gt;special.vorbis.p_comment );

FREENULL( p_stream-&gt;special.vorbis.p_comment );

p_stream-&gt;special.vorbis.i_headers_flags = <literal type="number">0</literal>;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

VLC_UNUSED( p_stream );

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

static void Ogg_LogicalStreamInit( logical_stream_t *p_stream )

{

memset( p_stream, <literal type="number">0</literal>, sizeof(logical_stream_t) );

es_format_Init( &amp;p_stream-&gt;fmt, UNKNOWN_ES, <literal type="number">0</literal> );

es_format_Init( &amp;p_stream-&gt;fmt_old, UNKNOWN_ES, <literal type="number">0</literal> );

p_stream-&gt;i_pcr = VLC_TICK_INVALID;

p_stream-&gt;i_first_frame_index = <literal type="number">1</literal>;

date_Set( &amp;p_stream-&gt;dts, VLC_TICK_INVALID );

p_stream-&gt;b_initializing = true;

p_stream-&gt;b_contiguous = true; 

p_stream-&gt;queue.pp_append = &amp;p_stream-&gt;queue.p_blocks;

}

static void Ogg_LogicalStreamDelete( demux_t *p_demux, logical_stream_t *p_stream )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

if( p_stream-&gt;p_es )

es_out_Del( p_demux-&gt;out, p_stream-&gt;p_es );

ogg_stream_clear( &amp;p_stream-&gt;os );

free( p_stream-&gt;p_headers );

Ogg_CleanSpecificData( p_stream );

es_format_Clean( &amp;p_stream-&gt;fmt_old );

es_format_Clean( &amp;p_stream-&gt;fmt );

if ( p_stream-&gt;idx != NULL)

{

oggseek_index_entries_free( p_stream-&gt;idx );

}

Ogg_FreeSkeleton( p_stream-&gt;p_skel );

p_stream-&gt;p_skel = NULL;

if( p_sys-&gt;p_skelstream == p_stream )

p_sys-&gt;p_skelstream = NULL;

block_ChainRelease( p_stream-&gt;queue.p_blocks );

free( p_stream );

}

static bool Ogg_IsVorbisFormatCompatible( const es_format_t *p_new, const es_format_t *p_old )

{

unsigned pi_new_size[XIPH_MAX_HEADER_COUNT];

const void *pp_new_data[XIPH_MAX_HEADER_COUNT];

unsigned i_new_count;

if( xiph_SplitHeaders(pi_new_size, pp_new_data, &amp;i_new_count, p_new-&gt;i_extra, p_new-&gt;p_extra ) )

i_new_count = <literal type="number">0</literal>;

unsigned pi_old_size[XIPH_MAX_HEADER_COUNT];

const void *pp_old_data[XIPH_MAX_HEADER_COUNT];

unsigned i_old_count;

if( xiph_SplitHeaders(pi_old_size, pp_old_data, &amp;i_old_count, p_old-&gt;i_extra, p_old-&gt;p_extra ) )

i_old_count = <literal type="number">0</literal>;

bool b_match = i_new_count == i_old_count;

for( unsigned i = <literal type="number">0</literal>; i &lt; i_new_count &amp;&amp; b_match; i++ )

{

if( i == <literal type="number">1</literal> )

continue;

if( pi_new_size[i] != pi_old_size[i] ||

memcmp( pp_new_data[i], pp_old_data[i], pi_new_size[i] ) )

b_match = false;

}

return b_match;

}

static bool Ogg_IsOpusFormatCompatible( const es_format_t *p_new,

const es_format_t *p_old )

{

unsigned pi_new_size[XIPH_MAX_HEADER_COUNT];

const void *pp_new_data[XIPH_MAX_HEADER_COUNT];

unsigned i_new_count;

if( xiph_SplitHeaders(pi_new_size, pp_new_data, &amp;i_new_count, p_new-&gt;i_extra, p_new-&gt;p_extra ) )

i_new_count = <literal type="number">0</literal>;

unsigned pi_old_size[XIPH_MAX_HEADER_COUNT];

const void *pp_old_data[XIPH_MAX_HEADER_COUNT];

unsigned i_old_count;

if( xiph_SplitHeaders(pi_old_size, pp_old_data, &amp;i_old_count, p_old-&gt;i_extra, p_old-&gt;p_extra ) )

i_old_count = <literal type="number">0</literal>;

bool b_match = false;

if( i_new_count == i_old_count &amp;&amp; i_new_count &gt; <literal type="number">0</literal> )

{

static const unsigned char default_map[<literal type="number">2</literal>] = { <literal type="number">0</literal>, <literal type="number">1</literal> };

const unsigned char *p_old_head;

unsigned char *p_new_head;

const unsigned char *p_old_map;

const unsigned char *p_new_map;

int i_old_channel_count;

int i_new_channel_count;

int i_old_stream_count;

int i_new_stream_count;

int i_old_coupled_count;

int i_new_coupled_count;

p_old_head = pp_old_data[<literal type="number">0</literal>];

i_old_channel_count = i_old_stream_count = i_old_coupled_count = <literal type="number">0</literal>;

p_old_map = default_map;

if( pi_old_size[<literal type="number">0</literal>] &gt;= <literal type="number">19</literal> &amp;&amp; p_old_head[<literal type="number">8</literal>] &lt;= <literal type="number">15</literal> )

{

i_old_channel_count = p_old_head[<literal type="number">9</literal>];

switch( p_old_head[<literal type="number">18</literal>] )

{

case <literal type="number">0</literal>:

i_old_stream_count = <literal type="number">1</literal>;

i_old_coupled_count = i_old_channel_count - <literal type="number">1</literal>;

break;

case <literal type="number">1</literal>:

if( pi_old_size[<literal type="number">0</literal>] &gt;= <literal type="number">21U</literal> + i_old_channel_count )

{

i_old_stream_count = p_old_head[<literal type="number">19</literal>];

i_old_coupled_count = p_old_head[<literal type="number">20</literal>];

p_old_map = p_old_head + <literal type="number">21</literal>;

}

break;

}

}

p_new_head = (unsigned char *)pp_new_data[<literal type="number">0</literal>];

i_new_channel_count = i_new_stream_count = i_new_coupled_count = <literal type="number">0</literal>;

p_new_map = default_map;

if( pi_new_size[<literal type="number">0</literal>] &gt;= <literal type="number">19</literal> &amp;&amp; p_new_head[<literal type="number">8</literal>] &lt;= <literal type="number">15</literal> )

{

i_new_channel_count = p_new_head[<literal type="number">9</literal>];

switch( p_new_head[<literal type="number">18</literal>] )

{

case <literal type="number">0</literal>:

i_new_stream_count = <literal type="number">1</literal>;

i_new_coupled_count = i_new_channel_count - <literal type="number">1</literal>;

break;

case <literal type="number">1</literal>:

if( pi_new_size[<literal type="number">0</literal>] &gt;= <literal type="number">21U</literal> + i_new_channel_count )

{

i_new_stream_count = p_new_head[<literal type="number">19</literal>];

i_new_coupled_count = p_new_head[<literal type="number">20</literal>];

p_new_map = p_new_head+<literal type="number">21</literal>;

}

break;

}

}

b_match = i_old_channel_count == i_new_channel_count &amp;&amp;

i_old_stream_count == i_new_stream_count &amp;&amp;

i_old_coupled_count == i_new_coupled_count &amp;&amp;

memcmp(p_old_map, p_new_map,

i_new_channel_count*sizeof(*p_new_map)) == <literal type="number">0</literal>;

}

return b_match;

}

static bool Ogg_LogicalStreamResetEsFormat( demux_t *p_demux, logical_stream_t *p_stream )

{

bool b_compatible = false;

if( !p_stream-&gt;fmt_old.i_cat || !p_stream-&gt;fmt_old.i_codec )

return true;

if( p_stream-&gt;fmt.i_codec == VLC_CODEC_VORBIS )

b_compatible = Ogg_IsVorbisFormatCompatible( &amp;p_stream-&gt;fmt, &amp;p_stream-&gt;fmt_old );

else if( p_stream-&gt;fmt.i_codec == VLC_CODEC_OPUS )

b_compatible = Ogg_IsOpusFormatCompatible( &amp;p_stream-&gt;fmt, &amp;p_stream-&gt;fmt_old );

else if( p_stream-&gt;fmt.i_codec == VLC_CODEC_FLAC )

b_compatible = !p_stream-&gt;fmt.b_packetized;

if( !b_compatible )

msg_Warn( p_demux, <literal type="string">"cannot reuse old stream, resetting the decoder"</literal> );

return !b_compatible;

}

static void Ogg_ExtractComments( demux_t *p_demux, es_format_t *p_fmt,

const void *p_headers, unsigned i_headers )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys;

int i_cover_score = <literal type="number">0</literal>;

int i_cover_idx = <literal type="number">0</literal>;

float pf_replay_gain[AUDIO_REPLAY_GAIN_MAX];

float pf_replay_peak[AUDIO_REPLAY_GAIN_MAX];

for(int i=<literal type="number">0</literal>; i&lt; AUDIO_REPLAY_GAIN_MAX; i++ )

{

pf_replay_gain[i] = <literal type="number">0</literal>;

pf_replay_peak[i] = <literal type="number">0</literal>;

}

vorbis_ParseComment( p_fmt, &amp;p_ogg-&gt;p_meta, p_headers, i_headers,

&amp;p_ogg-&gt;i_attachments, &amp;p_ogg-&gt;attachments,

&amp;i_cover_score, &amp;i_cover_idx,

&amp;p_ogg-&gt;i_seekpoints, &amp;p_ogg-&gt;pp_seekpoints,

&amp;pf_replay_gain, &amp;pf_replay_peak );

if( p_ogg-&gt;p_meta != NULL &amp;&amp; i_cover_idx &lt; p_ogg-&gt;i_attachments )

{

char psz_url[<literal type="number">128</literal>];

snprintf( psz_url, sizeof(psz_url), <literal type="string">"attachment://%s"</literal>,

p_ogg-&gt;attachments[i_cover_idx]-&gt;psz_name );

vlc_meta_Set( p_ogg-&gt;p_meta, vlc_meta_ArtworkURL, psz_url );

}

for ( int i=<literal type="number">0</literal>; i&lt;AUDIO_REPLAY_GAIN_MAX;i++ )

{

if ( pf_replay_gain[i] != <literal type="number">0</literal> )

{

p_fmt-&gt;audio_replay_gain.pb_gain[i] = true;

p_fmt-&gt;audio_replay_gain.pf_gain[i] = pf_replay_gain[i];

msg_Dbg( p_demux, <literal type="string">"setting replay gain %d to %f"</literal>, i, pf_replay_gain[i] );

}

if ( pf_replay_peak[i] != <literal type="number">0</literal> )

{

p_fmt-&gt;audio_replay_gain.pb_peak[i] = true;

p_fmt-&gt;audio_replay_gain.pf_peak[i] = pf_replay_peak[i];

msg_Dbg( p_demux, <literal type="string">"setting replay peak %d to %f"</literal>, i, pf_replay_gain[i] );

}

}

if( p_ogg-&gt;i_seekpoints &gt; <literal type="number">1</literal> )

{

p_ogg-&gt;updates |= INPUT_UPDATE_TITLE_LIST;

}

}

static inline uint32_t GetDW24BE( const uint8_t *p )

{

uint32_t i = ( p[<literal type="number">0</literal>] &lt;&lt; <literal type="number">16</literal> ) + ( p[<literal type="number">1</literal>] &lt;&lt; <literal type="number">8</literal> ) + ( p[<literal type="number">2</literal>] );

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
i = vlc_bswap32(i);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return i;

}

static void Ogg_ExtractFlacComments( demux_t *p_demux, es_format_t *p_fmt,

const uint8_t *p_headers, unsigned i_headers )

{

if(i_headers &lt;= <literal type="number">46</literal>)

return;

p_headers += <literal type="number">42</literal>; i_headers -= <literal type="number">42</literal>;

uint32_t blocksize = GetDW24BE(&amp;p_headers[<literal type="number">1</literal>]);

if(p_headers[<literal type="number">0</literal>] == <literal type="number">0x84</literal> &amp;&amp; blocksize &lt;= i_headers - <literal type="number">4</literal>)

{

Ogg_ExtractComments( p_demux, p_fmt, &amp;p_headers[<literal type="number">4</literal>], i_headers - <literal type="number">4</literal> );

}

}

static void Ogg_ExtractXiphMeta( demux_t *p_demux, es_format_t *p_fmt,

const void *p_headers, unsigned i_headers, unsigned i_skip )

{

unsigned pi_size[XIPH_MAX_HEADER_COUNT];

const void *pp_data[XIPH_MAX_HEADER_COUNT];

unsigned i_count;

if( xiph_SplitHeaders( pi_size, pp_data, &amp;i_count, i_headers, p_headers ) )

return;

if( i_count &gt;= <literal type="number">2</literal> &amp;&amp; pi_size[<literal type="number">1</literal>] &gt; i_skip )

{

Ogg_ExtractComments( p_demux, p_fmt,

(const uint8_t *)pp_data[<literal type="number">1</literal>] + i_skip,

pi_size[<literal type="number">1</literal>] - i_skip );

}

}

static void Ogg_ExtractMeta( demux_t *p_demux, es_format_t *p_fmt, const uint8_t *p_headers, int i_headers )

{

demux_sys_t *p_ogg = p_demux-&gt;p_sys;

switch( p_fmt-&gt;i_codec )

{

case VLC_CODEC_VORBIS:

case VLC_CODEC_THEORA:

case VLC_CODEC_DAALA:

Ogg_ExtractXiphMeta( p_demux, p_fmt, p_headers, i_headers, <literal type="number">1</literal>+<literal type="number">6</literal> );

break;

case VLC_CODEC_OPUS:

Ogg_ExtractXiphMeta( p_demux, p_fmt, p_headers, i_headers, <literal type="number">8</literal> );

break;

case VLC_CODEC_SPEEX:

Ogg_ExtractXiphMeta( p_demux, p_fmt, p_headers, i_headers, <literal type="number">0</literal> );

break;

case VLC_CODEC_VP8:

Ogg_ExtractComments( p_demux, p_fmt, p_headers, i_headers );

break;

case VLC_CODEC_KATE:

Ogg_ExtractXiphMeta( p_demux, p_fmt, p_headers, i_headers, <literal type="number">1</literal>+<literal type="number">7</literal>+<literal type="number">1</literal> );

break;

case VLC_CODEC_FLAC:

Ogg_ExtractFlacComments( p_demux, p_fmt, p_headers, i_headers );

break;

case VLC_CODEC_DIRAC:

default:

break;

}

if( p_ogg-&gt;p_meta )

p_ogg-&gt;updates |= INPUT_UPDATE_META;

}

static bool Ogg_ReadTheoraHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

bs_t bitstream;

unsigned int i_fps_numerator;

unsigned int i_fps_denominator;

int i_keyframe_frequency_force;

int i_major;

int i_minor;

int i_subminor;

int i_version;

p_stream-&gt;b_force_backup = true;

bs_init( &amp;bitstream, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes );

bs_skip( &amp;bitstream, <literal type="number">56</literal> );

i_major = bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

i_minor = bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

i_subminor = bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

bs_read( &amp;bitstream, <literal type="number">16</literal> ) ; 

bs_read( &amp;bitstream, <literal type="number">16</literal> ) ; 

bs_read( &amp;bitstream, <literal type="number">24</literal> ); 

bs_read( &amp;bitstream, <literal type="number">24</literal> ); 

bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

i_fps_numerator = bs_read( &amp;bitstream, <literal type="number">32</literal> );

i_fps_denominator = bs_read( &amp;bitstream, <literal type="number">32</literal> );

i_fps_denominator = __MAX( i_fps_denominator, <literal type="number">1</literal> );

bs_read( &amp;bitstream, <literal type="number">24</literal> ); 

bs_read( &amp;bitstream, <literal type="number">24</literal> ); 

p_stream-&gt;fmt.video.i_frame_rate = i_fps_numerator;

p_stream-&gt;fmt.video.i_frame_rate_base = i_fps_denominator;

bs_read( &amp;bitstream, <literal type="number">8</literal> ); 

p_stream-&gt;fmt.i_bitrate = bs_read( &amp;bitstream, <literal type="number">24</literal> );

bs_read( &amp;bitstream, <literal type="number">6</literal> ); 

i_keyframe_frequency_force = <literal type="number">1</literal> &lt;&lt; bs_read( &amp;bitstream, <literal type="number">5</literal> );

p_stream-&gt;i_granule_shift = <literal type="number">0</literal>;

i_keyframe_frequency_force--;

while( i_keyframe_frequency_force )

{

p_stream-&gt;i_granule_shift++;

i_keyframe_frequency_force &gt;&gt;= <literal type="number">1</literal>;

}

i_version = i_major * <literal type="number">1000000</literal> + i_minor * <literal type="number">1000</literal> + i_subminor;

p_stream-&gt;i_first_frame_index = (i_version &gt;= <literal type="number">3002001</literal>) ? <literal type="number">1</literal> : <literal type="number">0</literal>;

if ( !i_fps_denominator || !i_fps_numerator )

return false;

date_Init( &amp;p_stream-&gt;dts, i_fps_numerator, i_fps_denominator );

return true;

}

static bool Ogg_ReadDaalaHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

oggpack_buffer opb;

uint32_t i_timebase_numerator;

uint32_t i_timebase_denominator;

int keyframe_granule_shift;

unsigned int i_keyframe_frequency_force;

uint8_t i_major;

uint8_t i_minor;

uint8_t i_subminor;

int i_version;

p_stream-&gt;b_force_backup = true;

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes );

oggpack_adv( &amp;opb, <literal type="number">48</literal> );

i_major = oggpack_read( &amp;opb, <literal type="number">8</literal> ); 

i_minor = oggpack_read( &amp;opb, <literal type="number">8</literal> ); 

i_subminor = oggpack_read( &amp;opb, <literal type="number">8</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

i_timebase_numerator = oggpack_read( &amp;opb, <literal type="number">32</literal> );

i_timebase_denominator = oggpack_read( &amp;opb, <literal type="number">32</literal> );

i_timebase_denominator = __MAX( i_timebase_denominator, <literal type="number">1</literal> );

p_stream-&gt;fmt.video.i_frame_rate = i_timebase_numerator;

p_stream-&gt;fmt.video.i_frame_rate_base = i_timebase_denominator;

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

keyframe_granule_shift = oggpack_read( &amp;opb, <literal type="number">8</literal> );

keyframe_granule_shift = __MIN(keyframe_granule_shift, <literal type="number">31</literal>);

i_keyframe_frequency_force = <literal type="number">1u</literal> &lt;&lt; keyframe_granule_shift;

p_stream-&gt;i_granule_shift = <literal type="number">0</literal>;

i_keyframe_frequency_force--;

while( i_keyframe_frequency_force )

{

p_stream-&gt;i_granule_shift++;

i_keyframe_frequency_force &gt;&gt;= <literal type="number">1</literal>;

}

i_version = i_major * <literal type="number">1000000</literal> + i_minor * <literal type="number">1000</literal> + i_subminor;

VLC_UNUSED(i_version);

p_stream-&gt;i_first_frame_index = <literal type="number">0</literal>;

if ( !i_timebase_numerator || !i_timebase_denominator )

return false;

date_Init( &amp;p_stream-&gt;dts, i_timebase_numerator, i_timebase_denominator );

return true;

}

static bool Ogg_ReadVorbisHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

oggpack_buffer opb;

p_stream-&gt;b_force_backup = true;

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

oggpack_adv( &amp;opb, <literal type="number">88</literal> );

p_stream-&gt;fmt.audio.i_channels = oggpack_read( &amp;opb, <literal type="number">8</literal> );

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

p_stream-&gt;fmt.audio.i_rate = oggpack_read( &amp;opb, <literal type="number">32</literal> );

if( p_stream-&gt;fmt.audio.i_rate == <literal type="number">0</literal> )

return false;

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.audio.i_rate, <literal type="number">1</literal> );

oggpack_adv( &amp;opb, <literal type="number">32</literal> );

p_stream-&gt;fmt.i_bitrate = oggpack_read( &amp;opb, <literal type="number">32</literal> ); 

if( p_stream-&gt;fmt.i_bitrate &gt; INT32_MAX ) p_stream-&gt;fmt.i_bitrate = <literal type="number">0</literal>;

return true;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBVORBIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
static void Ogg_DecodeVorbisHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket, int i_number )

{

switch( i_number )

{

case VORBIS_HEADER_IDENTIFICATION:

p_stream-&gt;special.vorbis.p_info = calloc( <literal type="number">1</literal>, sizeof(vorbis_info) );

p_stream-&gt;special.vorbis.p_comment = malloc( sizeof(vorbis_comment) );

if ( !p_stream-&gt;special.vorbis.p_info || !p_stream-&gt;special.vorbis.p_comment )

{

FREENULL( p_stream-&gt;special.vorbis.p_info );

FREENULL( p_stream-&gt;special.vorbis.p_comment );

break;

}

vorbis_info_init( p_stream-&gt;special.vorbis.p_info );

vorbis_comment_init( p_stream-&gt;special.vorbis.p_comment );

case VORBIS_HEADER_COMMENT:

case VORBIS_HEADER_SETUP:

if ( !p_stream-&gt;special.vorbis.p_info ||

vorbis_synthesis_headerin(

p_stream-&gt;special.vorbis.p_info,

p_stream-&gt;special.vorbis.p_comment, p_oggpacket ) )

break;

p_stream-&gt;special.vorbis.i_headers_flags |= VORBIS_HEADER_TO_FLAG(i_number);

default:

break;

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static bool Ogg_ReadSpeexHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

oggpack_buffer opb;

p_stream-&gt;b_force_backup = true;

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

oggpack_adv( &amp;opb, <literal type="number">224</literal> );

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

p_stream-&gt;fmt.audio.i_rate = oggpack_read( &amp;opb, <literal type="number">32</literal> );

if ( !p_stream-&gt;fmt.audio.i_rate )

return false;

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.audio.i_rate, <literal type="number">1</literal> );

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

p_stream-&gt;fmt.audio.i_channels = oggpack_read( &amp;opb, <literal type="number">32</literal> );

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

p_stream-&gt;fmt.i_bitrate = oggpack_read( &amp;opb, <literal type="number">32</literal> );

p_stream-&gt;special.speex.i_framesize =

oggpack_read( &amp;opb, <literal type="number">32</literal> ); 

oggpack_adv( &amp;opb, <literal type="number">32</literal> ); 

p_stream-&gt;special.speex.i_framesperpacket =

oggpack_read( &amp;opb, <literal type="number">32</literal> ); 

p_stream-&gt;i_extra_headers_packets = oggpack_read( &amp;opb, <literal type="number">32</literal> ); 

return true;

}

static void Ogg_ReadOpusHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

oggpack_buffer opb;

p_stream-&gt;b_force_backup = true;

p_stream-&gt;fmt.audio.i_rate = <literal type="number">48000</literal>;

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.audio.i_rate, <literal type="number">1</literal> );

p_stream-&gt;fmt.i_bitrate = <literal type="number">0</literal>;

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

oggpack_adv( &amp;opb, <literal type="number">64</literal> );

oggpack_adv( &amp;opb, <literal type="number">8</literal> ); 

p_stream-&gt;fmt.audio.i_channels = oggpack_read( &amp;opb, <literal type="number">8</literal> );

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

p_stream-&gt;i_pre_skip = oggpack_read( &amp;opb, <literal type="number">16</literal> );

p_stream-&gt;i_pre_skip = __MAX( <literal type="number">80</literal>*<literal type="number">48</literal>, p_stream-&gt;i_pre_skip );

}

static bool Ogg_ReadFlacStreamInfo( demux_t *p_demux, logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

bs_t s;

bs_init( &amp;s, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes );

bs_read( &amp;s, <literal type="number">1</literal> );

if( p_oggpacket-&gt;bytes &gt; <literal type="number">0</literal> &amp;&amp; bs_read( &amp;s, <literal type="number">7</literal> ) != <literal type="number">0</literal> )

{

msg_Dbg( p_demux, <literal type="string">"Invalid FLAC STREAMINFO metadata"</literal> );

return false;

}

if( bs_read( &amp;s, <literal type="number">24</literal> ) &gt;= <literal type="number">34</literal> )

{

bs_skip( &amp;s, <literal type="number">80</literal> );

p_stream-&gt;fmt.audio.i_rate = bs_read( &amp;s, <literal type="number">20</literal> );

p_stream-&gt;fmt.audio.i_channels = bs_read( &amp;s, <literal type="number">3</literal> ) + <literal type="number">1</literal>;

fill_channels_info(&amp;p_stream-&gt;fmt.audio);

msg_Dbg( p_demux, <literal type="string">"FLAC header, channels: %"</literal>PRIu8<literal type="string">", rate: %u"</literal>,

p_stream-&gt;fmt.audio.i_channels, p_stream-&gt;fmt.audio.i_rate );

if ( p_stream-&gt;fmt.audio.i_rate == <literal type="number">0</literal> )

return false;

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.audio.i_rate, <literal type="number">1</literal> );

}

else

{

msg_Dbg( p_demux, <literal type="string">"FLAC STREAMINFO metadata too short"</literal> );

}

*((uint8_t*)p_oggpacket-&gt;packet) |= <literal type="number">0x80</literal>;

return true;

}

static bool Ogg_ReadKateHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

oggpack_buffer opb;

uint32_t gnum;

uint32_t gden;

int n;

char *psz_desc;

p_stream-&gt;b_force_backup = true;

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

oggpack_adv( &amp;opb, <literal type="number">11</literal>*<literal type="number">8</literal> ); 

p_stream-&gt;special.kate.i_num_headers = oggpack_read( &amp;opb, <literal type="number">8</literal> );

oggpack_adv( &amp;opb, <literal type="number">3</literal>*<literal type="number">8</literal> );

p_stream-&gt;i_granule_shift = oggpack_read( &amp;opb, <literal type="number">8</literal> );

oggpack_adv( &amp;opb, <literal type="number">8</literal>*<literal type="number">8</literal> ); 

gnum = oggpack_read( &amp;opb, <literal type="number">32</literal> );

gden = oggpack_read( &amp;opb, <literal type="number">32</literal> );

gden = __MAX( gden, <literal type="number">1</literal> );

if ( !gnum || !gden )

return false;

date_Init( &amp;p_stream-&gt;dts, gnum, gden );

p_stream-&gt;fmt.psz_language = malloc(<literal type="number">16</literal>);

if( p_stream-&gt;fmt.psz_language )

{

for( n = <literal type="number">0</literal>; n &lt; <literal type="number">16</literal>; n++ )

p_stream-&gt;fmt.psz_language[n] = oggpack_read(&amp;opb,<literal type="number">8</literal>);

p_stream-&gt;fmt.psz_language[<literal type="number">15</literal>] = <literal type="number">0</literal>; 

}

else

{

for( n = <literal type="number">0</literal>; n &lt; <literal type="number">16</literal>; n++ )

oggpack_read(&amp;opb,<literal type="number">8</literal>);

}

p_stream-&gt;fmt.psz_description = malloc(<literal type="number">16</literal>);

if( p_stream-&gt;fmt.psz_description )

{

for( n = <literal type="number">0</literal>; n &lt; <literal type="number">16</literal>; n++ )

p_stream-&gt;fmt.psz_description[n] = oggpack_read(&amp;opb,<literal type="number">8</literal>);

p_stream-&gt;fmt.psz_description[<literal type="number">15</literal>] = <literal type="number">0</literal>; 

psz_desc = strdup(FindKateCategoryName(p_stream-&gt;fmt.psz_description));

if( psz_desc )

{

free( p_stream-&gt;fmt.psz_description );

p_stream-&gt;fmt.psz_description = psz_desc;

}

}

else

{

for( n = <literal type="number">0</literal>; n &lt; <literal type="number">16</literal>; n++ )

oggpack_read(&amp;opb,<literal type="number">8</literal>);

}

return true;

}

static bool Ogg_ReadVP8Header( demux_t *p_demux, logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

switch( p_oggpacket-&gt;packet[<literal type="number">5</literal>] )

{

case <literal type="number">0x01</literal>:

if ( p_oggpacket-&gt;packet[<literal type="number">6</literal>] != <literal type="number">0x01</literal> || p_oggpacket-&gt;packet[<literal type="number">7</literal>] != <literal type="number">0x00</literal> )

return false;

p_stream-&gt;i_granule_shift = <literal type="number">32</literal>;

p_stream-&gt;fmt.video.i_width = GetWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">8</literal>] );

p_stream-&gt;fmt.video.i_height = GetWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">10</literal>] );

p_stream-&gt;fmt.video.i_visible_width = p_stream-&gt;fmt.video.i_width;

p_stream-&gt;fmt.video.i_visible_height = p_stream-&gt;fmt.video.i_height;

p_stream-&gt;fmt.video.i_sar_num = GetDWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">12</literal> - <literal type="number">1</literal>] ) &amp; <literal type="number">0x0FFF</literal>;

p_stream-&gt;fmt.video.i_sar_den = GetDWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">15</literal> - <literal type="number">1</literal>] ) &amp; <literal type="number">0x0FFF</literal>;

p_stream-&gt;fmt.video.i_frame_rate = GetDWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">18</literal>] );

p_stream-&gt;fmt.video.i_frame_rate_base = GetDWBE( &amp;p_oggpacket-&gt;packet[<literal type="number">22</literal>] );

if ( !p_stream-&gt;fmt.video.i_frame_rate || !p_stream-&gt;fmt.video.i_frame_rate_base )

return false;

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.video.i_frame_rate,

p_stream-&gt;fmt.video.i_frame_rate_base );

return true;

case <literal type="number">0x02</literal>:

Ogg_ExtractMeta( p_demux, &amp; p_stream-&gt;fmt,

p_oggpacket-&gt;packet + <literal type="number">7</literal>, p_oggpacket-&gt;bytes - <literal type="number">7</literal> );

return true;

default:

return false;

}

}

static void Ogg_ApplyContentType( logical_stream_t *p_stream, const char* psz_value,

bool *b_force_backup )

{

if( p_stream-&gt;fmt.i_cat != UNKNOWN_ES )

return;

if( !strncmp(psz_value, <literal type="string">"audio/x-wav"</literal>, <literal type="number">11</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, UNKNOWN_ES, <literal type="number">0</literal> );

free( p_stream-&gt;fmt.psz_description );

p_stream-&gt;fmt.psz_description = strdup(<literal type="string">"WAV Audio (Unsupported)"</literal>);

}

else if( !strncmp(psz_value, <literal type="string">"audio/x-vorbis"</literal>, <literal type="number">14</literal>) ||

!strncmp(psz_value, <literal type="string">"audio/vorbis"</literal>, <literal type="number">12</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_VORBIS );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"audio/x-speex"</literal>, <literal type="number">13</literal>) ||

!strncmp(psz_value, <literal type="string">"audio/speex"</literal>, <literal type="number">11</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_SPEEX );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"audio/flac"</literal>, <literal type="number">10</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, AUDIO_ES, VLC_CODEC_FLAC );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"video/x-theora"</literal>, <literal type="number">14</literal>) ||

!strncmp(psz_value, <literal type="string">"video/theora"</literal>, <literal type="number">12</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_THEORA );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"video/x-daala"</literal>, <literal type="number">13</literal>) ||

!strncmp(psz_value, <literal type="string">"video/daala"</literal>, <literal type="number">11</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_DAALA );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"video/x-xvid"</literal>, <literal type="number">12</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_FOURCC( <literal type="char">'x'</literal>,<literal type="char">'v'</literal>,<literal type="char">'i'</literal>,<literal type="char">'d'</literal> ) );

*b_force_backup = true;

}

else if( !strncmp(psz_value, <literal type="string">"video/mpeg"</literal>, <literal type="number">10</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_MPGV );

}

else if( !strncmp(psz_value, <literal type="string">"application/kate"</literal>, <literal type="number">16</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, UNKNOWN_ES, <literal type="number">0</literal> );

p_stream-&gt;fmt.psz_description = strdup(<literal type="string">"OGG Kate Overlay (Unsupported)"</literal>);

}

else if( !strncmp(psz_value, <literal type="string">"video/x-vp8"</literal>, <literal type="number">11</literal>) )

{

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_VP8 );

}

}

static void Ogg_ReadAnnodexHeader( demux_t *p_demux,

logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

if( p_oggpacket-&gt;bytes &gt;= <literal type="number">28</literal> &amp;&amp;

!memcmp( p_oggpacket-&gt;packet, <literal type="string">"Annodex"</literal>, <literal type="number">7</literal> ) )

{

oggpack_buffer opb;

uint16_t major_version;

uint16_t minor_version;

uint64_t timebase_numerator;

uint64_t timebase_denominator;

Ogg_ReadTheoraHeader( p_stream, p_oggpacket );

oggpack_readinit( &amp;opb, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes);

oggpack_adv( &amp;opb, <literal type="number">8</literal>*<literal type="number">8</literal> ); 

major_version = oggpack_read( &amp;opb, <literal type="number">2</literal>*<literal type="number">8</literal> ); 

minor_version = oggpack_read( &amp;opb, <literal type="number">2</literal>*<literal type="number">8</literal> ); 

timebase_numerator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">16</literal>] );

timebase_denominator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">24</literal>] );

msg_Dbg( p_demux, <literal type="string">"Annodex info: version %"</literal>PRIu16<literal type="string">".%"</literal>PRIu16<literal type="string">" "</literal>

<literal type="string">"Timebase %"</literal>PRId64<literal type="string">" / %"</literal>PRId64,

major_version, minor_version,

timebase_numerator, timebase_denominator );

}

else if( p_oggpacket-&gt;bytes &gt;= <literal type="number">42</literal> &amp;&amp;

!memcmp( p_oggpacket-&gt;packet, <literal type="string">"AnxData"</literal>, <literal type="number">7</literal> ) )

{

uint64_t granule_rate_numerator;

uint64_t granule_rate_denominator;

char content_type_string[<literal type="number">1024</literal>];

granule_rate_numerator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">8</literal>] );

granule_rate_denominator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">16</literal>] );

p_stream-&gt;i_secondary_header_packets =

GetDWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">24</literal>] );

content_type_string[<literal type="number">0</literal>] = <literal type="char">'\0'</literal>;

if( !strncasecmp( (char*)(&amp;p_oggpacket-&gt;packet[<literal type="number">28</literal>]), <literal type="string">"Content-Type: "</literal>, <literal type="number">14</literal> ) )

{

uint8_t *p = memchr( &amp;p_oggpacket-&gt;packet[<literal type="number">42</literal>], <literal type="char">'\r'</literal>,

p_oggpacket-&gt;bytes - <literal type="number">1</literal> );

if( p &amp;&amp; p[<literal type="number">0</literal>] == <literal type="char">'\r'</literal> &amp;&amp; p[<literal type="number">1</literal>] == <literal type="char">'\n'</literal> )

sscanf( (char*)(&amp;p_oggpacket-&gt;packet[<literal type="number">42</literal>]), <literal type="string">"%1023s\r\n"</literal>,

content_type_string );

}

msg_Dbg( p_demux, <literal type="string">"AnxData packet info: %"</literal>PRId64<literal type="string">" / %"</literal>PRId64<literal type="string">", %d, ``%s''"</literal>,

granule_rate_numerator, granule_rate_denominator,

p_stream-&gt;i_secondary_header_packets, content_type_string );

if( granule_rate_numerator &amp;&amp; granule_rate_denominator )

date_Init( &amp;p_stream-&gt;dts, granule_rate_numerator, granule_rate_denominator );

Ogg_ApplyContentType( p_stream, content_type_string,

&amp;p_stream-&gt;b_force_backup );

}

}

static void Ogg_ReadSkeletonHeader( demux_t *p_demux, logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

if( p_oggpacket-&gt;bytes &lt; <literal type="number">12</literal> )

return;

p_sys-&gt;p_skelstream = p_stream;

p_sys-&gt;skeleton.major = GetWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">8</literal>] );

p_sys-&gt;skeleton.minor = GetWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">10</literal>] );

if ( asprintf( &amp; p_stream-&gt;fmt.psz_description,

<literal type="string">"OGG Skeleton version %"</literal> PRIu16 <literal type="string">".%"</literal> PRIu16,

p_sys-&gt;skeleton.major, p_sys-&gt;skeleton.minor ) &lt; <literal type="number">0</literal> )

p_stream-&gt;fmt.psz_description = NULL;

}

static void Ogg_ReadSkeletonBones( demux_t *p_demux, ogg_packet *p_oggpacket )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

if ( p_sys-&gt;skeleton.major &lt; <literal type="number">3</literal> || p_oggpacket-&gt;bytes &lt; <literal type="number">52</literal> ) return;

ogg_int32_t i_serialno = GetDWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">12</literal>] );

logical_stream_t *p_target_stream = NULL;

for ( int i=<literal type="number">0</literal>; i&lt; p_sys-&gt;i_streams; i++ )

{

if ( p_sys-&gt;pp_stream[i]-&gt;i_serial_no == i_serialno )

{

p_target_stream = p_sys-&gt;pp_stream[i];

break;

}

}

if ( !p_target_stream ) return;

ogg_skeleton_t *p_skel = p_target_stream-&gt;p_skel;

if ( !p_skel )

{

p_skel = malloc( sizeof( ogg_skeleton_t ) );

if ( !p_skel ) return;

TAB_INIT( p_skel-&gt;i_messages, p_skel-&gt;ppsz_messages );

p_skel-&gt;p_index = NULL;

p_target_stream-&gt;p_skel = p_skel;

}

const unsigned char *p_messages = p_oggpacket-&gt;packet + <literal type="number">8</literal> + GetDWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">8</literal>] );

const unsigned char *p_boundary = p_oggpacket-&gt;packet + p_oggpacket-&gt;bytes;

const unsigned char *p = p_messages;

while ( p &lt;= p_boundary - <literal type="number">1</literal> &amp;&amp; p &gt; p_oggpacket-&gt;packet )

{

if ( *p == <literal type="number">0x0D</literal> &amp;&amp; *(p+<literal type="number">1</literal>) == <literal type="number">0x0A</literal> )

{

char *psz_message = strndup( (const char *) p_messages,

p - p_messages );

if ( psz_message )

{

msg_Dbg( p_demux, <literal type="string">"stream %"</literal> PRId32 <literal type="string">" [%s]"</literal>, i_serialno, psz_message );

TAB_APPEND( p_skel-&gt;i_messages, p_skel-&gt;ppsz_messages, psz_message );

}

if ( p &lt; p_boundary - <literal type="number">1</literal> ) p_messages = p + <literal type="number">2</literal>;

}

p++;

}

}

unsigned const char * Read7BitsVariableLE( unsigned const char *p_begin,

unsigned const char *p_end,

uint64_t *pi_value )

{

int i_shift = <literal type="number">0</literal>;

int64_t i_read = <literal type="number">0</literal>;

*pi_value = <literal type="number">0</literal>;

while ( p_begin &lt; p_end )

{

i_read = *p_begin &amp; <literal type="number">0x7F</literal>; 

*pi_value = *pi_value | ( i_read &lt;&lt; i_shift );

i_shift += <literal type="number">7</literal>;

if ( (*p_begin++ &amp; <literal type="number">0x80</literal>) == <literal type="number">0x80</literal> ) break; 

}

*pi_value = GetQWLE( pi_value );

return p_begin;

}

static void Ogg_ReadSkeletonIndex( demux_t *p_demux, ogg_packet *p_oggpacket )

{

demux_sys_t *p_sys = p_demux-&gt;p_sys;

if( p_sys-&gt;skeleton.major &lt; <literal type="number">4</literal>

|| p_oggpacket-&gt;bytes &lt; <literal type="number">44</literal> 

) return;

int32_t i_serialno = GetDWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">6</literal>] );

logical_stream_t *p_stream = NULL;

for ( int i=<literal type="number">0</literal>; i&lt; p_sys-&gt;i_streams; i++ )

{

if( p_sys-&gt;pp_stream[i]-&gt;i_serial_no == i_serialno )

{

p_stream = p_sys-&gt;pp_stream[i];

break;

}

}

if ( !p_stream || !p_stream-&gt;p_skel ) return;

uint64_t i_keypoints = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">10</literal>] );

msg_Dbg( p_demux, <literal type="string">"%"</literal> PRIi64 <literal type="string">" index data for %"</literal> PRIi32, i_keypoints, i_serialno );

if ( !i_keypoints ) return;

p_stream-&gt;p_skel-&gt;i_indexstampden = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">18</literal>] );

p_stream-&gt;p_skel-&gt;i_indexfirstnum = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">24</literal>] );

p_stream-&gt;p_skel-&gt;i_indexlastnum = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">32</literal>] );

unsigned const char *p_fwdbyte = &amp;p_oggpacket-&gt;packet[<literal type="number">42</literal>];

unsigned const char *p_boundary = p_oggpacket-&gt;packet + p_oggpacket-&gt;bytes;

uint64_t i_offset = <literal type="number">0</literal>;

uint64_t i_time = <literal type="number">0</literal>;

uint64_t i_keypoints_found = <literal type="number">0</literal>;

while( p_fwdbyte &lt; p_boundary &amp;&amp; i_keypoints_found &lt; i_keypoints )

{

uint64_t i_val;

p_fwdbyte = Read7BitsVariableLE( p_fwdbyte, p_boundary, &amp;i_val );

i_offset += i_val;

p_fwdbyte = Read7BitsVariableLE( p_fwdbyte, p_boundary, &amp;i_val );

i_time += i_val * p_stream-&gt;p_skel-&gt;i_indexstampden;

i_keypoints_found++;

}

if ( i_keypoints_found != i_keypoints )

{

msg_Warn( p_demux, <literal type="string">"Invalid Index: missing entries"</literal> );

return;

}

p_stream-&gt;p_skel-&gt;p_index = malloc( p_oggpacket-&gt;bytes - <literal type="number">42</literal> );

if ( !p_stream-&gt;p_skel-&gt;p_index ) return;

memcpy( p_stream-&gt;p_skel-&gt;p_index, &amp;p_oggpacket-&gt;packet[<literal type="number">42</literal>],

p_oggpacket-&gt;bytes - <literal type="number">42</literal> );

p_stream-&gt;p_skel-&gt;i_index = i_keypoints_found;

p_stream-&gt;p_skel-&gt;i_index_size = p_oggpacket-&gt;bytes - <literal type="number">42</literal>;

}

static void Ogg_FreeSkeleton( ogg_skeleton_t *p_skel )

{

if ( !p_skel ) return;

for ( int i=<literal type="number">0</literal>; i&lt; p_skel-&gt;i_messages; i++ )

free( p_skel-&gt;ppsz_messages[i] );

TAB_CLEAN( p_skel-&gt;i_messages, p_skel-&gt;ppsz_messages );

free( p_skel-&gt;p_index );

free( p_skel );

}

static void Ogg_ApplySkeleton( logical_stream_t *p_stream )

{

if ( !p_stream-&gt;p_skel ) return;

for ( int i=<literal type="number">0</literal>; i&lt; p_stream-&gt;p_skel-&gt;i_messages; i++ )

{

const char *psz_message = p_stream-&gt;p_skel-&gt;ppsz_messages[i];

if ( ! strncmp( <literal type="string">"Name: "</literal>, psz_message, <literal type="number">6</literal> ) )

{

free( p_stream-&gt;fmt.psz_description );

p_stream-&gt;fmt.psz_description = strdup( psz_message + <literal type="number">6</literal> );

}

else if ( ! strncmp(<literal type="string">"Content-Type: "</literal>, psz_message, <literal type="number">14</literal> ) )

{

bool b_foo;

Ogg_ApplyContentType( p_stream, psz_message + <literal type="number">14</literal>, &amp;b_foo );

}

}

}

bool Ogg_GetBoundsUsingSkeletonIndex( logical_stream_t *p_stream, vlc_tick_t i_time,

int64_t *pi_lower, int64_t *pi_upper )

{

if ( !p_stream || !p_stream-&gt;p_skel || !p_stream-&gt;p_skel-&gt;p_index ||

i_time == VLC_TICK_INVALID )

return false;

i_time -= VLC_TICK_0;

if ( i_time &lt; p_stream-&gt;p_skel-&gt;i_indexfirstnum

* p_stream-&gt;p_skel-&gt;i_indexstampden ||

i_time &gt; p_stream-&gt;p_skel-&gt;i_indexlastnum

* p_stream-&gt;p_skel-&gt;i_indexstampden ) return false;

unsigned const char *p_fwdbyte = p_stream-&gt;p_skel-&gt;p_index;

struct

{

int64_t i_pos;

vlc_tick_t i_time;

} current = { <literal type="number">0</literal>, <literal type="number">0</literal> }, prev = { -<literal type="number">1</literal>, -<literal type="number">1</literal> };

uint64_t i_keypoints_found = <literal type="number">0</literal>;

while( p_fwdbyte &lt; p_fwdbyte + p_stream-&gt;p_skel-&gt;i_index_size

&amp;&amp; i_keypoints_found &lt; p_stream-&gt;p_skel-&gt;i_index )

{

uint64_t i_val;

p_fwdbyte = Read7BitsVariableLE( p_fwdbyte,

p_fwdbyte + p_stream-&gt;p_skel-&gt;i_index_size, &amp;i_val );

current.i_pos += i_val;

p_fwdbyte = Read7BitsVariableLE( p_fwdbyte,

p_fwdbyte + p_stream-&gt;p_skel-&gt;i_index_size, &amp;i_val );

current.i_time += i_val * p_stream-&gt;p_skel-&gt;i_indexstampden;

if ( current.i_pos &lt; <literal type="number">0</literal> || current.i_time &lt; <literal type="number">0</literal> ) break;

i_keypoints_found++;

if ( i_time &lt;= current.i_time )

{

*pi_lower = prev.i_pos;

*pi_upper = current.i_pos;

return ( i_time == current.i_time );

}

prev = current;

}

return false;

}

static uint32_t dirac_uint( bs_t *p_bs )

{

uint32_t u_count = <literal type="number">0</literal>, u_value = <literal type="number">0</literal>;

while( !bs_eof( p_bs ) &amp;&amp; !bs_read( p_bs, <literal type="number">1</literal> ) )

{

u_count++;

u_value &lt;&lt;= <literal type="number">1</literal>;

u_value |= bs_read( p_bs, <literal type="number">1</literal> );

}

return (<literal type="number">1</literal>&lt;&lt;u_count) - <literal type="number">1</literal> + u_value;

}

static int dirac_bool( bs_t *p_bs )

{

return bs_read( p_bs, <literal type="number">1</literal> );

}

static bool Ogg_ReadDiracHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

p_stream-&gt;special.dirac.b_old = (p_oggpacket-&gt;packet[<literal type="number">0</literal>] == <literal type="char">'K'</literal>);

static const struct {

uint32_t u_n , u_d ;

} p_dirac_frate_tbl[] = { 

{<literal type="number">1</literal>,<literal type="number">1</literal>}, 

{<literal type="number">24000</literal>,<literal type="number">1001</literal>}, {<literal type="number">24</literal>,<literal type="number">1</literal>}, {<literal type="number">25</literal>,<literal type="number">1</literal>}, {<literal type="number">30000</literal>,<literal type="number">1001</literal>}, {<literal type="number">30</literal>,<literal type="number">1</literal>},

{<literal type="number">50</literal>,<literal type="number">1</literal>}, {<literal type="number">60000</literal>,<literal type="number">1001</literal>}, {<literal type="number">60</literal>,<literal type="number">1</literal>}, {<literal type="number">15000</literal>,<literal type="number">1001</literal>}, {<literal type="number">25</literal>,<literal type="number">2</literal>},

};

static const size_t u_dirac_frate_tbl = sizeof(p_dirac_frate_tbl)/sizeof(*p_dirac_frate_tbl);

static const uint32_t pu_dirac_vidfmt_frate[] = { 

<literal type="number">1</literal>, <literal type="number">9</literal>, <literal type="number">10</literal>, <literal type="number">9</literal>, <literal type="number">10</literal>, <literal type="number">9</literal>, <literal type="number">10</literal>, <literal type="number">4</literal>, <literal type="number">3</literal>, <literal type="number">7</literal>, <literal type="number">6</literal>, <literal type="number">4</literal>, <literal type="number">3</literal>, <literal type="number">7</literal>, <literal type="number">6</literal>, <literal type="number">2</literal>, <literal type="number">2</literal>, <literal type="number">7</literal>, <literal type="number">6</literal>, <literal type="number">7</literal>, <literal type="number">6</literal>,

};

static const size_t u_dirac_vidfmt_frate = sizeof(pu_dirac_vidfmt_frate)/sizeof(*pu_dirac_vidfmt_frate);

bs_t bs;

p_stream-&gt;b_force_backup = false;

bs_init( &amp;bs, p_oggpacket-&gt;packet, p_oggpacket-&gt;bytes );

bs_skip( &amp;bs, <literal type="number">13</literal>*<literal type="number">8</literal>); 

dirac_uint( &amp;bs ); 

dirac_uint( &amp;bs ); 

dirac_uint( &amp;bs ); 

dirac_uint( &amp;bs ); 

uint32_t u_video_format = dirac_uint( &amp;bs ); 

if( u_video_format &gt;= u_dirac_vidfmt_frate )

{

return false;

}

if( dirac_bool( &amp;bs ) )

{

dirac_uint( &amp;bs ); 

dirac_uint( &amp;bs ); 

}

if( dirac_bool( &amp;bs ) )

{

dirac_uint( &amp;bs ); 

}

if( dirac_bool( &amp;bs ) )

{

p_stream-&gt;special.dirac.b_interlaced = dirac_uint( &amp;bs ); 

}

else

p_stream-&gt;special.dirac.b_interlaced = false;

uint32_t u_n = p_dirac_frate_tbl[pu_dirac_vidfmt_frate[u_video_format]].u_n;

uint32_t u_d = p_dirac_frate_tbl[pu_dirac_vidfmt_frate[u_video_format]].u_d;

u_d = __MAX( u_d, <literal type="number">1</literal> );

if( dirac_bool( &amp;bs ) )

{

uint32_t u_frame_rate_index = dirac_uint( &amp;bs );

if( u_frame_rate_index &gt;= u_dirac_frate_tbl )

{

return false;

}

u_n = p_dirac_frate_tbl[u_frame_rate_index].u_n;

u_d = p_dirac_frate_tbl[u_frame_rate_index].u_d;

if( u_frame_rate_index == <literal type="number">0</literal> )

{

u_n = dirac_uint( &amp;bs ); 

u_d = dirac_uint( &amp;bs ); 

}

}

if( !u_n || !u_d )

return false;

date_Init( &amp;p_stream-&gt;dts, <literal type="number">2</literal> * u_n, u_d );

return true;

}

static bool Ogg_ReadOggSpotsHeader( logical_stream_t *p_stream,

ogg_packet *p_oggpacket )

{

uint64_t i_granulerate_numerator;

uint64_t i_granulerate_denominator;

int i_major;

int i_minor;

es_format_Change( &amp;p_stream-&gt;fmt, VIDEO_ES, VLC_CODEC_OGGSPOTS );

p_stream-&gt;b_force_backup = true;

if ( p_oggpacket-&gt;bytes != <literal type="number">52</literal> )

{

return false;

}

i_major = GetWLE( &amp;p_oggpacket-&gt;packet[ <literal type="number">8</literal>] ); 

i_minor = GetWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">10</literal>] ); 

if ( i_major != <literal type="number">0</literal> || i_minor != <literal type="number">1</literal> )

{

return false;

}

i_granulerate_numerator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">12</literal>] );

i_granulerate_denominator = GetQWLE( &amp;p_oggpacket-&gt;packet[<literal type="number">20</literal>] );

if ( i_granulerate_numerator == <literal type="number">0</literal> || i_granulerate_denominator == <literal type="number">0</literal> )

{

return false;

}

if ( i_granulerate_numerator == <literal type="number">1</literal> &amp;&amp; i_granulerate_denominator == <literal type="number">30</literal> )

{

i_granulerate_numerator = <literal type="number">30</literal>;

i_granulerate_denominator = <literal type="number">1</literal>;

}

if ( !i_granulerate_numerator || !i_granulerate_denominator )

return false;

vlc_ureduce(&amp;p_stream-&gt;fmt.video.i_frame_rate,

&amp;p_stream-&gt;fmt.video.i_frame_rate_base,

i_granulerate_numerator, i_granulerate_denominator, <literal type="number">0</literal>);

date_Init( &amp;p_stream-&gt;dts, p_stream-&gt;fmt.video.i_frame_rate,

p_stream-&gt;fmt.video.i_frame_rate_base );

p_stream-&gt;i_granule_shift = p_oggpacket-&gt;packet[<literal type="number">28</literal>];

return true;

}</argument></argument_list></macro></expr></condition></if></if_stmt></block_content></block></if></if_stmt></block_content></block></while></block_content></block></for></block_content></block></function>

</unit>
