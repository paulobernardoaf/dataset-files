<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\obs-analysis\_cppstats\obs-studio\deps\lzma\liblzma\api\lzma\index.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LZMA_H_INTERNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> Never include this file directly. Use &lt;lzma.h&gt; instead.</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>lzma_index_s</name></name></type> <name>lzma_index</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>lzma_stream_flags</name> <modifier>*</modifier></type><name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>number</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>block_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>compressed_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>uncompressed_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>compressed_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>padding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli4</name></decl>;</decl_stmt>

}</block> <decl><name>stream</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>number_in_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>compressed_file_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>uncompressed_file_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>number_in_stream</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>compressed_stream_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>uncompressed_stream_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>unpadded_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>total_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>reserved_vli4</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>reserved_ptr4</name></decl>;</decl_stmt>

}</block> <decl><name>block</name></decl>;</struct>

<union>union <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lzma_vli</name></type> <name>v</name></decl>;</decl_stmt>

}</block> <decl><name><name>internal</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</union>

}</block></struct></type> <name>lzma_index_iter</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>LZMA_INDEX_ITER_ANY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>LZMA_INDEX_ITER_STREAM</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>LZMA_INDEX_ITER_BLOCK</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,

<decl><name>LZMA_INDEX_ITER_NONEMPTY_BLOCK</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>

}</block></enum></type> <name>lzma_index_iter_mode</name>;</typedef>

<extern>extern LZMA_API(uint64_t</extern>) <macro><name>lzma_index_memusage</name><argument_list>(

<argument>lzma_vli streams</argument>, <argument>lzma_vli blocks</argument>)</argument_list></macro> <expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(uint64_t</extern>) <macro><name>lzma_index_memused</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(lzma_index *</extern>) <macro><name>lzma_index_init</name><argument_list>(<argument>lzma_allocator *allocator</argument>)</argument_list></macro>

<expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(void</extern>) <macro><name>lzma_index_end</name><argument_list>(<argument>lzma_index *i</argument>, <argument>lzma_allocator *allocator</argument>)</argument_list></macro>

<expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_append</name><argument_list>(

<argument>lzma_index *i</argument>, <argument>lzma_allocator *allocator</argument>,

<argument>lzma_vli unpadded_size</argument>, <argument>lzma_vli uncompressed_size</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_stream_flags</name><argument_list>(

<argument>lzma_index *i</argument>, <argument>const lzma_stream_flags *stream_flags</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(uint32_t</extern>) <macro><name>lzma_index_checks</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_stream_padding</name><argument_list>(

<argument>lzma_index *i</argument>, <argument>lzma_vli stream_padding</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_stream_count</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_block_count</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_size</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_stream_size</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_total_size</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_file_size</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_vli</extern>) <macro><name>lzma_index_uncompressed_size</name><argument_list>(<argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_pure</name></decl>;</decl_stmt>

<extern>extern LZMA_API(void</extern>) <macro><name>lzma_index_iter_init</name><argument_list>(

<argument>lzma_index_iter *iter</argument>, <argument>const lzma_index *i</argument>)</argument_list></macro> <expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(void</extern>) <macro><name>lzma_index_iter_rewind</name><argument_list>(<argument>lzma_index_iter *iter</argument>)</argument_list></macro>

<expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(lzma_bool</extern>) <macro><name>lzma_index_iter_next</name><argument_list>(

<argument>lzma_index_iter *iter</argument>, <argument>lzma_index_iter_mode mode</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_bool</extern>) <macro><name>lzma_index_iter_locate</name><argument_list>(

<argument>lzma_index_iter *iter</argument>, <argument>lzma_vli target</argument>)</argument_list></macro> <expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_cat</name><argument_list>(

<argument>lzma_index *restrict dest</argument>, <argument>lzma_index *restrict src</argument>,

<argument>lzma_allocator *allocator</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_index *</extern>) <macro><name>lzma_index_dup</name><argument_list>(

<argument>const lzma_index *i</argument>, <argument>lzma_allocator *allocator</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_encoder</name><argument_list>(

<argument>lzma_stream *strm</argument>, <argument>const lzma_index *i</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_decoder</name><argument_list>(

<argument>lzma_stream *strm</argument>, <argument>lzma_index **i</argument>, <argument>uint64_t memlimit</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>lzma_nothrow</name></type> <name>lzma_attr_warn_unused_result</name></decl>;</decl_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_buffer_encode</name><argument_list>(<argument>const lzma_index *i</argument>,

<argument>uint8_t *out</argument>, <argument>size_t *out_pos</argument>, <argument>size_t out_size</argument>)</argument_list></macro> <expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

<extern>extern LZMA_API(lzma_ret</extern>) <macro><name>lzma_index_buffer_decode</name><argument_list>(<argument>lzma_index **i</argument>,

<argument>uint64_t *memlimit</argument>, <argument>lzma_allocator *allocator</argument>,

<argument>const uint8_t *in</argument>, <argument>size_t *in_pos</argument>, <argument>size_t in_size</argument>)</argument_list></macro>

<expr_stmt><expr><name>lzma_nothrow</name></expr>;</expr_stmt>

</unit>
