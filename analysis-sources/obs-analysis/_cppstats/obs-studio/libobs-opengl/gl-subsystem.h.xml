<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\obs-analysis\_cppstats\obs-studio\libobs-opengl\gl-subsystem.h"><cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>once</name></cpp:pragma>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/darray.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util/threading.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;graphics/graphics.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;graphics/device-exports.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;graphics/matrix4.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;glad/glad.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gl-helpers.h"</cpp:file></cpp:include>

<struct_decl>struct <name>gl_platform</name>;</struct_decl>

<struct_decl>struct <name>gl_windowinfo</name>;</struct_decl>

<enum>enum <name>copy_type</name> <block>{ <decl><name>COPY_TYPE_ARB</name></decl>, <decl><name>COPY_TYPE_NV</name></decl>, <decl><name>COPY_TYPE_FBO_BLIT</name></decl> }</block>;</enum>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_format</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_A8</name></expr>:</case>

<return>return <expr><name>GL_RED</name></expr>;</return>

<case>case <expr><name>GS_R8</name></expr>:</case>

<return>return <expr><name>GL_RED</name></expr>;</return>

<case>case <expr><name>GS_RGBA</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_BGRX</name></expr>:</case>

<return>return <expr><name>GL_BGRA</name></expr>;</return>

<case>case <expr><name>GS_BGRA</name></expr>:</case>

<return>return <expr><name>GL_BGRA</name></expr>;</return>

<case>case <expr><name>GS_R10G10B10A2</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_RGBA16</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_R16</name></expr>:</case>

<return>return <expr><name>GL_RED</name></expr>;</return>

<case>case <expr><name>GS_RGBA16F</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_RGBA32F</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_RG16F</name></expr>:</case>

<return>return <expr><name>GL_RG</name></expr>;</return>

<case>case <expr><name>GS_RG32F</name></expr>:</case>

<return>return <expr><name>GL_RG</name></expr>;</return>

<case>case <expr><name>GS_R8G8</name></expr>:</case>

<return>return <expr><name>GL_RG</name></expr>;</return>

<case>case <expr><name>GS_R16F</name></expr>:</case>

<return>return <expr><name>GL_RED</name></expr>;</return>

<case>case <expr><name>GS_R32F</name></expr>:</case>

<return>return <expr><name>GL_RED</name></expr>;</return>

<case>case <expr><name>GS_DXT1</name></expr>:</case>

<return>return <expr><name>GL_RGB</name></expr>;</return>

<case>case <expr><name>GS_DXT3</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_DXT5</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_UNKNOWN</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_internal_format</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_A8</name></expr>:</case>

<return>return <expr><name>GL_R8</name></expr>;</return> 

<case>case <expr><name>GS_R8</name></expr>:</case>

<return>return <expr><name>GL_R8</name></expr>;</return>

<case>case <expr><name>GS_RGBA</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_BGRX</name></expr>:</case>

<return>return <expr><name>GL_RGB</name></expr>;</return>

<case>case <expr><name>GS_BGRA</name></expr>:</case>

<return>return <expr><name>GL_RGBA</name></expr>;</return>

<case>case <expr><name>GS_R10G10B10A2</name></expr>:</case>

<return>return <expr><name>GL_RGB10_A2</name></expr>;</return>

<case>case <expr><name>GS_RGBA16</name></expr>:</case>

<return>return <expr><name>GL_RGBA16</name></expr>;</return>

<case>case <expr><name>GS_R16</name></expr>:</case>

<return>return <expr><name>GL_R16</name></expr>;</return>

<case>case <expr><name>GS_RGBA16F</name></expr>:</case>

<return>return <expr><name>GL_RGBA16F</name></expr>;</return>

<case>case <expr><name>GS_RGBA32F</name></expr>:</case>

<return>return <expr><name>GL_RGBA32F</name></expr>;</return>

<case>case <expr><name>GS_RG16F</name></expr>:</case>

<return>return <expr><name>GL_RG16F</name></expr>;</return>

<case>case <expr><name>GS_RG32F</name></expr>:</case>

<return>return <expr><name>GL_RG32F</name></expr>;</return>

<case>case <expr><name>GS_R8G8</name></expr>:</case>

<return>return <expr><name>GL_RG8</name></expr>;</return>

<case>case <expr><name>GS_R16F</name></expr>:</case>

<return>return <expr><name>GL_R16F</name></expr>;</return>

<case>case <expr><name>GS_R32F</name></expr>:</case>

<return>return <expr><name>GL_R32F</name></expr>;</return>

<case>case <expr><name>GS_DXT1</name></expr>:</case>

<return>return <expr><name>GL_COMPRESSED_RGBA_S3TC_DXT1_EXT</name></expr>;</return>

<case>case <expr><name>GS_DXT3</name></expr>:</case>

<return>return <expr><name>GL_COMPRESSED_RGBA_S3TC_DXT3_EXT</name></expr>;</return>

<case>case <expr><name>GS_DXT5</name></expr>:</case>

<return>return <expr><name>GL_COMPRESSED_RGBA_S3TC_DXT5_EXT</name></expr>;</return>

<case>case <expr><name>GS_UNKNOWN</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>get_gl_format_type</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_A8</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_R8</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_RGBA</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_BGRX</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_BGRA</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_R10G10B10A2</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_INT_10_10_10_2</name></expr>;</return>

<case>case <expr><name>GS_RGBA16</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_SHORT</name></expr>;</return>

<case>case <expr><name>GS_R16</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_SHORT</name></expr>;</return>

<case>case <expr><name>GS_RGBA16F</name></expr>:</case>

<return>return <expr><name>GL_HALF_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_RGBA32F</name></expr>:</case>

<return>return <expr><name>GL_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_RG16F</name></expr>:</case>

<return>return <expr><name>GL_HALF_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_RG32F</name></expr>:</case>

<return>return <expr><name>GL_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_R8G8</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_R16F</name></expr>:</case>

<return>return <expr><name>GL_HALF_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_R32F</name></expr>:</case>

<return>return <expr><name>GL_FLOAT</name></expr>;</return>

<case>case <expr><name>GS_DXT1</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_DXT3</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_DXT5</name></expr>:</case>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

<case>case <expr><name>GS_UNKNOWN</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_UNSIGNED_BYTE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_zstencil_format</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_zstencil_format</name></name></type> <name>format</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_Z16</name></expr>:</case>

<return>return <expr><name>GL_DEPTH_COMPONENT16</name></expr>;</return>

<case>case <expr><name>GS_Z24_S8</name></expr>:</case>

<return>return <expr><name>GL_DEPTH24_STENCIL8</name></expr>;</return>

<case>case <expr><name>GS_Z32F</name></expr>:</case>

<return>return <expr><name>GL_DEPTH_COMPONENT32F</name></expr>;</return>

<case>case <expr><name>GS_Z32F_S8X24</name></expr>:</case>

<return>return <expr><name>GL_DEPTH32F_STENCIL8</name></expr>;</return>

<case>case <expr><name>GS_ZS_NONE</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_depth_test</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_depth_test</name></name></type> <name>test</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>test</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_NEVER</name></expr>:</case>

<return>return <expr><name>GL_NEVER</name></expr>;</return>

<case>case <expr><name>GS_LESS</name></expr>:</case>

<return>return <expr><name>GL_LESS</name></expr>;</return>

<case>case <expr><name>GS_LEQUAL</name></expr>:</case>

<return>return <expr><name>GL_LEQUAL</name></expr>;</return>

<case>case <expr><name>GS_EQUAL</name></expr>:</case>

<return>return <expr><name>GL_EQUAL</name></expr>;</return>

<case>case <expr><name>GS_GEQUAL</name></expr>:</case>

<return>return <expr><name>GL_GEQUAL</name></expr>;</return>

<case>case <expr><name>GS_GREATER</name></expr>:</case>

<return>return <expr><name>GL_GREATER</name></expr>;</return>

<case>case <expr><name>GS_NOTEQUAL</name></expr>:</case>

<return>return <expr><name>GL_NOTEQUAL</name></expr>;</return>

<case>case <expr><name>GS_ALWAYS</name></expr>:</case>

<return>return <expr><name>GL_ALWAYS</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_NEVER</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_stencil_op</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_stencil_op_type</name></name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_KEEP</name></expr>:</case>

<return>return <expr><name>GL_KEEP</name></expr>;</return>

<case>case <expr><name>GS_ZERO</name></expr>:</case>

<return>return <expr><name>GL_ZERO</name></expr>;</return>

<case>case <expr><name>GS_REPLACE</name></expr>:</case>

<return>return <expr><name>GL_REPLACE</name></expr>;</return>

<case>case <expr><name>GS_INCR</name></expr>:</case>

<return>return <expr><name>GL_INCR</name></expr>;</return>

<case>case <expr><name>GS_DECR</name></expr>:</case>

<return>return <expr><name>GL_DECR</name></expr>;</return>

<case>case <expr><name>GS_INVERT</name></expr>:</case>

<return>return <expr><name>GL_INVERT</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_KEEP</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_stencil_side</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_stencil_side</name></name></type> <name>side</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>side</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_STENCIL_FRONT</name></expr>:</case>

<return>return <expr><name>GL_FRONT</name></expr>;</return>

<case>case <expr><name>GS_STENCIL_BACK</name></expr>:</case>

<return>return <expr><name>GL_BACK</name></expr>;</return>

<case>case <expr><name>GS_STENCIL_BOTH</name></expr>:</case>

<return>return <expr><name>GL_FRONT_AND_BACK</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_FRONT</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_blend_type</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_blend_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_BLEND_ZERO</name></expr>:</case>

<return>return <expr><name>GL_ZERO</name></expr>;</return>

<case>case <expr><name>GS_BLEND_ONE</name></expr>:</case>

<return>return <expr><name>GL_ONE</name></expr>;</return>

<case>case <expr><name>GS_BLEND_SRCCOLOR</name></expr>:</case>

<return>return <expr><name>GL_SRC_COLOR</name></expr>;</return>

<case>case <expr><name>GS_BLEND_INVSRCCOLOR</name></expr>:</case>

<return>return <expr><name>GL_ONE_MINUS_SRC_COLOR</name></expr>;</return>

<case>case <expr><name>GS_BLEND_SRCALPHA</name></expr>:</case>

<return>return <expr><name>GL_SRC_ALPHA</name></expr>;</return>

<case>case <expr><name>GS_BLEND_INVSRCALPHA</name></expr>:</case>

<return>return <expr><name>GL_ONE_MINUS_SRC_ALPHA</name></expr>;</return>

<case>case <expr><name>GS_BLEND_DSTCOLOR</name></expr>:</case>

<return>return <expr><name>GL_DST_COLOR</name></expr>;</return>

<case>case <expr><name>GS_BLEND_INVDSTCOLOR</name></expr>:</case>

<return>return <expr><name>GL_ONE_MINUS_DST_COLOR</name></expr>;</return>

<case>case <expr><name>GS_BLEND_DSTALPHA</name></expr>:</case>

<return>return <expr><name>GL_DST_ALPHA</name></expr>;</return>

<case>case <expr><name>GS_BLEND_INVDSTALPHA</name></expr>:</case>

<return>return <expr><name>GL_ONE_MINUS_DST_ALPHA</name></expr>;</return>

<case>case <expr><name>GS_BLEND_SRCALPHASAT</name></expr>:</case>

<return>return <expr><name>GL_SRC_ALPHA_SATURATE</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_ONE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_shader_type</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_shader_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_SHADER_VERTEX</name></expr>:</case>

<return>return <expr><name>GL_VERTEX_SHADER</name></expr>;</return>

<case>case <expr><name>GS_SHADER_PIXEL</name></expr>:</case>

<return>return <expr><name>GL_FRAGMENT_SHADER</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_VERTEX_SHADER</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>convert_filter</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_sample_filter</name></name></type> <name>filter</name></decl></parameter>,

<parameter><decl><type><name>GLint</name> <modifier>*</modifier></type><name>min_filter</name></decl></parameter>, <parameter><decl><type><name>GLint</name> <modifier>*</modifier></type><name>mag_filter</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_FILTER_POINT</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_NEAREST_MIPMAP_NEAREST</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_NEAREST</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_LINEAR</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_LINEAR_MIPMAP_LINEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_LINEAR</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_MAG_POINT_MIP_LINEAR</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_NEAREST_MIPMAP_LINEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_NEAREST</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_NEAREST_MIPMAP_NEAREST</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_LINEAR</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_POINT_MAG_MIP_LINEAR</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_NEAREST_MIPMAP_LINEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_LINEAR</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_LINEAR_MAG_MIP_POINT</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_LINEAR_MIPMAP_NEAREST</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_NEAREST</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_LINEAR_MIPMAP_LINEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_NEAREST</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_MIN_MAG_LINEAR_MIP_POINT</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_LINEAR_MIPMAP_NEAREST</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_LINEAR</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>GS_FILTER_ANISOTROPIC</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_LINEAR_MIPMAP_LINEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_LINEAR</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>min_filter</name> <operator>=</operator> <name>GL_NEAREST_MIPMAP_NEAREST</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>mag_filter</name> <operator>=</operator> <name>GL_NEAREST</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLint</name></type> <name>convert_address_mode</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_address_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_ADDRESS_WRAP</name></expr>:</case>

<return>return <expr><name>GL_REPEAT</name></expr>;</return>

<case>case <expr><name>GS_ADDRESS_CLAMP</name></expr>:</case>

<return>return <expr><name>GL_CLAMP_TO_EDGE</name></expr>;</return>

<case>case <expr><name>GS_ADDRESS_MIRROR</name></expr>:</case>

<return>return <expr><name>GL_MIRRORED_REPEAT</name></expr>;</return>

<case>case <expr><name>GS_ADDRESS_BORDER</name></expr>:</case>

<return>return <expr><name>GL_CLAMP_TO_BORDER</name></expr>;</return>

<case>case <expr><name>GS_ADDRESS_MIRRORONCE</name></expr>:</case>

<return>return <expr><name>GL_MIRROR_CLAMP_EXT</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_REPEAT</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>GLenum</name></type> <name>convert_gs_topology</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>gs_draw_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GS_POINTS</name></expr>:</case>

<return>return <expr><name>GL_POINTS</name></expr>;</return>

<case>case <expr><name>GS_LINES</name></expr>:</case>

<return>return <expr><name>GL_LINES</name></expr>;</return>

<case>case <expr><name>GS_LINESTRIP</name></expr>:</case>

<return>return <expr><name>GL_LINE_STRIP</name></expr>;</return>

<case>case <expr><name>GS_TRIS</name></expr>:</case>

<return>return <expr><name>GL_TRIANGLES</name></expr>;</return>

<case>case <expr><name>GS_TRISTRIP</name></expr>:</case>

<return>return <expr><name>GL_TRIANGLE_STRIP</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>GL_POINTS</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>convert_sampler_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_sampler_state</name></name> <modifier>*</modifier></type><name>sampler</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>gs_sampler_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>gs_sampler_state</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>long</name></type> <name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>min_filter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>mag_filter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>address_u</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>address_v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>address_w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>max_anisotropy</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>samplerstate_addref</name><parameter_list>(<parameter><decl><type><name>gs_samplerstate_t</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>os_atomic_inc_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>samplerstate_release</name><parameter_list>(<parameter><decl><type><name>gs_samplerstate_t</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>os_atomic_dec_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>bfree</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>gs_timer</name> <block>{

<decl_stmt><decl><type><name>GLuint</name></type> <name><name>queries</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_shader_param</name> <block>{

<decl_stmt><decl><type><name><name>enum</name> <name>gs_shader_param_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_shader_t</name> <modifier>*</modifier></type><name>shader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_samplerstate_t</name> <modifier>*</modifier></type><name>next_sampler</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>texture_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sampler_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>array_count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_texture</name></name> <modifier>*</modifier></type><name>texture</name></decl>;</decl_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>uint8_t</argument>)</argument_list></macro> <expr_stmt><expr><name>cur_value</name></expr>;</expr_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>uint8_t</argument>)</argument_list></macro> <expr_stmt><expr><name>def_value</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>changed</name></decl>;</decl_stmt>

}</block>;</struct>

<enum>enum <name>attrib_type</name> <block>{

<decl><name>ATTRIB_POSITION</name></decl>,

<decl><name>ATTRIB_NORMAL</name></decl>,

<decl><name>ATTRIB_TANGENT</name></decl>,

<decl><name>ATTRIB_COLOR</name></decl>,

<decl><name>ATTRIB_TEXCOORD</name></decl>,

<decl><name>ATTRIB_TARGET</name></decl>

}</block>;</enum>

<struct>struct <name>shader_attrib</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>attrib_type</name></name></type> <name>type</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_shader</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_shader_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_shader_param</name></name> <modifier>*</modifier></type><name>viewproj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_shader_param</name></name> <modifier>*</modifier></type><name>world</name></decl>;</decl_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>struct shader_attrib</argument>)</argument_list></macro> <expr_stmt><expr><name>attribs</name></expr>;</expr_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>struct gs_shader_param</argument>)</argument_list></macro> <expr_stmt><expr><name>params</name></expr>;</expr_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>gs_samplerstate_t *</argument>)</argument_list></macro> <expr_stmt><expr><name>samplers</name></expr>;</expr_stmt>

}</block>;</struct>

<struct>struct <name>program_param</name> <block>{

<decl_stmt><decl><type><name>GLint</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_shader_param</name></name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_program</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_shader</name></name> <modifier>*</modifier></type><name>vertex_shader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_shader</name></name> <modifier>*</modifier></type><name>pixel_shader</name></decl>;</decl_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>struct program_param</argument>)</argument_list></macro> <expr_stmt><expr><name>params</name></expr>;</expr_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>GLint</argument>)</argument_list></macro> <expr_stmt><expr><name>attribs</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>prev_next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>gs_program_create</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_device</name></name> <modifier>*</modifier></type><name>device</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gs_program_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>program</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>program_update_params</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>shader</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>gs_vertex_buffer</name> <block>{

<decl_stmt><decl><type><name>GLuint</name></type> <name>vao</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>vertex_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>normal_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>tangent_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>color_buffer</name></decl>;</decl_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>GLuint</argument>)</argument_list></macro> <expr_stmt><expr><name>uv_buffers</name></expr>;</expr_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>size_t</argument>)</argument_list></macro> <expr_stmt><expr><name>uv_sizes</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>dynamic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_vb_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>bool</name></type> <name>load_vb_buffers</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>program</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>gs_vertex_buffer</name></name> <modifier>*</modifier></type><name>vb</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>gs_index_buffer</name></name> <modifier>*</modifier></type><name>ib</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>gs_index_buffer</name> <block>{

<decl_stmt><decl><type><name>GLuint</name></type> <name>buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_index_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>gl_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>dynamic</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_texture</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_texture_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_internal_format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>texture</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>levels</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_dynamic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_render_target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_dummy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>gen_mipmaps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_samplerstate_t</name> <modifier>*</modifier></type><name>cur_sampler</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>fbo_info</name></name> <modifier>*</modifier></type><name>fbo</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_texture_2d</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>gs_texture</name></name></type> <name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>gen_mipmaps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>unpack_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_texture_3d</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>gs_texture</name></name></type> <name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>gen_mipmaps</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>unpack_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_texture_cube</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>gs_texture</name></name></type> <name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_stage_surface</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>bytes_per_pixel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLint</name></type> <name>gl_internal_format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>gl_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>pack_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_zstencil_buffer</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>attachment</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLenum</name></type> <name>format</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>gs_swap_chain</name> <block>{

<decl_stmt><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gl_windowinfo</name></name> <modifier>*</modifier></type><name>wi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_init_data</name></name></type> <name>info</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>fbo_info</name> <block>{

<decl_stmt><decl><type><name>GLuint</name></type> <name>fbo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_color_format</name></name></type> <name>format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_texture_t</name> <modifier>*</modifier></type><name>cur_render_target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cur_render_side</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_zstencil_t</name> <modifier>*</modifier></type><name>cur_zstencil_buffer</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>fbo_info_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fbo_info</name></name> <modifier>*</modifier></type><name>fbo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fbo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>glDeleteFramebuffers</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fbo</name><operator>-&gt;</operator><name>fbo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gl_success</name><argument_list>(<argument><expr><literal type="string">"glDeleteFramebuffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bfree</name><argument_list>(<argument><expr><name>fbo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>gs_device</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>gl_platform</name></name> <modifier>*</modifier></type><name>plat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>copy_type</name></name></type> <name>copy_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GLuint</name></type> <name>empty_vao</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_texture_t</name> <modifier>*</modifier></type><name>cur_render_target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_zstencil_t</name> <modifier>*</modifier></type><name>cur_zstencil_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cur_render_side</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_texture_t</name> <modifier>*</modifier></type><name><name>cur_textures</name><index>[<expr><name>GS_MAX_TEXTURES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_samplerstate_t</name> <modifier>*</modifier></type><name><name>cur_samplers</name><index>[<expr><name>GS_MAX_TEXTURES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_vertbuffer_t</name> <modifier>*</modifier></type><name>cur_vertex_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_indexbuffer_t</name> <modifier>*</modifier></type><name>cur_index_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_shader_t</name> <modifier>*</modifier></type><name>cur_vertex_shader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_shader_t</name> <modifier>*</modifier></type><name>cur_pixel_shader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gs_swapchain_t</name> <modifier>*</modifier></type><name>cur_swap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>cur_program</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_program</name></name> <modifier>*</modifier></type><name>first_program</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>gs_cull_mode</name></name></type> <name>cur_cull_mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>gs_rect</name></name></type> <name>cur_viewport</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>matrix4</name></name></type> <name>cur_proj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>matrix4</name></name></type> <name>cur_view</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>matrix4</name></name></type> <name>cur_viewproj</name></decl>;</decl_stmt>

<macro><name>DARRAY</name><argument_list>(<argument>struct matrix4</argument>)</argument_list></macro> <expr_stmt><expr><name>proj_stack</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>fbo_info</name></name> <modifier>*</modifier></type><name>cur_fbo</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>fbo_info</name></name> <modifier>*</modifier></type><name>get_fbo</name><parameter_list>(<parameter><decl><type><name>gs_texture_t</name> <modifier>*</modifier></type><name>tex</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>width</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>height</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_update</name><parameter_list>(<parameter><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_clear_context</name><parameter_list>(<parameter><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>gl_platform</name></name> <modifier>*</modifier></type><name>gl_platform_create</name><parameter_list>(<parameter><decl><type><name>gs_device_t</name> <modifier>*</modifier></type><name>device</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name></type> <name>adapter</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_platform_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gl_platform</name></name> <modifier>*</modifier></type><name>platform</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>bool</name></type> <name>gl_platform_init_swapchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_swap_chain</name></name> <modifier>*</modifier></type><name>swap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_platform_cleanup_swapchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gs_swap_chain</name></name> <modifier>*</modifier></type><name>swap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>gl_windowinfo</name></name> <modifier>*</modifier></type>

<name>gl_windowinfo_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>gs_init_data</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_windowinfo_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gl_windowinfo</name></name> <modifier>*</modifier></type><name>wi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>gl_getclientsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>gs_swap_chain</name></name> <modifier>*</modifier></type><name>swap</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>width</name></decl></parameter>,

<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>height</name></decl></parameter>)</parameter_list>;</function_decl>

</unit>
