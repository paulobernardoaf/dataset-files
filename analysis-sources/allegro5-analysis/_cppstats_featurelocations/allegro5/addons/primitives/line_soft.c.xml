<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\allegro5-analysis\_cppstats_featurelocations\allegro5\addons\primitives\line_soft.c">


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_AL_NO_BLEND_INLINE_FUNC</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/allegro.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/allegro_primitives.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_blend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_pixels.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_prim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_prim_soft.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>






<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_draw</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_first</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_step</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color</name></decl>;</decl_stmt>
}</block></struct></type> <name>state_solid_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_draw_shade</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>al_put_blended_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>color</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_draw_opaque</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>al_put_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>color</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_y</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>start_x</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>start_y</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>v2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor_step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>state</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>minor_step</name></expr>;</expr_stmt>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>state_solid_any_2d</name></type> <name>solid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>minor_color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>major_color</name></decl>;</decl_stmt>
}</block></struct></type> <name>state_grad_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_interpolation_parameters</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_y</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>float</name><modifier>*</modifier></type> <name>param</name></decl></parameter>, <parameter><decl><type><name>float</name><modifier>*</modifier></type> <name>minor_delta_param</name></decl></parameter>, <parameter><decl><type><name>float</name><modifier>*</modifier></type> <name>major_delta_param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>dx</name> <init>= <expr><name><name>v2</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>dy</name> <init>= <expr><name><name>v2</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>y</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>lensq</name> <init>= <expr><name>dx</name> <operator>*</operator> <name>dx</name> <operator>+</operator> <name>dy</name> <operator>*</operator> <name>dy</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lensq</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lensq</name> <operator>=</operator> <literal type="number">0.0001f</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>param</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>start_x</name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>*</operator> <name>dx</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>start_y</name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>*</operator> <name>dy</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>param</name> <operator>/=</operator> <name>lensq</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>dx</name> <operator>=</operator> <call><name>fabsf</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dy</name> <operator>=</operator> <call><name>fabsf</name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dx</name> <operator>&gt;</operator> <name>dy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>minor_delta_param</name> <operator>=</operator> <name>dx</name> <operator>/</operator> <name>lensq</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>minor_delta_param</name> <operator>=</operator> <name>dy</name> <operator>/</operator> <name>lensq</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>major_delta_param</name> <operator>=</operator> <operator>(</operator><name>dx</name> <operator>+</operator> <name>dy</name><operator>)</operator> <operator>/</operator> <name>lensq</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_grad_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_y</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minor_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>major_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>state_grad_any_2d</name><modifier>*</modifier></type> <name>st</name> <init>= <expr><operator>(</operator><name>state_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>v1c</name></decl>, <decl><type ref="prev"/><name>v2c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1c</name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2c</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_interpolation_parameters</name><argument_list>(<argument><expr><name>start_x</name></expr></argument>, <argument><expr><name>start_y</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minor_delta_param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>major_delta_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>a</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>r</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>g</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>b</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_grad_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor_step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>minor_step</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>fix_var</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ivar</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ret</name> <init>= <expr><name>ivar</name> <operator>%</operator> <name>max_var</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>ret</name> <operator>+</operator> <name>max_var</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHADE_COLORS</name><parameter_list>(<parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>A.r = B.r * A.r; A.g = B.g * A.g; A.b = B.b * A.b; A.a = B.a * A.a;</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_UV</name></cpp:macro> <cpp:value>const int u = fix_var(s-&gt;u, s-&gt;w); const int v = fix_var(s-&gt;v, s-&gt;h);</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name><modifier>*</modifier></type> <name>texture</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>, <name>h</name>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>u</name></decl>, <name>v</name>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minor_du</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minor_dv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>major_du</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>major_dv</name></decl>;</decl_stmt>
}</block></struct></type> <name>state_texture_solid_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_draw_shade</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FIX_UV</name>

<name>ALLEGRO_COLOR</name></type> <name>color</name> <init>= <expr><call><name>al_get_pixel</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>SHADE_COLORS</name><argument_list>(<argument>color</argument>, <argument>s-&gt;color</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>al_put_blended_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_draw_shade_white</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FIX_UV</name></type>

<name>al_put_blended_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>al_get_pixel</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_draw_opaque</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FIX_UV</name>

<name>ALLEGRO_COLOR</name></type> <name>color</name> <init>= <expr><call><name>al_get_pixel</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>SHADE_COLORS</name><argument_list>(<argument>color</argument>, <argument>s-&gt;color</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>al_put_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_draw_opaque_white</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FIX_UV</name></type>

<name>al_put_pixel</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>al_get_pixel</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_y</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minor_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>major_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>st</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>du</name></decl>, <decl><type ref="prev"/><name>dv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v1c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1c</name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_interpolation_parameters</name><argument_list>(<argument><expr><name>start_x</name></expr></argument>, <argument><expr><name>start_y</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minor_delta_param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>major_delta_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>al_get_bitmap_width</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>al_get_bitmap_height</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>du</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>u</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dv</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>v</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>v</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>u</name></name> <operator>+</operator> <name>du</name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>v</name></name> <operator>+</operator> <name>dv</name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_du</name></name> <operator>=</operator> <name>du</name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_dv</name></name> <operator>=</operator> <name>dv</name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_du</name></name> <operator>=</operator> <name>du</name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_dv</name></name> <operator>=</operator> <name>dv</name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor_step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>minor_step</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_du</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_dv</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_du</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_dv</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name></type> <name>solid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>minor_color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>major_color</name></decl>;</decl_stmt>
}</block></struct></type> <name>state_texture_grad_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_grad_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_y</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>minor_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>major_delta_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>state_texture_grad_any_2d</name><modifier>*</modifier></type> <name>st</name> <init>= <expr><operator>(</operator><name>state_texture_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>du</name></decl>, <decl><type ref="prev"/><name>dv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>v1c</name></decl>, <decl><type ref="prev"/><name>v2c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1c</name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2c</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_interpolation_parameters</name><argument_list>(<argument><expr><name>start_x</name></expr></argument>, <argument><expr><name>start_y</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minor_delta_param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>major_delta_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>w</name></name> <operator>=</operator> <call><name>al_get_bitmap_width</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>h</name></name> <operator>=</operator> <call><name>al_get_bitmap_height</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>du</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>u</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>u</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dv</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>v</name></name> <operator>-</operator> <name><name>v1</name><operator>-&gt;</operator><name>v</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>u</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>u</name></name> <operator>+</operator> <name>du</name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>v</name></name> <operator>+</operator> <name>dv</name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>minor_du</name></name> <operator>=</operator> <name>du</name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>minor_dv</name></name> <operator>=</operator> <name>dv</name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>major_du</name></name> <operator>=</operator> <name>du</name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>major_dv</name></name> <operator>=</operator> <name>dv</name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>a</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>r</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>g</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>diff</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v2c</name><operator>.</operator><name>b</name></name> <operator>-</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>minor_delta_param</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>a</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>r</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>g</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name><name>diff</name><operator>.</operator><name>b</name></name> <operator>*</operator> <name>major_delta_param</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_grad_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor_step</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>state_texture_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>shader_texture_solid_any_step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>minor_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>minor_step</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>line_stepper</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>shader_first</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>shader_step</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>shader_draw</name></type> <name>draw</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>, <decl><type ref="prev"/><name>y2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>dx</name></decl>, <decl><type ref="prev"/><name>dy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>end_x</name></decl>, <decl><type ref="prev"/><name>end_y</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>vtx1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vtx1</name> <operator>=</operator> <name>vtx2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vtx2</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>vtx1</name><operator>-&gt;</operator><name>x</name></name> <operator>-=</operator> <literal type="number">0.5001f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name> <operator>-=</operator> <literal type="number">0.5001f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vtx2</name><operator>-&gt;</operator><name>x</name></name> <operator>-=</operator> <literal type="number">0.5001f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name> <operator>-=</operator> <literal type="number">0.5001f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>x1</name> <operator>=</operator> <name><name>vtx1</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>y1</name> <operator>=</operator> <name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>x2</name> <operator>=</operator> <name><name>vtx2</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>y2</name> <operator>=</operator> <name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>dx</name> <operator>=</operator> <name>x2</name> <operator>-</operator> <name>x1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dy</name> <operator>=</operator> <name>y2</name> <operator>-</operator> <name>y1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end_x</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>x2</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end_y</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>y2</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIRST</name></cpp:macro> <cpp:value>first(state, x, y, vtx1, vtx2); if((x2 - x1) * ((float)x - x1) + (y2 - y1) * ((float)y - y1) &gt;= 0) draw(state, x, y); (void)minor;</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP</name></cpp:macro> <cpp:value>step(state, minor); draw(state, x, y);</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST</name></cpp:macro> <cpp:value>step(state, minor); if((x1 - x2) * ((float)x - x2) + (y1 - y2) * ((float)y - y2) &gt; 0) draw(state, x, y);</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORKER</name><parameter_list>(<parameter><type><name>var1</name></type></parameter>, <parameter><type><name>var2</name></type></parameter>, <parameter><type><name>comp</name></type></parameter>, <parameter><type><name>dvar1</name></type></parameter>, <parameter><type><name>dvar2</name></type></parameter>, <parameter><type><name>derr1</name></type></parameter>, <parameter><type><name>derr2</name></type></parameter>, <parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ int minor = 1; if(err comp) { var1 += dvar1; err += derr1; minor = 0; } func var2 += dvar2; err += derr2; }</cpp:value></cpp:define>















<if_stmt><if>if <condition>(<expr><name>dx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dx</name> <operator>&gt;</operator> <name>dy</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>x1</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>y1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>y</name><operator>)</operator> <operator>*</operator> <name>dx</name> <operator>-</operator> <operator>(</operator><name>x1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>x</name><operator>)</operator> <operator>*</operator> <name>dy</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>dy</argument>, <argument>FIRST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>dy</argument>, <argument>STEP</argument>)</argument_list></macro>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>dy</argument>, <argument>LAST</argument>)</argument_list></macro>

</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y1</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>x1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>x</name><operator>)</operator> <operator>*</operator> <name>dy</name> <operator>-</operator> <operator>(</operator><name>y1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>y</name><operator>)</operator> <operator>*</operator> <name>dx</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dy</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dy</argument>, <argument>dx</argument>, <argument>FIRST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dy</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dy</argument>, <argument>dx</argument>, <argument>STEP</argument>)</argument_list></macro>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;=</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&gt; <literal type="number">0.5f</literal> * dy</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>-dy</argument>, <argument>dx</argument>, <argument>LAST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>-</operator><name>dx</name> <operator>&gt;</operator> <name>dy</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>x1</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>y1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>y</name><operator>)</operator> <operator>*</operator> <name>dx</name> <operator>-</operator> <operator>(</operator><name>x1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>x</name><operator>)</operator> <operator>*</operator> <name>dy</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&lt;= <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument>-<literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>-dy</argument>, <argument>FIRST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>x</name> <operator>&gt;</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&lt;= <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument>-<literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>-dy</argument>, <argument>STEP</argument>)</argument_list></macro>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <name>end_x</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>y</argument>, <argument>x</argument>, <argument>&lt;= <literal type="number">0.5f</literal> * dx</argument>, <argument><literal type="number">1</literal></argument>, <argument>-<literal type="number">1</literal></argument>, <argument>-dx</argument>, <argument>-dy</argument>, <argument>LAST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y1</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>x1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>x</name><operator>)</operator> <operator>*</operator> <name>dy</name> <operator>-</operator> <operator>(</operator><name>y1</name> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><name>y</name><operator>)</operator> <operator>*</operator> <name>dx</name></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&gt;</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>dy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>-=</operator> <name>dy</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&lt;= -<literal type="number">0.5f</literal> * dy</argument>, <argument>-<literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>dy</argument>, <argument>dx</argument>, <argument>FIRST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&lt;= -<literal type="number">0.5f</literal> * dy</argument>, <argument>-<literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>dy</argument>, <argument>dx</argument>, <argument>STEP</argument>)</argument_list></macro>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;=</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>
<macro><name>WORKER</name><argument_list>(<argument>x</argument>, <argument>y</argument>, <argument>&lt;= -<literal type="number">0.5f</literal> * dy</argument>, <argument>-<literal type="number">1</literal></argument>, <argument><literal type="number">1</literal></argument>, <argument>dy</argument>, <argument>dx</argument>, <argument>LAST</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FIRST</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LAST</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STEP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WORKER</name></cpp:undef>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>_al_line_2d</name><parameter_list>(<parameter><decl><type><name>ALLEGRO_BITMAP</name><modifier>*</modifier></type> <name>texture</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>shade</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>grad</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>src_mode</name></decl>, <decl><type ref="prev"/><name>dst_mode</name></decl>, <decl><type ref="prev"/><name>op_alpha</name></decl>, <decl><type ref="prev"/><name>src_alpha</name></decl>, <decl><type ref="prev"/><name>dst_alpha</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v1c</name></decl>, <decl><type ref="prev"/><name>v2c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1c</name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2c</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>al_get_separate_blender</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_alpha</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_alpha</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>_AL_DEST_IS_ZERO</name> <operator>&amp;&amp;</operator> <name>_AL_SRC_NOT_MODIFIED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>shade</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>r</name></name> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>g</name></name> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>b</name></name> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>a</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>grad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>texture</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>grad</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>state_texture_grad_any_2d</name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>solid</name><operator>.</operator><name>texture</name></name> <operator>=</operator> <name>texture</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_first</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_first</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>white</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>state_texture_solid_any_2d</name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>white</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>texture</name></name> <operator>=</operator> <name>texture</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>white</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_shade_white</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>white</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_opaque_white</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>grad</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>state_grad_any_2d</name></type> <name>state</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_grad_any_first</name></expr></argument>, <argument><expr><name>shader_grad_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_grad_any_first</name></expr></argument>, <argument><expr><name>shader_grad_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>state_solid_any_2d</name></type> <name>state</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_solid_any_first</name></expr></argument>, <argument><expr><name>shader_solid_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>al_draw_soft_line</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_solid_any_first</name></expr></argument>, <argument><expr><name>shader_solid_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>al_draw_soft_line</name><parameter_list>(<parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>first</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>step</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>draw</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name></type> <name>vtx1</name> <init>= <expr><operator>*</operator><name>v1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name></type> <name>vtx2</name> <init>= <expr><operator>*</operator><name>v2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_unlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ALLEGRO_LOCKED_REGION</name> <modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_x</name></decl>, <decl><type ref="prev"/><name>max_x</name></decl>, <decl><type ref="prev"/><name>min_y</name></decl>, <decl><type ref="prev"/><name>max_y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clip_min_x</name></decl>, <decl><type ref="prev"/><name>clip_min_y</name></decl>, <decl><type ref="prev"/><name>clip_max_x</name></decl>, <decl><type ref="prev"/><name>clip_max_y</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>al_get_clipping_rectangle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clip_min_x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_min_y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_max_x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_max_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>clip_max_x</name> <operator>+=</operator> <name>clip_min_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>clip_max_y</name> <operator>+=</operator> <name>clip_min_y</name></expr>;</expr_stmt>











<if_stmt><if>if <condition>(<expr><name><name>vtx1</name><operator>.</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>vtx2</name><operator>.</operator><name>x</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>min_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>max_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>min_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vtx1</name><operator>.</operator><name>y</name></name> <operator>&gt;=</operator> <name><name>vtx2</name><operator>.</operator><name>y</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>min_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>max_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>min_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>min_x</name> <operator>&gt;=</operator> <name>clip_max_x</name> <operator>||</operator> <name>min_y</name> <operator>&gt;=</operator> <name>clip_max_y</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_x</name> <operator>&gt;=</operator> <name>clip_max_x</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_x</name> <operator>=</operator> <name>clip_max_x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_y</name> <operator>&gt;=</operator> <name>clip_max_y</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_y</name> <operator>=</operator> <name>clip_max_y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_x</name> <operator>&lt;</operator> <name>clip_min_x</name> <operator>||</operator> <name>max_y</name> <operator>&lt;</operator> <name>clip_min_y</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min_x</name> <operator>&lt;</operator> <name>clip_min_x</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min_x</name> <operator>=</operator> <name>clip_min_x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min_y</name> <operator>&lt;</operator> <name>clip_min_y</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min_y</name> <operator>=</operator> <name>clip_min_y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>al_is_bitmap_locked</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_al_bitmap_region_is_locked</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>min_x</name></expr></argument>, <argument><expr><name>min_y</name></expr></argument>, <argument><expr><name>max_x</name> <operator>-</operator> <name>min_x</name></expr></argument>, <argument><expr><name>max_y</name> <operator>-</operator> <name>min_y</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>_al_pixel_format_is_video_only</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>locked_region</name><operator>.</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>lr</name> <operator>=</operator> <call><name>al_lock_bitmap_region</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>min_x</name></expr></argument>, <argument><expr><name>min_y</name></expr></argument>, <argument><expr><name>max_x</name> <operator>-</operator> <name>min_x</name></expr></argument>, <argument><expr><name>max_y</name> <operator>-</operator> <name>min_y</name></expr></argument>, <argument><expr><name>ALLEGRO_PIXEL_FORMAT_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>need_unlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>line_stepper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>draw</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtx1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_unlock</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>al_unlock_bitmap</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
