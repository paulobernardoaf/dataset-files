<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\allegro5-analysis\_cppstats\allegro5\src\tri_soft.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/allegro.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_bitmap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_blend.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_pixels.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"allegro5/internal/aintern_tri_soft.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<macro><name>ALLEGRO_DEBUG_CHANNEL</name><argument_list>(<argument><literal type="string">"tri_soft"</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name></cpp:macro> <cpp:value>_ALLEGRO_MIN</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name></cpp:macro> <cpp:value>_ALLEGRO_MAX</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_draw</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_init</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_first</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>shader_step</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>cur_color</name></decl>;</decl_stmt>

}</block></struct></type> <name>state_solid_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_init</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cur_color</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>v2</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>v3</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_minor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_major</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>state</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>x1</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>y</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>left_minor</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>left_major</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_solid_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>state</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>minor</name></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>state_solid_any_2d</name></type> <name>solid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_dx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_dy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_const</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>minor_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>major_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>off_x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>off_y</name></decl>;</decl_stmt>

}</block></struct></type> <name>state_grad_any_2d</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLANE_DETS</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>u1</name></type></parameter>, <parameter><type><name>u2</name></type></parameter>, <parameter><type><name>u3</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>float var##_det = u1 * minor3 - u2 * minor2 + u3 * minor1; float var##_det_x = u1 * y32 - u2 * y31 + u3 * y21; float var##_det_y = u1 * x23 - u2 * x13 + u3 * x12;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_PREAMBLE</name></cpp:macro> <cpp:value>const float x1 = 0; const float y1 = 0; const float x2 = v2-&gt;x - v1-&gt;x; const float y2 = v2-&gt;y - v1-&gt;y; const float x3 = v3-&gt;x - v1-&gt;x; const float y3 = v3-&gt;y - v1-&gt;y; const float minor1 = x1 * y2 - x2 * y1; const float minor2 = x1 * y3 - x3 * y1; const float minor3 = x2 * y3 - x3 * y2; const float y32 = y3 - y2; const float y31 = y3 - y1; const float y21 = y2 - y1; const float x23 = x2 - x3; const float x13 = x1 - x3; const float x12 = x1 - x2; const float det_u = minor3 - minor1 + minor2;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_grad_any_init</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INIT_PREAMBLE</name>

<name>ALLEGRO_COLOR</name></type> <name>v1c</name> <init>= <expr><name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v2c</name> <init>= <expr><name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v3c</name> <init>= <expr><name><name>v3</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<macro><name>PLANE_DETS</name><argument_list>(<argument>r</argument>, <argument>v1c.r</argument>, <argument>v2c.r</argument>, <argument>v3c.r</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>g</argument>, <argument>v1c.g</argument>, <argument>v2c.g</argument>, <argument>v3c.g</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>b</argument>, <argument>v1c.b</argument>, <argument>v2c.b</argument>, <argument>v3c.b</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>a</argument>, <argument>v1c.a</argument>, <argument>v2c.a</argument>, <argument>v3c.a</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>state_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>target</name></name> <operator>=</operator> <call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off_x</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off_y</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>det_u</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name></name> <operator>=</operator> <call><name>al_map_rgba_f</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><name>r_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><name>r_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>-</operator><name>g_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>-</operator><name>g_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name>g_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><name>b_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><name>b_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name>b_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>-</operator><name>a_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>-</operator><name>a_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>a_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_grad_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_minor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_major</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cur_x</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>x1</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>off_x</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cur_y</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>y</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>off_y</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_grad_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>minor</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHADE_COLORS</name><parameter_list>(<parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>A.r = B.r * A.r; A.g = B.g * A.g; A.b = B.b * A.b; A.a = B.a * A.a;</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>cur_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>du_dx</name></decl>, <name>du_dy</name>, <name>u_const</name>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>dv_dx</name></decl>, <name>dv_dy</name>, <name>v_const</name>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>u</name></decl>, <name>v</name>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>minor_du</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>minor_dv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>major_du</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>major_dv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>off_x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>off_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name><modifier>*</modifier></type> <name>texture</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>, <name>h</name>;</decl_stmt>

}</block></struct></type> <name>state_texture_solid_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_init</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INIT_PREAMBLE</name></type>

<name>PLANE_DETS</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><name><name>v2</name><operator>-&gt;</operator><name>u</name></name></expr></argument>, <argument><expr><name><name>v3</name><operator>-&gt;</operator><name>u</name></name></expr></argument>)</argument_list>

<name>PLANE_DETS</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>v2</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>v3</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list>

<name>state_texture_solid_any_2d</name><modifier>*</modifier> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cur_color</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off_x</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off_y</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>al_get_bitmap_width</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>al_get_bitmap_height</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>det_u</name> <operator>==</operator> <literal type="number">0.0f</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>du_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>u_const</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dv_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>v_const</name></name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>du_dx</name></name> <operator>=</operator> <operator>-</operator><name>u_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>du_dy</name></name> <operator>=</operator> <operator>-</operator><name>u_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u_const</name></name> <operator>=</operator> <name>u_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dv_dx</name></name> <operator>=</operator> <operator>-</operator><name>v_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>dv_dy</name></name> <operator>=</operator> <operator>-</operator><name>v_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v_const</name></name> <operator>=</operator> <name>v_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_minor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_major</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cur_x</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>x1</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>off_x</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cur_y</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>y</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>off_y</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dx</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dy</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>u_const</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dx</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dy</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>v_const</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_du</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dx</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dy</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_dv</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dx</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dy</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_du</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dx</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>du_dy</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_dv</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dx</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dv_dy</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_solid_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_texture_solid_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_solid_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>minor</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_du</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_dv</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_du</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_dv</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>state_texture_solid_any_2d</name></type> <name>solid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_dx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_dy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>color_const</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>minor_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>major_color</name></decl>;</decl_stmt>

}</block></struct></type> <name>state_texture_grad_any_2d</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_grad_any_init</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>INIT_PREAMBLE</name>

<name>ALLEGRO_COLOR</name></type> <name>v1c</name> <init>= <expr><name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v2c</name> <init>= <expr><name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v3c</name> <init>= <expr><name><name>v3</name><operator>-&gt;</operator><name>color</name></name></expr></init></decl>;</decl_stmt>

<macro><name>PLANE_DETS</name><argument_list>(<argument>r</argument>, <argument>v1c.r</argument>, <argument>v2c.r</argument>, <argument>v3c.r</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>g</argument>, <argument>v1c.g</argument>, <argument>v2c.g</argument>, <argument>v3c.g</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>b</argument>, <argument>v1c.b</argument>, <argument>v2c.b</argument>, <argument>v3c.b</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>a</argument>, <argument>v1c.a</argument>, <argument>v2c.a</argument>, <argument>v3c.a</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>u</argument>, <argument>v1-&gt;u</argument>, <argument>v2-&gt;u</argument>, <argument>v3-&gt;u</argument>)</argument_list></macro>

<macro><name>PLANE_DETS</name><argument_list>(<argument>v</argument>, <argument>v1-&gt;v</argument>, <argument>v2-&gt;v</argument>, <argument>v3-&gt;v</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>state_texture_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>target</name></name> <operator>=</operator> <call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>w</name></name> <operator>=</operator> <call><name>al_get_bitmap_width</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>h</name></name> <operator>=</operator> <call><name>al_get_bitmap_height</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>texture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>off_x</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>off_y</name></name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>det_u</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>du_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>du_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>u_const</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>dv_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>dv_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>v_const</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name></name> <operator>=</operator> <call><name>al_map_rgba_f</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>du_dx</name></name> <operator>=</operator> <operator>-</operator><name>u_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>du_dy</name></name> <operator>=</operator> <operator>-</operator><name>u_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>u_const</name></name> <operator>=</operator> <name>u_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>dv_dx</name></name> <operator>=</operator> <operator>-</operator><name>v_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>dv_dy</name></name> <operator>=</operator> <operator>-</operator><name>v_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>v_const</name></name> <operator>=</operator> <name>v_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><name>r_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>-</operator><name>r_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>-</operator><name>g_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>-</operator><name>g_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name>g_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><name>b_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><name>b_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name>b_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>-</operator><name>a_det_x</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>-</operator><name>a_det_y</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>a_det</name> <operator>/</operator> <name>det_u</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_grad_any_first</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_minor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left_major</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_texture_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>cur_x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>cur_y</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>shader_texture_solid_any_first</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>left_minor</name></expr></argument>, <argument><expr><name>left_major</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_x</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>x1</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>off_x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_y</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>y</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>off_y</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>cur_x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name>cur_y</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_const</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_minor</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>r</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>g</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>b</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_major</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dx</name><operator>.</operator><name>a</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>color_dy</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>shader_texture_grad_any_step</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minor</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>state_texture_grad_any_2d</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><operator>(</operator><name>state_texture_grad_any_2d</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>shader_texture_solid_any_step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>minor</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>minor_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>r</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>g</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>b</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>solid</name><operator>.</operator><name>cur_color</name><operator>.</operator><name>a</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>major_color</name><operator>.</operator><name>a</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanline_drawers.inc"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>triangle_stepper</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>,

<parameter><decl><type><name>shader_init</name></type> <name>init</name></decl></parameter>, <parameter><decl><type><name>shader_first</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>shader_step</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>shader_draw</name></type> <name>draw</name></decl></parameter>,

<parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name><name>Coords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{<expr><name><name>vtx1</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>, <expr><name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>, <expr><name><name>vtx2</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>, <expr><name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>, <expr><name><name>vtx3</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">0.5f</literal></expr>, <expr><name><name>vtx3</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">0.5f</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>V1</name> <init>= <expr><name>Coords</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>V2</name> <init>= <expr><operator>&amp;</operator><name><name>Coords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>V3</name> <init>= <expr><operator>&amp;</operator><name><name>Coords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>left_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>right_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>left_y_delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>right_y_delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>left_x_delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>right_x_delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>left_first</name></decl>, <decl><type ref="prev"/><name>right_first</name></decl>, <decl><type ref="prev"/><name>left_step</name></decl>, <decl><type ref="prev"/><name>right_step</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>left_x</name></decl>, <decl><type ref="prev"/><name>right_x</name></decl>, <decl><type ref="prev"/><name>cur_y</name></decl>, <decl><type ref="prev"/><name>mid_y</name></decl>, <decl><type ref="prev"/><name>end_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>left_d_er</name></decl>, <decl><type ref="prev"/><name>right_d_er</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>major_x_delta</name></decl>, <decl><type ref="prev"/><name>major_y_delta</name></decl>, <decl><type ref="prev"/><name>minor_x_delta</name></decl>, <decl><type ref="prev"/><name>minor_y_delta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>major_on_the_left</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>V2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V2</name> <operator>=</operator> <name>V1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V1</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>V3</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V3</name> <operator>=</operator> <name>V1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V1</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>V3</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V3</name> <operator>=</operator> <name>V2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>V2</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cur_y</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mid_y</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end_y</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_y</name> <operator>==</operator> <name>end_y</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>left_x</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>major_x_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>major_y_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>minor_x_delta</name> <operator>=</operator> <name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>minor_y_delta</name> <operator>=</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>major_x_delta</name> <operator>*</operator> <name>minor_y_delta</name> <operator>-</operator> <name>major_y_delta</name> <operator>*</operator> <name>minor_x_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>major_on_the_left</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>major_on_the_left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>vtx1</name></expr></argument>, <argument><expr><name>vtx2</name></expr></argument>, <argument><expr><name>vtx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_y</name> <operator>!=</operator> <name>mid_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>right_x</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>major_on_the_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_x_delta</name> <operator>=</operator> <name>major_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x_delta</name> <operator>=</operator> <name>minor_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_y_delta</name> <operator>=</operator> <name>major_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_y_delta</name> <operator>=</operator> <name>minor_y_delta</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>left_x_delta</name> <operator>=</operator> <name>minor_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x_delta</name> <operator>=</operator> <name>major_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_y_delta</name> <operator>=</operator> <name>minor_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_y_delta</name> <operator>=</operator> <name>major_y_delta</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>left_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>left_x</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>right_x</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_first</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><operator>(</operator><name>left_error</name><operator>)</operator> <operator>/</operator> <name>left_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>right_first</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><operator>(</operator><name>right_error</name><operator>)</operator> <operator>/</operator> <name>right_y_delta</name> <operator>-</operator> <literal type="number">0.000001f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_step</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>left_x_delta</name> <operator>/</operator> <name>left_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_d_er</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>float</name><operator>)</operator><name>left_step</name> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_step</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>right_x_delta</name> <operator>/</operator> <name>right_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>right_d_er</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>float</name><operator>)</operator><name>right_step</name> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_y</name> <operator>&lt;</operator> <name>mid_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_x</name> <operator>+=</operator> <name>left_first</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>-=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_first</name> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>+=</operator> <name>right_first</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>-=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>right_first</name> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>first</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>left_step</name></expr></argument>, <argument><expr><name>left_step</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>right_x</name> <operator>&gt;=</operator> <name>left_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>draw</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>right_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cur_y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_x_delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>cur_y</name> <operator>&lt;</operator> <name>mid_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_d_er</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x</name> <operator>+=</operator> <name>left_step</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>left_error</name> <operator>+</operator> <name>left_y_delta</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_d_er</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>+=</operator> <name>right_step</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>right_error</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>right_x</name> <operator>&gt;=</operator> <name>left_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>draw</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>right_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cur_y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_x_delta</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>major_on_the_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>right_x</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x_delta</name> <operator>=</operator> <name>major_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_y_delta</name> <operator>=</operator> <name>major_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_y_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>left_x</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>right_x</name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>right_x</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x_delta</name> <operator>=</operator> <name>major_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_y_delta</name> <operator>=</operator> <name><name>V3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_y_delta</name> <operator>=</operator> <name>major_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>left_x</name> <operator>-</operator> <name><name>V2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>cur_y</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_x_delta</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><name>right_x</name> <operator>-</operator> <name><name>V1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>left_first</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><operator>(</operator><name>left_error</name><operator>)</operator> <operator>/</operator> <name>left_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>right_first</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><operator>(</operator><name>right_error</name><operator>)</operator> <operator>/</operator> <name>right_y_delta</name> <operator>-</operator> <literal type="number">0.000001f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_step</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>left_x_delta</name> <operator>/</operator> <name>left_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left_d_er</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>float</name><operator>)</operator><name>left_step</name> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_step</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>right_x_delta</name> <operator>/</operator> <name>right_y_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>right_d_er</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>float</name><operator>)</operator><name>right_step</name> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cur_y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_x</name> <operator>+=</operator> <name>left_first</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>-=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>left_first</name> <operator>*</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>+=</operator> <name>right_first</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>-=</operator> <operator>(</operator><name>float</name><operator>)</operator><name>right_first</name> <operator>*</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>first</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>left_step</name></expr></argument>, <argument><expr><name>left_step</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>right_x</name> <operator>&gt;=</operator> <name>left_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>draw</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>right_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cur_y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_x_delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>cur_y</name> <operator>&lt;</operator> <name>end_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_d_er</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x</name> <operator>+=</operator> <name>left_step</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>left_error</name> <operator>+</operator> <name>left_y_delta</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left_x</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>step</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_d_er</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>+=</operator> <name>right_step</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>right_error</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_y_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_x</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>right_x</name> <operator>&gt;=</operator> <name>left_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>draw</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>left_x</name></expr></argument>, <argument><expr><name>cur_y</name></expr></argument>, <argument><expr><name>right_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cur_y</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>left_error</name> <operator>+=</operator> <name>left_x_delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>right_error</name> <operator>+=</operator> <name>right_x_delta</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>_al_triangle_2d</name><parameter_list>(<parameter><decl><type><name>ALLEGRO_BITMAP</name><modifier>*</modifier></type> <name>texture</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>shade</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>grad</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>src_mode</name></decl>, <decl><type ref="prev"/><name>dst_mode</name></decl>, <decl><type ref="prev"/><name>op_alpha</name></decl>, <decl><type ref="prev"/><name>src_alpha</name></decl>, <decl><type ref="prev"/><name>dst_alpha</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_COLOR</name></type> <name>v1c</name></decl>, <decl><type ref="prev"/><name>v2c</name></decl>, <decl><type ref="prev"/><name>v3c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v1c</name> <operator>=</operator> <name><name>v1</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v2c</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v3c</name> <operator>=</operator> <name><name>v3</name><operator>-&gt;</operator><name>color</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>al_get_separate_bitmap_blender</name><argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>src_mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_alpha</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_alpha</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst_alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>_AL_DEST_IS_ZERO</name> <operator>&amp;&amp;</operator> <name>_AL_SRC_NOT_MODIFIED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shade</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>r</name></name> <operator>&amp;&amp;</operator> <name><name>v2c</name><operator>.</operator><name>r</name></name> <operator>==</operator> <name><name>v3c</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>g</name></name> <operator>&amp;&amp;</operator> <name><name>v2c</name><operator>.</operator><name>g</name></name> <operator>==</operator> <name><name>v3c</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>b</name></name> <operator>&amp;&amp;</operator> <name><name>v2c</name><operator>.</operator><name>b</name></name> <operator>==</operator> <name><name>v3c</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>==</operator> <name><name>v2c</name><operator>.</operator><name>a</name></name> <operator>&amp;&amp;</operator> <name><name>v2c</name><operator>.</operator><name>a</name></name> <operator>==</operator> <name><name>v3c</name><operator>.</operator><name>a</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>grad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>texture</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>grad</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>state_texture_grad_any_2d</name></type> <name>state</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>.</operator><name>solid</name><operator>.</operator><name>texture</name></name> <operator>=</operator> <name>texture</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_init</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_first</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_step</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_init</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_first</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_step</name></expr></argument>, <argument><expr><name>shader_texture_grad_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>white</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>state_texture_solid_any_2d</name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v1c</name><operator>.</operator><name>r</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>g</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>b</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>v1c</name><operator>.</operator><name>a</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>white</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>.</operator><name>texture</name></name> <operator>=</operator> <name>texture</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>white</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_init</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_shade_white</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_init</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>white</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_init</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_opaque_white</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_init</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_first</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_step</name></expr></argument>, <argument><expr><name>shader_texture_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>grad</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>state_grad_any_2d</name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_grad_any_init</name></expr></argument>, <argument><expr><name>shader_grad_any_first</name></expr></argument>, <argument><expr><name>shader_grad_any_step</name></expr></argument>, <argument><expr><name>shader_grad_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_grad_any_init</name></expr></argument>, <argument><expr><name>shader_grad_any_first</name></expr></argument>, <argument><expr><name>shader_grad_any_step</name></expr></argument>, <argument><expr><name>shader_grad_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>state_solid_any_2d</name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shade</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_solid_any_init</name></expr></argument>, <argument><expr><name>shader_solid_any_first</name></expr></argument>, <argument><expr><name>shader_solid_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_shade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>_al_draw_soft_triangle</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>shader_solid_any_init</name></expr></argument>, <argument><expr><name>shader_solid_any_first</name></expr></argument>, <argument><expr><name>shader_solid_any_step</name></expr></argument>, <argument><expr><name>shader_solid_any_draw_opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bitmap_region_is_locked</name><parameter_list>(<parameter><decl><type><name>ALLEGRO_BITMAP</name><modifier>*</modifier></type> <name>bmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>bmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>al_is_bitmap_locked</name><argument_list>(<argument><expr><name>bmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x1</name> <operator>+</operator> <name>w</name> <operator>&gt;</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_x</name></name> <operator>&amp;&amp;</operator> <name>y1</name> <operator>+</operator> <name>h</name> <operator>&gt;</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_y</name></name> <operator>&amp;&amp;</operator> <name>x1</name> <operator>&lt;</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_x</name></name> <operator>+</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_w</name></name> <operator>&amp;&amp;</operator> <name>y1</name> <operator>&lt;</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_y</name></name> <operator>+</operator> <name><name>bmp</name><operator>-&gt;</operator><name>lock_h</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>_al_draw_soft_triangle</name><parameter_list>(

<parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>state</name></decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>first</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>step</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>draw</name>)<parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx1</name> <init>= <expr><name>v1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx2</name> <init>= <expr><name>v2</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_VERTEX</name><modifier>*</modifier></type> <name>vtx3</name> <init>= <expr><name>v3</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_BITMAP</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>al_get_target_bitmap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_unlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ALLEGRO_LOCKED_REGION</name> <modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_x</name></decl>, <decl><type ref="prev"/><name>max_x</name></decl>, <decl><type ref="prev"/><name>min_y</name></decl>, <decl><type ref="prev"/><name>max_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>clip_min_x</name></decl>, <decl><type ref="prev"/><name>clip_min_y</name></decl>, <decl><type ref="prev"/><name>clip_max_x</name></decl>, <decl><type ref="prev"/><name>clip_max_y</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>al_get_clipping_rectangle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>clip_min_x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_min_y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_max_x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clip_max_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>clip_max_x</name> <operator>+=</operator> <name>clip_min_x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>clip_max_y</name> <operator>+=</operator> <name>clip_min_y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>min_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>vtx3</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>min_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floorf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>vtx3</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>max_x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>vtx3</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>max_y</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceilf</name><argument_list>(<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>vtx1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>vtx2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>vtx3</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_x</name> <operator>&gt;=</operator> <name>clip_max_x</name> <operator>||</operator> <name>min_y</name> <operator>&gt;=</operator> <name>clip_max_y</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_x</name> <operator>&gt;=</operator> <name>clip_max_x</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_x</name> <operator>=</operator> <name>clip_max_x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_y</name> <operator>&gt;=</operator> <name>clip_max_y</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_y</name> <operator>=</operator> <name>clip_max_y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_x</name> <operator>&lt;</operator> <name>clip_min_x</name> <operator>||</operator> <name>max_y</name> <operator>&lt;</operator> <name>clip_min_y</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min_x</name> <operator>&lt;</operator> <name>clip_min_x</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>min_x</name> <operator>=</operator> <name>clip_min_x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min_y</name> <operator>&lt;</operator> <name>clip_min_y</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>min_y</name> <operator>=</operator> <name>clip_min_y</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>al_is_bitmap_locked</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bitmap_region_is_locked</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>min_x</name></expr></argument>, <argument><expr><name>min_y</name></expr></argument>, <argument><expr><name>max_x</name> <operator>-</operator> <name>min_x</name></expr></argument>, <argument><expr><name>max_y</name> <operator>-</operator> <name>min_y</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>_al_pixel_format_is_video_only</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>locked_region</name><operator>.</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>lr</name> <operator>=</operator> <call><name>al_lock_bitmap_region</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>min_x</name></expr></argument>, <argument><expr><name>min_y</name></expr></argument>, <argument><expr><name>max_x</name> <operator>-</operator> <name>min_x</name></expr></argument>, <argument><expr><name>max_y</name> <operator>-</operator> <name>min_y</name></expr></argument>, <argument><expr><name>ALLEGRO_PIXEL_FORMAT_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>need_unlock</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>triangle_stepper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>draw</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_unlock</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>al_unlock_bitmap</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

</unit>
